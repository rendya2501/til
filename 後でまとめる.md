# 後でまとめたいやつら

## NULLのLIKE検索

LIKE検索には引っかからない。  
NULLを検索したかったからISNULLを使うこと。  

## NULLのORDERBY

[NULLと戯れる: ORDER BYとNULL](https://qiita.com/SVC34/items/c23341c79325a0a95979)  
どうにも、NULLを最小値とするか最大値とするかは、RDBMS毎に違ったり、設定で変更出来たりするみたい。  
Oracleは最大値扱いだが、SQLServerは最小値扱い見たい。  
まぁ、どちらにせよ、先頭か末尾であることに違いはないということですね。  

## COUNT(*)の意味とNULLのCOUNT

[COUNT(*)　が何を意味しているのかわからない](https://ja.stackoverflow.com/questions/42915/count-%E3%81%8C%E4%BD%95%E3%82%92%E6%84%8F%E5%91%B3%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84)  
→  
**COUNT(*)は行数を数えてくれる**  

``` txt
OracleではCOUNT(*)とCOUNT(age)の結果は異なります。
ageにnullが入っているとCOUNT(age)では件数にカウントされません。
グループ化していても同様で、ageがnullのグループのみ0件となります。
COUNT(*)ではageにnullが入っていてもレコードの件数をカウントします。

COUNT(*)ではレコードの内容を取得するため、COUNT('X')やSUM(1)を使った方が高速化できると教わったことがあります。(10年ほど前に聞いたノウハウなので現在も適用されるのかは不明ですが…)
```

なるほど。COUNTはNULLはカウントしないのね。  
動作的にCOUNT(name)見たいにフィールド名を指定したほうが高速化できるっぽいけど、単純にレコード数を取得したいならCOUNT(*)でいいのか。  

## NULLをキャスト

(NULL AS CHAR)→NULLのまま
NULL -1 = NULL

## 名前付き引数 C#7.0



Overrideしたイベントは -= +=で解除と登録はできない。


staticだとthis.でアクセスできないのまとめる。



``` C#
using C1.WPF.Input;
using System.Collections;
using System.Collections.Specialized;
using System.Windows;
using System.Windows.Controls;

namespace RN3.Wpf.Common.Control
{
    /// <summary>
    /// C1MultiSelect拡張コントロール
    /// </summary>
    public class CustomMultiSelect : C1MultiSelect
    {
        #region プロパティ
        /// <summary>
        /// 表示行数公開プロパティ登録
        /// </summary>
        public static readonly DependencyProperty SelectedItemsProperty =
            DependencyProperty.Register(
                "SelectedItems",
                typeof(IList),
                typeof(CustomMultiSelect),
                new PropertyMetadata(null, new PropertyChangedCallback(OnSelectedItemsChanged))
            );
        /// <summary>
        /// 表示行数
        /// </summary>
        public new IList SelectedItems
        {
            get { return (IList)GetValue(SelectedItemsProperty); }
            set { SetValue(SelectedItemsProperty, value); }
        }

        private bool flag = false;
        #endregion


        #region コンストラクタ
        /// <summary>
        /// コンストラクタ
        /// </summary>
        public CustomMultiSelect()
        {
        }
        #endregion


        #region 内部処理
        private static void OnSelectedItemsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var control = (CustomMultiSelect)d;
            if (control.SelectedItems is INotifyCollectionChanged notify)
            {
                notify.CollectionChanged -= control.aa;
                notify.CollectionChanged += control.aa;
            }

            //if (d != null)
            //{
            //    //fg.SetValue(
            //    //    SelectedItemsProperty,
            //    //    () => SelectedItems.Add(e.NewValue)
            //    //);
            //    if (control.ListBox != null)
            //    {

            //        control.ListBox.SelectedItems.Add(e.NewValue);
            //    }
            //}


            //if (d is CustomMultiSelect multiselect)
            //{
            //    multiselect.SelectionChanged += (s, eventArgs) =>
            //    {
            //        multiselect.SelectedItems.Add(s);
            //        //var items = (List)multiselect.SelectedItems;
            //        //if (items == null)
            //        //{
            //        //    return;
            //        //}
            //        //foreach (var item in items.Where(x => x.IsSelected == true))
            //        //{
            //        //    multiselect.SelectedItems.Add(item);
            //        //}
            //    };
            //    //// 削除
            //    //foreach (var deleteItem in args.RemovedItems.OfType<SubjectLargeTypeWithSubjectCDList>())
            //    //{
            //    //    multiselect.Remove(deleteItem);
            //    //}
            //    //// 追加
            //    //foreach (var addItem in args.AddedItems.OfType<SubjectLargeTypeWithSubjectCDList>())
            //    //{
            //    //    multiselect.Add(addItem);
            //    //}
            //}
        }

        private void aa(object sender, NotifyCollectionChangedEventArgs e)
        {
            flag = true;

            if (e.Action == NotifyCollectionChangedAction.Add)
            {
                foreach (var item in e.NewItems)
                {
                    ListBox.SelectedItems.Add(item);
                }
            }
            else if (e.Action == NotifyCollectionChangedAction.Remove)
            {
                foreach (var item in e.OldItems)
                {
                    ListBox.SelectedItems.Remove(item);
                }
            }
            else if (e.Action == NotifyCollectionChangedAction.Reset)
            {
                ListBox.SelectedItems.Clear();
            }

            flag = false;
        }


        protected override void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (flag)
            {
                return;
            }
            if (SelectedItems is INotifyCollectionChanged x)
            {
                x.CollectionChanged -= aa;

                // 削除
                foreach (var deleteItem in e.RemovedItems)
                {
                    SelectedItems.Remove(deleteItem);
                }
                // 追加
                foreach (var addItem in e.AddedItems)
                {

                    SelectedItems.Add(addItem);
                }

                x.CollectionChanged += aa;
            }

            base.OnSelectionChanged(sender, e);
        }
        #endregion
    }
}
```




テンププロパティ
コントロールがあって、
テキストボックスとボタン。
カーソルが当たったら色を変えたい。
どちらにもその機能はない。
じゃあCustomButton,CustomTextを作るかと言われたらそうではない。
テンププロパティなるものを作って、それをテキストボックスとボタンに実装してあげることで、その機能を実現することができる。
それが、テンププロパティ。


DependencyProperty→バインディングができるようにする。コントロールにそういう機能がある。

INotify
Classに実装。

バインディングをしたときに、バインド間で通知をしてくれる。
。Net側の処理。

CollectionChanged。

ObsColle 
Foreachの中で、inに入れるコレクションの内容が変わった時にエラーが発生する。
これは、イベントが邪魔をしている証拠。
抑制する必要がある。

---

## 雑記

・昼休みでローカルのラウンドナビを動かせるようにしておく。
・100均で筋トレ用のマット＆封筒購入
・俺が仕様書メモとしてまとめてる内容は全て開発フォルダの仕様書フォルダに乗っけておけばいいのでは？
メモ書き程度のやつは上に持っていくのはどうかな。

・会社の健保のあれ注文する。
令和3年10月12日（火）9時から令和3年10月25日（月）24時まで
