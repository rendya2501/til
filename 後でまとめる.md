# 後でまとめたいやつら

---

## C# if or

C# 9.0(.Net5)からパターンマッチングによって可能になった。  

``` cs
if (i is 2 or 3 or 5 or >= 10){}
```

[【C#】複数のORをまとめて書けないか](https://shozo-gson.com/cs-alt-or/)  

---

## C#のVSCodeのデバッグでコンソールの入力を有効にする方法

`.vscode`ディレクトリ配下にある`launch.json`の`"console":"internalConsole"`の部分を
`"console":"externalTerminal"`に書き換える。  

[Visual Studio Code で Console.ReadLineを使う方法](https://qiita.com/link_to_someone/items/2b7cb8747a34165b8c8e)  
c# vscode debug console readline  

---

## WPFとWEBAPIを同じソリューションに含めて実行する  

ソリューションを右クリック → `スタートアッププロジェクトの設定(A)...`  

共通プロパティ→スタートアッププロジェクト  

マルチスタートアッププロジェクトを選択する。  

WebApiClientとWebApiServerのアクションを`開始`にする。  

[Asp.Net Core Web API Client/Server Application | Visual Studio 2019](https://www.youtube.com/watch?v=Bz5S86jmXQQ)  
[Consume ASP.Net Core Web API Using HttpClient in WPF](https://www.youtube.com/watch?v=qb3o_PIwVUk)  

---

## wifiと接続されたら電気をつける

・Tasker  
・IFTTT  
・SwitchBot  
・MailTask  

Taskerでwifi接続イベントを検出する。  
接続イベントに対してTaskerからMailTaskにアクションを送信する。MailTaskで設定しているメールアドレスに特定の形式のメールを送信する。  
IFTTTで、設定したメールアドレスに対する特定のメールの受信を検知する。  
イベントを検知したら設定しているSwitchBotに点灯命令を送信する。  

---

sql where 仕組み
[SELECT文の処理の仕組みを説明してみた。](https://nattou-curry-2.hatenadiary.org/entry/20090315/1237089749)

LEFT OUTER JOIN A
RIGHT OUTER JOIN B
ON A.aa = B.aa
ON A.bb = oya.bb

この構文は

LEFT OUTER JOIN A ON B
A.aa = B.aa
LEFT OUTER JOIN B ON oya

でよいのでは説。

---

## オペレーション対応表

``` txt
OPERATION | SQL    | HTTP/REST
----------+--------+-----------
CREATE    | INSERT | POST
READ      | SELECT | GET
UPDATE    | UPDATE | PUT
DELETE    | DELETE | DELETE
```

[Repository Pattern](https://www.youtube.com/watch?v=x6C20zhZHw8)  

## PUTとPATCHの違い

PUT : 全てのリソースを変更  
PATCH : 一部のリソース変更  

以下のようなテーブルがあるとする。  

``` cs
class Hoge {
    public int Id {get;set;}
    public string Name {get;set;}
    public string Description {get;set;}
}
```

以下のようなリクエストを送ったとする。  

``` cs
{
    Name = "hoge"
}
```

putは全て置き換えるので、IdとDescriptionはnullとなる。  
Patchであれば、IdとDescriptionはそのままでNameだけ更新する形となる。  

これが全てのリソースを変更するか一部のリソースを変更するかの違いとなる。  

[PUTとPATCHの違いは何？](https://techblg.app/articles/difference-between-put-and-patch/)  

---

## IPアドレスからドメイン名を取得する

- linuxの場合  
  - `dig`コマンド  
  - `dig -x xxx:xxx:xxx:xxx`  
  - `host`コマンド  
  - `host xxx:xxx:xxx:xxx`  

- windowsの場合  
  - `nslookup`コマンド  
  - `nslookup xxx:xxx:xxx:xxx`  

[IPアドレスからドメイン名を割り出す「逆引き」について](https://rainbow-engine.com/domain-from-address-revdns/#:~:text=DNS%E3%82%B5%E3%83%BC%E3%83%90%E3%81%8C%E5%88%A9%E7%94%A8%E3%81%A7%E3%81%8D%E3%82%8B,%E6%96%B9%E6%B3%95%E3%81%8C%E3%81%8A%E3%82%B9%E3%82%B9%E3%83%A1%E3%81%A7%E3%81%99%E3%80%82&text=Windows%E3%81%AE%E6%A4%9C%E7%B4%A2%E7%AA%93%E3%81%8B%E3%82%89,%E3%81%A8%E3%81%97%E3%81%A6%E5%AE%9F%E8%A1%8C%E3%80%8D%E3%81%A7%E9%96%8B%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82&text=%E5%AE%9F%E8%A1%8C%E7%B5%90%E6%9E%9C%E3%81%AE%E4%B8%AD%E3%81%8B%E3%82%89,%E3%81%9F%E8%A1%8C%E3%82%92%E6%8E%A2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82)  

[LinuxでIPアドレスからホスト名/ドメイン名を取得する方法–Linuxヒント](https://ciksiti.com/ja/chapters/3833-how-to-get-a-hostname-domain-name-from-an-ip-address-in-linu)  

---

## 仕様書 マークダウン

簡単な概要書 プログラム  
マークダウン 仕様書 テンプレート  
簡単な仕様書 マークダウン  

[仕様書の参考例と、こんな内容を仕様書に最低書くといいというお話](https://note.com/tanabemg/n/na2db89a5cbda)  

---

## テストコード

[意識が高くないVisualStudioを使用した単体テストの自動化](https://qiita.com/mima_ita/items/05ce44c3eb1fd6e9dd46)  

---

## レビューに関して

>レビューはエンジニアの好き嫌いとか最近興味がある技術とかなどの思いの丈を語る為に提供されたしゃべり場ではなく、成果物の品質が基準に達しているかを確認する場という事が分かっていない人がホント多いなというが最近の感想。  
<https://twitter.com/komitsubo/status/1516544935423770624>  

---

## DI_相互参照

- 中間サービスを挟む。  
- 相互参照が発生したタイミングでその処理を別のサービスとして切り出す。  
- 必要な処理だけメソッドインジェクションする。  

[【Angular】お互いにDIしあっている（循環参照）と発生するエラー](https://www.l08084.com/entry/2018/06/09/170727)  
[DIコンテナの本当の使いどころ](https://www.ulsystems.co.jp/archives/025.html)  

---

## git stash ものすごく古い状態の変更を最新に適応した時どうなるのか？

古いブランチで開発していた内容。  
変更内容を最新の環境に当てたい。  
古いブランチでの変更内容をstashして最新の環境にapplyした場合、変更箇所だけ適応されるのか？  

コンフリクトするだけか？  

---

## メソッド名

入力された引数をチェックして最終的に出力するような関数の名前。  
GetEnable○○Code  
最終的に取得したいのは有効なコードだから、チェック○○ではなく、最終目標を関数名とする。  

``` cs
/// <summary>
/// Web連携基本情報が存在しない、または連携フラグがtrueではない場合はnullを返します。
/// </summary>
/// <param name="officeCD"></param>
/// <param name="coopClsCD"></param>
/// <returns></returns>
private int? CheckCoopFlag(string officeCD, int? coopClsCD)
{
    if (string.IsNullOrEmpty(officeCD) || !coopClsCD.HasValue)
    {
        return null;
    }
    var basicInfo = WebCoopBasicInfoModel.Get(officeCD, coopClsCD.Value);
    if (basicInfo?.CoopFlag != true)
    {
        return null;
    }
    return coopClsCD;
}
```

---

## Enum バックからの受け取り

asp側の定義

``` cs
    /// <summary>
    /// 実行結果のステータス
    /// </summary>
    public enum ResultStatus
    {
        /// <summary>
        /// 成功
        /// </summary>
        Success,

        /// <summary>
        /// 精算済み
        /// </summary>
        Settled,

        /// <summary>
        /// 精算中
        /// </summary>
        Settling,

        /// <summary>
        /// エラー
        /// </summary>
        Error
    }
```

``` cs
wpf側
これだとasp側からSuccessで帰ってきてもExecutionになってしまう。
暗黙的に降られている番号的に一致するからだと思われる。

    /// <summary>
    /// 実行結果のステータス
    /// </summary>
    public enum ResultStatus
    {
        /// <summary>
        /// 実行中
        /// </summary>
        Execution,

        /// <summary>
        /// 成功
        /// </summary>
        Success,

        /// <summary>
        /// 精算済み
        /// </summary>
        Settled,

        /// <summary>
        /// 精算中
        /// </summary>
        Settling,

        /// <summary>
        /// エラー
        /// </summary>
        Error
    }

合わせたければこうする事
/// <summary>
    /// 実行結果のステータス
    /// </summary>
    public enum ResultStatus
    {
        /// <summary>
        /// 成功
        /// </summary>
        Success,

        /// <summary>
        /// 精算済み
        /// </summary>
        Settled,

        /// <summary>
        /// 精算中
        /// </summary>
        Settling,

        /// <summary>
        /// エラー
        /// </summary>
        Error,

        /// <summary>
        /// 実行中
        /// </summary>
        Execution,
    }

web側は結果を返すだけだが、フロントは実行中というステータスがあるのでこんな感じになっている。
```

---

## XAML Enterでコマンド実行

[【WPF】Enterキーで確定できるTextBoxにする添付プロパティ](https://threeshark3.com/updatesource-with-enter/)  
[How to Invoke a Command on the ViewModel by Pressing the Enter Key in a TextBox with Silverlight and MVVM](https://markheath.net/post/how-to-invoke-command-on-viewmodel-by)  
[Executing viewmodels command on enter in TextBox](https://stackoverflow.com/questions/3413927/executing-viewmodels-command-on-enter-in-textbox)  
[Capturing the Enter key in a TextBox](https://stackoverflow.com/questions/5556489/capturing-the-enter-key-in-a-textbox)  

---

## クラスターインデックスと非クラスター化インデックス

[SQL Server/SQL Database再入門 第2回 Index SeekとIndex Scan](https://qiita.com/yyukawa/items/4cc1cd5e447b5a5d1b48)  

[【SQL】ゼロ知識から実行計画を読み解きパフォーマンス改善](https://qiita.com/yoshinori_hisakawa/items/5ef0cf4fd8eb6dd3037f)  
[【SQL】ゼロ知識からSQLのパフォーマンスを考えられるようになるまで](https://qiita.com/yoshinori_hisakawa/items/f5d608d302ede8f9883d)  

実行計画の見方  
[実行計画の処理](https://use-the-index-luke.com/ja/sql/explain-plan/sql-server/operations)  

---

## 委譲(delegation)

委譲とは合成で代入されたオブジェクトをメソッドから呼び出すこと  

---

## AIに聞いたこと

``` md
Q.リポジトリパターンとはなんですか？

リポジトリパターンとは、データアクセスレイヤーにおけるデータの保存と取得を行うためのデザインパターンです。
このパターンは、データを永続化するストレージにアクセスするための中間レイヤーを提供します。
このレイヤーは、データを永続化するストレージとのインターフェースを提供し、アプリケーション層とストレージ層を分離します。

データの永続化とはなんですか？

データの永続化とは、アプリケーションが終了してもデータが保持されることを意味します。永続化されたデータを永続ストレージと呼び、そのストレージはデータベースやファイルシステムなどを想定します。

Q.リポジトリパターンを実装するメリットは何ですか？

リポジトリパターンを実装するメリットは以下の通りです。

1. アプリケーション層とストレージ層の分離を行うことで、耐久性と保守性の向上が期待できます。
2. パフォーマンスを向上させるために、正しいインデックスを使用したり、クエリの最適化を行うなどの最適化が容易に行えます。
3. 分離されたデータアクセスレイヤーを使用することで、テストが簡単に行えます。
4. アプリケーションに複数の異なるデータストアを使用する場合、リポジトリパターンを使用することで、ストレージの切り替えが容易に行えます。

リポジトリはどのような単位で実装すればよいですか？

1. リポジトリは、特定のエンティティを表すモデルに対して実装する必要があります。
2. リポジトリは、そのモデルに対するCRUD操作を行うメソッドを持つ必要があります。
3. リポジトリは、依存関係を注入する場所であり、また、データを書き込むストレージからデータを取得する場所でもあります。
4. リポジトリは、複数のデータストアを使用しても動作するように設計する必要があります。

複数のリポジトリを跨いだ場合のトランザクションはどのように実装すればよいですか？

複数のリポジトリを跨いだ場合のトランザクションは、UnitOfWorkパターンを使用して実装することができます。
UnitOfWorkパターンでは、複数のリポジトリを宣言的に管理するオブジェクトが提供されます。
このオブジェクトでは、複数のリポジトリを一度に処理することが可能です。
また、UnitOfWorkパターンはコミット、ロールバックなどのトランザクションを管理するメソッドも提供しています。

Q.UnitOfWorkパターンとは何ですか？

UnitOfWorkパターンとは、複数のリポジトリオブジェクトを一度に管理する仕組みを提供するデザインパターンのことです。
UnitOfWorkパターンでは、複数のリポジトリを一度に処理することが可能であるほか、トランザクションの管理も可能です。
これにより、複数のリポジトリを跨いだ操作を安全に行うことができます。

リポジトリパターン自体が複数のリポジトリを集約する方式もあるようです。
その場合、UnitOfWorkパターンとの違いは何ですか？

リポジトリパターンは、モデルに関するデータアクセスを行うリポジトリを提供するデザインパターンです。
UnitOfWorkパターンは、複数のリポジトリを一度に管理する仕組みを提供するデザインパターンです。
リポジトリパターンでは、モデルに関するデータアクセスを行うリポジトリを提供することができますが、複数のリポジトリを一度に管理する仕組みを提供するUnitOfWorkパターンとは異なります。
UnitOfWorkパターンでは、複数のリポジトリを一度に処理することができますが、リポジトリパターンではそれができません。
また、UnitOfWorkパターンでは、トランザクションの管理も可能ですが、リポジトリパターンではそれができません。

Q.EntityFrameworkを採用しているのにリポジトリパターンとユニットオブワークパターンを実装する意味はありますか？

>はい、あります。
EntityFrameworkを使用していても、リポジトリパターンとユニットオブワークパターンを実装することで、アプリケーションやライブラリの設計をより簡単にし、コードをより洗練し、管理しやすくなることです。
EntityFrameworkの仕組みを理解した上で、リポジトリパターンとユニットオブワークパターンを実装することで、アプリケーションやライブラリの設計をより効率的に行うことができます。

なぜC#以外でリポジトリパターンとユニットオブワークパターンの実装の紹介が少ないのですか？

>C#を用いたリポジトリパターンとユニットオブワークパターンの実装については、多くの情報が紹介されていますが、C#以外の言語では、情報が少ないというのは、C#が元々、そういったパターンを実装しやすい言語であるためです。そのため、その他のプログラミング言語では、パターンの実装の仕方が少し異なってくるということもあります。

EntityFrameworkを採用している場合、リポジトリパターンとユニットオブワークパターンの再実装は必要ないと主張している人たちの根拠は何ですか？

>EntityFrameworkを採用している場合、多くの人たちがリポジトリパターンとユニットオブワークパターンの再実装が不要であると主張している理由は、EntityFrameworkがすでにそれらのパターンを提供しているからです。
EntityFrameworkは、データベースへのアクセスを容易にするために、リポジトリパターンやユニットオブワークパターンを提供しています。
そのため、EntityFrameworkを採用している場合、リポジトリパターンとユニットオブワークパターンを再実装する必要はなく、EntityFrameworkを使用するだけで、データベースへのアクセスを簡単に行うことができます。

にも関わらず、実装する意味があるというのは矛盾しているように感じます。
結局、どうすればよいのですか？

>最終的には、プロジェクトのニーズや要件に応じて、リポジトリパターンとユニットオブワークパターンを適切に実装するかどうかを検討する必要があります。
例えば、プロジェクト内でEntityFrameworkを使用したいが、すでに実装されたEntityFrameworkの機能を使用している部分が多い場合は、実装する必要はないかもしれません。
一方、プロジェクト内でEntityFrameworkの機能を使用していない場合は、リポジトリパターンとユニットオブワークパターンを実装することを検討する必要があるでしょう。

C#以外のバックエンド系の言語ではどのようなパターンを用いてデータベースとの接続を抽象化するのですか？

>C#以外のバックエンド系の言語では、ORM（オブジェクト関係マッピング）を用いて、データベースとの接続を抽象化することができます。
ORMは、オブジェクトモデル（クラスやメソッドなど）を使用してデータベースにアクセスするための仕組みです。
ORMを用いて、データベースへのアクセスを容易に行うことができるため、リポジトリパターンとユニットオブワークパターンを実装する必要がなくなります。

Javaではリポジトリパターンとユニットオブワークパターンの実装は容易ですか？

はい、容易です。
Javaは非常に強力なオブジェクト指向プログラミング言語であり、リポジトリパターンとユニットオブワークパターンの実装に最適な言語として知られています。
また、Javaでは、ORM（Object-Relational Mapping）を使用したデータベースとオブジェクトモデルの操作も可能です。
```

``` md
パワーシェルでdotnet buildを並列実行する書き方を教えてください。

dotnet buildコマンドを並列実行するには、Start-Job cmdletを使用します。次の例では、PowerShellを使用してdotnet buildコマンドを4つの並列ジョブで実行します。

$jobs = 1..4 | % { 
    Start-Job -ScriptBlock { 
        param($jobNum) 
        dotnet build -c Release -o bin_$jobNum 
    } -ArgumentList $_ 
} 

Wait-Job –Job $jobs 

Receive-Job –Job $jobs

パワーシェルで並列実行する書き方を教えてください。

PowerShellを使用して並列実行する書き方を示します。

1. Start-Job cmdletを使用します。

Start-Job -ScriptBlock { 
    param($jobNum) 
    <処理内容> 
} -ArgumentList <パラメータ>

2. ForEach-Object cmdletを使用します。

<パラメータのリスト> | ForEach-Object { 
    Start-Job -ScriptBlock { 
        param($jobNum) 
        <処理内容> 
    } -ArgumentList $_ 
}

3. Invoke-Parallel cmdletを使用します。

Invoke-Parallel -ScriptBlock { 
    param($jobNum) 
    <処理内容> 
} -ArgumentList <パラメータのリスト>
```

---

``` cs
    [HttpGet("GetInt/{id}")]
    public ActionResult<int?> GetInt(int? id)
    {
        return Ok(id);
    }
```

>オブジェクトの生存期間を外部からコントロールする必要があるクラスを『状態を持つクラス』と言い、基本的に DI コンテナへ登録する対象には向いていません。  
>
>とは言っても『状態を持つクラス』を DI したい場合もあるため、状態を持たない Factory クラスをインジェクションして Factory からインスタンスを受け取るようにしています。  
>[ようこそ Dapper 至上主義の DataAccess へ【#5 WPF MVVM L@bo】](https://elf-mission.net/programming/wpf/mvvm-labo/phase05/#DataAccess_Repository)  

[superの呼び出し](https://bliki-ja.github.io/CallSuper/)  

- `asp.net` パイプライン  
プロセス間通信  
x86Extension  

Calenderのカスタマイズ  
[WPFのCalendarコントロールをカスタマイズ](https://iyemon018.hatenablog.com/?page=1484034348)  

[新人「先輩、参照の値渡しについてちゃんと理解してますか？😊」](https://qiita.com/yoshi_10_11/items/1b70ccb859891b57cb5a)  

[【Laravel】確認画面付きのお問い合わせフォームを作成する【メール送信対応】](https://into-the-program.com/laravel-create-contact-form/)
[【 Laravel 】CRUD『 表示・登録・更新・削除 』機能をCODEを書かず自動作成（Beta版機能）](https://qiita.com/daisu_yamazaki/items/3755467b39ef158b81a3)
[.NET 6とVSCodeでデスクトップアプリ（ランチャー）](https://qiita.com/Kosen-amai/items/61e6b03b8e0fccc35ee5)

[PHP（サーバー）と C#（クライアント）で圧縮した文字列のやりとりをする](https://www.create-forever.games/php-csharp-gzip-encode-decode/)  
[ASP.NET Core のミドルウェア](https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/middleware/?view=aspnetcore-6.0)  

[イベントログの確認と保存](https://news.mynavi.jp/techplus/article/techp923/)  

[いま動いてるプロセスのユーザを知る方法ってあるでしょうか。](https://teratail.com/questions/247990)

[NET Frameworkアプリケーションを64bit OS上で32bitモードで動かす方法(その2)](http://niyodiary.cocolog-nifty.com/blog/2009/05/net-framework-1.html)  

[【WPF】フォーカス遷移について知っておきたい３つのキーワード](https://qiita.com/furugen/items/40dae26ef6684dac7fc7)  
[修飾語](https://sho.benesse.co.jp/qat/j/23.html)  

[変数の渡し方 ref out in](https://qiita.com/muniel/items/02de40a7d806a39b91c1)  
[C#における値と参照](https://qiita.com/Tokeiya/items/365b3c5b613868f4c928)  

[ストップforeach！LINQで集合/結合する](https://qiita.com/i-tanaka730/items/3e6b560e80f1395ae8ea)  

[RESTとGraphQLについて](https://www.utakata.work/entry/2019/12/02/000000)
[Reference Source .NET Framework 4.8](https://referencesource.microsoft.com/#System.Web,namespaces)  

[C# の Web アプリで async/await を使わないとどれくらい性能劣化するか見てみよう(.NET Framework編)](https://zenn.dev/okazuki/articles/async-sync-webapi-dotnetfw)  

モジュールはクラスの代替になるのか？  
[第7回 VBのモジュールはオブジェクト指向に不要？](https://atmarkit.itmedia.co.jp/fdotnet/vbcheer/vbcheer07/vbcheer07.html)  

[有名企業のエンジニア向け研修資料まとめ](https://qiita.com/KNR109/items/f3268b311e11d5b821c0)  

curlってwindowsにも入ってるのな。
[curl コマンド 使い方メモ](https://qiita.com/yasuhiroki/items/a569d3371a66e365316f)  

[ncコマンドの使い方](https://hana-shin.hatenablog.com/entry/2021/12/18/203658)  

[実践WPF業務アプリケーションのアーキテクチャ【概要編】 ～ マイクロソフト公式サンプルデータベースAdventureWorksを題材に](https://codezine.jp/article/detail/10727?p=7)  

[UnityにおけるC#のGC Allocation（ヒープメモリ確保）パターンの紹介](https://creator.game.cyberagent.co.jp/?p=8645)  

[Gitリモートリポジトリの作り方](https://qiita.com/onigra/items/326ba157d5552f0076be)

[金融の基幹システムを1年半かけて.NET 6に移行した話](https://zenn.dev/nuits_jp/articles/2022-08-26-migration-to-net6)
[特別な理由なしにgit-flowを新規採用するべきではない](https://qiita.com/ktateish/items/76ca0130aec3be05376c)  

[３年間ソシャゲ開発に携わって、プログラムを書く上で大切だなと思ったこと](https://qiita.com/KyoheiOkawa/items/223368639b9a67c289d9#%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AF%E6%B0%97%E3%82%92%E3%81%A4%E3%81%91%E3%82%8B)  

[ローカル環境を汚さずDockerコンテナのオーバーヘッドもなく、開発環境を自在に構築できる「Devbox 0.2.0」登場](https://www.publickey1.jp/blog/22/dockerdevbox_020.html)  
[プロフェッショナルSSL/TLS](https://www.lambdanote.com/collections/ssl-tls/products/tls)  
[GraphQL で REST API を作る - 技術的な挑戦と、それを支える文化の話](https://tech.layerx.co.jp/entry/2022/12/19/230000)  
[DBSJ最強データベース講義](https://www.youtube.com/@dbsj4040/videos)  

dto デザインパターン  
[【デザインパターン】DAO/DTOパターン](http://www.code-magagine.com/?p=1311)  

rest postのみ  
[内部的な ajax リクエストは全部 POST でいいと思った](http://var.blog.jp/archives/79981429.html)  

[switch(true) イディオム考察](https://qiita.com/t_uda/items/1969e09a970d71e4cfd6)

[Redux is not MVC](https://github.com/yewstack/yew/issues/645)  

azure dev ops イシューに当たるものは「懸念事項」  
