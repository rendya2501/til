# 後でまとめたいやつら

---

## RPXで○○様ってつけたい

``` txt
= DataField + "様"
```

---

## 表の名称

パターン表  
デシジョンテーブル  
直交表  

``` txt
予約       | プレーヤー
-----------+------------------------------
キャンセル | 全員キャンセル → これが普通
キャンセル | 一部キャンセル → ありえない
予約       | 全員キャンセル → あり得る
予約       | 一部キャンセル → あり得る
予約       | キャンセルなし → 普通
```

ベン図×
真理値表×

---

## asp.net パイプライン

プロセス間通信
x86Extension

---

## マニフェストファイル

アプリケーション マニフェスト [application manifest]  
アプリケーションおよびそのすべての構成ファイルを記述するファイル。ClickOnce アプリケーションによって使用されます。  

俺が調べたい内容はこんな事だっただろうか。  
発行の時に追加されるあれについてだった気がする。  
それ以外の意味では、見た目に関する事だとか、管理者権限を付与するものだとか、他のアセンブリとの接続情報を保持するものだとか、  
そういったメタデータの集まり的なファイルの模様。  
まぁ、でも意味合い的にはそれだけで十分な気がするけどね。  

[C#メモ Manifestファイルを追加してフォームの表示がぼやっとしているのをはっきりさせてみる](https://www.tetsuyanbo.net/tetsuyanblog/45990)  
どういう仕組みなのかは知らないが、マニフェストファイルを追加するだけで文字のぼやけが解消するらしい。  
ここら辺は必要になったらまた調べることに鳴るだろう。  

---

## レビューに関して

<https://twitter.com/komitsubo/status/1516544935423770624>
>レビューはエンジニアの好き嫌いとか最近興味がある技術とかなどの思いの丈を語る為に提供されたしゃべり場ではなく、成果物の品質が基準に達しているかを確認する場という事が分かっていない人がホント多いなというが最近の感想。

---

## SIクラスタ認定ツイッタラー試験

①SIer:エスアイヤー
②瑕疵:かし
③敷衍:ふえん
④輻輳:ふくそう
⑤打鍵:だけん
⑥k8s:クバーネテス
⑦MECE:ミーシー
⑧EBCDIC:エビスデイック
⑨筐体:きょうたい
⑩遷移:せんい
⑪脆弱性:ぜいじゃくせい
⑫凡例:はんれい
⑬xeon:ジーオン
⑭ping（本来の英語読み）:ピン
⑮言質:げんち

※11問正解で合格
※①②⑤⑨⑩⑪⑫は禁忌問題

[SIクラスタ認定ツイッタラー試験](https://twitter.com/chio_pkmn2gen/status/1554054477417590785)  

---

## MECE (Mutually Exclusive and Collectively Exhaustive)

>MECE（ミーシー (Mee-cee); 英語: Mutually Exclusive, Collectively Exhaustive (頭字語)）とは、「相互に排他的な項目」による「完全な全体集合」を意味する言葉である。  
要するに「漏れなく・ダブりなく」という意味である。  
経営学、経営コンサルティングなどの領域でよく使われる言葉である。  
[wiki]  

<!--  -->
>MECEは、「Mutually Exclusive and Collectively Exhaustive」の頭文字を取った造語です。  
直訳すると「互いに重複せず、全体として漏れがない」という意味になりますが、「漏れなく、ダブりなく」という意味合いで使用されています。  
[HR大学](https://www.hrbrain.jp/media/human-resources-development/mece)  

---

## EBCDIC (Extended Binary Coded Decimal Interchange Code : エビシディック)

>EBCDIC (英語: Extended Binary Coded Decimal Interchange Code、エビシディック、拡張二進化十進コード) はIBMにより定義された8ビットのコード化文字セットである。  
ASCII普及前の1963年に、BCD(Binary-coded decimal、二進化十進コード)を拡張する形で作られ、主にIBM系のメインフレームやオフィスコンピュータなどで使用されている。  
[wiki]  

---

## VCS (Version Control System : バージョン管理システム)

>バージョン管理システムとは、ファイルの変更履歴の保存・管理を行うソフトウェア。  
管理下のファイルについて、過去の版の参照や、複数の版の比較、差分の検出などを行うことができる。  
[e-Words]  

---

## LT(Lightning Talk)

>ライトニングトーク（英: Lightning Talks; LT）とはカンファレンスやフォーラムなどで行われる短いプレゼンテーションのこと。  
イベントで「ライトニングトーク」と明示される場合は、それより長いプレゼンテーションも開催される。  
様々な形式があるが、持ち時間が5分という制約が広く共有されている。  
[wiki](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%A4%E3%83%88%E3%83%8B%E3%83%B3%E3%82%B0%E3%83%88%E3%83%BC%E3%82%AF)  

---

## ハッカソン(hackathon)

《hack（ハック）＋marathon（マラソン）からの造語》  
ソフトウエア開発者が、一定期間集中的にプログラムの開発やサービスの考案などの共同作業を行い、その技能やアイデアを競う催し。  
期間はふつう数時間から数日程度。  
企業内で研修の一環として行われるほか、大手企業が広く外部から参加者を集めて自社の製品やサービスに役立つアイデアを競わせたり、ベンチャーキャピタルによる出資対象の選定に利用されたりする。  
ソフトウエア以外にも、機器やプロジェクトについてのアイデアを対象とするものもある。  
ハックデイ。ハックフェスト。コードフェスト。アイデアソン。  

マラソンってついてるのに短期間なのね。  

---

## ページネーション

>ページネーションとは、丁付け、ページ割りという意味の英単語。  
>Webページに長い文章を掲載する際に、同じデザインの複数のページに分割し、各ページへのリンクを並べたものをこのように呼ぶ。  
>
>Webページに長い文章やコンテンツを掲載したいとき、一枚のページにすべての内容を掲載すると表示が完了するまでに長い時間がかかったり、一度に表示される情報量が多すぎて読みやすさや操作のしやすさが低下することがある。  
そのような場合に、内容を適度な長さごとに区切って同じデザインの複数のページに分割して掲載し、ページ下部などに各ページへのリンクを並べた構成にすることがよくある。  
このようなページ構成や、ソフトウェアにより自動的にページ分割を行う処理や機能のことをページネーションという。  
[e-words](https://e-words.jp/w/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3.html)  

グーグル検索した時、下のほうに左右の矢印と今何ページ目かを表す数字とGoooooooooooogle って表示されるアレのこと。  

---

## malloc

>malloc（マロック, エムアロック）  
動的メモリ確保を行うC言語の標準ライブラリの関数。  
確保したメモリの解放にはfree関数を使用する。  
[wiki]

<!-- -->
>この関数を使うことにより、プログラムで予め配列などを使ってメモリを確保せずに、必要な場所で必要なだけメモリを確保することが出来る。  
木構造やリストなど多くのデータ構造は、通常 malloc関数によって動的にメモリを確保している。  
[malloc](http://www9.plala.or.jp/sgwr-t/lib/malloc.html)  

---

## vlookup

表を縦方向に検索し、特定のデータに対応する値を取り出すExcel関数  

`=VLOOKUP（検索値, 範囲, 列番号, 検索の型）`  

[検索値] : どのデータで  
[範囲] : どこを検索して  
[列番号] : どの列にある値を取り出すか  
[検索の型] : 検索する値が見つからない場合、どのように処理するか  
TRUE : ［検索値］を超えない最大値を該当のデータとする。
FLASE : エラーとする。

たいていはFALSEになる模様。  

[VLOOKUP関数の使い方](https://dekiru.net/article/21009/)  

---

## 電文

>電文とは、一定の形式に従って記述された、コンピュータ間で送受信されるひとまとまりのデータ。  
原義は電報でやり取りされる文章のこと。  
コンピュータの普及が進み始めた高度成長期の頃、電気通信によって遠隔地間を伝送されるという共通点から、システム間で送受信される文字メッセージを電報になぞらえてこのように呼ぶようになった。  
現在でも、当時からの歴史が続くメインフレーム（大型汎用機）関連の分野、コンピュータの導入が早かった官庁や金融機関のシステムなどで電文という表現が使われる。  
インターネット関連など、近年に発達・普及した技術分野では英語の言い回しにならって「メッセージ」（あるいは文脈によってフレーム、パケット、リクエスト、レスポンス、クエリ等）と呼ぶことが多い。  
[e-words](https://e-words.jp/w/%E9%9B%BB%E6%96%87.html)  

<!--  -->
>電文  
あんまり今使う人いませんかね？  
ソケット通信などでやり取りする際の受け渡しデータのことです。  
Web業界では使ったためしないですが、諸先輩方は電文電文と言っているのを聞いていたので懐かしく思い挙げました。  
[一瞬何言ってるのか分からなくなるエンジニアの常用語](https://blog.8bit.co.jp/?p=5736)  

---

## RWD (Real World Data)

>日常の実臨床の中で得られる医療データの総称です。  
RWDにはレセプトデータ、DPC（Diagnosis Procedure Combination）データ、電子カルテのデータ、健診データ、患者レジストリデータ、ウェラブルデバイスから得られるデータなどがあります。  
近年、医療ITの進展により大量のRWDを取得・解析できるようになっています。  
[中外製薬](https://www.chugai-pharm.co.jp/profile/digital/real_world_data.html)  

---

## セカンドオピニオン

>がんの診断や治療では、患者や家族が正しい情報に基づいて担当医と十分に話し合い、納得して治療を受けることがとても大切です。  
しかし、担当医と十分な話し合いを行っていたとしても、「別の医師の話を聞いてみたい」と思うことがあるかもしれません。  
>
>診断や治療選択などについて、現在診療を受けている担当医とは別に、違う医療機関の医師に求める「第2の意見」を**セカンドオピニオン**といいます。  
セカンドオピニオンは、今後も現在の担当医のもとで治療を受けることを前提に利用するものであり、「セカンドオピニオンを聞くこと＝転院すること」ではありません。  
[ガン情報サービス](https://ganjoho.jp/public/dia_tre/dia_tre_diagnosis/second_opinion.html)

---

## is-a,has-a,part-of

### is-a(汎化－特化)関係

「動物－犬」や「家電－テレビ」などのように「…は、○○である」で表される関係。

### part-of(集約－分解)関係

「コンピュータ－CPU」や「自転車－サドル」などのように「…は、○○の一部である」で表される関係。

### has-a(包含関係)

全体クラス has a 部分クラス。

---

## 継続的デリバリー復習

継続的デリバリー :  
手動。本番環境にデプロイ可能な状態を保証する。  
沢山デプロイするのは色々不都合がある場合もあるので、手動でデプロイする。  

継続的デプロイメント :  
自動。インテグレーションに問題が無かったら自動的にデプロイする。  
コミットするたびなので頻度がヤバい。  
なので継続的デリバリーという概念がある。  

継続的インテグレーション :  
コミットをトリガーとして、ビルドとテストを実行する。  

バージョン管理:  
言わずもがな。  

---

## wifiと接続されたら電気をつける

・Tasker  
・IFTTT  
・SwitchBot  
・MailTask  

Taskerでwifi接続イベントを検出する。  
接続イベントに対してTaskerからMailTaskにアクションを送信する。MailTaskで設定しているメールアドレスに特定の形式のメールを送信する。  
IFTTTで、設定したメールアドレスに対する特定のメールの受信を検知する。  
イベントを検知したら設定しているSwitchBotに点灯命令を送信する。  

---

## メモリ

・変数はメモリのアドレスに名前をつけている？値を入れることで始めてメモリが確保される？それとも変数名を定義した瞬間メモリが確保される？
メモリに名前をつけただけで領域は確保されない？

変数はメモリのアドレスと紐づける。
C#で変数を宣言するだけで使わない場合、コンパイラが宣言しなかったときと同じ扱いにしてくれるのではなかろうか。
だから、使うなら領域を確保するし、しないなら宣言していないのと同じ状態としてくれるのではなかろうか。
そこらへんはコンパイラのさじ加減によるだろう。
親切なコンパイラならわざわざ確保する事はないだろうし、そうでないならアドレスと紐づけはしつつ、内部には何も入れないみたいな感じになるのでは？

いや、違うな。
変数を宣言した場合、そのアドレスと紐づけはするけど、その中身は操作しないことになるのか？
だからコンパイルの段階で紐づけをしないようにしてもらわないと、そのアドレスにアクセスできないことになる可能性があるのか。

まぁ、使わない変数を定義したところで、使っていないのだから定義すべきではないし、それだけの話だった気がする。  

``` C#
    static void Main(string[] args)
    {
        System.Diagnostics.Process hProcess = System.Diagnostics.Process.GetCurrentProcess();

        //Console.WriteLine("BaseAddress     :0x" + Convert.ToString(hProcess.MainModule.BaseAddress.ToInt64(), 16));
        //Console.WriteLine("EntryPoint      :0x" + Convert.ToString(hProcess.MainModule.EntryPointAddress.ToInt64(), 16));
        //Console.WriteLine("ModuleMemorySize:" + hProcess.MainModule.ModuleMemorySize);
        //Console.WriteLine("WorkingSet      :" + hProcess.WorkingSet64);

        //hProcess.Refresh();
        //Console.WriteLine($"物理メモリ使用量: {hProcess.WorkingSet64}\r\n仮想メモリ使用量: {hProcess.VirtualMemorySize64}");
        ////int a;
        //hProcess.Refresh();
        //Console.WriteLine($"物理メモリ使用量: {hProcess.WorkingSet64}\r\n仮想メモリ使用量: {hProcess.VirtualMemorySize64}");

        Console.WriteLine($"現在のメモリ使用量は{Environment.WorkingSet:N0}byteです。");
        Console.WriteLine($"現在のメモリ使用量は{Environment.WorkingSet:N0}byteです。");

        Console.WriteLine($"現在のメモリ使用量は{Environment.WorkingSet:N0}byteです。");
        int a = 0;
        int j;
        Console.WriteLine($"{a:N0}");
        Console.WriteLine($"現在のメモリ使用量は{Environment.WorkingSet:N0}byteです。");

        // aaaaa();
    }

    // unsafe句を使う場合はデバッグオプションでunsafeを許可する必要がある。
    // まぁ、unsafeって書いて「ctrl + .」でヒント出てくるはずだからそれ使えばよろしい。
    static unsafe void aaaaa()
    {
        int a = 100;
        int* b = &a;

        Console.WriteLine(Convert.ToString((int)&a, 16));
        Console.WriteLine("0x" + Convert.ToString((int)b, 16));

        Console.Read();
    }
```

[[変数] 変数とメモリ](https://zenn.dev/antez/books/568dd4d86562a1/viewer/09848c)  
[プログラムがメモリをどう使うかを理解する(1)](https://zenn.dev/rita0222/articles/e6ff75245d79b5)  
[プログラムがメモリをどう使うかを理解する(2)](https://zenn.dev/rita0222/articles/beda4311d9a6bf)  
[プログラムがメモリをどう使うかを理解する(3)](https://zenn.dev/rita0222/articles/f59b79bab45a2a)  
[プログラムがメモリをどう使うかを理解する(4)](https://zenn.dev/rita0222/articles/1f37a5bf910282)  
<https://twitter.com/404death/status/968381431146778624/photo/1>  

---

## CONSTRAINT 句

`CONSTRAINT 制約の名前 制約`  

`CONSTRAINT [○○_PKC] PRIMARY KEY ([フィールド1],[フィールド2],・・・)`  

テーブルのインデックスフォルダの中を見ると`Customers_PKC(クラスター化)`という名称でインデックスが生成される。  
CONSTRAINT でインデックス名の指定をしない場合`PK_Customer_*****(クラスター化)`という名称でインデックスが生成される。  
`*****`の部分は16桁のランダムな16進数となる模様。  

制約を生成するのでFOREIGN KEY等も作成可能な模様。  

CONSTRAINT句で制約名を設定しなくても複合主キーは設定できるが、ランダムチックな制約名になってしまう。  
SQLServer2016の教科書でもできるなら任意の名前をつけたほうがよいとのこと。  

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    PRIMARY KEY(CustomerID,CustomerName)
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    CONSTRAINT [Customers_PKC] PRIMARY KEY(CustomerID,CustomerName)
);
```

外部キー制約も作れる。

``` sql
CONSTRAINT `制約の名前`
    FOREIGN KEY (`このテーブルの列名を外部キーに設定`)
    REFERENCES `データベース名`.`テーブル名` (`カラム名`)
    ON DELETE NO ACTION ←親テーブルの削除時何もしない
    ON UPDATE NO ACTION ←親テーブルの更新時何もしない
```

CONSTRAINT : 制限、強制  

[SQL文でのINDEX句、CONSTRAINT句について](https://toru-takagi.dev/article/3)  

---

## 制約名を変更する方法

削除して追加する。  
制約名を更新する命令はない模様。  

``` sql : 主キー制約の変更
-- 制約削除
ALTER TABLE [テーブル名] DROP CONSTRAINT [削除する制約名]

-- 制約の追加
ALTER TABLE [テーブル名] ADD CONSTRAINT [追加する制約名]
PRIMARY KEY ([フィールド1],[フィールド2],...)
```

外部キー制約を確認するクエリ  

``` sql
select * from sys.key_constraints
```

[【SQL Server】外部キー制約の一覧を確認する](https://sqlserver.work/2021/01/06/%E3%80%90sys-foreign_keys-%E3%80%91%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC%E5%88%B6%E7%B4%84%E3%81%AE%E4%B8%80%E8%A6%A7%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B/)  

---

## PRIMARY KEY指定

主キーが1つだけの場合は`フィールド名 型 PRIMARY KEY`でもよいし、一番最後に`PRIMARY KEY (フィールド名)`のどちらでもよい。  
主キーが複数の場合は、CREATE TABLEの一番最後に`PRIMARY KEY (フィールド1,フィールド2,・・・)`の形でなければならない。  

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    PRIMARY KEY(CustomerID)
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20) PRIMARY KEY,
    CustomerName nvarchar(20),
    CustomerAdd nvarchar(50) NULL
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    CONSTRAINT [Customers_PKC] PRIMARY KEY(CustomerID)
);
```

---

・なぜwhere inは重いのか

sql where 仕組み
[SELECT文の処理の仕組みを説明してみた。](https://nattou-curry-2.hatenadiary.org/entry/20090315/1237089749)

・DB制約まとめ
・ロックのまとめ

LEFT OUTER JOIN A
RIGHT OUTER JOIN B
ON A.aa = B.aa
ON A.bb = oya.bb

この構文は

LEFT OUTER JOIN A ON B
A.aa = B.aa
LEFT OUTER JOIN B ON oya

でよいのでは説。


・重複レコードを削除する方法
　・Window関数を使った方法(rk where rk = 1)
　・JOINを使った方法(A EXCEPT A JOIN B)

あれ？単純にEXCEPTでいいのでは？
SELECT AFiled,BField FROM A
EXCEPT
SELECT DISTINCT AField,BField FROM B

あぁ、やらかしてるな。

``` sql
WITH TmpTable AS (
    SELECT 1 AS ID, 1 AS RowNum, 'and seventy nine' AS [Data]
    UNION
    SELECT 1, 2, 'five hundred'
    UNION
    SELECT 1, 3, 'two thousand'
)
select
    ID,
    [Data]
from
    (SELECT * FROM TmpTable ORDER BY RowNum DESC ) t1
group by
    t1.ID

-- メッセージ 1033、レベル 15、状態 1、行 12
-- TOP、OFFSET、または FOR XML が指定されていない場合、ビュー、インライン関数、派生テーブル、サブクエリ、および共通テーブル式では ORDER BY 句は無効です。
```

ソートはかなり重い処理に分類されるため、基本的に一番最後に行う。  
それだけで頻繁にやるべきでないことは分かるし、一番最後に出力する時にだけ行うべきってことが自然と分かるだろう。  

---

## プリペアードステートメント

SQL文で値がいつでも変更できるように、変更する箇所だけ変数のようにした命令文を作る仕組みのこと。  
パラメータクエリともいうらしい。  
Dapperにおいて`@変数`として動的にSQL文を組み立てるあの部分がそういうことになる。  

[プリペアドステートメントを利用してデータを取得する方法について解説！](https://qiita.com/wakahara3/items/d7a3674eecd3b021a21e)  
[C# .NET パラメータクエリでSQLインクジェクション対策](https://greentown.tokyo/dotnet-sqlinjection/)  

---

## トランザクションの肥大化

[トランザクションログ肥大化の対処方法 (log_reuse_wait_desc : LOG_BACKUP) [SQL Server]](https://www.nobtak.com/entry/tlogs2)  
[【INDEX】SQL Server トランザクションログ肥大化 (原因／対処方法)](https://www.nobtak.com/tlogidx#2-%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%AD%E3%82%B0%E3%82%92%E8%82%A5%E5%A4%A7%E5%8C%96%E3%81%95%E3%81%9B%E3%81%A6%E3%81%84%E3%82%8B%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AE%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95)  
[トランザクションログを肥大化させているクエリの特定方法 [SQL Server]](https://www.nobtak.com/entry/tlogs0)  

---

## VisualStudioのソリューション

>ソリューションとプロジェクト  
Visual Studio のソリューションは、"解決策" ではありません。  
ソリューションは、1 つ以上の関連するプロジェクトを整理するために Visual Studio で使用される単なるコンテナーにすぎません。  
ソリューションを開くと、Visual Studio により、ソリューションに含まれるすべてのプロジェクトが自動的に読み込まれます。  
[プロジェクトとソリューションの概要](https://learn.microsoft.com/ja-jp/visualstudio/get-started/tutorial-projects-solutions?view=vs-2022)  

プロジェクトをまとめる単位。  
製品としてのまとまりって認識でよさそうだな。  

## クラスライブラリの発行

何も考えずに発行したら`.nupkg`が生成された。  
名前からしてNuGetのパッケージだと思われる。  

[C#でクラスライブラリを開発する時に必ずやった方が便利な設定](https://qiita.com/kojimadev/items/9d41e57da628dd74246d)  

---

## フルテキストインデックス

>インデックス（索引）は、データベースの性能を向上させる方法の一つです。  
しかし、通常のIndex では text ベースのカラム(CHAR型、VARCHAR型、TEXT型) から特定の文字列を検索する全文検索には向いていません。  
それは、通常のIndex はカラムの値の一部ではなく、値全体に対する検索に最適化されているからです。  
そのため、全文検索 (カラムの値の一部が一致している結果を取得) するには、別のインデックス FULLTEXT INDEX が必要です。  
[世界一わかりやすい FULLTEXT INDEX の説明と気を付けるべきポイント](https://zenn.dev/hiroakey/articles/9f68ad249af20c)  

---

## ER図 Git管理

[tblsを使えば，ER図をgitで管理しやすい](https://zenn.dev/lightkun/articles/6caf17872b6521)

---

## git.bashでexeを実行する方法

`./ <exe_name>`  

例:カレントディレクトリのefbundle.exeを実行する  
`./ efbundle`  

- 気を付けること  
  - exe名の直接指定では実行できない  
  - `.\`ではなく`./`  

[Windows git-bash.exeでバッチファイルを実行](https://teratail.com/questions/100039)  

---

## appsettings.json 有無 確認

appsettings.json existance check
https://stackoverflow.com/questions/44641488/how-to-check-if-configuration-section-exists-in-net-core

---

## コンソールアプリでappsettings.jsonを使う

単純そうに見えて、意外とやることが多い。  

NuGetからライブラリをインストールする。  

`Microsoft.Extensions.Configuration`  
`Microsoft.Extensions.Configuration.Json`  

`dotnet add package Microsoft.Extensions.Configuration --version 6.*`
`dotnet add package Microsoft.Extensions.Configuration.Json --version 6.*`

``` json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=<sv_name>;Database=<db_name>;User ID=<user_id>;Password=<passwd>"
  }
}
```

### appsettings.jsonをビルド結果に含める場合

プロジェクトファイルにセクション追加

``` xml : csproj
  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>
```

デフォルトの場合、`bin/debug`階層のappsettings.jsonファイルを参照しに行く模様。  

``` cs
using Microsoft.Extensions.Configuration;

var configuration = new ConfigurationBuilder()
    .AddJsonFile("appsettings.json")
    .Build();

Console.WriteLine(configuration.GetConnectionString("DefaultConnection"));
```

### プロジェクトファイルと同じ階層のappsettings.jsonを使用する場合

`Directory.GetCurrentDirectory()`はPCが処理を行っている場所を指し示すので、プロジェクトファイル階層で`dotnet run`を行う限りはプロジェクトファイル階層のappsettings.jsonを参照できる。  

``` cs
using System.IO;
using Microsoft.Extensions.Configuration;

var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .Build();

Console.WriteLine(configuration.GetConnectionString("DefaultConnection"));
```

[.NETのコンソールアプリでappsettings.jsonを使う (.NET6)](https://zenn.dev/higmasu/articles/b3dab3c7bea6db)
[How to Get Connection String from Appsettings.json? .net Core Console Application](https://yarkul.com/how-to-get-connection-string-from-appsettings-json-net-core-console-application/)  

---

## コンソールアプリから別のexeを引数ありで実行する

``` cs
using System;
using System.Diagnostics;

// Processクラスのオブジェクトを作成
Process process = new Process();
// コマンドプロンプト
process.StartInfo.FileName = "cmd.exe";
// コマンドプロンプトに渡す引数
process.StartInfo.Arguments = "/c dir";
// ウィンドウを表示しない
process.StartInfo.CreateNoWindow = true;
process.StartInfo.UseShellExecute = false;
// 標準出力および標準エラー出力を取得可能にする
process.StartInfo.RedirectStandardOutput = true;
process.StartInfo.RedirectStandardError = true;

// プロセス起動
process.Start();
// 標準出力を取得
string standardOutput = process.StandardOutput.ReadToEnd();
// 標準出力を表示
Console.WriteLine(standardOutput);
```

[C#でのexeファイルの扱い方とは？exeの起動・exeの実行結果を取り込む・exeの終了を待ち合わせる・exeのパスを取得する方法](https://www.fenet.jp/dotnet/column/language/9700/)

---

## er diagram github

tblsとGitHub Actionsを使ってDBマイグレーションを含むPRには自動更新したER図を追加する
https://devblog.thebase.in/entry/auto_generated_er_graph_by_tbls_and_github_actions

``` txt
OPERATION | SQL    | HTTP/REST
----------+--------+-----------
CREATE    | INSERT | POST
READ      | SELECT | GET
UPDATE    | UPDATE | PUT
DELETE    | DELETE | DELETE
```

[Repository Pattern](https://www.youtube.com/watch?v=x6C20zhZHw8)  

---

## クラス図

[IT専科](https://www.itsenka.com/contents/development/uml/class.html)  

継承(inheritance) → 汎化(generalization)  
実装(implemente) → 実現(realization)  

---

## テストコード

[意識が高くないVisualStudioを使用した単体テストの自動化](https://qiita.com/mima_ita/items/05ce44c3eb1fd6e9dd46)  

---

## ARM

>ARM系プロセッサはスマートフォンなどのモバイル端末、機器の制御装置など組み込みシステムで人気が高いが、ARM64は高い性能が求められる高性能スマートフォンやサーバでよく用いられる。  
汎用コンピュータ製品での普及も見込まれ、Windows 10以降がARM64に新たに対応したり、MacのCPUが米インテル（Intel）系製品からARM64ベースの自社開発チップ（M1など）に変更されるなどの動きが広がっている。  
[e-words]  

<!--  -->
>「ARM」のCPUは、パソコンを除けばスマホは勿論、タブレットやモバイル系のゲーム機、カーナビやルーターに至るまで、様々デバイスに搭載されています。  
また、小型で省電力性能に優れる、RISC型のCPUのアーキテクチャーのため、スマホやタブレットなどのモバイル機はもちろん、カーナビやSTB、白物家電などの組み込みではシェアは圧倒的。  
[「ARM」のCPUとは？特徴と種類を徹底解説!!](https://mo-no-log.com/arm/)  

---

## null!の意味

C#8.0からの問題  

null免除演算子をnullにつけただけ。  
nullなのにnullではない事をアピールしている。  
なんとも奇妙だが、型システム的には実際の値には関心がないからこれでも良いらしい。  

意味的には警告を消すためだけのシグネチャ。  

`! = from Nullable to Non-Nullable`  
`? = from Non-Nullable to Nullable`  

``` cs
// line 1
// null 非許容の プロパティ 'FirstName' には、コンストラクターの終了時に null 以外の値が入っていなければなりません。プロパティ を Null 許容として宣言することをご検討ください。
public string FirstName { get; }

// line 2
// 警告なし
public string LastName { get; } = null!;

// assign null is possible
// 警告なし
public string? MiddleName { get; } = null;
```

>オッケー！？でも、null！ってどういう意味？  
>これはコンパイラに、nullはnullableな値ではないことを伝えるものです。  
>変な感じでしょう？  
>nullリテラルに演算子を適用しているので、変に見えるだけです。  
>しかし、コンセプトは同じです。
>この>場合、NULLリテラルは他の式/型/値/変数と同じです。  
>
>ヌルリテラル型は、デフォルトでヌル可能な唯一の型なのです。  
>しかし、学習したように、どのような型でもnullabilityは!でnon-nullableに上書きすることができます。  
>
>型システムは、変数の実際の値や実行時の値には関心を持ちません。  
>コンパイル時の型だけで、あなたの例では、LastNameに割り当てたい>変数（null！）はnon-nullableで、これは型システムに関する限り有効です。  

[What does null! statement mean?](https://stackoverflow.com/questions/54724304/what-does-null-statement-mean)

---

## 詳細設計書

[詳細設計書って何をどう書くの？](https://qiita.com/pickles1413/items/38d650fc29bb6a6c070d)

---

## Parallel.For, Parallel.ForEach

デフラグっぽいグラフィカルな表現で並列処理が確認できて面白い。  
[(C#)Parallel.For, Parallel.ForEach並列処理の挙動確認](https://qiita.com/longlongago_k/items/8f19d84fce6dd677922e)  

---

## C# Transaction Attribute

ASP.Net Core ではHTTP通信のミドルウェアでトランザクション制御ができる模様。  
なので、この手法であればコントローラーの中でならTransaction Attributeをつける事ができる。  
が、ビジネス層でやるわけではないので、融通は効かないだろう。  

そもそも独自のAOPを実装する場合はAutofacとかCastle等のパッケージをインストールして開発していくことになる模様。  
その場合、スタートアップにおいて色々やる必要があって、そこまでしてようやく使える用になるので、正直面倒くさい。  

やりたいのはメソッドに`[Transaction]`ってつけたいだけなんだ。  

まぁ、C#で実装されていないなら素直にTransactionScopeを使うべし。  
実装できるかも？という可能性は感じたが、何が何でも実装してやっていきたいというほどではないし、苦労に見合わない。  

ミドルウェアでトランザクション処理を定義する方法を紹介しているところ。  
ざっくり見ると可能性を感じるが、どう頑張ってもControllerの中でしか生きられない。  
[Transaction middleware in ASP.NET Core](https://dev.to/moesmp/transaction-middleware-in-aspnet-core-2608)  

C#でもJavaのようなアトリビュートを！って考える人はやっぱりいるらしく、一番可能性のある記事だったが、やっぱりController限定である。  
下の方にAutofacを使った場合の処理も紹介されているが何故かスルーされている。  
[Transactional annotation attribute in .NET Core](https://stackoverflow.com/questions/57441301/transactional-annotation-attribute-in-net-core)  

少し古いけどRealProxyを使ったTransaction Annotationの実装が紹介されている。  
これを参考に色々やったらできるかもしれないね。  
[透過プロキシでアスペクト指向プログラミング (2)](https://sakapon.wordpress.com/tag/%E9%80%8F%E9%81%8E%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/)  

Castle Coreを利用した基本的な実装方法が紹介されている。  
AOPしたいなら基本的なところから入って参考にする分にはいいかもしれない。  
[XamarinでもAOPしたい！　希望編](https://www.nuits.jp/entry/xamarin-fody-01)  

.NetFrameworkでは「RealProxy」.NetCoreでは「DispatchProxy」でAOPを実装するらしい。  
なるほど。  
アスペクト指向的な処理はProxyパターンとしてデザインパターンがあるのか。  
で、RealProxyはProxyパターンをさらに拡張したモノだとか。  
[RealProxyクラスによるアスペクト指向プログラミングに入門してみた。](RealProxyクラスによるアスペクト指向プログラミングに入門してみた。)  

---

## C# AOPライブラリ

代表的なものとして`PostSharp`と`Fody`なるものがあるらしい。  
PostSharpは有料のライブラリだが、小規模なプログラム(1000行以下とか)なら無料で使える。  
ただ、無料で使おうとした場合でも、メールアドレスの登録などは必要そうだったので断念した。  

Fodyは完全無料。  
手っ取り早くAOPしてみたいならこっちでいいんじゃないかな。  

[C#のAOPライブラリ（PostSharp）](https://kouki-hoshi.hatenablog.com/entry/2017/06/21/023159)  
[C#のAOPライブラリ（Fody）](https://kouki-hoshi.hatenablog.com/entry/2017/06/25/011038)  

---

## Cysharp

C#の可能性を切り開いていく専門会社が作ってるOSSライブラリ  

コンソールアプリでCLIプログラムのひな形を紹介している。  
[github_Cysharp](https://github.com/Cysharp/ConsoleAppFramework)  

---

## C# .Net6のWebプロジェクトにおけるappsettings.jsonの取得

`dotnet new web`で`ASP.Net Core (空)`プロジェクトを作成した時のデフォルトのProgram.csの状態は以下の通り

``` cs : Program.cs
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

この状態において`appsettings.json`に`ConnectionStrings.DefaultConnection`を追加する。  

``` json : appsettings.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Server=<sv_name>;Database=<db_name>;User ID=<user_id>;Password=<passwd>"
  },
  "AllowedHosts": "*"
}
```

`builder.Configuration`から`GetConnectionString()`メソッドによって読み取ることができる。  

``` cs
var builder = WebApplication.CreateBuilder(args);
// buiderのConfigurationから取得可能
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

---

## Name=\<connection-string\> 構文によるappsettings.jsonの読み取り

EFCoreによるスキャフォールド及びバンドル作成において検証。  
appsettings.jsonの読み取りは`Configuration.GetConnectionString("DefaultConnection")`  

ユーザーシークレット使用  
appsettings.jsonにConnectionStrings.DefaultConnectionを追加  
`name=ConnectionStrings:DefaultConnection`で読み取り  
→OK  

[ConnectionStrings.DefaultConnection]→[ConnectionStrings.DefaultConnection2] に変更  
バンドル作成  
→エラー  

`name=ConnectionStrings:DefaultConnection`を`name=ConnectionStrings:DefaultConnection2`に変更  
バンドル作成  
→OK  

これから見るに、name=構文はappsettings.jsonを見ている。  

試しにユーザーシークレットを使わないでスキャフォールドして同じような状況を作ってみた。  
appsetting.jsonにConnectionStrings.DefaultConnectionを追加  
name=ConnectionStrings:DefaultConnectionで読み取り  
バンドル作成  
→OK  

というわけで、name構文でもappsetting.jsonを読み取れることが分かった。  
ユーザーシークレットの有無は関係ない模様。  

まぁ、それでappsettings.jsonを読み取れるならそれでいいか。  

``` json : appsettings.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection2": "Server=<sv_name>;Database=<db_name>;User ID=<user_id>;Password=<passwd>"
  },
  "AllowedHosts": "*"
}
```

``` cs
using namespace.Context;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(
    options =>options.UseSqlServer("name=ConnectionStrings:DefaultConnection2"));
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

[[ASP.NET]多層システムにおけるDbContextのバケツリレーをDIコンテナで解消する](https://qiita.com/jun1s/items/484cb55e7b6023e8fd23)  
[ASP.NET Core の依存関係の挿入における DbContext](https://learn.microsoft.com/ja-jp/ef/core/dbcontext-configuration/#dbcontext-in-dependency-injection-for-aspnet-core)  

---

## ASP.NET Core開発におけるアプリシークレットの安全な保存

dotnet-efコマンドでスキャフォールドする時に、`--no-onconfiguring`オプションを入力しない状態で接続先情報を直接入力すると黄色い文字で警告が表示される。  

``` txt : 実行コマンド
dotnet ef dbcontext scaffold 'Server=<sv_name>;Database=<db_name>;User ID=<user_id>;Password=<passwd>;' Microsoft.EntityFrameworkCore.SqlServer --output-dir Entity --context-dir Context --context DatContext --data-annotations --use-database-names --force
```

``` txt : 警告文
To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263.
```

>接続文字列に含まれる潜在的な機密情報を保護するために、接続文字列をソースコードの外に移動する必要があります。
>接続文字列を構成から読み込むためにName=構文を使用することで、scaffoldを回避することができます - <https://go.microsoft.com/fwlink/?linkid=2131148> を参照してください。  
>接続文字列の保存に関するより詳しいガイダンスは、<http://go.microsoft.com/fwlink/?LinkId=723263> を参照してください。  

警告文を訳すとそのままなのだが、接続情報はセンシティブなので、機密データを格納するいい方法があるからそっち使ったほうがいいよって言ってくれる。  

[リバース エンジニアリング](https://learn.microsoft.com/ja-jp/ef/core/managing-schemas/scaffolding/?tabs=dotnet-core-cli#configuration-and-user-secrets)  
上記リンク先の[リンク構成とユーザーシークレット]で紹介されている構文を利用することで`Name=ConnectionString:<alias>`で安全？にスキャフォールドできるっぽい。  

そこから先はまた何か分かったらまとめる。  
因みにこの方法はコンソールアプリでは使えない。  

``` txt : ユーザーシークレットを使った場合
dotnet user-secrets init
dotnet user-secrets set connectionStrings:<Alias> "Server=<sv_name>;Database=<db_name>;User ID=<user_id>;Password=<passwd>;"
dotnet ef dbcontext scaffold Name=ConnectionStrings:<Alias> Microsoft.EntityFrameworkCore.SqlServer --output-dir Entity --context-dir Context --context DatContext --data-annotations --use-database-names --force
```

[ASP.NET Core での開発におけるアプリ シークレットの安全な保存](https://learn.microsoft.com/ja-jp/aspnet/core/security/app-secrets?view=aspnetcore-7.0&tabs=windows)  
[ASP.NET CoreにおけるUserSecretを使用した設定情報の保存](https://shuhelohelo.hatenablog.com/entry/2019/11/13/101328)  

---

>オブジェクトの生存期間を外部からコントロールする必要があるクラスを『状態を持つクラス』と言い、基本的に DI コンテナへ登録する対象には向いていません。  
>
>とは言っても『状態を持つクラス』を DI したい場合もあるため、状態を持たない Factory クラスをインジェクションして Factory からインスタンスを受け取るようにしています。  
>[ようこそ Dapper 至上主義の DataAccess へ【#5 WPF MVVM L@bo】](https://elf-mission.net/programming/wpf/mvvm-labo/phase05/#DataAccess_Repository)  

[superの呼び出し](https://bliki-ja.github.io/CallSuper/)  

なぜ新しい技術を使っていきたいのか？  
・市場価値のため  
・他でやっていける力をつけるため  
・学ぶことが楽しいから  
でもこれは、今の職場で学ぶことが何もなくなったり、圧倒的な成果を出すことが出来た時に考えることであって、現職で毎日学ぶことがあって楽しいならまだ早いと思う。  
[転職・退職する前に考えてほしいこと](https://qiita.com/hiro-hiro/items/5d4f89cd30cf3e87bd61)  

---

## ASP.Net Core Web API のSwaggerを VSCodeのCLIから立ち上げる

`WepAPI`を起動する時の話。  

Visual Studioでは`IIS Express`の起動オプションがあって、それで実行した場合、自動的にSwaggerが表示される。  
同じ感覚でVSCodeからCLIで`dotnet run`するのだが、何も立ち上がらない。  
表示されるURLに飛んでもエラーの画面が出るだけ。  
VSCodeからCLIで起動した場合にSwaggerを使うためにはどうすればよいのか調べた。  

結果的に表示されるURLに`/Swagger`でアクセスするだけでよかった。  

`https://localhost:port/swagger/`  

[VSCODE ASP.NET Coreで「Swagger」を導入して利用するまで](https://mebee.info/2021/07/17/post-35547/)  

検索文字列  
dotnet run --launch-profile "WebAPISample"
dotnet watch run swagger  
dotnet swagger cli

---

## ASP.Net Core Web API のデフォルトURLを変更する

`WebAPI`を`dotnet run`で立ち上げたときに表示されるデフォルトのURLの末尾に`/Swagger`って追加して、Ctrl+クリックですぐにSwaggerに飛べるようにできないか調べてみた。  

できなかったが、同じようなことを考えている人たちはいたのでリンクだけまとめる。  

[Set start URL in ASP.NET Core – Quick & Easy ways](https://procodeguide.com/programming/how-to-set-start-url-in-aspnet-core/)  
[How to set up URL of ASP.NET Core Web Application in Visual Studio 2015](https://stackoverflow.com/questions/38737847/how-to-set-up-url-of-asp-net-core-web-application-in-visual-studio-2015)  

---

``` cs
    [HttpGet("GetInt/{id}")]
    public ActionResult<int?> GetInt(int? id)
    {
        return Ok(id);
    }
```
