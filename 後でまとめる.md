# 後でまとめたいやつら

## 最近見つかったシンプルなソート法

``` C#
var array = new int[2,4,5,6,4,6,8,2,8,9,4];

for(var i = 0 ; array.length; i++){
    for(var j = 0 ; array.length; j++){
        if (array[j] < array[i]){
            swap(array[i],array[j]);
        }
    }
}

// O(n^2)
```


## 添付プロパティ

例えば、テキストボックスとボタンがあります。
カーソルが当たっている間は色を変えたいけれど、どちらにもその機能はない。
それぞれを継承して拡張した、CustomButton,CustomTextを作ってもいいけど、どちらにも同じコードを書くことになるし作ること自体に手間がかかる。
そういう時に添付プロパティなるものを作って、それをテキストボックスとボタンに実装してあげることで、その機能を実現することができる。
それが、添付プロパティ。

どうやって作るかは後でまとめる。



DependencyProperty→バインディングができるようにする。コントロールにそういう機能がある。

INotify
Classに実装。

バインディングをしたときに、バインド間で通知をしてくれる。
この処理は.Net側の処理なので、その先で何をやっているかはわからない。

CollectionChanged。

ObsColle 
Foreachの中で、inに入れるコレクションの内容が変わった時にエラーが発生する。
これは、イベントが邪魔をしている証拠。
抑制する必要がある。

## インスタンスの状態

[[C# 入門] クラスのインスタンスについて](https://yaspage.com/prog/csharp/cs-instance/)  

DependencyPropertyのBindingの件で東さんがインスタンスの状態なんて事を言っていたので調べたわけだが、  
それとは別にインスタンスについての基礎を紹介しているページがわかりやすかったのでまとめる。  

---

## コントロールのスタイルを作成する方法 (WPF .NET)

[コントロールのスタイルを作成する方法 (WPF .NET)](https://docs.microsoft.com/ja-jp/dotnet/desktop/wpf/controls/how-to-create-apply-style?view=netdesktop-5.0)  
[WPF4.5入門 その50 「Style」](https://blog.okazuki.jp/entry/2014/09/04/200304)  

因みにXAMLをデバッグ中に変更できる機能は「エディットコンテニュー」というらしい。  
VisualStudio2017から使えるようになったようなので、比較的新しい技術みたいだ。  


Styleで指定した値はデフォルト値になる。

スタイルの暗黙的な適応  
スタイルの TargetType を TextBlock 型に設定し、x:Key属性を省略すると、
そのスタイルにスコープ指定されているすべての TextBlock 要素 (通常、XAML ファイル自体) にスタイルが適用されます。

``` XML : スタイルの暗黙的な適応
<Window.Resources>
    <!-- x:Key属性が省略されているのでTextBlock型全てに設定が適応される -->
    <Style TargetType="TextBlock">
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="FontFamily" Value="Comic Sans MS"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
</Window.Resources>
<StackPanel>
    <TextBlock>My Pictures</TextBlock>
    <TextBlock>Check out my new pictures!</TextBlock>
</StackPanel>
```

スタイルの明示的な適応  
値が含まれる x:Key 属性をスタイルに追加すると、そのスタイルは TargetType のすべての要素に暗黙的に適用されなくなります。  

``` XML : スタイルの明示的な適応
<Window.Resources>
    <!-- x:Key属性を定義 -->
    <Style x:Key="TitleText" TargetType="TextBlock">
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="FontFamily" Value="Comic Sans MS"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
</Window.Resources>
<StackPanel>
    <!-- x:Key属性の使用を宣言することでMyPicturesのみに設定が適応される -->
    <TextBlock Style="{StaticResource TitleText}">My Pictures</TextBlock>
    <TextBlock>Check out my new pictures!</TextBlock>
</StackPanel>
```

スタイルの継承  
Styleは、別のスタイルを元にして新しいStyleを作ることが出来ます。  
BaseOnというプロパティに元になるStyleを指定することで実現出来ます。  

``` XML : スタイルの継承
<Window.Resources>
    <Style TargetType="TextBlock">
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="FontFamily" Value="Comic Sans MS"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
    <!-- BasedOnで元となるスタイルを定義 -->
    <Style BasedOn="{StaticResource {x:Type TextBlock}}"
           TargetType="TextBlock"
           x:Key="TitleText">
        <Setter Property="FontSize" Value="26"/>
        <Setter Property="Foreground">
            <Setter.Value>
                <LinearGradientBrush StartPoint="0.5,0" EndPoint="0.5,1">
                    <LinearGradientBrush.GradientStops>
                        <GradientStop Offset="0.0" Color="#90DDDD" />
                        <GradientStop Offset="1.0" Color="#5BFFFF" />
                    </LinearGradientBrush.GradientStops>
                </LinearGradientBrush>
            </Setter.Value>
        </Setter>
    </Style>
</Window.Resources>
<StackPanel>
    <!-- x:Key属性の使用を宣言することでMyPicturesのみに設定が適応される -->
    <TextBlock Style="{StaticResource TitleText}" Name="textblock1">My Pictures</TextBlock>
    <TextBlock>Check out my new pictures!</TextBlock>
</StackPanel>
```

トリガー  
Styleでは、Triggerを使うことでプロパティの値に応じてプロパティの値を変更することが出来ます。  
例えばマウスが上にあるときにTrueになるIsMouseOverプロパティがTrueの時に、背景色を青にするには以下のようなStyleを記述します。  

``` XML
<Style x:Key="DefaultTextStyle" TargetType="{x:Type TextBlock}">
    <Setter Property="FontFamily" Value="Meiryo UI" />
    <Setter Property="FontSize" Value="12" />
    <Style.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter Property="Background" Value="Blue" />
        </Trigger>
    </Style.Triggers>
</Style>
```

・Template

・TemplateBinding
親の設定を子にも適応させるやつ。

・StaticResource  
対象のプロパティに1度だけ設定が行われます。
リソースとバインド先の依存関係プロパティの対応付けは起動時の1回のみ、ただしクラスは参照なのでリソースのプロパティの変更はバインド先も影響を受ける。

・DynamicResource
リソースの内容が変更されたら対象のプロパティも変更されます。
リソースとバインド先の依存関係プロパティの対応付けは起動時および起動中(リソースに変更がある度)。つまりリソースのオブジェクトが変わってもバインド先は影響を受けるし、当然リソースのプロパティ変更はバインド先も影響を受ける。


・ControlTemplate
コントロールのためのテンプレート。
なんかControlTemplate定義してるところは全部Gridから始まっているけど何なのだろうか。そういうものなのか？  

このコントロール テンプレートは単純です。
コントロールのルート要素である Grid
ボタンの丸みのある外観を描画するための Ellipse
ユーザー指定のボタンの内容を表示する ContentPresenter

ControlTemplate単体で定義して、x:keyで指定することも可能な模様。  

・ContentControl
どんなに頑張ってもチェックボックスのForegroundが変わってくれなかった。
元のソースを見てみると、CheckBoxのContentプロパティのContentControlなるものを操作していたので、
そちらのForegroundを変更したら行けた。

・何個も入れ子になっているStyleのTemplateBindingは本当に全部親の設定を引き継いでいるという認識でいいのか？

・いろいろなコントロールが組み合わさってモノができているのはわかるけど、その中のこのコントロールの大しての設定！みたいな指定ってどこでやってるんだ？

[WPFのStaticResourceとDynamicResourceの違い](https://tocsworld.wordpress.com/2014/06/26/wpf%E3%81%AEstaticresource%E3%81%A8dynamicresource%E3%81%AE%E9%81%95%E3%81%84/)  
[MSDN_WPFのStaticResourceとDynamicResourceの違い](https://social.msdn.microsoft.com/Forums/ja-JP/3bbcdc48-2a47-495e-9406-2555dc515c3a/wpf12398staticresource12392dynamicresource123983694912356?forum=wpfja)  
[コントロールのためのテンプレートを作成する方法 (WPF.NET)](https://docs.microsoft.com/ja-jp/dotnet/desktop/wpf/controls/how-to-create-apply-template?view=netdesktop-5.0)  
[テンプレート（WPF）](https://ufcpp.net/study/dotnet/wpf_template.html)  
[[WPF]ComboBoxのControlTemplateを使ってシンプルかつMouseOrver時に色が変わるComboBoxを作ってみた](https://qiita.com/nori0__/items/61bc195ff6e07ff1daa5)  



・SnapsToDevicePixels

エッジをシャープにするオプションらしい。
これがないとぼやけるっぽいので常につけておけばいいんじゃないかな。

---

## シングルトン

[デザインパターン「Singleton」](https://qiita.com/shoheiyokoyama/items/c16fd547a77773c0ccc1)  
・指定したクラスのインスタンスが1つしか存在しないことを保証する
・インスタンスが1個しか存在しないことをプログラム上で表現したい

``` C# : シングルトン実装例
    /// <summary>
    /// シングルトンクラス
    /// 1.Singletonクラスがロードされた時点では、Singletonインスタンスは生成されない
    /// 2.Singleton#getInstance()を最初に呼び出した時に、SingletonHolderクラスがロードされ、Singletonインスタンスが生成される
    /// ギリギリまでSingletonインスタンスを生成しないような挙動になるようです。
    /// </summary>
    class Singleton
    {
        /// <summary>
        /// コンストラクタ
        /// </summary>
        private Singleton() { }
        /// <summary>
        /// インスタンス
        /// </summary>
        /// <returns></returns>
        public static Singleton Instace { get; } = SingletonHolder.INSTANCE;
        /// <summary>
        /// シングルトン生成クラス
        /// </summary>
        private static class SingletonHolder
        {
            public static readonly Singleton INSTANCE = new Singleton();
        }
    }
```

[シングルトンがなぜ必要なのか](https://teratail.com/questions/36721)  

インスタンスがなぜ一つじゃないといけないのか
使えるリソースが一つだけの場合、それにアクセスするクラスインスタンスも一つだけの方が都合が良い場合が多いからです。
例えば、画面に何か出力するとき、JavaではSystem.outを使いますが、それは「標準出力」というたった一つしかないリソースに対してアクセスを行うために、staticフィールドで定義されたインスタンスであり、staticなのでプロセス内には1個しかインスタンスがありません。
なぜそうしているのかというと、画面に何か書きたいときに、いちいちnewしてクラスインスタンスを作るのは面倒だし、そのたびにnewしていたら無駄にメモリを食うし、それを避けるために一度newしたものを別のクラスでも使い回そうとすると、そのインスタンスの受け渡しをどうするのかという問題が出てくるし……。
ということで、staticフィールドにインスタンスを作ってそれをみんなで使い回すことにするのです。

どのような場面でシングルトンを使うのか
シングルトン（パターン）はインスタンスを一つしか作らないことを「保証する」ための仕組みです。
ただ単にインスタンスを一つにしたいというだけならstaticフィールドにすればできますが、それを知らずに誰かがnewしてしまったらインスタンスが複数になってしまいます。あるいは、staticフィールドにインスタンスを作りたいけど、初期化の順番をコントロールしたい、というケースもあるかもしれません。マルチスレッドでの動作を考慮しないといけないかもしれません。
そういうときに一手間かけてシングルトン（パターン）を使います。

[[Swift]Singleton（シングルトン）とは？メリット、実装方法、使い方](https://ticklecode.com/swiftsingleton/)  

シングルトンはどんなときに使うのか、そのメリット
・たくさんのインスタンスからアクセスされると困るとき
・毎回、インスタンス生成をするのが手間
・共通的な情報保持をして、メモリを節約したい

例えば

・ログを出力機能、常に１つのインスタンスからファイルへ出力したい
・画面に出力（標準出力）、画面は1つなので1つのインスタンスから出力
・取得したJSONデータをどの画面でも使う時

[【Singeltonパターン】考え方は単純だが、使いどころが大切なデザインパターン【コード例はRubyとJava】](https://debimate.jp/2020/04/26/%E3%80%90singelton%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%80%91%E8%80%83%E3%81%88%E6%96%B9%E3%81%AF%E5%8D%98%E7%B4%94%E3%81%A0%E3%81%8C%E3%80%81%E4%BD%BF%E3%81%84%E3%81%A9%E3%81%93%E3%82%8D%E3%81%8C/)  

Singletonパターンが適さないケース
No.	適さないケース	理由
1	多くの状態（filed、メンバ変数）を持つ	状態はグローバル変数と同一なので、その数は0に近い方が良い
2	単体テストの実行順に制約を生む場合	単体テストの作成および実行を困難にしてしまう
3	マルチスレッド環境に導入する場合	Singeltonへのアクセス管理（ロック）にコストが発生してしまう
4	常に決まった値を渡す（or 出力）	クラスメソッド（static関数）に置き換えた方が良い


Singletonパターンが適したケース
IBMが定義するSingletonパターンが適したケースは、以下の3項目を全て満たした場合です。正直、私は下記の引用説明ではピンとこなかったので、Singletonを使ったクラス例を調べました（後述しています）。

すべてのアプリケーションは、まったく同一の方法でこのクラスを使用するか? (「まったく」がキーワード)
すべてのアプリケーションは、常にこのクラスの1つのインスタンスのみを必要とするか? (「常に 」と「1つの」がキーワード)
このクラスのクライアントは、自分自身がその一部に含まれているアプリケーションを意識しないべきか?


Singletonパターンが適したクラス例
以下に、Singletonパターンで設計した方が良い可能性のあるクラス（機能）を示します。

ロギング
キャッシュ管理
スレッドプール管理
データベース接続ドライバ
ソケット制御ドライバ
上記のクラス（機能）を踏まえると、リソース管理にSingletonパターンが適していると考えられます。リソースに対して複数のインスタンスが管理を行えば、状態管理で不整合が生じる可能性があります。この不整合を防止するために、Singletonを用いるのは自然な事だと思います。

---

## C# プレースホルダー中におけるToStringFormatの指定

SettlementAmount.ToString("N0") → SettlementAmount:N0  
に省略できるらしい。便利。  

因みにToStringするときに文字列で指定するこれは、「書式設定」というらしい。  
そのまんまだね。  
これはプレースホルダー中で有効な機能なだけだった。
C#Ver6からの機能みたい。

``` C#
$"支払額{SettlementAmount:N0}円を人数{TargetPlayerCount}人で均等に割り付けます。{Environment.NewLine}よろしいですか？"
```

[【C#6.0～】文字列補間（$を使った文字列書式設定）](https://imagingsolution.net/program/string_interpolation/)  

---

## staticクラスでthisが使えないのはなぜか？

①スタティックって結局何なのか？  
②staticクラスのメンバーにthisでアクセスできないのはなぜなのか？  

### ①スタティックって結局何なのか？  

[C#初心者のための基礎！staticスタティックの意味と使い方を解説#25](https://anderson02.com/cs/cskiso/cskisoniwari-25/)  

staticはインスタンスを生成しない。  
staticはプログラム実行時にメモリ領域が確保される。  
なので、そのアプリケーションにただ1つだけ生成したい時に使用される。  
staticの用途としては、最初に1回定義したら後は変更されないような情報になるので、データベース接続情報などが適している。  

※インスタンスを生成するということはヒープ領域から領域を拝借するのだから、  
1回だけということはサイズは決まっているので、おそらくスタック領域に展開されるはず。  

### ②staticクラスのメンバーにthisでアクセスできないのはなぜなのか？  

[staticメソッド内でstaticでないメンバを参照できない理由](https://shirakamisauto.hatenablog.com/entry/2015/06/15/181428)  

thisは自分自身のインスタンスを参照する命令。  
staticはインスタンスを生成しないのは①でやった通り。  
インスタンスが存在しないのだから、自分自身のインスタンスにアクセスできるわけがないので、staticクラスでthisは使えない。  

### その他

[staticクラス、staticメソッドの意味と利点](https://teratail.com/questions/174252)  
インスタンス毎に返す値が違うならstaticでないほうがいいし、Mathのsqrtのように誰がどう計算してもそうなるしかないものはstaticであるほうがいい。  
なぜならインスタンス毎に挙動が変わって欲しくないし、そういう共通で使う処理は起動時に一回だけメモリに確保して、いつでも使えるようにしたほうが効率がいいし、  
いちいちnewしてメモリを確保する手間がいらない。  

[わい、static変数とstaticメソッドについて熱く語る](https://qiita.com/Nekonecode/items/19f3a261a8391853ddec)  

---

## 雑記

・俺が仕様書メモとしてまとめてる内容は全て開発フォルダの仕様書フォルダに乗っけておけばいいのでは？
メモ書き程度のやつは上に持っていくのはどうかな。

・会社の健保のあれ注文する。
令和3年10月12日（火）9時から令和3年10月25日（月）24時まで

・ネットワーク
・C# 配列
・Javaジェネリック
・バニラのWPFで最小のMVVMサンプルを作ってみたい
・インスタンスがどうのこうのも調べたい。

前のJavaまとめ
C#配列
javaジェネリック
UTF-8,UNICODE,ShiftJis

ジェネリックの書き方程度でいい。
配列はjavaだけ。



            //if (SettlementDetailList
            //    // 割り勘の伝票IDを取得
            //    .Select(s => s.SlipList.FirstOrDefault(w => w.SlipType == SlipType.DutchTreat)?.SlipID)
            //    // 同じ伝票IDはカウントしない。
            //    .Distinct()
            //    // nullを除いた結果が2以上なら、別々の割り勘伝票の人をセットしているのでダメ。
            //    .Count(c => c != null) >= 2)
            //{
            //    MessageDialogUtil.ShowWarning(
            //        Messenger,
            //        "dame"
            //    );
            //    return;
            //};


                var test = SettlementDetailList
                    .SelectMany(
                        p => p.SlipList,
                        (s, slip) => new { s.AccountNo, s.ReservationPlayerName, slip.SlipID }
                    )
                    .Where(w => dutchTreatSlipIDList.Contains(w.SlipID))
                    .GroupBy(
                        param => param.SlipID,
                        (k,v) => new
                        {
                            key = k,
                            value = v.FirstOrDefault()
                        }
                    )
                    .Select(s => $"【{s.value.AccountNo}】【{s.value.ReservationPlayerName}】様")
                    .ToList();


                IEnumerable<string> targetPlayerList = SettlementDetailList
                    .SelectMany(
                        p => p.SlipList,
                        (s, slip) => new { s.AccountNo, s.ReservationPlayerName, slip }
                    )
                    .Where(w => dutchTreatSlipIDList.Contains(w.slip.SlipID))

                    .Select(s => $"【{s.AccountNo}】【{s.ReservationPlayerName}】様")
                    .ToList();


・基本情報の勉強をして、抜けていた基本的な部分の学習ができたのはよかった。
　30だからってやって損はない。スタートダッシュ遅れたのは事実だが、最速で効率よく勉強するなら資格の勉強するのが一番だ。
〆・プロテインが定期便になってた。公式で買うより安く買えるので、次の定期便に含めることにする。
→とりあえず、トイレは言っている間にぶち込んでおいた。
・今日は静かなので集中できるし、ほとんど終わっているので精神的に楽である。
・布団の中で毛布を横にずらすやり方が結構よい。熱くなったら迷わずこれ。
・ハリオのガラスの炊飯器がよさげ。
・今日は1000円分のガソリンを入れておく。27日にがっつり入れる予定。それまでに不安はなくしたい。
・会社に来る途中の紅葉がきれいだった。今が秋真っ盛りだろう。
・最近、弁当が冷えるので、昔使っていた弁当の容器にいれた。そしたらめちゃくちゃ臭かったので、ハイターします。
・容器に入れたら逆に更に冷えたのでいつもどおりがいいみたいですね。
・そういえば電子レンジの手入れは少し濡れたスポンジでゴシゴシするだけで十分であることが分かりました。
わざわざハイターしてたのがばからしいですね。
・昼休みの散歩が当たり前になってきた。日照時間が短くなってきたので日に当たるためと、人と距離を置くため。

・skip,takeをまとめたい。skipの存在を知らなかったからreverse.take.reverseなんてくそ面倒くさいことして実現したのもまとめたい。
・linqで文字列をjoinするサンプルがわかりずらいので修正したい。
・javaのジェネリックのまとめをしたい。
・リエントラントとかのまとめをしたい。
・隙間時間は、用語集の確認に使いたい。
・それらがまとめ終わってから令和3年の午前問題の続きをする。
・昨日やったselectmanyとgroupbyのやつもまとめたい。


<https://www.gwtcenter.com/java-generics-primer-1>
[リエントラント 【reentrant】 再入可能](https://e-words.jp/w/%E3%83%AA%E3%82%A8%E3%83%B3%E3%83%88%E3%83%A9%E3%83%B3%E3%83%88.html)
[リユーザブル 【reusable】 再使用可能 / 再利用可能](https://e-words.jp/w/%E3%83%AA%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%96%E3%83%AB.html)
[リロケータブル 【relocatable】 再配置可能](https://e-words.jp/w/%E3%83%AA%E3%83%AD%E3%82%B1%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB.html)
[ミューテックス 【mutex】 mutual exclusion](https://e-words.jp/w/%E3%83%9F%E3%83%A5%E3%83%BC%E3%83%86%E3%83%83%E3%82%AF%E3%82%B9.html)
mutual
[take,skip](https://symfoware.blog.fc2.com/blog-entry-1927.html)

[selectMany](https://www.urablog.xyz/entry/2018/05/28/070000#SelectMany%E3%82%92%E4%BD%BF%E3%81%86)
[groupby](https://www.urablog.xyz/entry/2018/07/07/070000)
[groupbyして先頭](https://entityframework.net/knowledge-base/3850429/get-the-first-record-of-a-group-in-linq-)
<https://stackoverflow.com/questions/19012986/how-to-get-first-record-in-each-group-using-linq/39932057>

``` C#
// 呼び出す前のチェック
// 別の割り勘のグループと一緒にすることはできないので、 開く前にここで塞ぐ。
IEnumerable<string> dutchTreatSlipIDList = SettlementDetailList
    // 割り勘の伝票IDを取得
    .Select(s => s.SlipList.FirstOrDefault(w => w.SlipType == SlipType.DutchTreat)?.SlipID)
    .Distinct()
    .Where(w => w != null)
    .ToList();
if (dutchTreatSlipIDList.Count() >= 2)
{
    IEnumerable<string> targetPlayerList = SettlementDetailList
        .SelectMany(
            p => p.SlipList,
            (s, slip) => (s.AccountNo, s.ReservationPlayerName, slip.SlipID)
        )
        .Where(w => dutchTreatSlipIDList.Contains(w.SlipID))
        .GroupBy(
            p => p.SlipID,
            // SlipIDでグループ化したうち、先頭のデータのみ取得する
            (k, v) => (key: k, value: v.FirstOrDefault())
        )
        .Select(s => $"【{s.value.AccountNo}】【{s.value.ReservationPlayerName}】様")
        .ToList();
    var msg = string.Join(" と ", targetPlayerList) + " はそれぞれで既に割り勘済みのため、割り勘を開くことができません。";
    MessageDialogUtil.ShowWarning(Messenger, msg);
    return;
}
```

[C# LINQで特定の値を先頭にして並び替え](https://teratail.com/questions/120228)  

sql インデックス 仕組み
[インデックスとは？仕組みをわかりやすく解説](https://products.sint.co.jp/siob/blog/index)