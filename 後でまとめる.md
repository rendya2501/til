# 後でまとめたいやつら

## ウェビナー

・ウェブとセミナーを組み合わせた造語。  
・ウェブセミナー、オンラインセミナーとも言う。  
・インターネット上で行うセミナーそのもの、もしくはそのためのツールの名称。  
・数十~数百人規模の対話型セミナーを主用途とする。  
・参加者との対話が可能な点が今までのネット上のセミナーと大きく違うのが特徴とか何とか。  
・Zoomなんかが主たるサービスになる。(他 Microsoft Terms等)  

---

## マイクロサービス

福田さんが発したのでまとめ。  
これくらいの単語なら既にまとめているようなモノだと思っていたが、意外とまとめていなかった。  

なんてことはない、SOAの概念の1部みたいだ。  
1つ1つの機能を部品として細かくわけて、使うときは組み合わせて使うサービスのあれね。  
コーディング然り、サービス然り、ITの世界においては、小さく作ることは正義なのだ。  

``` txt : wiki
ソフトウェア開発技法の1つ。
1つのアプリケーションをビジネス機能に沿った複数の小さいサービスの疎に結合された集合体として構成するサービス志向アーキテクチャ(SOA)の1種。
マイクロサービスアーキテクチャでは、各サービスはきめ細かい粒度を持ち、軽量なプロトコルを用いて通信を行う。
```

``` txt : マイクロサービスで検索したら一番上に出てくる説明
小さな独立した複数のサービスでソフトウェアを構成する、ソフトウェア開発に対するアーキテクチャ的、組織的アプローチ。
各サービスは、正確に定義されたAPIを通じてやり取りする。
これらのサービスは小規模の自己完結できるチームが所有する。
```

---

## ファームウェア

[わかりそう](https://wa3.i-3-i.info/word12773.html)  

ハードウェアの中に住んでいる、そのハードウェアを動かすためのソフトウェア(プログラム)のこと  

firm : 硬い、堅固(けんご)  
どうでもいいが「堅固」を毎回、「けんこ」って読む。  

ハードウェアの中に組み込まれて、あまり変更されないっぽい。  
でもファームウェアの更新とかよく聞くから、更新出来ないわけではないんだろうな。  
因みにBIOSもパソコンにとってのファームウェアに該当するんだとか。  

他の出典もまとめておく。  

``` txt : e-Words
ファームウェアとは、コンピューターや電子機器等に内臓されるソフトウェアの一種で、本体内部の回路や装置等の基本的な制御をつかさどる機能を持ったもの。
機器内部に固定的に組み込まれ、内部のハードウェアと密接に結びついており、通常の仕様や操作では原則として内容の変更を行わないことから、ハードウェアに性質が近いソフトウェアとして、firm(堅い、固定の)という語が当てられている。
```

### ファームウェアとデバイスドライバの違い

[わかりそう](https://wa3.i-3-i.info/diff176driver.html)  

・どちらもハードウェアを動かすためのソフトウェア  
・ファームウェアは部品に内臓されている  
・デバイスドライバはパソコンの中にインストールされている  

---

## プラグアンドプレイ(Plug and Play, PnP)

USBとか刺したときにデバイスドライバとか自動的にダウンロードしてくれたりするアレ。  
単語を知らなかった。恥ずかしい限りである。  

``` txt : wiki
PCに周辺機器や拡張カード等を接続した際にハードウェアとファームウェア、ドライバ、オペレーションシステム、およびアプリケーション間が自動的に強調し、
危機の組み込みと設定を自動的に行う仕組みのこと。
パソコンのユーザービリティ(使い勝手)を向上させる技術の1つ。
ドライバの自動インストール機能。
つないだら(plug)、ユーザーが何か特別なことをしなくても実行(play)できる、という意味。
```

今の時代、刺せば大抵使えるから別に珍しくもなんともないけど、パソコンの黎明期はそうでもなかったんだな。  

---

## 異常終了系の用語まとめ

- ハングアップ : フリーズとほぼ同義。ソフトウェアからの反応が停止した状態。  
- フリーズ : ハングアップとほぼ同義。ソフトウェアからの反応が停止した状態、もしくは処理が多すぎて停止しているように見える。  
- クラッシュ : ソフトウェアが停止して終了します。通常、イベントログに履歴が残ります。
- アベンド : 大型コンピューターにおけるプログラム的な異常終了。  

大体がフリーズかクラッシュで通じると思われる。  
個人的にハングアップはあまり聞いたことがない。  
アベンドに関してはメインフレームの時代の話なので、ほとんど使われない気がする。  

### アベンド(abend)

``` txt : アベンドで調べたら一番上に出てくる説明
アプリケーションなどで実行中の処理が、プログラムのバグ等の理由によって、通常の手順で終了出来なくなった状態のこと。
IBMのメインフレーム「system/360」で用いられたエラーメッセージの一種。
アベンドは異常終了と呼ばれる場合もある。
```

``` txt : e-Words
アベンドとは、「異常終了」（abnormal end）を意味する略語。
実行中のコンピュータプログラムが何らかのトラブルに遭遇し唐突に終了することを表す。
 
プログラム上に設定された本来の終端箇所とは異なる位置で突然終了することを指す。
プログラムの誤り（バグ）や想定外のデータの入力、ハードウェアの障害などによって続行不能に陥ったり、
何らかの異常な振る舞いによりOSなどにより強制的に終了させられたりすることにより発生する。
異常の種類や内容を知らせる識別番号が出力される場合もあり、これを「アベンドコード」（ABEND code）という。

1960年代にIBM社の大型コンピュータ（メインフレーム）上で動作するソフトウェアについて用いられた用語が広まったもので、
主にメインフレーム系システムに関連する分野や文脈で用いられるが、現代では他の分野でも異常終了を意味する一般的な用語として使う人がいる。
```

### ハングアップ(hang up)

「電話を切る」という意味もある模様。  

``` txt : 調べたら一番上に出てくる説明
利用中のアプリケーションやPCが停止し、(あるいは正常に動作しなくなり)、入力装置からの入力が出来なくなった状態の事。
操作を全く受け付けなくなった状態。
システムの再起動以外に復帰の方法はない。
```

``` txt :  e-Words
ハングアップとは、動作中のコンピュータやソフトウェアが機能を停止し、操作を受け付けなくなったり外部からの通信に応答しなくなること。

一般的には、表示状態などがある時点で固まったままコンピュータそのものが（OSレベルで）一切の操作を受け付けなくなり、
復帰するにはスイッチなどを操作して電源を落としたり、リセットして再起動するしかない状況を指すことが多い。
特定のアプリケーションソフトが停止することなどを指す場合もある。

「フリーズ」（freeze/凍る）、「ストール」（stall/固まる）などはほぼ同義語であり明確な意味上の違いはないが、
これらは完全な停止状態に加えて、一時的な停止状態や処理に長い時間がかかっている状態を指すこともある。

「クラッシュ」（crash）「異常終了」なども動作を停止するという意味では同じだが、これらはソフトウェアが突如終了してOSの操作画面に戻ることや、
コンピュータの電源が突然切れたり再起動するなど、異常によって強制的に終了することを表し、
「使っていた状態のまま操作を受け付けなくなる」ハングアップとは区別されることが多い。
```

### フリーズ(Fleeze)

``` txt : e-Words
コンピューターやソフトウェアの動作が停止して、操作を受け付けなくなる現象や状態。
時間経過や特定の操作で解除されるような一時体な停止状態と、まったく制御不能な完全な停止状態がある。

「ハングアップ」（hang-up）もほぼ同義語であり明確な意味上の違いは見られないが、こちらは一時的な停止を指すことは稀で、
機器やOSのレベルで回復不能な停止状態に陥り、再起動が必要な状態を指すことが多い。

「クラッシュ」（crash）「異常終了」なども動作を停止するという意味では同じだが、これらはソフトウェアが突如終了してOSの操作画面に戻ることや、
コンピュータの電源が突然切れたり再起動するなど、異常によって強制的に終了することを表し、
「使っていた状態のまま操作を受け付けなくなる」フリーズとは区別されることが多い。
```

### クラッシュ(Crash)

``` txt : e-Words
クラッシュとは、衝突（する）、激突（する）、潰れる、砕ける、といった意味の英単語で、
ITの分野では、俗にストレージ（外部記憶装置）が物理的に破損して記憶内容が損なわれることや、実行中のソフトウェアが突如として異常終了することなどを指す。

ハードウェアのクラッシュ
主にハードディスクなどの記憶装置について、記録面の摩耗や激しい衝撃による損傷などにより正常に読み書きが行えなくなることをクラッシュという。
損傷箇所に記録されていたデータは失われ、上書きや初期化もできなくなる。
電源回路や制御用チップなどが破損した場合には装置全体に渡ってまったくアクセスできなくなる場合もある。

ソフトウェアのクラッシュ
ソフトウェアについてクラッシュという場合には、コンピュータ上で実行されていたプログラムが何らかの理由により異常終了することを指す。
プログラムそのものに不具合（バグ）があり実行を継続できなくなる場合のほか、想定外の異常なデータの入力、処理に必要なメモリ容量の不足、
限度を超えた高負荷など様々な理由により生じる。通常、アプリケーションソフトがクラッシュすると編集中のデータなどは失われて突然終了し、
制御はOSに戻る。終了せずに停止状態に陥ることは「フリーズ」（凍る）「ストール」（固まる）などという。

異常な高負荷やハードウェア異常、ソフトウェアの脆弱性を利用した外部からの攻撃などによりOS自体がクラッシュする場合もある。
自動的に再起動される場合もあるが、機能停止状態となり管理者がリセットボタンで強制的に再起動させるなどの措置が必要となる場合もある。
```

---

## ボリュームライセンス

福田さんのパソコンにウィルスバスターが入ってないとかで、インストールしたいけどその場合、富田さんに言わないと無理でしょってなって、  
ライセンスで管理してるから尚更富田さんでしょってなった時に福田さんが発した。  
まとめて買えばお得、って販売形態だと思ってたが、具体的に知らなかったのでまとめ。  

``` txt : 一番上の説明
ソフトウェア販売形態の一つ。
多数のライセンス(使用許諾権)をまとめて提供する仕組み。
個別に購入するよりも低価格で提供されるほか、ライセンスコード(シリアルナンバーなど)のみ販売して不要なパッケージやマニュアル、
記録媒体が大量に発生しないなどのメリットがある。
```

購入するのは権利。  
まとめ買いでお安く。  

---

## システムドライブ

東さんが「システムドライブにSATAを使うのはどうなんだ？」みたいなこと言ってたのでまとめ。  

``` txt : 一番上に出てくる説明<http://koyocha.blog.fc2.com/blog-entry-29.html>
オペレーティングシステムがインストールされているハードディスクドライブのこと。
メーカー製のパソコンでも自作パソコンでも意図して変更しない限りCドライブとなる。

データドライブとはOSがインストールされていないHDDのこと。
意図して変更しない限りDドライブを含む以降のドライブがこれに当たる。

OSがインストールされているドライブにいくら音楽、動画、画像ファイルやメールなどが入っていようがそれはシステムドライブである。
```

なんてことはない。これだけの意味だ。  
ここにSATAが関わるとつまりどういうことを言いたかったのだろうか。  
単純に遅いってことか？

---

## 車輪の再発明

地味に意味を知らなかった。  

``` txt : うぃき<https://ja.wikipedia.org/wiki/%E8%BB%8A%E8%BC%AA%E3%81%AE%E5%86%8D%E7%99%BA%E6%98%8E>
「広く受け入れられ確立されている技術や解決法を知らずに、または意図的に無視して再び一から作ること」を指すための慣用句。
一般的には、古くからタダで皆に使われている技術や技法があるのなら、それをそっくりそのまま模倣して使えば、ほとんど時間もかからず労力もほとんど使わずに済む。
それなのに、わざわざまた自分でゼロからアイディアを練る段階から始めていては、時間・労力・コストなどの無駄なので、「車輪の再発明」は基本的には、時間の無駄、愚かなこと、ばかばかしいこと、というニュアンスで用いられている。

特にIT業界、なかでもSEやプログラマの間で好んで用いられている表現、概念である。

再発明を行ってしまう理由としては、「既存のものの存在を知らない」「既存のものがあることを知っていたはずなのに、つい思い出しそこなった」「既存のものを一応探したが、見つけそこなった」「既存のものが意図的に隠されていた（時間を無駄遣いするように罠をかけられていた）」「既存のものの意味を誤解している」などということがある。
```

つまり、「誰かが既に生み出した何かを自分で生み出そうとして時間を無駄にすること」の意味。  
Wikiの説明がいちいち面白い。  

---

## ペイロード(Payload)

レスポンスのデータ部分をペイロードとはよく言うが、つまり何？という事を知らなかったのでまとめ。  
簡単に言えば、データ本体そのものを指す言葉だった。  

以下説明。  
[ペイロード 【payload】](https://e-words.jp/w/%E3%83%9A%E3%82%A4%E3%83%AD%E3%83%BC%E3%83%89.html)  

``` txt
有料荷重、有効搭載量、積載物等の意味を持つ英単語。  
通信・ネットワークの分野に置いては、送受信されるデータに伝送単位(パケットやデータグラムなど)のうち、  
宛先などの制御情報を除いた、相手に送り届けようとしている正味のデータ本体のことをペイロードという。  

パケットやデータグラムの多くは、先頭部分に制御情報を記したヘッダ部。
続けてペイロード(ボディ)。  
必要に応じて末尾にパディング(特定の長さに合わせるための「詰め物」となる無意味なデータ)という構成になっている。  
```

---

## JP1

Twitterでこの単語を見て、この単語を見ても一般の人は～みたいな感じで書いてあったので調べた。  

調べたらあった。

``` txt : <https://twitter.com/haijin88/status/1461655607191113734>
IT業界の人に「JP1」って言ったら通じなかった。なんでや！と思ったが、web系の人はそりゃ知らんよな
```

``` txt : wiki
JP1は日立製作所が開発・発売している日立オープンミドルウェアシリーズのひとつで、1994年に発売されたソフトウェア。
統合システム運用管理ツールと位置付けられ、運用ツールとしての日本国内シェアは約27%でトップクラスである。
```

``` txt : e-Words
JP1とは、日立製作所が開発・販売している、企業のITシステムの運用管理ソフト。
IT資産の管理や稼動状況の把握、定型業務の自動化、セキュリティ対策などを統合的に行うことができる。
1台から数千台まで様々な規模のシステムに導入することができ、必要に応じて拡張していくことができる。
「オートメーション」「モニタリング」「コンプライアンス」の3分野で様々なソフトウェア製品やサービスを提供しており、
これらの中から必要なものを組み合わせてシステムを構成する。
```

うーん。よくわからないけど、企業における資源の管理や自動化などを行ってくれるすごいソフトって事かな。  
とても巨大なソフトなのだろう。  
いったいどれだけの事ができるのか全く想像出来ないけど、とりあえずそういうものがあるんだなー程度でいいか。  

調べてみたら、これ専用の資格試験まであるらしい。すごいね。  

---

## プロプライエタリ

JP1の契約形態がプロプライエタリって書いてあったのでついでに調べた。  

``` txt : 調べたら一番上に出てくる奴。
プロプライエタリ（proprietary）は「専用の」「独自の」「独占的な」「所有権・占有権のある」「非公開の」の意味で、コンピュータ関連用語としてはオープン（open）の対義語となる。 
```

``` txt
「独占的な」という意味の形容詞。ソースコード、仕様、規格、構造などが公開されていない状態を指す。
特定の企業や団体が権利を保有し、その具体的詳細を公開していないこと。
プロプライエタリシステム、プロプライエタリソフトウェアなど。「オープン」の反意語として使われる。
関連する語として「クローズド」という語があるが、この語はソースコードが公開されていない状態のみを指すことが多い。
オープンであることを至上とする教条主義的な文脈において、否定的な形容として使われることがあるが、この語自体に否定的な意味はない。
```

代表的なものとして、もちろん「JP1」が上げられるが、WindowsやMacOSとかOSも含まれる見たい。  
後は、「弥生会計」とか「OracleDatabase」とかもかな。  
「MAYA」とかのCGソフトもあるか。  
てか、上げれば意外とキリがない。  
まぁ、使うのにお金払う奴は大体これって事だよね。  

---

## バイナリ

こんなに勉強してきて「バイナリとは何か？」をまとめていなかったのは意外である。  
というわけでまとめ。  

``` txt : ZDNet
バイナリとは、コンピュータ用語としては、データが「0」と「1」で表現されているデータ形式のこと。
あるいは、テキストではない情報でデータが書かれているファイル一般のことである。
バイナリ（binary）とは、元々「2進数の」という意味の英語である。

コンピュータはデータを処理するために、全ての情報を2進数に変換しているので、コンピュータが解釈するために用意されたデータはすべてバイナリ形式となっている。
一般的には、データがバイナリで記述されているファイルはバイナリファイル、バイナリファイルのデータはバイナリデータと呼ばれている。
バイナリファイルの主なものには、音声ファイルや画像ファイル、実行形式のプログラムファイル、圧縮ファイルなどがある。
バイナリデータは、人間が読んでも、意味を解釈することはきわめて困難である。
テキストはテキストエディタで表示・編集することができるが、バイナリデータはテキストエディタでは開くことができない。
このため、テキストでないデータ形式のデータをバイナリデータと総称している場合も多い。

 ちなみに、データ構造の一種である2分木は、2つに分岐するという意味でバイナリツリーと呼ばれている。
```

大抵の説明では0か1ばかりのファイルとあるが、それを表示するバイナリエディターでは16進数で表示されている。  
まぁ、01を永遠と見させられるよりは、16進数で2つにまとめて見せたほうが、効率がいいよね。  
wikiみたら、バイナリエディタでは16進数で表示するのが一般的みたいなので、あながち間違いではなさそうだ。  

## リテラル

literally : 文字通り

ソースコード内の値となる、文字列、数字、式を直接表記したもの。  
変数を箱を例えるなら、その変数の中に入る値をリテラルという。  

## 関数リテラル

変数に関数を代入して記述することを関数リテラルという。  
関数リテラル、無名関数、匿名関数、3つはほぼ同義。  
var test = function() {}　の形なら関数側が関数リテラルであり、無名関数であり、匿名関数である。  

## 関数シグネチャ

(もしくは型シグネチャ、メソッドシグネチャ) は関数やメソッドの入力と出力を定義します。  
シグネチャは以下のものを含みます:  

・パラメーター とその 型  
・返り値とその型  
・スローされる可能性のある例外  
・オブジェクト指向 プログラムにおける利用可能性の情報(public、static、prototype のようなキーワード)。  

※シグネチャー : 書名  

---

## CSV(Comma-Separated Values または Comma-Separated Variables)

日本語では「カンマ区切り」などと呼びます。  
テキストデータを複数のフィールド（項目）に分け、区切り文字カンマ「,」を使って区切ったデータ形式です。  

## XML (Extensible Markup Language)

ユーザが独自に定義したタグを用いて文書構造を記述するマークアップ言語です。  
XMLでは各データを要素(Element)と呼び、要素名と属性(Attribute)をつけたタグで挟んで表現します。  
要素を自由に追加することができ、入れ子構造にもできるので汎用性が高いという特徴があります。  

---

## ASP.NET

まぁ、使ってて地味に知らなかったというか、ふわふわしたままだったのでまとめ。  

・ASP.NET(Active Server Page を.Net向けにしたもの)
Webアプリケーションフレームワークで動的なウェブサイトやWebアプリケーションやXML Webサービスの開発や運用を行う

``` txt : wiki
マイクロソフト社が提供している、Web アプリケーション開発フレームワーク。
動的なウェブサイトやWebアプリケーションやWebサービスの開発や運用を行う。
ASP.NetはActive Service Pagesを.Net向けにしたもの。

ASP.NET Webフォーム
ASP.NET MVC : 
ASP.NET Webページ : 
ASP.NET Web API : WebAPI作成に特化
ASP.NET SignalR : リアルタイム処理
ASP.NET Core
```

やベーくらいいっぱいある。  
てかASPってフロント側も作れたんだな。  
Web側で使ってるのはMVCかAPIか。明日調べてみよう。
ASPを知るためにはMVCとMVVMも改めて確認しないとなぁ。

うちのプロジェクトでは特にフレームワークは利用しないでMVCっぽく作ってるだけだった。  
前はEntityFrameworkなるものを使っていたらしい。  

---

## 抽象操作（抽象メソッド）

処理の内容が入っておらず、外部から呼び出すときのインタフェース、すなわち戻り値の型、メソッド名、引数の型、引数の数のみが定義されているメソッドです。  
抽象メソッドを1つ以上含むクラスは抽象クラスといいます。処理内容が定義されていないため、抽象クラスをインスタンス化することはできず、必ずサブクラスに継承してオーバーライドし、処理内容を確定する必要があります。  

## オーバーライド（Override）

上位クラスで定義されたメソッド(メンバ関数)を、下位クラス側の役割に応じて再定義し動作を変更すること  

---

## MVC(Model View Controler)

### なぜMVCは廃れたのか

---

## MVVM(Model View ViewModel)

プログラムの構成をView(見た目),ViewModel(見た目とデータの制御),Model(データの制御)に分けた物。
基本的に、View,ViewModel間のやり取りはプロパティのBindingを行う。
プロパティ変更通知はINotifyPropertyChangedインターフェースを使用するが、Prismは便利なサポート

---

## URLとURIの違い

プロになるためのWeb入門でやったのは覚えているがまとめていなかった。  

- URI(Uniform Resource Identifier)  
- URL(Uniform Resource Locator)  
- URN(Uniform Resource Name)  

URLを拡張した概念としてURIが考えだされた。  
URLに加えてURNが追加されたものがURI。  

URI = URL + URN  

URL：住所  
URN：名前  
URI：宛先  

URNはインターネット上に存在する名前を一意に識別するために用意された物。  
URLはインターネット上の住所のような物。  
URLだけではリソースが引っ越してしまうと居場所がわからなくなってしまう。  
このような問題を解決するために、インターネット上に存在するリソースに対して統一的な名前を決めようと考えだされたのがURN。  
物理的にどのような位置にあろうと、同じURNで指し示すことができるという寸法。  

「位置」を示すURLと「名前」を示すURNとを統一的に表したものがURI。  
しかし、URNが利用される事はあまりなかったので、実質的にURIもURLも同じ意味で使われるようになった。  
世間的にはURLのほうが一般的かも。  

---

## UTF-8(Unicode Transformation Format-8)

LPIC102の勉強ついでにまとめる。  

Unicode用の符号化方式の1つ。  
ASCIIで定義している文字をUnicodeでそのまま使用する事を目的として制定している。  
Unicodeを使った文字コードで、1文字を1バイトから6バイトで表す。

ASCIIと同じ部分は1バイトで表現し、そのほかの部分を2~6バイトで表現する可変長の符号化方式。  
漢字、かな文字は3~4で表現するため、UTF-16を比較するとデータサイズが大きくなる。  

---

## サロゲートペア

>1つの文字に対して 2つの文字コードを使って表される文字のこと。  

_  

><https://kotobank.jp/word/%E3%82%B5%E3%83%AD%E3%82%B2%E3%83%BC%E3%83%88%E3%83%9A%E3%82%A2-1825148>  
>ユニコードにおいて標準化された文字符号化方式、UTF-16で用いられる符号化の拡張方法。  
>2バイトで定義された基本多言語面に含まれない拡張領域の文字を、2バイトのバイト列二つを組み合わせて、計4バイトで表す。  
>追加漢字面の漢字をはじめ、約100万字の文字の符号化が可能となる。  

[サロゲートペアってなんでコワイの](https://qiita.com/wingsys/items/81d46451d8b93ab065de)  

コンピューターで文字を表すために世界中が頑張った。  
様々な符号化文字集合と文字符号化方式が乱立した。  
Unicode「全世界のあらゆる文字を1つの符号化文字集合のもとに統一しよう!!!」  
Unicode「16bit,65536種分の領域があれば、あらゆる文字を格納できるはず!!!!!!」  
Unicode「あかん、これ65536文字じゃたらんくね？でももう世界中で実装されてるし、今更なかったことにはできん!!!!」  
Unicode「しゃーない!!!使われてない2つの領域があるから、そいつら組み合わせて1文字ってことにしたろ!!!!組み合わせ増えたら事足りるやろ!!!!」  
→サロゲートペア  

弊害は1文字だと思ったら0.5文字だったみたいな事が出てくること。  

---

## CLI(Common Language Infrastructure)

共通言語基盤。  
.Net Frameworkの基幹を構成する実行コードや実行環境等についてマイクロソフトが策定した仕様。  
プログラミング言語やコンピューターアーキテクチャに依存しない閑居うを定義しており、様々な高水準言語で書いたソースコードを書き直すことなく他のプラットフォームでも使える。  

Vueの開発の時にCommonLanguageInterfaceと頭文字が同じなので、ついでにまとめておいた。  

---

## log4j

巷で話題ではあるが、何が悪いのかさっぱりわからなかったのでまとめ。  
ツイッターで解説が出ていたけど、確かにやばいわ。  

[【log4jのヤバさを一般人でもわかるように説明する】](https://twitter.com/ito_yusaku/status/1471767438308315138)  
>・音声レコーダーを屋内に置いていました。  
>・その音声レコーダーは実はアレクサでした。  
>・アレクサには全ての権限を与えられていました。  
>・屋外の音を屋内にそのまま伝えるスピーカーが設置されていました。  

[log4jの、非プログラマ向けの説明](https://twitter.com/MitAtoM/status/14716787772522618929)  
・議事録係がいて、ふだんはみんなの発言をそのまま記録している。  
・誰かが今すぐまんじゅう買って食べたいとしゃべったら、議事録係がまんじゅうを買いに行ってしまうことが分かった  
・事務所のあちこちの部屋に入れる鍵を持っているので、勝手に動くととてもヤバい  

---

## QA(Quality Assurance)

品質保証のこと。  
Assurance : [名詞] : 保障,保険  
アシュランスと読んでおけば問題なさそう。  

Gitのブランチのルールを調べていた時の話。  
Releaseブランチが担当する部分。  
Masterにリリースする直前にDevelopから派生して品質を向上させてからMasterにマージするためのブランチ。  

---

## JPEG (Joint Photographic Experts Group)

>静止画像のデータ圧縮形式の一つ。  
>フルカラーの画像を多少の劣化を伴いながら高い圧縮率で符号化できるのが特徴で、写真など自然画像の記録に向いている。  
>画像の一部の不可逆的な変化や画質の劣化、情報の欠損を許容する代わりに極めて小さなデータに圧縮することができる  
>「非可逆圧縮」（lossy compression）方式を採用しているのが大きな特徴で、圧縮前の状態に完全に復元することはできない。  
>非可逆圧縮では画質の劣化の度合いが大きくなるほど圧縮率を高められるため、保存時にどの程度の画質とするかを係数の形で利用者が指定することができる。  
>人間の目にはほとんど見分けがつかない画質でも元のデータの数分の一程度には圧縮することができ、最も低い画質では数十分の一から百分の一以下になることもある。  

■JPEGの圧縮方式  
JPEGの圧縮方式の大きな特徴は、「表面の画質に影響を与えない部分のデータを削除する」という点です。  
画像データには表面には見えない沢山のデータが内包されており、画質とは関係のないデータがファイルサイズを膨らませる要因となっています。  
JPEGは、画質が維持できる程度に不要なデータを削除することによって、質を保ちながら画像データを軽量化することができるのです。  
しかし、保存を繰り返す毎にデータを削除していくため、保存する度に画像が劣化していってしまいます。  
また、写真やグラデーションのような色変化の緩やかな画像は得意ですが、イラストのようなくっきりとした画像では色と色の境目にノイズが出てしまう点も注意が必要です。  

■メリット  
・写真やグラデーションなど連続した色変化に強い。写真など自然画像向き。  
・ファイルサイズが軽い。  

■デメリット  
・保存する度に画像が劣化する。  
・イラストのようなくっきりとした画像では色と色の境目にノイズが出る。  

---

## PNG (Portable Network Graphics)

>画像データを圧縮して記録するファイル形式の一つ。  
>フルカラーの画像を無劣化（lossless）で圧縮することができ、図やイラストなど向いている。  
>色のついた画素を縦横に敷き詰めたビットマップ形式の画像を圧縮符号化するデータ形式の一つで、  
>内容の変質や劣化を一切起こさず正確に元の状態に戻すことができる可逆圧縮（ロスレス圧縮）方式を採用している。  

■PNGの圧縮方式  
画像データは全て「ビット」と呼ばれる小さい”点”の集合でできており、保存の際はビットを一つひとつ保存していきます。  
しかしPNGは、同じ色のパターンを再度保存することはせず、同じ色は一つの括りとして処理し、圧縮していきます。  
同じ色のパターンを保存することが得意であるため、イラストなどの塗りつぶしの多い画像には適しており、品質を保った上で画像を軽量化できます。  
逆に写真やグラデーションなど色変化の多い画像は、綺麗に保存することはできるものの、ファイルサイズが重くなってしまいます。  

■メリット  
・透過処理ができる。イラスト向き。  
・輪郭がはっきりしている。  
・保存による画像劣化が起きにくい。  

■デメリット  
・JPEGより容量は大きい。  
・写真やグラデーションなど色変化の多い画像は、綺麗に保存することはできるものの、ファイルサイズが大きくなる。  

---

・メーリングリスト
複数の人に同時に電子メールを配信する仕組み。
1．登録メンバーの電子メールアドレスのリスト
2．メーリングリスト宛の代表電子メールアドレス
を用意する。
代表アドレスへ送信されたメールをリストに登録されたメンバー全員のアドレスへ転送するもの。

comroomみたいなものか

---

## コンパイルとビルドの違い

<https://twitter.com/itengr_matome/status/1488270286302507009>  

>Compileは文字通り翻訳なので、ソースコードを中間言語とかバイトコードとか機械語とかに翻訳する行為。
>インタプリタ言語なら実行時にコンパイルしてたりする。  
>Buildは製品としてデプロイ可能な状態にすること（コンパイル、テスト、パッケージング等）  
>と習ったかなぁ・・・  

---

## ドメインって結局なに？

ドメインとは？  
インターネット上の「住所」に当たるものが「IPアドレス」ですが、IPアドレスをわかりやすく文字列にしたものが「ドメイン」です。  

URLとかのドメインのほう。  
DNSで名前解決の時に使うあれ。  

---

## Linuxディストリビューション

・Red Hat系
 ・Fedora
 ・Red Hat Enterprise Linux
 ・CentOS

・Debian系
 ・Ubuntu
 ・Linux Mint
 ・Raspbian

・Slackware系
 ・Slackware
 ・openSUSE

・独立系
 ・Arck Linux

## ふるさと納税の申込期限はいつまで？

ふるさと納税で税金の控除を受けるためには、税務上の手続き（控除の申請）が必要で、その対象となる期間は1月1日～12月31日の1年区切りです。  
したがって、今年1年間に行ったふるさと納税については、すべて翌年に税務上の手続きをすることが必要です。  

## 画像の追加でミスった話

・binとobjを削除する必要があった模様。
・フォルダに追加するだけだと認識されない。
・その場合はすべて表示にして、右クリックして追加する。

---

[ディレクトリ構成図を書くときに便利な記号](https://qiita.com/paty-fakename/items/c82ed27b4070feeceff6)

``` txt
読み          文字

たて        : │ ┃
たてひだり  : ┨ ┥ ┤ ┫
たてみぎ    : ┣ ┠ ┝ ├
ひだりうえ  : ┌ ┏
ひだりした  : └ ┗
ふとわく    : ┗┻━┛ ┏┳━┓
ほそわく    : └┴─┘ ┌┬─┐
まんなか    : ┼ ╋ ┿ ╂
みぎうえ    : ┐ ┓
みぎした    : ┘ ┛
よこ        : ─ ━
よこうえ    : ┻ ┷ ┸ ┴
よこした    : ┳　┯ ┰ ┬
```

---

## 外字

[1] wiki:  
外字とは特定の文字集合（文字コードなど）に含まれない文字のことをいう。  
日本で一般には、JIS規格の文字コード（通常はJIS X 0208、稀にJIS X 0213やJIS X 0221）に含まれない文字のことをさし、「表外字」、「拡張漢字(ベンダ選定拡張漢字)」とも呼ばれる。  
常用漢字に含まれない文字のことを外字ということもある。  

[2]  
一般的に外字とは、IMEなどの文字入力ソフトに登録されていない文字で、テキスト入力の際に変換しても表示できない文字を意味します。  
外字に分類されている多くは人名・地名に該当しますが、その他にも枠付き文字・単位記号・省略文字・シンボルマークなどを含んでいます。  

---

## ansi shift-jis 文字コード

[Shift_JISと死の文字化け](https://jyuch.hatenablog.com/entry/2018/12/21/000000)  
歴史的な経緯等は原典を見つけられなかったのですが、『ANSI』はそのロケールの既定の文字コードを表す単語らしく日本語だとShift_JIS（CP932）を表します。  

---

## テーブル結合にLIKE演算子を使えるか

[テーブル結合 LIKE演算子](https://teratail.com/questions/65949)  

``` sql
SELECT
    テーブル1.X 
FROM
    テーブル1
    LEFT JOIN テーブル2 
    ON テーブル2.Y LIKE テーブル1.X + '%' 
    (AND / OR テーブル2でさらに絞りたい条件式)
WHERE
    テーブル2.Y IS NULL 
    AND ~~
```

---

## ダーティリード、ファントムリードと分離レベル

[トランザクション分離レベルについてのまとめ](https://qiita.com/song_ss/items/38e514b05e9dabae3bdb)  
[[RDBMS][SQL]トランザクション分離レベルについて極力分かりやすく解説](https://qiita.com/PruneMazui/items/4135fcf7621869726b4b)  

READ UNCOMMITTED

---

## 時々コマンドに付いてる--(Double Dash)って何なの？

[時々コマンドに付いてる--(Double Dash)って何なの？](https://zenn.dev/dowanna6/articles/245df006deee0c)  

結論  
「--」は「これ以降の入力はオプションではありません」と指定する記号です。  

---

## RPXで○○様ってつけたい

``` txt
= DataField + "様"
```

---

## JWT(JSON Web Token)

読み方は「ジョット」

JWTとは、JSON形式で表現された認証情報などをURL文字列などとして安全に送受信できるよう、符号化やデジタル署名の仕組みを規定した標準規格。  
IETFによってRFC 7519として標準化されている。  

---

## NULLを排除した設計

[NULLを排除した設計①](http://onefact.jp/wp/2014/08/26/null%E3%82%92%E6%8E%92%E9%99%A4%E3%81%97%E3%81%9F%E8%A8%AD%E8%A8%88/)  

---

結合法則

[wpf入門](https://blog.okazuki.jp/entry/2014/12/27/200015)  

[PrismとLivetで画面を閉じるMVVM](https://redwarrior.hateblo.jp/entry/2020/08/31/090000)  
[DIYプログラミングでMVVMを推奨しない理由](https://resanaplaza.com/2020/08/13/%E3%80%90wpf%E3%80%91diy%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%A7mvvm%E3%82%92%E6%8E%A8%E5%A5%A8%E3%81%97%E3%81%AA%E3%81%84%E7%90%86%E7%94%B1/)  

[XAML の基本構造（WPF）](https://ufcpp.net/study/dotnet/wpf_xamlbasic.html)

Attribute Syntax

``` XML
<TextBox 
  Width = "100" FontSize = "30" Text = "text 1"
  Background = "White" Foreground = "Blue" />
```

この書き方は Attribute Syntax と言って、 値を文字列で指定できる（文字列そのもの or 文字列から直接変換可能な型）プロパティの場合はこの構文を使うと便利です。

Property Element Syntax

では、もっと複雑な型を持つプロパティの場合にはどうすればいいかと言うと、 XML 要素の子要素としてプロパティの値を設定する Property Element Syntax という構文も用意されています。 例えば、上の例を Property Element Syntax で書き直すと以下のようになります。

``` XML
<TextBox>
  <TextBox.Width>100</TextBox.Width>
  <TextBox.FontSize>30</TextBox.FontSize>
  <TextBox.Background>White</TextBox.Background>
  <TextBox.Foreground>Blue</TextBox.Foreground>
  <TextBox.Text>text 1</TextBox.Text>
</TextBox>
```


<SETTER>はStyleタグでのみ有効な模様。




---

## 行けそうだけどいけないUPDATE

sqlserverの

``` sql
UPDATE [TB_会員]
SET
    日付0 = MAX(CASE WHEN [AA].ItemCD = '101' THEN [AA].[Date] ELSE NULL END),
    日付1 = MAX(CASE WHEN [AA].ItemCD = '102' THEN [AA].[Date] ELSE NULL END),
    日付2 = MAX(CASE WHEN [AA].ItemCD = '103' THEN [AA].[Date] ELSE NULL END),
    日付3 = MAX(CASE WHEN [AA].ItemCD = '104' THEN [AA].[Date] ELSE NULL END),
    日付4 = MAX(CASE WHEN [AA].ItemCD = '105' THEN [AA].[Date] ELSE NULL END),
    日付5 = MAX(CASE WHEN [AA].ItemCD = '106' THEN [AA].[Date] ELSE NULL END),
    日付6 = MAX(CASE WHEN [AA].ItemCD = '107' THEN [AA].[Date] ELSE NULL END),
    日付7 = MAX(CASE WHEN [AA].ItemCD = '108' THEN [AA].[Date] ELSE NULL END),
    日付8 = MAX(CASE WHEN [AA].ItemCD = '109' THEN [AA].[Date] ELSE NULL END),
    日付9 = MAX(CASE WHEN [AA].ItemCD = '110' THEN [AA].[Date] ELSE NULL END),
    数値0 = MAX(CASE WHEN [AA].ItemCD = '111' THEN [AA].[Number] ELSE NULL END),
    数値1 = MAX(CASE WHEN [AA].ItemCD = '112' THEN [AA].[Number] ELSE NULL END),
    数値2 = MAX(CASE WHEN [AA].ItemCD = '113' THEN [AA].[Number] ELSE NULL END),
    数値3 = MAX(CASE WHEN [AA].ItemCD = '114' THEN [AA].[Number] ELSE NULL END),
    数値4 = MAX(CASE WHEN [AA].ItemCD = '115' THEN [AA].[Number] ELSE NULL END),
    数値5 = MAX(CASE WHEN [AA].ItemCD = '116' THEN [AA].[Number] ELSE NULL END),
    数値6 = MAX(CASE WHEN [AA].ItemCD = '117' THEN [AA].[Number] ELSE NULL END),
    数値7 = MAX(CASE WHEN [AA].ItemCD = '118' THEN [AA].[Number] ELSE NULL END),
    数値8 = MAX(CASE WHEN [AA].ItemCD = '119' THEN [AA].[Number] ELSE NULL END),
    数値9 = MAX(CASE WHEN [AA].ItemCD = '120' THEN [AA].[Number] ELSE NULL END),
    名称0 = MAX(CASE WHEN [AA].ItemCD = '121' THEN [AA].[Text] ELSE '' END),
    名称1 = MAX(CASE WHEN [AA].ItemCD = '122' THEN [AA].[Text] ELSE '' END),
    名称2 = MAX(CASE WHEN [AA].ItemCD = '123' THEN [AA].[Text] ELSE '' END),
    名称3 = MAX(CASE WHEN [AA].ItemCD = '124' THEN [AA].[Text] ELSE '' END),
    名称4 = MAX(CASE WHEN [AA].ItemCD = '125' THEN [AA].[Text] ELSE '' END),
    名称5 = MAX(CASE WHEN [AA].ItemCD = '126' THEN [AA].[Text] ELSE '' END),
    名称6 = MAX(CASE WHEN [AA].ItemCD = '127' THEN [AA].[Text] ELSE '' END),
    名称7 = MAX(CASE WHEN [AA].ItemCD = '128' THEN [AA].[Text] ELSE '' END),
    名称8 = MAX(CASE WHEN [AA].ItemCD = '129' THEN [AA].[Text] ELSE '' END),
    名称9 = MAX(CASE WHEN [AA].ItemCD = '130' THEN [AA].[Text] ELSE '' END)
FROM
    [TB_会員]
    INNER JOIN Round3DatBRK_20220308.dbo.TMc_CustomerGenericInfoContent AS [AA]
    ON [TB_会員].[顧客CD] = REPLACE([AA].[CustomerCD],'BRK','')
    AND [AA].[UpdateProgram] LIKE 'RN3.WPF%'
    GROUP BY [TB_会員].[顧客CD]





UPDATE
    [TB_会員] 
    INNER JOIN Round3DatBRK_20220308.dbo.TMc_CustomerGenericInfoContent AS [RN3_Cus] 
    ON [TB_会員].顧客CD = REPLACE([RN3_Cus].[CustomerCD],'BRK','')
    AND [RN3_Cus].[UpdateProgram] LIKE 'RN3.WPF%'
SET
    日付0 = MAX(CASE WHEN ItemCD = '101' THEN [Date] ELSE NULL END) AS [日付0],
    日付1 = MAX(CASE WHEN ItemCD = '102' THEN [Date] ELSE NULL END) AS [日付1],
    日付2 = MAX(CASE WHEN ItemCD = '103' THEN [Date] ELSE NULL END) AS [日付2],
    日付3 = MAX(CASE WHEN ItemCD = '104' THEN [Date] ELSE NULL END) AS [日付3],
    日付4 = MAX(CASE WHEN ItemCD = '105' THEN [Date] ELSE NULL END) AS [日付4],
    日付5 = MAX(CASE WHEN ItemCD = '106' THEN [Date] ELSE NULL END) AS [日付5],
    日付6 = MAX(CASE WHEN ItemCD = '107' THEN [Date] ELSE NULL END) AS [日付6],
    日付7 = MAX(CASE WHEN ItemCD = '108' THEN [Date] ELSE NULL END) AS [日付7],
    日付8 = MAX(CASE WHEN ItemCD = '109' THEN [Date] ELSE NULL END) AS [日付8],
    日付9 = MAX(CASE WHEN ItemCD = '110' THEN [Date] ELSE NULL END) AS [日付9],
    数値0 = MAX(CASE WHEN ItemCD = '111' THEN [Number] ELSE NULL END) AS [数値0],
    数値1 = MAX(CASE WHEN ItemCD = '112' THEN [Number] ELSE NULL END) AS [数値1],
    数値2 = MAX(CASE WHEN ItemCD = '113' THEN [Number] ELSE NULL END) AS [数値2],
    数値3 = MAX(CASE WHEN ItemCD = '114' THEN [Number] ELSE NULL END) AS [数値3],
    数値4 = MAX(CASE WHEN ItemCD = '115' THEN [Number] ELSE NULL END) AS [数値4],
    数値5 = MAX(CASE WHEN ItemCD = '116' THEN [Number] ELSE NULL END) AS [数値5],
    数値6 = MAX(CASE WHEN ItemCD = '117' THEN [Number] ELSE NULL END) AS [数値6],
    数値7 = MAX(CASE WHEN ItemCD = '118' THEN [Number] ELSE NULL END) AS [数値7],
    数値8 = MAX(CASE WHEN ItemCD = '119' THEN [Number] ELSE NULL END) AS [数値8],
    数値9 = MAX(CASE WHEN ItemCD = '120' THEN [Number] ELSE NULL END) AS [数値9],
    名称0 = MAX(CASE WHEN ItemCD = '121' THEN [Text] ELSE NULL END) AS [名称0],
    名称1 = MAX(CASE WHEN ItemCD = '122' THEN [Text] ELSE NULL END) AS [名称1],
    名称2 = MAX(CASE WHEN ItemCD = '123' THEN [Text] ELSE NULL END) AS [名称2],
    名称3 = MAX(CASE WHEN ItemCD = '124' THEN [Text] ELSE NULL END) AS [名称3],
    名称4 = MAX(CASE WHEN ItemCD = '125' THEN [Text] ELSE NULL END) AS [名称4],
    名称5 = MAX(CASE WHEN ItemCD = '126' THEN [Text] ELSE NULL END) AS [名称5],
    名称6 = MAX(CASE WHEN ItemCD = '127' THEN [Text] ELSE NULL END) AS [名称6],
    名称7 = MAX(CASE WHEN ItemCD = '128' THEN [Text] ELSE NULL END) AS [名称7],
    名称8 = MAX(CASE WHEN ItemCD = '129' THEN [Text] ELSE NULL END) AS [名称8],
    名称9 = MAX(CASE WHEN ItemCD = '130' THEN [Text] ELSE NULL END) AS [名称9]
WHERE
    [TB_会員].顧客CD = REPLACE([RN3_Cus].[CustomerCD],'BRK','')
```

---

##

<https://twitter.com/franc_life_/status/1496233334573346822?t=WleD8oKm4hL6tJHyWvFJ5g&s=09>

①「月給」と「月収」
②「年収」と「年俸」
③「基本給」と「手取り」
④「所得税」と「住民税」
⑤「社会保険料」と「雇用保険料」
⑥「法定内残業」と「法定外残業」

給与明細の見方は、社会人の基本。
1つでも説明できない方は、僕と一緒に勉強しましょうか✍

---

## 平均的プログラマ以前向けのスキルの指標

[平均的プログラマ以前向けのスキルの指標](https://satob.hatenablog.com/entry/2018/10/26/012245)  

レベル1：プログラムを書こうとするが、「コードは決まった文法で書かないと受理すらされない」ということを理解できず、プログラム言語の文法に沿わないコードを書き続ける*7。

レベル2：文法に沿ってコードを書こうとはするが、自分の知っている他の文法と食い違いがあるために、そのプログラムの文法を受け入れられない。「イコール記号は代入を意味する」ということが理解できないケースなど*8*9。

レベル3：ターゲットとしている言語の文法を受け入れることができ、その文法に沿ってコードを書こうとはするが、ループが理解できない。if文は理解できるため、リストの代わりに「userName1」「userName2」……のように大量の変数を並べて処理を書いたりする*10*11*12*13。

レベル4：ターゲットとしている言語の文法に従ってコードを書くことができ、ループの概念も理解しているが、コンパイルを通せない*14。エラーメッセージにはコンパイラがエラーを検知した箇所が含まれているということを理解できない *15 。コンパイルエラーが発生したら、「プログラムを読み返して、怪しいと思った（多くの場合は見当違いな）場所を修正しては再コンパイル」をエラーが出なくなるまで繰り返す。

レベル5：ターゲットとしている言語のコードを書くことができ、コンパイルを通すことができる。コンパイルエラーは解決できるが、実行時エラーを解決できない。コンパイルが通ったからプログラムは完成だと報告を上げてくる*16*17。

レベル6：実行時エラーが発生しても、めげずに立ち向かえる。エラーの原因を体系的に調査することはできないため、「プログラムを読み返して、怪しいと思った場所を修正しては再実行」をエラーが出なくなるまで繰り返す。結果として、プログラムの挙動が当初の想定から意図せず変わっていたりする*18。

レベル7：実行時エラーログの存在は知っており、業務プログラムが出力した日本語のエラーメッセージは読める。一方で、スタックトレースや、英語のエラーメッセージは読めない*19。そのため、フレームワークやライブラリの内部でエラーが発生すると立ち往生してしまう。

レベル7.5：実行時エラーが発生した際に、スタックトレースをもとにエラーの原因箇所を調査できる。ただし、エラーメッセージ通りの修正しか行えない。たとえば、NullPointerExceptionが発生していたら、発生箇所の直前にnullチェックを入れるくらいしかできず、根本的な原因までさかのぼった修正（メソッドの戻り値がnullにならないよう引数を確認する、など）は行えない*20。

レベル8：実行時エラーが発生した際に、スタックトレースをもとにエラーの原因箇所を調査できる。スタックトレースや英語のエラーメッセージを読んで意味が理解できる。一方で、スタックトレースが出力されなかったり、スタックトレースが直接原因箇所を示さなかったりするエラーは解決できない*21。

レベル9：実行時エラーが発生した際に、体系的に原因を調査できる。スタックトレースがなくても、printfデバッグやデバッガの機能を頼りにエラーの発生箇所を特定できる。エラーの原因を調査し、正しいかどうかは別としても簡単な修正が行える。

レベル10：ターゲットとしている言語のプログラムを読み書きでき、デバッグも行える。ただし、コードを書く際には擬似コードなどで詳細に書かれた内容をもとにする必要があり、与えられた仕様を元に一からコードを書くことはできない*22*23*24。

レベル11：ターゲットとしている言語のプログラムを読み書きできる。与えられた仕様を元に一から自分でコードを書こうとするが、基本的にはググって見つかったサンプルコードをコピペして、変数名などを調整することで仕様を満たそうとする*25*26。作成したコードの中に、与えられた仕様と関係ない処理が混ざっていても、何のためにその処理があるのか理解しておらず、削除するのも怖いので、そのまま放っておく。

レベル12：ターゲットとしている言語のプログラムを読み書きできる。処理の流れが単純なプログラムなら、処理内容を把握できるし、自分で一から処理内容を考えることもできる。一方で、メソッド呼び出しのネストが深いプログラムでは、処理内容の把握は難しい。ソースコード上の記述の順序とプログラム実行時の動きの順序を区別していない*27。

レベル13：ターゲットとしている言語のプログラムを読み書きできる。処理の起点がひとつだけであればプログラムの処理内容を把握できるが、コールバック処理・イベント処理・非同期呼び出しなどがある場合は把握は難しい*28。

レベル14：ターゲットとしている言語のプログラムを読み書きできる。与えられた仕様を元に、コールバック処理・イベント処理・非同期呼び出しなどを使ってコードを書くことができる（利用法が適切とは限らない）。フレームワークのホットスポットにビジネスロジックを実装することはできるが、フレームワークなしでプログラムを書き始めることはできない。

レベル15：ターゲットとしている言語のプログラムを読み書きできる。与えられた仕様を満たすコードを自分で考えて書くことができるが、行数・性能の両面とも効率的なコードを書くことは難しい。テーブルルックアップで済む処理をif文の繰り返しやswitch文で実装したり、ハッシュテーブルを使うべき処理でリストを使ったりする*29*30。

レベル16：ターゲットとしている言語のプログラムを読み書きできる。与えられた仕様を元に、コールバック処理・イベント処理・非同期呼び出しや、扱うデータに合った適切なデータ構造を、必要に応じて利用してコードを書くことができる。雛形コードがない場合でも、どのような単位でモジュールを構成すべきかをアプリケーションアーキテクチャをもとに検討して、与えられた仕様を満たすプログラムをスクラッチから開発できる。

---

## 雑記

トーレス・デル・パイネ国立公園
avalon peninsula canada

・クエリエラー調査
DISTINCTとワイルドカード `*` を併用したら.NETFrameworkで実行速度が遅くなるらしい

