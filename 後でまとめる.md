# 後でまとめたいやつら

## 添付プロパティ

例えば、テキストボックスとボタンがあります。
カーソルが当たっている間は色を変えたいけれど、どちらにもその機能はない。
それぞれを継承して拡張した、CustomButton,CustomTextを作ってもいいけど、どちらにも同じコードを書くことになるし作ること自体に手間がかかる。
そういう時に添付プロパティなるものを作って、それをテキストボックスとボタンに実装してあげることで、その機能を実現することができる。
それが、添付プロパティ。

どうやって作るかは後でまとめる。



DependencyProperty→バインディングができるようにする。コントロールにそういう機能がある。

INotify
Classに実装。

バインディングをしたときに、バインド間で通知をしてくれる。
この処理は.Net側の処理なので、その先で何をやっているかはわからない。

CollectionChanged。

ObsColle 
Foreachの中で、inに入れるコレクションの内容が変わった時にエラーが発生する。
これは、イベントが邪魔をしている証拠。
抑制する必要がある。

## インスタンスの状態

[[C# 入門] クラスのインスタンスについて](https://yaspage.com/prog/csharp/cs-instance/)  

DependencyPropertyのBindingの件で東さんがインスタンスの状態なんて事を言っていたので調べたわけだが、  
それとは別にインスタンスについての基礎を紹介しているページがわかりやすかったのでまとめる。  

---

## コントロールのスタイルを作成する方法 (WPF .NET)

[コントロールのスタイルを作成する方法 (WPF .NET)](https://docs.microsoft.com/ja-jp/dotnet/desktop/wpf/controls/how-to-create-apply-style?view=netdesktop-5.0)  
[WPF4.5入門 その50 「Style」](https://blog.okazuki.jp/entry/2014/09/04/200304)  

因みにXAMLをデバッグ中に変更できる機能は「エディットコンテニュー」というらしい。  
VisualStudio2017から使えるようになったようなので、比較的新しい技術みたいだ。  


Styleで指定した値はデフォルト値になる。

スタイルの暗黙的な適応  
スタイルの TargetType を TextBlock 型に設定し、x:Key属性を省略すると、
そのスタイルにスコープ指定されているすべての TextBlock 要素 (通常、XAML ファイル自体) にスタイルが適用されます。

``` XML : スタイルの暗黙的な適応
<Window.Resources>
    <!-- x:Key属性が省略されているのでTextBlock型全てに設定が適応される -->
    <Style TargetType="TextBlock">
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="FontFamily" Value="Comic Sans MS"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
</Window.Resources>
<StackPanel>
    <TextBlock>My Pictures</TextBlock>
    <TextBlock>Check out my new pictures!</TextBlock>
</StackPanel>
```

スタイルの明示的な適応  
値が含まれる x:Key 属性をスタイルに追加すると、そのスタイルは TargetType のすべての要素に暗黙的に適用されなくなります。  

``` XML : スタイルの明示的な適応
<Window.Resources>
    <!-- x:Key属性を定義 -->
    <Style x:Key="TitleText" TargetType="TextBlock">
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="FontFamily" Value="Comic Sans MS"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
</Window.Resources>
<StackPanel>
    <!-- x:Key属性の使用を宣言することでMyPicturesのみに設定が適応される -->
    <TextBlock Style="{StaticResource TitleText}">My Pictures</TextBlock>
    <TextBlock>Check out my new pictures!</TextBlock>
</StackPanel>
```

スタイルの継承  
Styleは、別のスタイルを元にして新しいStyleを作ることが出来ます。  
BaseOnというプロパティに元になるStyleを指定することで実現出来ます。  

``` XML : スタイルの継承
<Window.Resources>
    <Style TargetType="TextBlock">
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="FontFamily" Value="Comic Sans MS"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
    <!-- BasedOnで元となるスタイルを定義 -->
    <Style BasedOn="{StaticResource {x:Type TextBlock}}"
           TargetType="TextBlock"
           x:Key="TitleText">
        <Setter Property="FontSize" Value="26"/>
        <Setter Property="Foreground">
            <Setter.Value>
                <LinearGradientBrush StartPoint="0.5,0" EndPoint="0.5,1">
                    <LinearGradientBrush.GradientStops>
                        <GradientStop Offset="0.0" Color="#90DDDD" />
                        <GradientStop Offset="1.0" Color="#5BFFFF" />
                    </LinearGradientBrush.GradientStops>
                </LinearGradientBrush>
            </Setter.Value>
        </Setter>
    </Style>
</Window.Resources>
<StackPanel>
    <!-- x:Key属性の使用を宣言することでMyPicturesのみに設定が適応される -->
    <TextBlock Style="{StaticResource TitleText}" Name="textblock1">My Pictures</TextBlock>
    <TextBlock>Check out my new pictures!</TextBlock>
</StackPanel>
```

トリガー  
Styleでは、Triggerを使うことでプロパティの値に応じてプロパティの値を変更することが出来ます。  
例えばマウスが上にあるときにTrueになるIsMouseOverプロパティがTrueの時に、背景色を青にするには以下のようなStyleを記述します。  

``` XML
<Style x:Key="DefaultTextStyle" TargetType="{x:Type TextBlock}">
    <Setter Property="FontFamily" Value="Meiryo UI" />
    <Setter Property="FontSize" Value="12" />
    <Style.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter Property="Background" Value="Blue" />
        </Trigger>
    </Style.Triggers>
</Style>
```

・Template

・TemplateBinding
親の設定を子にも適応させるやつ。

・StaticResource  
対象のプロパティに1度だけ設定が行われます。
リソースとバインド先の依存関係プロパティの対応付けは起動時の1回のみ、ただしクラスは参照なのでリソースのプロパティの変更はバインド先も影響を受ける。

・DynamicResource
リソースの内容が変更されたら対象のプロパティも変更されます。
リソースとバインド先の依存関係プロパティの対応付けは起動時および起動中(リソースに変更がある度)。つまりリソースのオブジェクトが変わってもバインド先は影響を受けるし、当然リソースのプロパティ変更はバインド先も影響を受ける。


・ControlTemplate
コントロールのためのテンプレート。
なんかControlTemplate定義してるところは全部Gridから始まっているけど何なのだろうか。そういうものなのか？  

このコントロール テンプレートは単純です。
コントロールのルート要素である Grid
ボタンの丸みのある外観を描画するための Ellipse
ユーザー指定のボタンの内容を表示する ContentPresenter

ControlTemplate単体で定義して、x:keyで指定することも可能な模様。  

・ContentControl
どんなに頑張ってもチェックボックスのForegroundが変わってくれなかった。
元のソースを見てみると、CheckBoxのContentプロパティのContentControlなるものを操作していたので、
そちらのForegroundを変更したら行けた。

・何個も入れ子になっているStyleのTemplateBindingは本当に全部親の設定を引き継いでいるという認識でいいのか？

・いろいろなコントロールが組み合わさってモノができているのはわかるけど、その中のこのコントロールの大しての設定！みたいな指定ってどこでやってるんだ？

[WPFのStaticResourceとDynamicResourceの違い](https://tocsworld.wordpress.com/2014/06/26/wpf%E3%81%AEstaticresource%E3%81%A8dynamicresource%E3%81%AE%E9%81%95%E3%81%84/)  
[MSDN_WPFのStaticResourceとDynamicResourceの違い](https://social.msdn.microsoft.com/Forums/ja-JP/3bbcdc48-2a47-495e-9406-2555dc515c3a/wpf12398staticresource12392dynamicresource123983694912356?forum=wpfja)  
[コントロールのためのテンプレートを作成する方法 (WPF.NET)](https://docs.microsoft.com/ja-jp/dotnet/desktop/wpf/controls/how-to-create-apply-template?view=netdesktop-5.0)  
[テンプレート（WPF）](https://ufcpp.net/study/dotnet/wpf_template.html)  
[[WPF]ComboBoxのControlTemplateを使ってシンプルかつMouseOrver時に色が変わるComboBoxを作ってみた](https://qiita.com/nori0__/items/61bc195ff6e07ff1daa5)  

---

## シングルトン

[デザインパターン「Singleton」](https://qiita.com/shoheiyokoyama/items/c16fd547a77773c0ccc1)  
・指定したクラスのインスタンスが1つしか存在しないことを保証する
・インスタンスが1個しか存在しないことをプログラム上で表現したい

``` C# : シングルトン実装例
    /// <summary>
    /// シングルトンクラス
    /// 1.Singletonクラスがロードされた時点では、Singletonインスタンスは生成されない
    /// 2.Singleton#getInstance()を最初に呼び出した時に、SingletonHolderクラスがロードされ、Singletonインスタンスが生成される
    /// ギリギリまでSingletonインスタンスを生成しないような挙動になるようです。
    /// </summary>
    class Singleton
    {
        /// <summary>
        /// コンストラクタ
        /// </summary>
        private Singleton() { }
        /// <summary>
        /// インスタンス
        /// </summary>
        /// <returns></returns>
        public static Singleton Instace { get; } = SingletonHolder.INSTANCE;
        /// <summary>
        /// シングルトン生成クラス
        /// </summary>
        private static class SingletonHolder
        {
            public static readonly Singleton INSTANCE = new Singleton();
        }
    }
```

[シングルトンがなぜ必要なのか](https://teratail.com/questions/36721)  

インスタンスがなぜ一つじゃないといけないのか
使えるリソースが一つだけの場合、それにアクセスするクラスインスタンスも一つだけの方が都合が良い場合が多いからです。
例えば、画面に何か出力するとき、JavaではSystem.outを使いますが、それは「標準出力」というたった一つしかないリソースに対してアクセスを行うために、staticフィールドで定義されたインスタンスであり、staticなのでプロセス内には1個しかインスタンスがありません。
なぜそうしているのかというと、画面に何か書きたいときに、いちいちnewしてクラスインスタンスを作るのは面倒だし、そのたびにnewしていたら無駄にメモリを食うし、それを避けるために一度newしたものを別のクラスでも使い回そうとすると、そのインスタンスの受け渡しをどうするのかという問題が出てくるし……。
ということで、staticフィールドにインスタンスを作ってそれをみんなで使い回すことにするのです。

どのような場面でシングルトンを使うのか
シングルトン（パターン）はインスタンスを一つしか作らないことを「保証する」ための仕組みです。
ただ単にインスタンスを一つにしたいというだけならstaticフィールドにすればできますが、それを知らずに誰かがnewしてしまったらインスタンスが複数になってしまいます。あるいは、staticフィールドにインスタンスを作りたいけど、初期化の順番をコントロールしたい、というケースもあるかもしれません。マルチスレッドでの動作を考慮しないといけないかもしれません。
そういうときに一手間かけてシングルトン（パターン）を使います。

[[Swift]Singleton（シングルトン）とは？メリット、実装方法、使い方](https://ticklecode.com/swiftsingleton/)  

シングルトンはどんなときに使うのか、そのメリット
・たくさんのインスタンスからアクセスされると困るとき
・毎回、インスタンス生成をするのが手間
・共通的な情報保持をして、メモリを節約したい

例えば

・ログを出力機能、常に１つのインスタンスからファイルへ出力したい
・画面に出力（標準出力）、画面は1つなので1つのインスタンスから出力
・取得したJSONデータをどの画面でも使う時

[【Singeltonパターン】考え方は単純だが、使いどころが大切なデザインパターン【コード例はRubyとJava】](https://debimate.jp/2020/04/26/%E3%80%90singelton%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%80%91%E8%80%83%E3%81%88%E6%96%B9%E3%81%AF%E5%8D%98%E7%B4%94%E3%81%A0%E3%81%8C%E3%80%81%E4%BD%BF%E3%81%84%E3%81%A9%E3%81%93%E3%82%8D%E3%81%8C/)  

Singletonパターンが適さないケース
No.	適さないケース	理由
1	多くの状態（filed、メンバ変数）を持つ	状態はグローバル変数と同一なので、その数は0に近い方が良い
2	単体テストの実行順に制約を生む場合	単体テストの作成および実行を困難にしてしまう
3	マルチスレッド環境に導入する場合	Singeltonへのアクセス管理（ロック）にコストが発生してしまう
4	常に決まった値を渡す（or 出力）	クラスメソッド（static関数）に置き換えた方が良い


Singletonパターンが適したケース
IBMが定義するSingletonパターンが適したケースは、以下の3項目を全て満たした場合です。正直、私は下記の引用説明ではピンとこなかったので、Singletonを使ったクラス例を調べました（後述しています）。

すべてのアプリケーションは、まったく同一の方法でこのクラスを使用するか? (「まったく」がキーワード)
すべてのアプリケーションは、常にこのクラスの1つのインスタンスのみを必要とするか? (「常に 」と「1つの」がキーワード)
このクラスのクライアントは、自分自身がその一部に含まれているアプリケーションを意識しないべきか?


Singletonパターンが適したクラス例
以下に、Singletonパターンで設計した方が良い可能性のあるクラス（機能）を示します。

ロギング
キャッシュ管理
スレッドプール管理
データベース接続ドライバ
ソケット制御ドライバ
上記のクラス（機能）を踏まえると、リソース管理にSingletonパターンが適していると考えられます。リソースに対して複数のインスタンスが管理を行えば、状態管理で不整合が生じる可能性があります。この不整合を防止するために、Singletonを用いるのは自然な事だと思います。

---

## 雑記

・100均で筋トレ用のマット＆封筒購入
・俺が仕様書メモとしてまとめてる内容は全て開発フォルダの仕様書フォルダに乗っけておけばいいのでは？
メモ書き程度のやつは上に持っていくのはどうかな。

・会社の健保のあれ注文する。
令和3年10月12日（火）9時から令和3年10月25日（月）24時まで


・ヒートテックがゆるゆるになってきた。そろそろ新しい奴買ったほうがいいだろうか。割と真剣に考えよう。
　ついでだからパンツも新しくしてもよくないだろうか。
・100均のトレーニングマットがどんなものか

・ネットワーク
・C# 配列
・Javaジェネリック
・バニラのWPFで最小のMVVMサンプルを作ってみたい
・インスタンスがどうのこうのも調べたい。
・スタティックって結局何なのかもまとめたい。
・Overrideしたイベントは -= +=で解除と登録はできない。
・staticだとthis.でアクセスできないのまとめる。

前のJavaまとめ
C#配列
javaジェネリック
ALUとかプログラムカウンタなど
午前問題のまとめ
UTF-8,UNICODE,ShiftJis
絶対値とは

ジェネリックの書き方程度でいい。
配列はjavaだけ。
スマホでやる午前はssで対応


8時きっかりに起床。
体内時計が完璧すぎる。

朝から買い物ラッシュ。
例の店員さんにすべてのクーポンを消化させてもらった。ありがたい。

ついでにツルハでウィンドウォッシャー液も購入。
偶然にもLINEの5%オフクーポンもあった。
ツルハの10%オフクーポンとポイントを使って100円くらいで入手。すっきりした。
ウォッシャー液はツルハに売ってないと思ったけど、よく探してみると申し訳程度の車コーナーに最後の1品が残ってたので助かった。
よかったよかった。

昼休みに荷物を受け取りつつ、液を補充だな。
液入れたけど、ほとんど持ってかれた。
そんなに入るのねあれ。

17時になったら誰がスウィフトに入るのか観察することにしよう。


12日を満喫できたから後はどうでもいいや。
今日中に100問行けたらどんなにいいことか。


なんか足が痛い。
筋肉痛の類の痛み。
立ってるだけなんだけどなぁ。
