# 後でまとめたいやつら

## ウェビナー

・ウェブとセミナーを組み合わせた造語。  
・ウェブセミナー、オンラインセミナーとも言う。  
・インターネット上で行うセミナーそのもの、もしくはそのためのツールの名称。  
・数十~数百人規模の対話型セミナーを主用途とする。  
・参加者との対話が可能な点が今までのネット上のセミナーと大きく違うのが特徴とか何とか。  
・Zoomなんかが主たるサービスになる。(他 Microsoft Terms等)  

---

## マイクロサービス

福田さんが発したのでまとめ。  
これくらいの単語なら既にまとめているようなモノだと思っていたが、意外とまとめていなかった。  

なんてことはない、SOAの概念の1部みたいだ。  
1つ1つの機能を部品として細かくわけて、使うときは組み合わせて使うサービスのあれね。  
コーディング然り、サービス然り、ITの世界においては、小さく作ることは正義なのだ。  

``` txt : wiki
ソフトウェア開発技法の1つ。
1つのアプリケーションをビジネス機能に沿った複数の小さいサービスの疎に結合された集合体として構成するサービス志向アーキテクチャ(SOA)の1種。
マイクロサービスアーキテクチャでは、各サービスはきめ細かい粒度を持ち、軽量なプロトコルを用いて通信を行う。
```

``` txt : マイクロサービスで検索したら一番上に出てくる説明
小さな独立した複数のサービスでソフトウェアを構成する、ソフトウェア開発に対するアーキテクチャ的、組織的アプローチ。
各サービスは、正確に定義されたAPIを通じてやり取りする。
これらのサービスは小規模の自己完結できるチームが所有する。
```

---

## プラグアンドプレイ(Plug and Play, PnP)

USBとか刺したときにデバイスドライバとか自動的にダウンロードしてくれたりするアレ。  
単語を知らなかった。恥ずかしい限りである。  

``` txt : wiki
PCに周辺機器や拡張カード等を接続した際にハードウェアとファームウェア、ドライバ、オペレーションシステム、およびアプリケーション間が自動的に強調し、
危機の組み込みと設定を自動的に行う仕組みのこと。
パソコンのユーザービリティ(使い勝手)を向上させる技術の1つ。
ドライバの自動インストール機能。
つないだら(plug)、ユーザーが何か特別なことをしなくても実行(play)できる、という意味。
```

今の時代、刺せば大抵使えるから別に珍しくもなんともないけど、パソコンの黎明期はそうでもなかったんだな。  

---

## ボリュームライセンス

福田さんのパソコンにウィルスバスターが入ってないとかで、インストールしたいけどその場合、富田さんに言わないと無理でしょってなって、  
ライセンスで管理してるから尚更富田さんでしょってなった時に福田さんが発した。  
まとめて買えばお得、って販売形態だと思ってたが、具体的に知らなかったのでまとめ。  

``` txt : 一番上の説明
ソフトウェア販売形態の一つ。
多数のライセンス(使用許諾権)をまとめて提供する仕組み。
個別に購入するよりも低価格で提供されるほか、ライセンスコード(シリアルナンバーなど)のみ販売して不要なパッケージやマニュアル、
記録媒体が大量に発生しないなどのメリットがある。
```

購入するのは権利。  
まとめ買いでお安く。  

---

## システムドライブ

東さんが「システムドライブにSATAを使うのはどうなんだ？」みたいなこと言ってたのでまとめ。  

``` txt : 一番上に出てくる説明<http://koyocha.blog.fc2.com/blog-entry-29.html>
オペレーティングシステムがインストールされているハードディスクドライブのこと。
メーカー製のパソコンでも自作パソコンでも意図して変更しない限りCドライブとなる。

データドライブとはOSがインストールされていないHDDのこと。
意図して変更しない限りDドライブを含む以降のドライブがこれに当たる。

OSがインストールされているドライブにいくら音楽、動画、画像ファイルやメールなどが入っていようがそれはシステムドライブである。
```

なんてことはない。これだけの意味だ。  
ここにSATAが関わるとつまりどういうことを言いたかったのだろうか。  
単純に遅いってことか？

---

## ペイロード(Payload)

レスポンスのデータ部分をペイロードとはよく言うが、つまり何？という事を知らなかったのでまとめ。  
簡単に言えば、データ本体そのものを指す言葉だった。  

以下説明。  
[ペイロード 【payload】](https://e-words.jp/w/%E3%83%9A%E3%82%A4%E3%83%AD%E3%83%BC%E3%83%89.html)  

``` txt
有料荷重、有効搭載量、積載物等の意味を持つ英単語。  
通信・ネットワークの分野に置いては、送受信されるデータに伝送単位(パケットやデータグラムなど)のうち、  
宛先などの制御情報を除いた、相手に送り届けようとしている正味のデータ本体のことをペイロードという。  

パケットやデータグラムの多くは、先頭部分に制御情報を記したヘッダ部。
続けてペイロード(ボディ)。  
必要に応じて末尾にパディング(特定の長さに合わせるための「詰め物」となる無意味なデータ)という構成になっている。  
```

---

## JP1

Twitterでこの単語を見て、この単語を見ても一般の人は～みたいな感じで書いてあったので調べた。  

調べたらあった。

``` txt : <https://twitter.com/haijin88/status/1461655607191113734>
IT業界の人に「JP1」って言ったら通じなかった。なんでや！と思ったが、web系の人はそりゃ知らんよな
```

``` txt : wiki
JP1は日立製作所が開発・発売している日立オープンミドルウェアシリーズのひとつで、1994年に発売されたソフトウェア。
統合システム運用管理ツールと位置付けられ、運用ツールとしての日本国内シェアは約27%でトップクラスである。
```

``` txt : e-Words
JP1とは、日立製作所が開発・販売している、企業のITシステムの運用管理ソフト。
IT資産の管理や稼動状況の把握、定型業務の自動化、セキュリティ対策などを統合的に行うことができる。
1台から数千台まで様々な規模のシステムに導入することができ、必要に応じて拡張していくことができる。
「オートメーション」「モニタリング」「コンプライアンス」の3分野で様々なソフトウェア製品やサービスを提供しており、
これらの中から必要なものを組み合わせてシステムを構成する。
```

うーん。よくわからないけど、企業における資源の管理や自動化などを行ってくれるすごいソフトって事かな。  
とても巨大なソフトなのだろう。  
いったいどれだけの事ができるのか全く想像出来ないけど、とりあえずそういうものがあるんだなー程度でいいか。  

調べてみたら、これ専用の資格試験まであるらしい。すごいね。  

---

## プロプライエタリ

JP1の契約形態がプロプライエタリって書いてあったのでついでに調べた。  

``` txt : 調べたら一番上に出てくる奴。
プロプライエタリ（proprietary）は「専用の」「独自の」「独占的な」「所有権・占有権のある」「非公開の」の意味で、コンピュータ関連用語としてはオープン（open）の対義語となる。 
```

``` txt
「独占的な」という意味の形容詞。ソースコード、仕様、規格、構造などが公開されていない状態を指す。
特定の企業や団体が権利を保有し、その具体的詳細を公開していないこと。
プロプライエタリシステム、プロプライエタリソフトウェアなど。「オープン」の反意語として使われる。
関連する語として「クローズド」という語があるが、この語はソースコードが公開されていない状態のみを指すことが多い。
オープンであることを至上とする教条主義的な文脈において、否定的な形容として使われることがあるが、この語自体に否定的な意味はない。
```

代表的なものとして、もちろん「JP1」が上げられるが、WindowsやMacOSとかOSも含まれる見たい。  
後は、「弥生会計」とか「OracleDatabase」とかもかな。  
「MAYA」とかのCGソフトもあるか。  
てか、上げれば意外とキリがない。  
まぁ、使うのにお金払う奴は大体これって事だよね。  

---

## バイナリ

こんなに勉強してきて「バイナリとは何か？」をまとめていなかったのは意外である。  
というわけでまとめ。  

``` txt : ZDNet
バイナリとは、コンピュータ用語としては、データが「0」と「1」で表現されているデータ形式のこと。
あるいは、テキストではない情報でデータが書かれているファイル一般のことである。
バイナリ（binary）とは、元々「2進数の」という意味の英語である。

コンピュータはデータを処理するために、全ての情報を2進数に変換しているので、コンピュータが解釈するために用意されたデータはすべてバイナリ形式となっている。
一般的には、データがバイナリで記述されているファイルはバイナリファイル、バイナリファイルのデータはバイナリデータと呼ばれている。
バイナリファイルの主なものには、音声ファイルや画像ファイル、実行形式のプログラムファイル、圧縮ファイルなどがある。
バイナリデータは、人間が読んでも、意味を解釈することはきわめて困難である。
テキストはテキストエディタで表示・編集することができるが、バイナリデータはテキストエディタでは開くことができない。
このため、テキストでないデータ形式のデータをバイナリデータと総称している場合も多い。

 ちなみに、データ構造の一種である2分木は、2つに分岐するという意味でバイナリツリーと呼ばれている。
```

大抵の説明では0か1ばかりのファイルとあるが、それを表示するバイナリエディターでは16進数で表示されている。  
まぁ、01を永遠と見させられるよりは、16進数で2つにまとめて見せたほうが、効率がいいよね。  
wikiみたら、バイナリエディタでは16進数で表示するのが一般的みたいなので、あながち間違いではなさそうだ。  

## リテラル

literally : 文字通り

ソースコード内の値となる、文字列、数字、式を直接表記したもの。  
変数を箱を例えるなら、その変数の中に入る値をリテラルという。  

## 関数リテラル

変数に関数を代入して記述することを関数リテラルという。  
関数リテラル、無名関数、匿名関数、3つはほぼ同義。  
var test = function() {}　の形なら関数側が関数リテラルであり、無名関数であり、匿名関数である。  

## 関数シグネチャ

(もしくは型シグネチャ、メソッドシグネチャ) は関数やメソッドの入力と出力を定義します。  
シグネチャは以下のものを含みます:  

・パラメーター とその 型  
・返り値とその型  
・スローされる可能性のある例外  
・オブジェクト指向 プログラムにおける利用可能性の情報(public、static、prototype のようなキーワード)。  

※シグネチャー : 書名  

---

## log4j

巷で話題ではあるが、何が悪いのかさっぱりわからなかったのでまとめ。  
ツイッターで解説が出ていたけど、確かにやばいわ。  

[【log4jのヤバさを一般人でもわかるように説明する】](https://twitter.com/ito_yusaku/status/1471767438308315138)  
>・音声レコーダーを屋内に置いていました。  
>・その音声レコーダーは実はアレクサでした。  
>・アレクサには全ての権限を与えられていました。  
>・屋外の音を屋内にそのまま伝えるスピーカーが設置されていました。  

[log4jの、非プログラマ向けの説明](https://twitter.com/MitAtoM/status/14716787772522618929)  
・議事録係がいて、ふだんはみんなの発言をそのまま記録している。  
・誰かが今すぐまんじゅう買って食べたいとしゃべったら、議事録係がまんじゅうを買いに行ってしまうことが分かった  
・事務所のあちこちの部屋に入れる鍵を持っているので、勝手に動くととてもヤバい  

---

## QA(Quality Assurance)

品質保証のこと。  
Assurance : [名詞] : 保障,保険  
アシュランスと読んでおけば問題なさそう。  

Gitのブランチのルールを調べていた時の話。  
Releaseブランチが担当する部分。  
Masterにリリースする直前にDevelopから派生して品質を向上させてからMasterにマージするためのブランチ。  

---

## JPEG (Joint Photographic Experts Group)

>静止画像のデータ圧縮形式の一つ。  
>フルカラーの画像を多少の劣化を伴いながら高い圧縮率で符号化できるのが特徴で、写真など自然画像の記録に向いている。  
>画像の一部の不可逆的な変化や画質の劣化、情報の欠損を許容する代わりに極めて小さなデータに圧縮することができる  
>「非可逆圧縮」（lossy compression）方式を採用しているのが大きな特徴で、圧縮前の状態に完全に復元することはできない。  
>非可逆圧縮では画質の劣化の度合いが大きくなるほど圧縮率を高められるため、保存時にどの程度の画質とするかを係数の形で利用者が指定することができる。  
>人間の目にはほとんど見分けがつかない画質でも元のデータの数分の一程度には圧縮することができ、最も低い画質では数十分の一から百分の一以下になることもある。  

■JPEGの圧縮方式  
JPEGの圧縮方式の大きな特徴は、「表面の画質に影響を与えない部分のデータを削除する」という点です。  
画像データには表面には見えない沢山のデータが内包されており、画質とは関係のないデータがファイルサイズを膨らませる要因となっています。  
JPEGは、画質が維持できる程度に不要なデータを削除することによって、質を保ちながら画像データを軽量化することができるのです。  
しかし、保存を繰り返す毎にデータを削除していくため、保存する度に画像が劣化していってしまいます。  
また、写真やグラデーションのような色変化の緩やかな画像は得意ですが、イラストのようなくっきりとした画像では色と色の境目にノイズが出てしまう点も注意が必要です。  

■メリット  
・写真やグラデーションなど連続した色変化に強い。写真など自然画像向き。  
・ファイルサイズが軽い。  

■デメリット  
・保存する度に画像が劣化する。  
・イラストのようなくっきりとした画像では色と色の境目にノイズが出る。  

---

## PNG (Portable Network Graphics)

>画像データを圧縮して記録するファイル形式の一つ。  
>フルカラーの画像を無劣化（lossless）で圧縮することができ、図やイラストなど向いている。  
>色のついた画素を縦横に敷き詰めたビットマップ形式の画像を圧縮符号化するデータ形式の一つで、  
>内容の変質や劣化を一切起こさず正確に元の状態に戻すことができる可逆圧縮（ロスレス圧縮）方式を採用している。  

■PNGの圧縮方式  
画像データは全て「ビット」と呼ばれる小さい”点”の集合でできており、保存の際はビットを一つひとつ保存していきます。  
しかしPNGは、同じ色のパターンを再度保存することはせず、同じ色は一つの括りとして処理し、圧縮していきます。  
同じ色のパターンを保存することが得意であるため、イラストなどの塗りつぶしの多い画像には適しており、品質を保った上で画像を軽量化できます。  
逆に写真やグラデーションなど色変化の多い画像は、綺麗に保存することはできるものの、ファイルサイズが重くなってしまいます。  

■メリット  
・透過処理ができる。イラスト向き。  
・輪郭がはっきりしている。  
・保存による画像劣化が起きにくい。  

■デメリット  
・JPEGより容量は大きい。  
・写真やグラデーションなど色変化の多い画像は、綺麗に保存することはできるものの、ファイルサイズが大きくなる。  

---

・メーリングリスト
複数の人に同時に電子メールを配信する仕組み。
1．登録メンバーの電子メールアドレスのリスト
2．メーリングリスト宛の代表電子メールアドレス
を用意する。
代表アドレスへ送信されたメールをリストに登録されたメンバー全員のアドレスへ転送するもの。

comroomみたいなものか

---

## RPXで○○様ってつけたい

``` txt
= DataField + "様"
```

---

## JWT(JSON Web Token)

読み方は「ジョット」

JWTとは、JSON形式で表現された認証情報などをURL文字列などとして安全に送受信できるよう、符号化やデジタル署名の仕組みを規定した標準規格。  
IETFによってRFC 7519として標準化されている。  

---

##

<https://twitter.com/franc_life_/status/1496233334573346822?t=WleD8oKm4hL6tJHyWvFJ5g&s=09>

①「月給」と「月収」
②「年収」と「年俸」
③「基本給」と「手取り」
④「所得税」と「住民税」
⑤「社会保険料」と「雇用保険料」
⑥「法定内残業」と「法定外残業」

給与明細の見方は、社会人の基本。
1つでも説明できない方は、僕と一緒に勉強しましょうか

---

## デシャップ

デシャップとは、レストランなどの飲食店で厨房で出来上がった料理が配膳の前に置かれる場所のことをいいます。  
「dish up（ディッシュアップ）」という言葉が語源になっており、飲食業界の専門用語として用いられています。  
また、完成した料理をホールなどに運ぶ仕事をする人のことを指す場合もあります。

---

## ウェブサイトとホームページの違い

[今更聞けないネット知識「ウェブサイト」と「ホームページ」は何が違うのか](https://www.axis-corp.com/quest/website-homepage-difference/)  

### ウェブサイト

個々のページ → ウェブページ  
複数のウェブページのまとまり → ウェブサイト  
つまり、サイト全体をウェブサイトと呼ぶ。  

``` txt
ウェブサイト
├ トップページ (ウェブページ、ホームページ)
├ 各記事 (ウェブページ)
├ お問い合わせ (ウェブページ)
└ 採用情報 (ウェブページ)
```

### ホームページ

大きく分けて2つの意味を持つ。  

1. ウェブサイトのトップページのこと  
2. ブラウザを開いて最初に表示されるページのこと  

---

## Windowsデスクトップ向け業務アプリ開発には何を採用すべきか？

[Windowsデスクトップ向け業務アプリ開発には何を採用すべきか？](https://qiita.com/sengoku/items/fb4948e0d2746e3cc26f)  

- UWPで要件を満たせるのであれば[UWP]  
- Webに慣れた開発者が多ければ[Electron]か[React Native]  
- iOS/Android向けアプリも一緒に開発するなら[Xamarin]か[React Native]  
- そうでなければ[WPF]一択  

WPFを選択した場合、.NET Framework 4.7/4.8にするか、.NET Core 3にするのかも選ばなければいけません。  
将来的なサポートやテストしやすさを考えれば、.NET Core 3から.NET 5へと続く道へ。  
リリースが間近か、現在ある資産をどうしても手放せないのであれば、.NET Framework 4.7/4.8でしょうか。  

---

## POCO(Plain Old CLR Object)

メソッドを持たず、プロパティだけ持つ、データを格納するだけが目的のクラス  

共通言語ランタイム（Common Language Runtime、CLR）のみに依存するプレーンなオブジェクトである。  

---

## 最低限のアクセサーの実装

``` C# : Accessor
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using RN3.Wpf.Common.Auth;
using RN3.Wpf.Common.Resource;
using RN3.Wpf.Common.Util.Config;
using RN3.Wpf.Common.Util.Extension;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Net.Http;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using static RN3.Wpf.Common.Resource.ConstResource;

namespace RN3.Wpf.Common.Accessor
{
    /// <summary>
    /// HttpAlientを用いたAPI実行クラス
    /// </summary>
    public class HTTPAccessor
    {
        #region メンバ
        /// <summary>
        /// 内包するHttpClient
        /// </summary>
        private static HttpClient _Client = new HttpClient()
        {
            //暫定でタイムアウトを5分にしています。
            Timeout = TimeSpan.FromMinutes(5)
        };
        #endregion

        #region コンストラクタ
        /// <summary>
        /// コンストラクタ
        /// </summary>
        public HTTPAccessor()
        {
            var config = ConfigUtil.GetConfigOrDefault().SelectionConnection;
            if (config == null)
            {
                throw new Exception(string.Format(Message.Invalid, "アプリケーション設定"));
            }
        }
        #endregion

        #region 外部公開メソッド
        /// <summary>
        /// 同期通信でAPI実行。認証方式はJWTトークン認証。
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        public T GetResult<T>(string path, object param = null, [CallerFilePath] string callerFilePath = "")
        {
            //送信情報生成
            var request = CreateRequestMessage(path, SerializeParam(param), GetCallerDirectoryName(callerFilePath));
            request.Headers.Add("Authorization", "Bearer " + AuthenticationInfo.Token);
            //Http送信
            var result = ApiExecute(request);
            if (string.IsNullOrEmpty(result))
            {
                return default;
            }
            return DeserializeResult<T>(result);
        }

        /// <summary>
        /// 非同期通信でAPI実行。認証方式はJWTトークン認証。
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        /// <remarks>
        /// RequestMessageを生成してSendAsyncで実行するパターン
        /// </remarks>
        public async Task<T> GetResultAsync<T>(string path, object param = null, [CallerFilePath] string callerFilePath = "")
        {
            //送信情報生成
            var request = CreateRequestMessage(path, SerializeParam(param), GetCallerDirectoryName(callerFilePath));
            request.Headers.Add("Authorization", "Bearer " + AuthenticationInfo.Token);
            //非同期API実行
            var result = await ApiExecuteAsync(request);
            if (string.IsNullOrEmpty(result))
            {
                return default;
            }
            return DeserializeResult<T>(result);
        }

        /// <summary>
        /// 同期通信でAPI実行。認証方式はApiKey。
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        public string GetResultByApiKey(string path, object param = null, [CallerFilePath] string callerFilePath = "")
        {
            var config = ConfigUtil.GetConfigOrDefault().SelectionConnection;
            //送信情報生成
            var request = CreateRequestMessage(path, SerializeParam(param), GetCallerDirectoryName(callerFilePath));
            request.Headers.Add("X-Api-Key", config.X_Api_Key);
            //Http送信
            return ApiExecute(request);
        }

        /// <summary>
        /// 同期通信でAPI実行。認証方式はApiKey。
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        public T GetResultByApiKey<T>(string path, object param = null, [CallerFilePath] string callerFilePath = "")
        {
            var config = ConfigUtil.GetConfigOrDefault().SelectionConnection;
            //送信情報生成
            var request = CreateRequestMessage(path, SerializeParam(param), GetCallerDirectoryName(callerFilePath));
            request.Headers.Add("X-Api-Key", config.X_Api_Key);
            //Http送信
            var result = ApiExecute(request);
            if (string.IsNullOrEmpty(result))
            {
                return default;
            }
            return DeserializeResult<T>(result);
        }

        /// <summary>
        /// 非同期通信でAPI実行。認証方式はApiKey。
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        /// <remarks>
        /// RequestMessageを生成してSendAsyncで実行するパターン
        /// </remarks>
        public async Task<string> GetResultByApiKeyAsync(string path, object param = null, [CallerFilePath] string callerFilePath = "")
        {
            var config = ConfigUtil.GetConfigOrDefault().SelectionConnection;
            //送信情報生成
            var request = CreateRequestMessage(path, SerializeParam(param), GetCallerDirectoryName(callerFilePath));
            request.Headers.Add("X-Api-Key", config.X_Api_Key);
            //非同期API実行
            return await ApiExecuteAsync(request);
        }

        /// <summary>
        /// 非同期通信でAPI実行。認証方式はApiKey。
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        /// <remarks>
        /// RequestMessageを生成してSendAsyncで実行するパターン
        /// </remarks>
        public async Task<T> GetResultByApiKeyAsync<T>(string path, object param = null, [CallerFilePath] string callerFilePath = "")
        {
            var config = ConfigUtil.GetConfigOrDefault().SelectionConnection;
            //送信情報生成
            var request = CreateRequestMessage(path, SerializeParam(param), GetCallerDirectoryName(callerFilePath));
            request.Headers.Add("X-Api-Key", config.X_Api_Key);
            //非同期API実行
            var result = await ApiExecuteAsync(request);
            if (string.IsNullOrEmpty(result))
            {
                return default;
            }
            return DeserializeResult<T>(result);
        }
        #endregion

        #region 内部処理メソッド
        /// <summary>
        /// ObservableCollection用リゾルバ
        /// </summary>
        private class JsonObservableCollectionConverter : DefaultContractResolver
        {
            public override JsonContract ResolveContract(Type type)
            {
                if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                {
                    return ResolveContract(typeof(ObservableCollection<>).MakeGenericType(type.GetGenericArguments()));
                }
                return base.ResolveContract(type);
            }
        }
        /// <summary>
        /// 戻り値をデシリアライズします。
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        private T DeserializeResult<T>(string result)
        {
            // ※Viewで直接一覧にバインドする場合、ListだとメモリリークするためここでObservableCollectionに変換することで対応しています。
            // 　本来はViewModelで行うべきですが、対応箇所が多く漏れの防止のためと、
            // 　入れ子になっているプロパティがIEnumerableだった場合もサポートできることから、ここで処理します。
            return JsonConvert.DeserializeObject<T>(
                result,
                new JsonSerializerSettings()
                {
                    ContractResolver = new JsonObservableCollectionConverter(),
                }
            );
        }
        /// <summary>
        /// 呼び出し元ファイルパスからプロジェクトディレクトリ名を取得します
        /// </summary>
        /// <param name="callerFilePath"></param>
        /// <returns></returns>
        private string GetCallerDirectoryName(string callerFilePath)
        {
            var splitPath = callerFilePath.Split(Path.DirectorySeparatorChar);
            var rootIndex = Array.IndexOf(splitPath, AppInfo.SolutionName);
            if (rootIndex >= 0 && splitPath.Length >= rootIndex)
            {
                // ソリューション名と同じディレクトリ名の次をプロジェクトディレクトリ名と判断します
                return splitPath[rootIndex + 1];
            }
            return null;
        }

        private string GetCallingAssemblyName(string callerDirectoryName)
        {
            //Commonのアセンブリ名を取得
            string commonAssemblyName = Assembly.GetExecutingAssembly().GetName().Name;
            //実行元のアセンブリ名を取得
            string entryAssemblyName = Assembly.GetEntryAssembly().GetName().Name;

            if (commonAssemblyName != callerDirectoryName)
            {
                //呼び出し元がCommonではない場合、直近のアセンブリを優先
                return callerDirectoryName;
            }
            //呼び出し元もCommonと同じ場合は、一番根元のアセンブリを使用
            return entryAssemblyName;
        }

        /// <summary>
        /// 共通処理、送信情報生成
        /// </summary>
        /// <param name="path"></param>
        /// <param name="param"></param>
        /// <param name="callerDirectoryName"></param>
        /// <returns></returns>
        private HttpRequestMessage CreateRequestMessage(string path, string param, string callerDirectoryName)
        {
            var config = ConfigUtil.GetConfigOrDefault().SelectionConnection;
            var request = new HttpRequestMessage()
            {
                Method = HttpMethod.Post,
                RequestUri = new UriBuilder(config.Host + config.Domain + path).Uri,
                Content = new StringContent(param ?? string.Empty, Encoding.UTF8, @"application/json")
            };
            request.Headers.Add("StaffCD", AuthenticationInfo.StaffCode);
            if (!string.IsNullOrEmpty(AuthenticationInfo.StaffName))
            {
                request.Headers.Add("StaffName", string.Join(",", Encoding.UTF8.GetBytes(AuthenticationInfo.StaffName)));
            }
            request.Headers.Add("Program", GetCallingAssemblyName(callerDirectoryName)?.Left(200));
            request.Headers.Add("Terminal", Environment.MachineName);

            return request;
        }

        /// <summary>
        /// 同期API実行
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        private string ApiExecute(HttpRequestMessage request)
        {
            HttpResponseMessage response = null;
            try
            {
                //SendAsyncでHttp通信を送り応答を待つ。
                response = _Client.SendAsync(request).GetAwaiter().GetResult();
            }
            catch (TaskCanceledException e)
            {
                throw new Exception("接続がタイムアウトしました", e);
            }
            //ボディの内容を取得する。
            var content = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
            //ステータスコードのチェック
            IsSuccessStatusCode(content, response);
            //JsonのBodyを返す
            return content;
        }

        /// <summary>
        /// 非同期API実行
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        private async Task<string> ApiExecuteAsync(HttpRequestMessage request)
        {
            HttpResponseMessage response = null;
            try
            {
                //SendAsyncでHttp通信を送り応答を待つ。
                response = await _Client.SendAsync(request);
            }
            catch (TaskCanceledException e)
            {
                throw new Exception("接続がタイムアウトしました", e);
            }
            //ボディの内容を取得する。
            var content = await response.Content.ReadAsStringAsync();
            //ステータスコードのチェック
            IsSuccessStatusCode(content, response);
            //JsonのBodyを返す
            return content;
        }

        /// <summary>
        /// ステータスコードのチェック。
        /// 200以外の場合例外を発生させる。
        /// </summary>
        /// <param name="content"></param>
        /// <param name="response"></param>
        private void IsSuccessStatusCode(string content, HttpResponseMessage response)
        {
            if (!response.IsSuccessStatusCode)
            {
                CreateHttpReqestException(content, response);
            }
        }

        /// <summary>
        /// 共通HttpRequestException生成処理
        /// </summary>
        /// <param name="content"></param>
        /// <param name="response"></param>
        private void CreateHttpReqestException(string content, HttpResponseMessage response)
        {
            if (string.IsNullOrEmpty(content))
            {
                throw new HttpRequestException(
                    string.Format(
                        Message.HttpError,
                        (int)response.StatusCode, response.ReasonPhrase
                    )
                );
            }
            else
            {
                throw new HttpRequestException(
                    content,
                    new HttpRequestException(
                        string.Format(
                            Message.HttpError,
                            (int)response.StatusCode, response.ReasonPhrase
                        )
                    )
                );
            }
        }

        /// <summary>
        /// HTTPリクエストパラメータをJSON文字列にシリアライズします
        /// </summary>
        /// <param name="param"></param>
        /// <returns></returns>
        private string SerializeParam(object param)
        {
            if (param is string)
            {
                return param as string;
            }
            else
            {
                return param != null ? JsonConvert.SerializeObject(param) : null;
            }
        }
        #endregion
    }
}
```

``` C# : ConfigUtil
using Microsoft.Extensions.Configuration;
using RN3.Wpf.Common.Data.AppSetting;
using RN3.Wpf.Common.Properties;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace RN3.Wpf.Common.Util.Config
{
    /// <summary>
    /// コンフィグユーティリティ
    /// </summary>
    public static class ConfigUtil
    {
        private static Configurations _ConfigInstance = null;

        /// <summary>
        /// 接続中のサーバ名
        /// </summary>
        public static string Connection_ServerName
        {
            get => Settings.Default.Connection_ServerName;
        }

        /// <summary>
        /// コンフィグを取得します。
        /// </summary>
        public static Configurations GetConfigOrDefault()
        {
            if(_ConfigInstance != null)
            {
                return _ConfigInstance;
            }
            //アプリケーション用フォルダパス取得
            var configurationDirectory = GetOrCreateAppPath();
            var baseAppsettingsFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "appsettings.json");
            var appsettingsFilePath = Path.Combine(configurationDirectory, "appsettings.json");
            if (File.Exists(baseAppsettingsFilePath) && !File.Exists(appsettingsFilePath))
            {
                // デフォルトとなるappsetting.jsonが存在し、まだ設定ファイルが存在しなければ複写する
                File.Copy(baseAppsettingsFilePath, appsettingsFilePath);
            }
            var configuration = new ConfigurationBuilder()
                .SetBasePath(configurationDirectory)
                .AddJsonFile("appsettings.json", false, true).Build();
            var configurations = new Configurations
            {
                Connections = configuration.GetSection("Connections")?.Get<IEnumerable<Connection>>() ?? new List<Connection>(),
                ConnectionServerName = Settings.Default.Connection_ServerName
            };
            if (configurations.Connections.Count() <= 0)
            {
                throw new System.Exception(string.Format(Resource.Message.Invalid, "アプリケーション設定"));
            }
            if (string.IsNullOrEmpty(Settings.Default.Connection_ServerName))
            {
                configurations.ConnectionServerName = configurations.Connections.First().ServerName;
                Settings.Default.Connection_ServerName = configurations.ConnectionServerName;
                Settings.Default.Save();
            }

            _ConfigInstance = configurations;
            return configurations;
        }

        /// <summary>
        /// コンフィグを保存します。
        /// </summary>
        /// <param name="configurations"></param>
        public static void SaveConfig(Configurations configurations)
        {
            //選択した接続先を保存
            Settings.Default.Connection_ServerName = configurations.ConnectionServerName;
            Settings.Default.Save();
        }

        /// <summary>
        /// アプリケーション用フォルダパスを取得します。存在しなければ作成します。
        /// </summary>
        /// <returns></returns>
        private static string GetOrCreateAppPath()
        {
            //ユーザのAppData\Localフォルダのパスを取得。
            //string localAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData, Environment.SpecialFolderOption.Create);
            string localAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData, Environment.SpecialFolderOption.Create);
            //プロセス名を取得
            string processName = Process.GetCurrentProcess().ProcessName;
            //アプリケーション用フォルダパス作成
            string appPath = localAppDataPath + "\\" + processName;
            //アプリケーション用フォルダパスのフォルダが存在しなければ、フォルダを作成
            if (!Directory.Exists(appPath))
            {
                Directory.CreateDirectory(appPath);
            }

            return appPath;
        }
    }
}
```

``` C# : Configurations
using System.Collections.Generic;
using System.Linq;

namespace RN3.Wpf.Common.Data.AppSetting
{
    /// <summary>
    /// アプリケーション設定
    /// </summary>
    public class Configurations
    {
        /// <summary>
        /// 接続中のサーバ名
        /// </summary>
        public string ConnectionServerName { get; set; }
        /// <summary>
        /// 接続先一覧
        /// </summary>
        public IEnumerable<Connection> Connections { get; internal set; }
        /// <summary>
        /// Connectionsの選択中の要素
        /// </summary>
        public Connection SelectionConnection
        {
            get
            {
                return Connections.FirstOrDefault(f => f.ServerName.Equals(ConnectionServerName)) ??
                    Connections.First();
            }
        }
    }
}
```

---

## Base64

これが必要になったのはセルフオーダーの実装の時である。  
商品画像を表示しないといけないときに、データベースから画像データをバイナリとして取得して復元しなければならなかった。  
その時にこのエンコード方式が使われていたので調べることとなった。  
本当はその時にまとめたかったが余裕がなさ過ぎて後になってしまった。  

[base64ってなんぞ？？理解のために実装してみた](https://qiita.com/PlanetMeron/items/2905e2d0aa7fe46a36d4)  
[わかりそう](https://wa3.i-3-i.info/word11338.html)  

- データの変換方式  
- データを64文字の文字（a～z、A～Z、0～9、+、/）と「=」で表現する  
- メールの添付ファイルの変換等でよく使われる  

---

## SignalR

発火させたい関数名を指定する。  
SignalR用のアクセサーが必要。  
Hubなるものの実装は必須。  

SignalR発火の起点はAccessorによる受信か？  
それをどうやってViewModelはイベントとして感知している？  

[ASP.NET Core SignalR でルーム付きチャットアプリを作ってみた](https://www.tetsis.com/blog/asp-net-core-signalr-group-chat/)  

``` C# : Web Send
    /// <summary>
    /// 更新枠を送信します。
    /// </summary>
    /// <param name="param"></param>
    /// <returns></returns>
    public Task SendUpdateStartFrame(string param)
    {
        return Clients.All.SendAsync("ReceiveUpdateStartFrame", param);
    }

        /// <summary>
    /// 更新予約枠を送信します。
    /// </summary>
    /// <param name="group"></param>
    /// <param name="param"></param>
    /// <returns></returns>
    public Task SendUpdateReservationFrame(DateTime group, string param)
    {
        return Clients.Group(ConvertGroupName(group)).SendAsync("ReceiveUpdateReservationFrame", param);
    }
```

``` C# : Front Recieve
        /// <summary>
        /// 更新予約枠を受信する関数
        /// </summary>
        /// <param name="paramStr"></param>
        public void ReceiveUpdateReservationFrame(string paramStr)
        {
            var param = JsonConvert.DeserializeObject<IEnumerable<UpdateParam<TSheetReservationFrame>>>(paramStr);
            if (param != null)
            {
                List<TSheetReservationFrame> createList = new List<TSheetReservationFrame>();
                List<TSheetReservationFrame> updateList = new List<TSheetReservationFrame>();
                List<TSheetReservationFrame> deleteList = new List<TSheetReservationFrame>();

                foreach (var p in param)
                {
                    if (p.Value == null)
                    {
                        continue;
                    }

                    if (p.UpdateType == UpdateType.Create)
                    {
                        createList.Add(p.Value);
                    }
                    else if (p.UpdateType == UpdateType.Update)
                    {
                        updateList.Add(p.Value);
                    }
                    else if (p.UpdateType == UpdateType.Cancel || p.UpdateType == UpdateType.Delete)
                    {
                        deleteList.Add(p.Value);
                    }
                }
                if (0 < createList.Count)
                {
                    ReservationFrameCreate?.Invoke(createList);
                }
                if (0 < updateList.Count)
                {
                    ReservationFrameUpdate?.Invoke(updateList);
                }
                if (0 < deleteList.Count)
                {
                    ReservationFrameDelete?.Invoke(deleteList);
                }
            }
        }
```

``` C# : Front SignalRAccessor
namespace RN3.Wpf.Common.Accessor
{
    /// <summary>
    /// SignalRを用いたサーバ接続クラスです。
    /// </summary>
    /// <typeparam name="THub">ハブ</typeparam>
    public class SignalRAccessor<THub> : NotifyPropertyChanged where THub : IHub
    {
        #region プロパティ
        private HubConnectionState _State;
        /// <summary>
        /// 接続状態
        /// </summary>
        public HubConnectionState State
        {
            get { return _State; }
            set { SetProperty(ref _State, value); }
        }

        /// <summary>
        /// ハブ
        /// </summary>
        public THub Hub { get; set; }

        /// <summary>
        /// 再接続イベント
        /// </summary>
        public EventHandler Reconnected;

        /// <summary>
        /// サーバへのコネクション
        /// </summary>
        private HubConnection _Connection = null;
        #endregion

        /// <summary>
        /// コンストラクタ
        /// </summary>
        /// <param name="hub"></param>
        public SignalRAccessor(THub hub)
        {
            Hub = hub;
            try
            {
                if (_Connection == null)
                {
                    //接続先の設定
                    var configConnection = ConfigUtil.GetConfigOrDefault().SelectionConnection;
                    _Connection = new HubConnectionBuilder()
                        .WithUrl(new UriBuilder(configConnection.Host + Hub.Pattern).Uri.OriginalString)
                        .WithAutomaticReconnect()
                        .Build();
                    _Connection.Reconnected -= SignalRAccessor_Reconnected;
                    _Connection.Reconnected += SignalRAccessor_Reconnected;
                    _Connection.Reconnecting -= SignalRAccessor_Reconnecting;
                    _Connection.Reconnecting += SignalRAccessor_Reconnecting;
                    _Connection.Closed -= SignalRAccessor_Closed;
                    _Connection.Closed += SignalRAccessor_Closed;
                    State = _Connection.State;
                }
            }
            catch (Exception e)
            {
                //接続でエラーが発生
                Logger.SaveErrorLog(e);
                //TODO：エラー時の処理
            }
        }

        /// <summary>
        /// 接続を試みます。
        /// </summary>
        /// <returns></returns>
        public async Task ConnectingAsync()
        {
            if (_Connection != null && _Connection.State  == HubConnectionState.Disconnected)
            {
                State = _Connection.State;
                await _Connection.StartAsync();
                State = _Connection.State;
            }
        }

        /// <summary>
        /// 接続を破棄します。
        /// </summary>
        /// <returns></returns>
        public async Task DisConnectingAsync()
        {
            if (_Connection != null && _Connection.State == HubConnectionState.Connected)
            {
                State = _Connection.State;
                await _Connection.StopAsync();
                State = _Connection.State;
            }
        }

        /// <summary>
        /// サーバからクライアントへの処理登録
        /// </summary>
        /// <param name="methodName"></param>
        /// <param name="handler"></param>
        public void Register(string methodName, Action handler)
        {
            _Connection.Remove(methodName);
            _Connection.On(methodName, handler);
        }

        /// <summary>
        /// サーバからの受信時処理登録
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="methodName"></param>
        /// <param name="handler"></param>
        public void Register<T>(string methodName, Action<T> handler)
        {
            _Connection.Remove(methodName);
            _Connection.On(methodName, handler);
        }

        /// <summary>
        /// サーバからの受信時処理登録
        /// </summary>
        /// <typeparam name="T1"></typeparam>
        /// <typeparam name="T2"></typeparam>
        /// <param name="methodName"></param>
        /// <param name="handler"></param>
        public void Register<T1, T2>(string methodName, Action<T1, T2> handler)
        {
            _Connection.Remove(methodName);
            _Connection.On(methodName, handler);
        }

        /// <summary>
        /// サーバからの受信時処理登録
        /// </summary>
        /// <typeparam name="T1"></typeparam>
        /// <typeparam name="T2"></typeparam>
        /// <typeparam name="T3"></typeparam>
        /// <param name="methodName"></param>
        /// <param name="handler"></param>
        public void Register<T1, T2, T3>(string methodName, Action<T1, T2, T3> handler)
        {
            _Connection.Remove(methodName);
            _Connection.On(methodName, handler);
        }

        /// <summary>
        /// サーバからの受信時処理登録
        /// </summary>
        /// <typeparam name="T1"></typeparam>
        /// <typeparam name="T2"></typeparam>
        /// <typeparam name="T3"></typeparam>
        /// <typeparam name="T4"></typeparam>
        /// <param name="methodName"></param>
        /// <param name="handler"></param>
        public void Register<T1, T2, T3, T4>(string methodName, Action<T1, T2, T3, T4> handler)
        {
            _Connection.Remove(methodName);
            _Connection.On(methodName, handler);
        }

        /// <summary>
        /// サーバからの受信処理登録解除
        /// </summary>
        /// <param name="methodName"></param>
        public void Unregister(string methodName)
        {
            _Connection.Remove(methodName);
        }

        /// <summary>
        /// クライアントからサーバへ送信
        /// </summary>
        /// <param name="methodName"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        public async void Send(string methodName, params object[] args)
        {
            if (_Connection.State != HubConnectionState.Connected)
            {
                return;
            }
            switch (args.Length)
            {
                case 0:
                    await _Connection.SendAsync(methodName);
                    break;
                case 1:
                    await _Connection.SendAsync(methodName, args[0]);
                    break;
                case 2:
                    await _Connection.SendAsync(methodName, args[0], args[1]);
                    break;
                case 3:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2]);
                    break;
                case 4:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3]);
                    break;
                case 5:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3], args[4]);
                    break;
                case 6:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3], args[4], args[5]);
                    break;
                case 7:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    break;
                case 8:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                    break;
                case 9:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
                    break;
                case 10:
                    await _Connection.SendAsync(methodName, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                    break;
                default:
                    throw new Exception("argsの長さが未対応です。");
            }
        }

        /// <summary>
        /// 現在の接続をグループに追加します。
        /// </summary>
        /// <param name="groupName">グループに指定するための項目名</param>
        /// <param name="group">追加するグループ</param>
        public async Task AddGroup(string groupName, object group)
        {
            if (_Connection.State != HubConnectionState.Connected)
            {
                return;
            }
            if (group == null)
            {
                return;
            }
            await _Connection.SendAsync("AddGroup_" + groupName, _Connection.ConnectionId, group);
        }

        /// <summary>
        /// 現在の接続をグループに追加します。
        /// </summary>
        /// <param name="groupName">グループに指定するための項目名</param>
        /// <param name="oldGroup">破棄するグループ</param>
        /// <param name="newGroup">追加するグループ</param>
        public async void AddGroup(string groupName, object oldGroup, object newGroup)
        {
            if (_Connection.State != HubConnectionState.Connected)
            {
                return;
            }
            await RemoveGroup(groupName, oldGroup);
            await AddGroup(groupName, newGroup);
        }

        /// <summary>
        /// 現在の接続をグループから解除します。
        /// </summary>
        /// <param name="groupName"></param>
        /// <param name="group"></param>
        /// <returns></returns>
        public async Task RemoveGroup(string groupName, object group)
        {
            if (_Connection.State != HubConnectionState.Connected)
            {
                return;
            }

            if (group == null)
            {
                return;
            }
            await _Connection.SendAsync("RemoveGroup_" + groupName, _Connection.ConnectionId, group);
        }

        /// <summary>
        /// 再接続処理
        /// </summary>
        /// <param name="connectionID"></param>
        /// <returns></returns>
        private Task SignalRAccessor_Reconnected(string connectionID)
        {
            State = _Connection.State;
            Reconnected?.Invoke(this, new EventArgs());
            return Task.CompletedTask;
        }

        /// <summary>
        /// 再接続中処理
        /// </summary>
        /// <param name="arg"></param>
        /// <returns></returns>
        private Task SignalRAccessor_Reconnecting(Exception arg)
        {
            State = _Connection.State;
            return Task.CompletedTask;
        }
        /// <summary>
        /// 再接続中処理
        /// </summary>
        /// <param name="arg"></param>
        /// <returns></returns>
        private Task SignalRAccessor_Closed(Exception arg)
        {
            State = _Connection.State;
            return Task.CompletedTask;
        }
    }
}
```

---

## SQL てく

範囲で連番生成

``` sql
SELECT * FROM (
    SELECT TOP (1000)
        ROW_NUMBER() OVER (ORDER BY object_id) AS SeqNo,
        ROW_NUMBER() OVER (ORDER BY object_id)+6 AS SeqNoTo
    FROM sys.all_objects
    ORDER BY SeqNo
) AS rn_q
WHERE rn_q.SeqNo%6 = 0



SELECT * FROM (
    SELECT   TOP (1000)
             ROW_NUMBER() OVER (ORDER BY object_id)-1 AS SeqNo,
             ROW_NUMBER() OVER (ORDER BY object_id)+3 AS SeqNoTo
    FROM     sys.all_objects
    ORDER BY SeqNo
) AS rn_q
WHERE rn_q.SeqNo%5 = 0
-- 0    4
-- 5    9
-- 10    14
-- 15    19
-- 20    24
-- 25    29
-- 30    34
```

[SQLServerで指定した文字で文字列を分割する](https://it-engineer-info.com/database/divide-string)  

``` sql
DECLARE    @separator   VARCHAR(MAX) = ','
DECLARE    @target_str  VARCHAR(MAX)='123,45678'
 
--文字列を「-」で前後に分割する
SELECT
     SUBSTRING( @target_str, 1, CHARINDEX( @separator, @target_str ) - 1 ) AS before
    ,SUBSTRING( @target_str, CHARINDEX( @separator, @target_str ) + 1, LEN( @target_str ) - CHARINDEX( @separator, @target_str )) AS after
```

（※SQL Server 2016以降では「STRING_SPLIT」という関数が実装されています。)

[【T-SQL】文字列を分割して〇番目の値を取得したい場合 (string_split)](http://ubisnews.blogspot.com/2018/07/t-sql-stringsplit.html)  
T-SQL(SQLSERVER)で文字列を分割したいと思ったところ、調べるとstring_split関数というものが利用できるとわかりました。
ただ分割した文字列は表になり分割後の文字をサクッと取り出す方法が探しても見つからなかったのでメモしておこうと思います。
例えば、abc,def,ghiという文字列をカンマ(,)で分割して2番目の値(ここではdef)
を取り出したい場合

``` sql
DECLARE @Val AS VARCHAR(10) --取得する値を格納する変数

SELECT @Val = (
SELECT A.value FROM
(
 SELECT
   ROW_NUMBER() OVER (ORDER BY (SELECT 1)) AS "Id",
   value
 FROM
   STRING_SPLIT(N'abc,def,ghi', N',')
) A
WHERE A.Id = 1
)

SELECT @Val

```


カーソル処理基本
[SELECT した結果をカーソルを使用してループ処理をする方法](https://www.projectgroup.info/tips/SQLServer/SQL/SQL000028.html)  

``` sql
--カーソルの値を取得する変数宣言
DECLARE @W_COL1 varchar(50)
DECLARE @W_COL2 decimal(18,0)

--カーソル定義
DECLARE CUR_AAA CURSOR FOR
    SELECT COL1
          ,COL2
    FROM   TAB_A
    WHERE  TAB_A.COL1 = ＜条件値＞

--カーソルオープン
OPEN CUR_AAA;

--最初の1行目を取得して変数へ値をセット
FETCH NEXT FROM CUR_AAA
INTO @W_COL1,@W_COL2;

--データの行数分ループ処理を実行する
WHILE @@FETCH_STATUS = 0
BEGIN

    -- ========= ループ内の実際の処理 ここから===
    INSERT INTO TAB_B
    VALUES (
        @W_COL1
       ,@W_COL2
    )
    -- ========= ループ内の実際の処理 ここまで===

    --次の行のデータを取得して変数へ値をセット
    FETCH NEXT FROM CUR_AAA
    INTO @W_COL1,@W_COL2;
END

--カーソルを閉じる
CLOSE CUR_AAA;
DEALLOCATE CUR_AAA;
```

[[SQLServer]テーブルをまるっとコピーする方法](https://ameblo.jp/nature3298type-s/entry-10313449987.html)

``` sql
SELECT * INTO <コピー先テーブル名> FROM <コピー元テーブル名>
```

`<コピー元テーブル名>`は名前の指定だけあればよい。
あらかじめテーブルを作成する必要は無し。
実行するとテーブルもSQLServerが自動でテーブルも作成してくれます。
※注：ただし、テーブルは規定の領域（なにも設定してなければPrimary）に作られるので、ファイルグループ管理は要注意。


``` SQL
-- 改良前
UPDATE [Base]
SET 
	[MemberName] = REPLACE([Base].[MemberName],LEFT([Base].[MemberName],LEN([SQ].[Myouji])),[CT].[Name]),
	[MemberKana] = REPLACE([Base].[MemberKana],LEFT([Base].[MemberKana],LEN([SQ].[MyoujiKana])),[CT].[Kana]),
	SearchKeyName = REPLACE([Base].[SearchKeyName],LEFT([Base].SearchKeyName,LEN([SQ].[Myouji])),[CT].[Name]),
	SearchKeyKana = REPLACE([Base].[SearchKeyKana],LEFT([Base].[SearchKeyKana],LEN([SQ].[MyoujiKana])),[CT].[Kana]),
	SearchKeyNameIdentification = REPLACE([Base].SearchKeyNameIdentification,LEFT([Base].SearchKeyNameIdentification,LEN(myouji)),[CT].[Name])
FROM
	TMc_Member AS [Base]
	JOIN 
	(
		SELECT 
			CASE 
				WHEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','') <> '' 
				THEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','')
				ELSE [MemberName]
			END AS [Myouji],
			CASE 
				WHEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','') <> '' 
				THEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','')
				ELSE [MemberKana]
			END AS [MyoujiKana],
			*
		FROM TMc_Member
	) AS [SQ]
	ON [Base].MemberCD = [SQ].MemberCD
	AND [Base].[HistoryNo] = [SQ].[HistoryNo]
	JOIN [ConversionTable] AS [CT]
	ON RIGHT(UNICODE(LEFT([SQ].[myouji],1)),3) BETWEEN [CT].[From] AND [CT].[To]


-- 改良後2
UPDATE [Base]
SET 
	[MemberName] = REPLACE([Base].[MemberName],LEFT([Base].[MemberName],LEN([Base].[Myouji])),[CT].[Name]),
	[MemberKana] = REPLACE([Base].[MemberKana],LEFT([Base].[MemberKana],LEN([Base].[MyoujiKana])),[CT].[Kana]),
	SearchKeyName = REPLACE([Base].[SearchKeyName],LEFT([Base].SearchKeyName,LEN([Base].[Myouji])),[CT].[Name]),
	SearchKeyKana = REPLACE([Base].[SearchKeyKana],LEFT([Base].[SearchKeyKana],LEN([Base].[MyoujiKana])),[CT].[Kana]),
	SearchKeyNameIdentification = REPLACE([Base].SearchKeyNameIdentification,LEFT([Base].SearchKeyNameIdentification,LEN(myouji)),[CT].[Name])
FROM
	(
		SELECT 
			CASE 
				WHEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','') <> '' 
				THEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','')
				ELSE [MemberName]
			END AS [Myouji],
			CASE 
				WHEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','') <> '' 
				THEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','')
				ELSE [MemberKana]
			END AS [MyoujiKana],
			*
		FROM TMc_Member
	) AS [Base]
	JOIN [ConversionTable] AS [CT]
	ON RIGHT(UNICODE(LEFT([Base].[myouji],1)),3) BETWEEN [CT].[From] AND [CT].[To]
```


``` txt


select * from TMc_Customer
select * from TMc_CustomerAddress
select * from TMc_Member
select * from TRe_Reservation
select * from TRe_ReservationPlayer




--文字列を「-」で前後に分割する
SELECT
     CASE WHEN LEN(ISNULL(CustomerName,0)) > 1 THEN SUBSTRING(CustomerName, 1, CHARINDEX(' ', CustomerName )  ) ELSE CustomerName END AS before
    -- ,SUBSTRING( CustomerName, CHARINDEX( @separator, CustomerName ) + 1, LEN( @target_str ) - CHARINDEX( @separator, @target_str )) AS after
FROM
	TMc_Customer

	--文字列を「-」で前後に分割する
SELECT
	CHARINDEX(' ', CustomerName ),
     SUBSTRING(CustomerName, 1, CASE WHEN CHARINDEX(' ', CustomerName ) > 0 THEN CHARINDEX(' ', CustomerName ) -1 ELSE 0 END) AS before
    -- ,SUBSTRING( CustomerName, CHARINDEX( @separator, CustomerName ) + 1, LEN( @target_str ) - CHARINDEX( @separator, @target_str )) AS after
FROM
	TMc_Customer



select * from ConversionTable
where [Name] = '鶴居'


select (UNICODE('井')),(UNICODE('五'))
select RIGHT(UNICODE('井'),3),RIGHT(UNICODE('五'),3)





DECLARE @Count INT = 100;
SELECT   TOP (@Count)
         ROW_NUMBER() OVER (ORDER BY object_id)-1 AS SeqNo
FROM     sys.all_objects
ORDER BY SeqNo;



SELECT * FROM (
	SELECT   TOP (1000)
			 ROW_NUMBER() OVER (ORDER BY object_id)-1 AS SeqNo,
			 ROW_NUMBER() OVER (ORDER BY object_id)+3 AS SeqNoTo
	FROM     sys.all_objects
	ORDER BY SeqNo
) AS rn_q
WHERE rn_q.SeqNo%5 = 0

```

---

## 雑記

トーレス・デル・パイネ国立公園
avalon peninsula canada

[新人「先輩、参照の値渡しについてちゃんと理解してますか？😊」](https://qiita.com/yoshi_10_11/items/1b70ccb859891b57cb5a)  

[【Laravel】確認画面付きのお問い合わせフォームを作成する【メール送信対応】](https://into-the-program.com/laravel-create-contact-form/)
[【 Laravel 】CRUD『 表示・登録・更新・削除 』機能をCODEを書かず自動作成（Beta版機能）](https://qiita.com/daisu_yamazaki/items/3755467b39ef158b81a3)

<https://twitter.com/Sheeeeepla/status/1512642396416528387>
Windowsをインストールしたらやること
☑Sysinternalsを入れて不要な・サービス・スタートアップを探して止める
☑NoMeiryoUIでシステムフォントをIBM Plex Sans JPに変更
☑AutoHotKeyでIME変換キーをAlt単押しで切替可に
☑OneDriveの無効化
☑Remove-AppxPackage
☑PowerShell Coreをインストール

[.NET 6とVSCodeでデスクトップアプリ（ランチャー）](https://qiita.com/Kosen-amai/items/61e6b03b8e0fccc35ee5)
[分岐アンチパターン](https://qiita.com/pakkun/items/9bef9132f168ba0befd7)  

居林さんが文字列の圧縮を実現させた。  
どういうことしたのか気になる。  
似たようなことができないだろうか。  
[PHP（サーバー）と C#（クライアント）で圧縮した文字列のやりとりをする](https://www.create-forever.games/php-csharp-gzip-encode-decode/)  

``` xml
ItemsPanel
    <Setter Property="ItemsPanel">
        <Setter.Value>
            <ItemsPanelTemplate>
                <Grid></Grid>
            </ItemsPanelTemplate>
        </Setter.Value>
    </Setter>
```

``` xml
    <Style x:Key="CloseButton" TargetType="Button">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Button">
                    <Button Command="{TemplateBinding Command}" Margin="0" Padding="0" VerticalAlignment="Center" Height="22">
                        <Border Margin="4,0" MaxWidth="14" CornerRadius="1">
                            <Image Stretch="None" RenderOptions.BitmapScalingMode="Fant" Source="{Binding Source={StaticResource res}, Converter={StaticResource ResourceImageConverter}, Path=Resources.closeerror}" />
                        </Border>
                    </Button>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
```

