# 後でまとめたいやつら

## NULLのLIKE検索

LIKE検索には引っかからない。  
NULLを検索したかったからISNULLを使うこと。  

## NULLのORDERBY

[NULLと戯れる: ORDER BYとNULL](https://qiita.com/SVC34/items/c23341c79325a0a95979)  
どうにも、NULLを最小値とするか最大値とするかは、RDBMS毎に違ったり、設定で変更出来たりするみたい。  
Oracleは最大値扱いだが、SQLServerは最小値扱い見たい。  
まぁ、どちらにせよ、先頭か末尾であることに違いはないということですね。  

## NULLをキャスト

(NULL AS CHAR)→NULLのまま
NULL -1 = NULL



---

Overrideしたイベントは -= +=で解除と登録はできない。


staticだとthis.でアクセスできないのまとめる。



``` C#
    /// <summary>
    /// C1MultiSelect拡張コントロール
    /// </summary>
    public class CustomMultiSelect : C1MultiSelect
    {
        /// <summary>
        /// SelectedItemsプロパティ登録
        /// </summary>
        public static readonly DependencyProperty SelectedItemsProperty =
            DependencyProperty.Register(
                "SelectedItems",
                typeof(IList),
                typeof(CustomMultiSelect),
                new PropertyMetadata(null, new PropertyChangedCallback(OnSelectedItemsChanged))
            );
        /// <summary>
        /// 現在選択されている行に対応するデータ項目のコレクションです。
        /// </summary>
        public new IList SelectedItems
        {
            // newをつけると、元のプロパティを隠ぺいする。
            get { return (IList)GetValue(SelectedItemsProperty); }
            set { SetValue(SelectedItemsProperty, value); }
        }
        /// <summary>
        /// OnSelectionChangedイベント抑制フラグ
        /// </summary>
        /// <remarks>
        /// overrideしたイベントは登録と解除ができないのでフラグで制御する
        /// </remarks>
        private bool OnSelectionChangedSuppressionFlag { get; set; } = false;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public CustomMultiSelect() { }

        /// <summary>
        /// SelectedItems変更イベント
        /// </summary>
        /// <param name="d"></param>
        /// <param name="e"></param>
        private static void OnSelectedItemsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var control = (CustomMultiSelect)d;
            if (control.SelectedItems is INotifyCollectionChanged notify)
            {
                notify.CollectionChanged -= control.OnCollectionChanged;
                notify.CollectionChanged += control.OnCollectionChanged;
            }

            // 試行錯誤の後
            //if (d != null)
            //{
            //    //fg.SetValue(
            //    //    SelectedItemsProperty,
            //    //    () => SelectedItems.Add(e.NewValue)
            //    //);
            //    if (control.ListBox != null)
            //    {
            //        control.ListBox.SelectedItems.Add(e.NewValue);
            //    }
            //}

            //if (d is CustomMultiSelect multiselect)
            //{
            //    multiselect.SelectionChanged += (s, eventArgs) =>
            //    {
            //        multiselect.SelectedItems.Add(s);
            //        //var items = (List)multiselect.SelectedItems;
            //        //if (items == null)
            //        //{
            //        //    return;
            //        //}
            //        //foreach (var item in items.Where(x => x.IsSelected == true))
            //        //{
            //        //    multiselect.SelectedItems.Add(item);
            //        //}
            //    };
            //    //// 削除
            //    //foreach (var deleteItem in args.RemovedItems.OfType<SubjectLargeTypeWithSubjectCDList>())
            //    //{
            //    //    multiselect.Remove(deleteItem);
            //    //}
            //    //// 追加
            //    //foreach (var addItem in args.AddedItems.OfType<SubjectLargeTypeWithSubjectCDList>())
            //    //{
            //    //    multiselect.Add(addItem);
            //    //}
            //}
        }

        /// <summary>
        /// SelectedItemsコレクション変更イベント
        /// OneWayに対応する処理です。
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        /// <remarks>
        /// 主にViewModel側から選択状態を反映させるときに発動する。
        /// 選択項目の反映はC1MultiSelectのプロパティであるListBoxのSelectedItemsを操作することで反映されることが分かった。
        /// </remarks>
        private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // SelectionChanged抑制開始
            OnSelectionChangedSuppressionFlag = true;
            // 要素の追加、削除、クリアに応じた処理を実行します。
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add: foreach (var item in e.NewItems) ListBox.SelectedItems.Add(item); break;
                case NotifyCollectionChangedAction.Remove: foreach (var item in e.OldItems) ListBox.SelectedItems.Remove(item); break;
                case NotifyCollectionChangedAction.Reset: ListBox.SelectedItems.Clear(); break;
                default: break;
            }
            // SelectionChanged抑制終了
            OnSelectionChangedSuppressionFlag = false;
        }

        /// <summary>
        /// コンボボックスが選択された時に発動します。
        /// ToSourceに対応する処理です。
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected override void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            // CollectionChangedが発動しているときは処理をしない
            if (OnSelectionChangedSuppressionFlag) return;
            // コンボボックスの選択状態をSelectedItemsに反映させる
            if (SelectedItems is INotifyCollectionChanged notify)
            {
                // SelectedItemsのAddとRemoveを実行するのでCollectionChangedイベントを抑制する
                notify.CollectionChanged -= OnCollectionChanged;
                // 衝突の危険性があるので先に削除する
                foreach (var deleteItem in e.RemovedItems) SelectedItems.Remove(deleteItem);
                // 後から追加する
                foreach (var addItem in e.AddedItems) SelectedItems.Add(addItem);
                // イベント再登録
                notify.CollectionChanged += OnCollectionChanged;
            }
            base.OnSelectionChanged(sender, e);
        }
    }
```

``` C# : 改良版
    /// <summary>
    /// C1MultiSelect拡張クラス
    /// </summary>
    public class CustomMultiSelect : C1MultiSelect
    {
        #region プロパティ
        #region 依存関係プロパティ
        /// <summary>
        /// SelectedItems依存関係プロパティ登録
        /// </summary>
        public static readonly DependencyProperty SelectedItemsProperty =
            DependencyProperty.Register(
                "SelectedItems",
                typeof(IList),
                typeof(CustomMultiSelect),
                new PropertyMetadata(null, new PropertyChangedCallback(OnSelectedItemsChanged))
            );
        /// <summary>
        /// 現在選択されている行に対応するデータ項目のコレクションです。
        /// </summary>
        public new IList SelectedItems
        {
            get { return (IList)GetValue(SelectedItemsProperty); }
            set { SetValue(SelectedItemsProperty, value); }
        }
        #endregion

        /// <summary>
        /// OnSelectionChangedイベント抑制フラグ
        /// </summary>
        /// <remarks>
        /// overrideしたイベントは登録と解除ができないのでフラグで制御する
        /// </remarks>
        private bool OnSelectionChangedSuppressionFlag { get; set; } = false;
        #endregion


        #region コンストラクタ
        /// <summary>
        /// コンストラクタ
        /// </summary>
        public CustomMultiSelect() { }
        #endregion


        #region 内部処理
        /// <summary>
        /// SelectedItems変更イベント
        /// ViewModelからCustomMultiSelectに対応する処理です。
        /// </summary>
        /// <param name="d"></param>
        /// <param name="e"></param>
        private static void OnSelectedItemsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var control = (CustomMultiSelect)d;
            if (control?.ListBox == null || control?.SelectedItems == null)
            {
                return;
            }
            // OnSelectionChangedの抑制
            control.OnSelectionChangedSuppressionFlag = true;
            // 衝突を避けるため内部の選択状態をクリアする
            control.ListBox.SelectedItems.Clear();
            // フロントから代入された選択項目
            foreach (var frontItem in control.SelectedItems)
            {
                // CustomMultiSelectが保持している項目
                foreach (var sourceItem in control.ListBox.ItemsSource)
                {
                    // 保持しているアイテムと同じ選択項目をコントロール内部の選択項目に反映させる
                    if (sourceItem == frontItem)
                    {
                        // 内部の選択状態はC1MultiSelectのListBoxを操作することで反映される。
                        control.ListBox.SelectedItems.Add(frontItem);
                        break;
                    }
                }
            }
            // OnSelectionChangedの抑制解除
            control.OnSelectionChangedSuppressionFlag = false;
        }

        /// <summary>
        /// コンボボックスが選択された時に発動します。
        /// CustomMultiSelectからViewModelに対応する処理です。
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected override void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (SelectedItems == null || OnSelectionChangedSuppressionFlag)
            {
                return;
            }
            // SelectedItemsの変更通知を何回も行わせないため、参照だけコピーして
            // コピー先を書き換えてもとに戻すことで、変更を1回だけにする。

            // シャローコピー。
            var items = SelectedItems;
            // 衝突の危険性があるので先に削除する
            foreach (var deleteItem in e.RemovedItems ?? new List<object>())
            {
                items.Remove(deleteItem);
            }
            // 追加は削除の後に実行
            foreach (var addItem in e.AddedItems ?? new List<object>())
            {
                items.Add(addItem);
            }
            SelectedItems = items;

            base.OnSelectionChanged(sender, e);
        }
        #endregion
    }
```

``` C# : KeyValuePairConverter
    /// <summary>
    /// KeyValuePairのKeyをValueに変換するコンバーター
    /// </summary>
    public class KeyValuePairConverter : IValueConverter
    {
        /// <summary>
        /// KeyValuePairのKeyをValueに変換します。
        /// </summary>
        /// <param name="value">バインディング ソースによって生成された値</param>
        /// <param name="targetType">バインディング ターゲット プロパティの型</param>
        /// <param name="parameter">使用するコンバーター パラメーター</param>
        /// <param name="culture">コンバーターで使用するカルチャ</param>
        /// <returns></returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // null判定
            if (parameter == null) throw new Exception(string.Format(Message.Invalid, "値"));
            // 型の判定とIListへ変換
            if (!(parameter is IList list)) throw new Exception(string.Format(Message.Invalid, "型"));
            // 要素をループ
            foreach (var item in list)
            {
                // 値が一般的であることを確認
                Type valueType = item.GetType();
                if (valueType.IsGenericType)
                {
                    // ジェネリック型の定義を抽出
                    Type baseType = valueType.GetGenericTypeDefinition();
                    // KeyValuePair型の判定
                    if (baseType == typeof(KeyValuePair<,>))
                    {
                        // KeyとValueの取得
                        var kvpKey = valueType.GetProperty("Key")?.GetValue(item, null);
                        var kvpValue = valueType.GetProperty("Value")?.GetValue(item, null);
                        // Keyと引数valueの比較
                        if (kvpKey?.Equals(value) ?? kvpKey == value)
                        {
                            return kvpValue;
                        }
                    }
                }
            }
            // Keyに合致するものがなければnullを返却。
            return null;
        }

        /// <summary>
        /// OneWayでのBindingでしか使用しません。
        /// </summary>
        /// <param name="value">バインディング ソースによって生成された値</param>
        /// <param name="targetType">バインディング ターゲット プロパティの型</param>
        /// <param name="parameter">使用するコンバーター パラメーター</param>
        /// <param name="culture">コンバーターで使用するカルチャ</param>
        /// <returns></returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
```

## DependencyProperyのSetterの値がNullになってしまう問題

[Why does my Dependency Property send null to my view model?](https://stackoverflow.com/questions/38958177/why-does-my-dependency-property-send-null-to-my-view-model)  
[MVVMのDataGridまたはListBoxからSelectedItemsにバインド](https://www.webdevqa.jp.net/ja/c%23/mvvm%E3%81%AEdatagrid%E3%81%BE%E3%81%9F%E3%81%AFlistbox%E3%81%8B%E3%82%89selecteditems%E3%81%AB%E3%83%90%E3%82%A4%E3%83%B3%E3%83%89/942024865/amp/)  

MultiSelectComboBoxのSelectedItemsの2WayBindingを実装している時に出くわした問題。  
コントロール側はIList,ViewModel側はIEnumerable<T>で実装していたのだが、Setterまでは値が入っているのに、ViewModelのSetterにはNullが入ってしまう。  

どうやら非ジェネリックIListとIListを同じ意味で使用はできない模様。  
コントロール側の型とViewModel側の型を合わせれば値は届くが、2Wayにしたい以上、コントロールはIList,ViewModelはIEnumerableで受け取りたい願望がある。  
いろいろ探してみたが、どうやら無理らしい。  
どのサンプルでもObservableCollectionを使っていたり、イベントやビヘイビアで実現している。  
現状では、ジェネリックのバインディングは実現できない模様。  

1.コントロールの型とViewModelの型を合わせる→IListで受け取ってOfTypeで変換して使う。  
2.ObservableCollectionのCollectionChangedイベントを観測する。  
3.イベントやビヘイビアで観測する。  

いろいろな実現方法もまとめておく  
[ListBoxやDataGridなどのItemsControlでSelectedItemsやIsSelectedをBindingする](https://qiita.com/mkuwan/items/7372b4b602fdabc3358c)  


## 添付プロパティ

例えば、テキストボックスとボタンがあります。
カーソルが当たっている間は色を変えたいけれど、どちらにもその機能はない。
それぞれを継承して拡張した、CustomButton,CustomTextを作ってもいいけど、どちらにも同じコードを書くことになるし作ること自体に手間がかかる。
そういう時に添付プロパティなるものを作って、それをテキストボックスとボタンに実装してあげることで、その機能を実現することができる。
それが、添付プロパティ。

どうやって作るかは後でまとめる。



DependencyProperty→バインディングができるようにする。コントロールにそういう機能がある。

INotify
Classに実装。

バインディングをしたときに、バインド間で通知をしてくれる。
。Net側の処理。

CollectionChanged。

ObsColle 
Foreachの中で、inに入れるコレクションの内容が変わった時にエラーが発生する。
これは、イベントが邪魔をしている証拠。
抑制する必要がある。

---


SELECTした結果をINSERTできたよなぁーと思ってやったら一発で行けたので備忘録として載せておく。

INSERT INTO Round3SysC3.dbo.TSm_ReportFileSetting
(WindowName,TemplateName,ReportName,ValidFlag,Sort,ApiUri,Remarks)
SELECT WindowName,TemplateName,ReportName,ValidFlag,Sort,ApiUri,Remarks
FROM Round3Sys_Test.dbo.TSm_ReportFileSetting
WHERE WindowName = 'RN3.Wpf.Front.CheckOut.Views.CheckOutWindow'
AND TemplateName = 'RN3.Wpf.Front.CheckOut.SettlementH.rdlx'

---

## 雑記

・昼休みでローカルのラウンドナビを動かせるようにしておく。
・100均で筋トレ用のマット＆封筒購入
・俺が仕様書メモとしてまとめてる内容は全て開発フォルダの仕様書フォルダに乗っけておけばいいのでは？
メモ書き程度のやつは上に持っていくのはどうかな。

・会社の健保のあれ注文する。
令和3年10月12日（火）9時から令和3年10月25日（月）24時まで


・ヒートテックがゆるゆるになってきた。そろそろ新しい奴買ったほうがいいだろうか。割と真剣に考えよう。
・100均のトレーニングマットがどんなものか


・ネットワーク
・C# 配列
・Javaジェネリック
・バニラのWPFで最小のMVVMサンプルを作ってみたい


・朝も散歩。昼も散歩。散歩してなきゃやってられない。  

・シャローコピーとディープコピー、名前付き引数、プレジデンスダイアグラム、DependencyPropertyのIListとのBinding、正規系の確認

