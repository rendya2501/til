# 後でまとめたいやつら


## mariaDBで0埋めして文字列結合するサンプル

意外と調べるのに苦労したのでまとめる。  
GORAPriceに20とか30レコードもあるようなプランがあるか調べたかったので、  
IDを作る要領で3つのキーを0埋めして文字列結合して、GroupByしてCOUNT取ってHAVINGで20以上のIDを表示ってやつ。  

左0埋め→LPAD  
文字列結合→CONCAT  
数値→文字列変換→CAST(数値 AS CHAR)  
数値文字列変換に関してはLPADしてCONCATしたらそのまま行けたので別に必要ないのかも。  

``` SQL
SELECT
    CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode, 6, '0'),LPAD(OpenPlanCode, 6, '0')),
    COUNT(CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode, 6, '0'),LPAD(OpenPlanCode, 6, '0')))
FROM
    TmOpenPlanGORAPrice
GROUP BY
    CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode , 6, '0'),LPAD(OpenPlanCode, 6, '0'))
HAVING
    COUNT(CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode, 6, '0'),LPAD(OpenPlanCode, 6, '0'))) > 30
```


## JavaScriptもしくはTypeScriptにstring.IsNullOrEmptyに相当する関数は存在するか？

結論から言うとない。  
けど、言語使用上、必要ないみたい。  
そんなものを使わなくても !stringで全部わかるんだとか。  

<https://codereview.stackexchange.com/questions/5572/string-isnullorempty-in-javascript>  


## nginx

nginx再起動コマンド : sudo nginx -s reload
→
通常、Webサーバーの再起動を行った場合、瞬断が発生するが、-sオプションをつけることでそれがなくなるらしい。
-sオプションを指定すると、nginxのworkerプロセスが少しずつ新しいプロセスに置き換わっていくだとかなんだとか。
[[nginx]設定の反映](https://qiita.com/WisteriaWave/items/fa2e7f4442aee497fe46)


伊藤の開発ポートの設定ファイル
/etc/nginx/conf.d/2061.conf : bugfix
/etc/nginx/conf.d/2062.conf : hotfix

fastcgi_intercept_errors on;
をlocation ~ \.php$ {}の中に記述すると300以上のエラーがクライアントに伝わらなくなるので、正常にエラー表示ができなくなる。
2062ファイルにはこれが設定されていたので、hotfixでは意図的に500エラーを発生させても、bugfixのようなエラー表示にならなくて困っていた。
原因はサーバーの設定であって、Laravelの機能ではなかった。
[cakephp3 + CentOS8 + nginx + php-fpmでエラー表示がされないとき](https://blog.supersonico.info/archives/4277/)


[nginx 起動ポートの変更](https://qiita.com/Watercat3/items/38b2bac5fa70b232bee3)


## APIのメッセージを表示する方法(Response型のメッセージを取得する方法)

APIからのメッセージは_bodyプロパティの中にあるみたいが、素直にアクセスしようとすると存在しないというエラーになる。  
実行したときは存在するけど、コーディングの段階では存在しないみたいなパターン。  
これがJavascriptの仕様なのかTypescriptの仕様なのかは、わからないが、それはまた別でまとめたい。  
取り出すときはres.json()でなぜか取り出せる。  
そういうものなのだろうか。これも後でまとめる。  

``` ts
    // Service
    public maintenance(param: any): Promise<Response> {
        return this.apiService.put('system/web-cooperation/plan-cooperation/maintenance/', JSON.stringify(param));
    }
    
    // ViewModel
    this.goraMaintenanceService
        .maintenance(param)
        .then(
            res => {
                if (res.json() !== null && res.json() !== '') {
                    this.confirmComponent.dialogOk(res.json(), '確認', null)
                }
                this.notify.success('メンテナンスしました。');
                // 成功したら一覧を更新する
                this.getPlanList();
            },
            error => this.notify.error('失敗しました。\n : ' + error.json());
        )
        .then(() => this.isLoading = false);
```


どうでもいいけどこの人すごい。
1990年生まれ。京大卒。

RESTとGraphQLについて
<https://www.utakata.work/entry/2019/12/02/000000>


## DDLについて

[わかりそうデータ定義言語 (DDL)](https://wa3.i-3-i.info/word15639.html)


## NULLのLIKE検索

LIKE検索には引っかからない。

## NULLのORDERBY

[NULLと戯れる: ORDER BYとNULL](https://qiita.com/SVC34/items/c23341c79325a0a95979)  
どうにも、NULLを最小値とするか最大値とするかは、RDBMS毎に違ったり、設定で変更出来たりするみたい。  
Oracleは最大値扱いだが、SQLServerは最小値扱い見たい。  
まぁ、どちらにせよ、先頭か末尾であることに違いはないということですね。  

## COUNT(*)の意味とNULLのCOUNT

[COUNT(*)　が何を意味しているのかわからない](https://ja.stackoverflow.com/questions/42915/count-%E3%81%8C%E4%BD%95%E3%82%92%E6%84%8F%E5%91%B3%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84)  
COUNT(*)は行数を数えてくれる。  

``` txt
OracleではCOUNT(*)とCOUNT(age)の結果は異なります。
ageにnullが入っているとCOUNT(age)では件数にカウントされません。
グループ化していても同様で、ageがnullのグループのみ0件となります。
COUNT(*)ではageにnullが入っていてもレコードの件数をカウントします。

COUNT(*)ではレコードの内容を取得するため、COUNT('X')やSUM(1)を使った方が高速化できると教わったことがあります。(10年ほど前に聞いたノウハウなので現在も適用されるのかは不明ですが…)
```

なるほど。COUNTはNULLはカウントしないのね。  
動作的にCOUNT(name)見たいにフィールド名を指定したほうが高速化できるっぽいけど、単純にレコード数を取得したいならCOUNT(*)でいいのか。  

## NULLをキャスト

(NULL AS CHAR)→NULLのまま
NULL -1 = NULL

## 名前付き引数 C#7.0



## Laravel 405

最後にスラッシュを入れるとリダイレクトになるらしいが、なぜ？
開発環境ではならないのに、61ではなるのはなぜ？
WEBサーバーの違いに寄るものなのか？

## クロックの計算

<https://www.foresight.jp/blog/it/archives/964>  

計算は苦手。  
書けるのか割るのかその基準があいまいだから。  

1GHz = 10^9 = 10億  
というわけで、1秒間に10億回のクロックが発生する。もとい10億回計算出来る。  
1命令が1クロックならMIPSは1,000MIPS  
1M = 10^6 = 100万  

1命令が0.8クロックなら何万命令実行できる？  

10億を0.8で割ると？
125000000000


