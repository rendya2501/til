# 午後メモ

【アルゴリズム】  
・バブルソート（交換法）  
・選択法  
・挿入法  
・マージソート  
・クイックソート  
・線形探索法  
・二分探索法  
・ハッシュ表探索法  

【データ構造】  
・配列  
・構造体の配列  
・連結リスト  
・二分探索木  
・ヒープ  
・キュー  
・スタック  

---

## アルゴリズム

### クイックソート

<https://www.hanachiru-blog.com/entry/2020/03/08/120000>  

最悪計算時間 : $n^2$
最良計算時間 : $n log n$
平均計算時間 : $n log n$

最良になる時の構造とは？
→再帰の各段階で常に均等に分割された場合が最良のケース。
最悪になる時の構造とは？
→1要素と残り全部のように偏って分割された場合が最悪のケース。

中央値の選定が重要であり、なるべく中間の値を選ぶ必要がある。

分割統治法

安定ではない。
隣接していない遠く離れた2要素を交換するから。

### 線形探索法

### 二分探索法

### ハッシュ表探索法

### バブルソート（交換法）

### 選択法

### 挿入法

### マージソート

### ヒープソート

ヒープとは、親の値が子の値以上であるという条件を満たす完全2分木(p.332)です。  
もちろん一貫していれば値の大小関係は反対(親の値が子の値以下となる)でも構いません。  

---

## データ構造

### 配列

同じ型を連続して確保する仕組み。  
要素数が決まっている場合は配列を使う。  

### 構造体の配列

構造体と言えばC言語。
というか、それしか出てこない。
用は配列の型を構造体にしたってだけな気がする。
実際そうみたい。
一応コード乗せておく

``` C
struct pop_dt {         /* 人口情報構造体 */
    char region[20];    /* 地域名 */
    long pop;           /* 人口 */
};

struct pop_dt world[7]= {
    {"asia", 3769},
    {"north_america", 498},
    {"south_america", 357},
    {"europe", 725},
    {"africa", 832},
    {"oceania", 31},
    {"nowhere", 0}
};
```

### 連結リスト

ポインタによって値を連結した物。  
要素数が増減する場合は配列よりリストのほうがよい。  

### 二分探索木

### ヒープ

ヒープ : 累積,山積み,雑然と詰まれた物  
ヒープに関してはメモリとソートに関する話題が含まれている。  
ここに書くのはメモリに関するものとする。ヒープソートは上でやる。  

自分の言葉で書けば、プログラムを実行する上で確保されたり解放されたりするメモリ領域の事。
参考にしたサイトの言葉をそのまま書くなら、
動的に確保と解放を繰り返せるメモリ領域の事。
プログラムの実行時には、OSからソフトウェアに対して一定量のヒープ領域が与えられます。  
ソフトウェアは、必要に応じて任意にヒープ領域を確保・解放できます。  

C系ならmalloc(memory allocation:メモリ割り当て),freeで確保と解放を行う。  
Java,C#系ならガベージコレクションで管理してくれるから意識する必要はない。(と、いいつつ、最近の仕事でメモリーリークしてるけどね)  
classをnewした時に確保される領域はこっち。  
int等を宣言したときに確保される領域はスタック領域。  

### キュー

FIFO  
待ち行列  

### スタック

スタック : 整然と詰まれた物  
LIFO : 後入れ先だし : 古いものほど残る→後に入った物ほど先に出る。  
再帰のあれ。  
PUSHとPOP。  
