# 午後メモ

アルゴリズムに関しては、何年前の問題でもかまわない。  
ネタが尽きることはない。  

午後問題は逆に言えば、アルゴリズムとJavaさえできてしまえば問題がないわけだよな。  
というわけで、31年から順々にやっていってるわけだが、先にアルゴリズムを全てやる勢いでやったほうがいいかもしれない。  
他の問題は息抜き程度で十分かも。  
午前問題の復習になるからそれはそれでいいだけど、そこで点数をとっても合格には弱い。  

アルゴリズムが解けないのは、日本語の解読が難しいから。  
説明をプログラムと紐づけて理解するのに時間がかかるから。  
頭の中だけで頑張って考えるので最終的に混乱してしまうから。  
そのプログラムが何を実現したいプログラムなのかをイメージできないから。  



---

## アルゴリズム解き方のコツやポイント

[アルゴリズム問題を解くコツ](https://www.seplus.jp/dokushuzemi/fe/fenavi/patterns_algorithms/#!)  
まずこれに全部目を通す。  
それが終わった後で、問題を解き始める。  
とりあえず、25年までのアルゴリズムとJava全て。  
平日で疲れているときは、午前問題か午後の他の問題をやればいい。  

---

## アルゴリズム

・バブルソート（交換法）  
・選択法  
・挿入法  
・マージソート  
・クイックソート  
・線形探索法  
・二分探索法  
・ハッシュ表探索法  

---

### クイックソート

<https://www.hanachiru-blog.com/entry/2020/03/08/120000>  

最良計算時間 : $n log n$
最悪計算時間 : $n^2$
平均計算時間 : $n log n$

最良になる時の構造とは？
→再帰の各段階で常に均等に分割された場合が最良のケース。
最悪になる時の構造とは？
→1要素と残り全部のように偏って分割された場合が最悪のケース。

中央値の選定が重要であり、なるべく中間の値を選ぶ必要がある。

分割統治法

安定ではない。
隣接していない遠く離れた2要素を交換するため。

### マージソート

<https://daeudaeu.com/merge_sort/>

平均計算量 $O(n log n)$
最悪計算量 $O(n log n)$

分割統治法

安定である。
離れた要素を交換しないため。

一時的な領域を確保するので、外部ソートに分類される。

マージソートの解析をしてみたけど、これは分割して考えるソート法になるのだろうか。
半分にしていくまではわかった。
バッファーに1つ取って比較していく方法ってだけじゃないか。

### 線形探索法

要素が直線状に並んだ配列から、目的とするキー値をもつ要素に出会うまで先頭から順に要素を走査する探索法  

### 二分探索法

キー値が書順位ソート済みである時に使うことが出来る。  
その場合、線形探索より高速に検索を行える。  

### ハッシュ表探索法

### バブルソート（交換法）

### 選択法

### 挿入法

### ヒープソート

平均計算量 $O(n log n)$
最悪計算量 $O(n log n)$

不安定な内部ソート

なんだかんだクイックソートのほうが早い。

・ヒープソート とは 二分ヒープ と呼ばれるデータ構造を用いてソートを行うアルゴリズムです。  
・二分ヒープと呼ばれるデータ構造は、二分木を使って作られるデータ構造で、各ノードの値は常に子ノードの値より大きいか等しくなるように配置されます。  
・二分ヒープのルートノードの値は最大値となる  
・ヒープソートは最大値が根に位置している事を利用してソートを行うアルゴリズム  

ヒープとは、親の値が子の値以上であるという条件を満たす完全2分木(p.332)です。  
もちろん一貫していれば値の大小関係は反対(親の値が子の値以下となる)でも構いません。  

---

## データ構造

・配列  
・構造体の配列  
・連結リスト  
・二分探索木  
・ヒープ(木構造)  
・キュー  
・スタック  
・ハッシュテーブル  

[データ構造](https://qiita.com/AckyFc3/items/7ce74598c4fd82206c1a)  
[うさぎでもわかる配列と連結リスト](https://www.momoyama-usagi.com/entry/info-algo-list)  

---

### 配列(Array)

配列は要素の集合を格納・管理するのに用いられるデータ構造  
同じ型を連続して確保する仕組み。  
メモリ上に連続して領域を確保する。  

・メリット  
　・インデックスを通して高速にアクセス可能  
　・末尾のデータ挿入、削除は高速  
・デメリット  
　・データが大きい場合に大量のメモリを消費する  
　・末尾以外のデータを挿入、削除は遅い  

配列、リストあたりはここの解説をどうぞ  
[うさぎでもわかる配列と連結リスト](https://www.momoyama-usagi.com/entry/info-algo-list)  

### 構造体の配列(Struct Array)

構造体と言えばC言語。
というか、それしか出てこない。
用は配列の型を構造体にしたってだけな気がする。
実際そうみたい。
一応コード乗せておく

``` C
struct pop_dt {         /* 人口情報構造体 */
    char region[20];    /* 地域名 */
    long pop;           /* 人口 */
};

struct pop_dt world[7]= {
    {"asia", 3769},
    {"north_america", 498},
    {"south_america", 357},
    {"europe", 725},
    {"africa", 832},
    {"oceania", 31},
    {"nowhere", 0}
};
```

### 連結リスト(Linked List)

一連のノードが、データフィールドと1つか2つの参照を持ち、参照により次(および前)のノードへのリンクを保持している  
C#ではLinkedListクラスとして実装されているので、普段使っているListとはまた別のリストなのかもしれない。  

・線形リスト(linear linked list) : 先頭と末尾があるようなもの  
・循環リスト(circular linked list) : すべての要素が円環状に連結されていて先頭や末尾が存在しないもの  
・片方向リスト(singly linked list),単方向リスト:各要素が自分の次の要素への参照のみを持っているようなもの  
・双方向リスト:(doubly linked list) : 自分の前と次の両方の参照を持っているようなもの  

### 二分探索木(Binary Tree)

全ての要素が「左の子＜親≦右の子」（あるいは「左の子≦親＜右の子」）という大小関係を満たす二分木構造  

### ヒープ(Heap)

ヒープ : 累積,山積み,雑然と詰まれた物  
ヒープに関してはメモリとソートに関する話題が含まれている。  
ここに書くのはメモリに関するものとする。ヒープソートは上でやる。  

自分の言葉で書けば、プログラムを実行する上で確保されたり解放されたりするメモリ領域の事。
参考にしたサイトの言葉をそのまま書くなら、
動的に確保と解放を繰り返せるメモリ領域の事。
プログラムの実行時には、OSからソフトウェアに対して一定量のヒープ領域が与えられます。  
ソフトウェアは、必要に応じて任意にヒープ領域を確保・解放できます。  

C系ならmalloc(memory allocation:メモリ割り当て),freeで確保と解放を行う。  
Java,C#系ならガベージコレクションで管理してくれるから意識する必要はない。(と、いいつつ、最近の仕事でメモリーリークしてるけどね)  
classをnewした時に確保される領域はこっち。  
int等を宣言したときに確保される領域はスタック領域。  

### ヒープ(木構造)

「子要素は親要素より常に大きいか等しい（または常に小さいか等しい）」という制約を持つ木構造  

・木構造の一種で、格納されている全ての要素の中から、最小値または最大値を持つ要素を探すことに適した構造である。  
・ヒープはルートが最小値、または最大値となるように構成する。  
・ルートが最小値とした場合、ある節の値は必ずその親以上の値になる。  
・2分探索木と違い、ある節が持っている子同士には、特に条件はない。  

1
3 6
4 8 7

### 2分岐探索木

・2分木(各ノードは最大で2本の個を持つ)  
・全ての要素が「左の子<親<=右の子」(あるいは「左の子<=親<右の子」)という大小関係を満たす  

### キュー(Queue)

データを先入れ先出し（FIFO:First In First Out）のリスト構造  
待ち行列  
スタックに値を挿入することをエンキュー(Enqueue)、 取り出すことをデキュー(Dequeue)するという  

### スタック(Stack)

データを後入れ先出し（LIFO:Last In First Out）のリスト構造  

スタック : 整然と詰まれた物  
LIFO : 後入れ先だし : 古いものほど残る→後に入った物ほど先に出る。  
スタックに値を挿入することをプッシュ(Push)、 取り出すことをポップ(Pop)するという  
主に再帰で使う。  

### ハッシュテーブル(HashTable)

キーと値の組（エントリと呼ぶ）を複数個格納し、キーに対応する値をすばやく参照するためのデータ構造  
