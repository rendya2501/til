# 平成31年春期

■ a 不正解  
■ b 不正解  
■ c 不正解  
■ d 不正解  
■ e 不正解  
■ f 不正解  
■ g 不正解  
■ h 不正解  

## セキュリティー

15分 【成績】全5問中 5問 回答/5問 正解　正解率:100.0%  

15分で完了!!しかも100点!!  
やっぱりセキュリティーですよ。  
100点とは言いつつ、パッと出てこなかった知識や復習としてまとめたいものもあるので、それらはしっかりやっていく。  

■a  
生体認証かパスワードで迷ったけど、問題文をよく見るとパスワード一択であることがわかる。  

■b  
デジタル署名で確認できることは、「改ざんの有無」と「送信者の正当性」。
なので改ざん一択。
デジタル署名自体、復習が必要。

■c  
送信者は秘密鍵で暗号化して、受信者は送信者の公開鍵で複合するので、公開鍵一択。  

■d  
落ち着いて、シーケンス図と照らし合わせれば、消去法で答えにたどり着いた。  
Idpとクラウドサービスの間には必ずWebブラウザがあるのだから、それで選べば良い。  

■e  
自分のイメージと答えが一致していたので、完全にあっていた。  
実際に外部からアクセスした場合のシーケンスをトレースすればいける。  

---

## ネットワーク

26分 【成績】全5問中 5問 回答/5問 正解　正解率:100.0%  

ネットワークは簡単だった。  
最後の問題だけ利用率の話で数式に落とし込むまでに時間がかかったけど、最終的に解けたからOK  

a~dは問題を読むだけでわかったので、とりあえず解説そのまま乗せておきます。  

■a  
負荷分散装置導入後の構成では、クライアントからの要求を負荷分散装置が受け取り、各種情報を基に適切なアプリケーションサーバに要求を振り分けることになります。

eラーニングシステムはWebベースのシステムなので、クライアントはWebブラウザ上でドメイン名を指定してeラーニングシステムにアクセスします。この際にドメイン名の名前解決が行われるのですが、DNSサーバが返すIPアドレスによってクライアントがアクセスする機器が変わります。クライアントからの全ての要求を負荷分散装置に集めたいのですから、ドメイン名に対応するIPアドレスとして負荷分散装置のIPアドレスを設定しなければなりません。

負荷分散装置のIPアドレスには、インターネット側(グローバルIPアドレス)の「192.0.2.2」と内部ネットワーク向け(プライベートIPアドレス)の「192.168.0.254」がありますが、クライアントはインターネットを介して負荷分散装置にアクセスするので、DNSサーバにはグローバルIPアドレスである「192.0.2.2」を登録します。

■b  
本文中の説明にもあるように、負荷分散装置は、クライアントからの要求を、同じ機能をもつ複数のサーバのうちいずれかに振り分ける装置です。eラーニングシステムの構成上、同じ機能のサーバはアプリケーションサーバの組みだけであり、〔負荷分散装置を用いたアクセスの振り分け〕ではアプリケーションサーバ2台への振り分け方式が説明されているため、振り分け先は2台のアプリケーションサーバになるとわかります。アプリケーションサーバのIPアドレスは「192.168.0.1」と「192.168.0.2」なので、この2つを振り分け先IPアドレスとして登録することになります。

■c  
装置タイプBでは、HTTPヘッダ内の情報を基に振り分けるので選択肢のうちHTTPヘッダに含まれる情報が正解となります。  
cookieは、HTTPのレスポンスヘッダ内の指示によってWebブラウザにユーザ情報などを保存し、HTTPのリクエストヘッダを通じてその情報をWebサーバに送信する仕組みです。セッションIDとは、サーバ側でユーザを識別するためにWebブラウザに埋め込まれるキー情報であり、通常はcookieの仕組みを用いてWebブラウザにセッションIDを埋め込みます。
したがって、装置タイプBが識別情報として利用するのは「セッションIDを示すcookie」になります。  

■d  
装置タイプAは送信元IPアドレスを基に振り分ける方式です。教室からeラーニングシステムへのアクセスには、教室ごとに設置されたプロキシサーバを利用するため、負荷分散装置に届いたパケットの送信元IPアドレスは、各教室のプロキシサーバのIPアドレスになっています。このため、同一教室内のクライアントは全て同一のアプリケーションサーバに振り分けられることになります。

装置タイプAで採用されているラウンドロビン方式は、2つのアプリケーションサーバの負荷状態や接続数に関係なく、単純に2台の装置に順番に振り分けていく方式なので、以下の例のようにアクセスが一方のサーバに偏る可能性があります。
教室A(20台)をサーバ1に振り分ける
教室B(100台)をサーバ2に振り分ける
教室C(10台)をサーバ1に振り分ける
教室D(200台)をサーバ2に振り分ける
各サーバの最大接続数は、サーバ1が30台、サーバ2が300台
大規模教室からのアクセスが一方のアプリケーションサーバに集中し得る理由は、同じ教室内のクライアントの送信元IPアドレスが全て同じになるからです。

∴ア：同じ教室のどのクライアントからの要求も送信元IPアドレスが全て同じになること

■e  
また当てずっぽうにするところだったけど、問題文をよく読んで、数式に当てはめて考えれば問題なかった。  
逆数って表現が出てきて焦ったけど、それも計算で算出可能だったので意味は知らなくてよかった。  
因みに本当に分母と分子を逆にするだけ見たいね。  

解説:  
M/M/1の待ち行列の計算式が与えられているので、設問中の値を当てはめて計算していきます。

まず、現行のネットワーク構成における平均処理待ち時間(4.6秒)の算出手順を確認します。
μ … 平均処理時間の逆数と説明されているので「0.4秒＝2／5秒 → 5／2＝2.5」
λ … 平均到着率なので「2.3」
ρ … 2.3÷2.5＝0.92
待ち行列の計算式にρを代入すると、

　0.92／(1－0.92)×0.4秒
＝11.5×0.4秒＝4.6秒

本題となる新構成では、要求が2台のサーバに交互に振り分けられるので、各サーバの平均到着率は1台構成のときの半分となる1.15件／秒になります。
μ … 現行の時と同じ「0.4秒＝2／5秒 → 5／2＝2.5」
λ … 平均到着率なので「1.15」
ρ … 1.15÷2.5＝0.46
待ち行列の計算式にρを代入すると、

　0.46／(1－0.46)×0.4秒
＝0.8518…×0.4秒≒0.34秒

∴イ：0.34

---

## データベース

15分 【成績】全6問中 6問 回答/4問 正解　正解率:66.7%  

15分で終わらせたが、結果は6割で最悪なものになった。  
これを契機にしっかり復習したい。  

■ a 不正解
いきなり間違えた。  
SQLであいまい検索する時、`LINE '%○○%'`で済ませて来たツケが回ってきた。  

LIKE句は、指定したパターンと文字列比較を行うための演算子で、次の特殊記号を用いて文字列のパターンを指定します。  
・`_` … 任意の1文字  
・`%` … 0文字以上の任意の文字列  

`_`が任意の1文字だとは知らなかった。SQL側にもまとめよう。  

エ : `= '201%'`  
を選択したけど、ワイルドカードを使用した文字列は、LIKE句と同時に使用しなければ効果を生じません。年度が"201%"の行は存在しませんので結果は0行になります。  
との事だった。  
これも、まとめよう。  

■ b 正解  
ビューで生成された結果をWHEREしているので、文字列で`男`指定で問題ない。  

■ c 正解  
言わずもがな。  

■ d 正解  
dとeは制約の話だが、正直自信がなかった。  
問題文に思いっきりPRIMARY,FOREIGNって書いてあるから助かったけど、これが無かったら危なかっただろう。  

`PRIMARY KEY(年度, 受信者ID)`  
PRIMARY KEYは指定した列に主キー制約を課す文。  
主キー制約が課された列(または列の組み合わせ)は、NULL値が許されず、表の中で一意の値を持つことが強制される。  

■ e 正解  
`FOREIGN KEY(受診者ID)`  
`REFERRENCE 受診者情報表(受診者ID)`  

FOREING KEYは外部キーを指定する文。  
外部キーを指定する差異には、REFERRENCEで参照先の列を指定する。  
外部キーを設定された列は、参照先の列に存在しない値を設定できなくなる。  
また、参照先の列は、外部の表から参照されている値がある場合、その値を含む行を更新したり削除したりできなくなる。  
この表間の整合性を保つための2つの制約を合わせて**参照成約**という。  

■ f 不正解  
正解をイメージできなかった。  

`RIGHT OUTER JOIN`  
右外部結合とは、基準となる右表の行を全て抽出し、左表空は右表の行と結合できる行も身を抽出する結合方法。  
対応する左表の行が存在しない場合にはNULLで埋められる。  

``` txt : JOINした時の状態
170以上180未満 170.0 180.0 177.5
               170.0 180.0 178.8
180以上190未満 180.0 190.0 180.1
190以上        190.0 999.9 NULL
```

BETWEEN 階級下限 AND 階級上限 の結果はこういう風になるわけか。  
同じレコードで身長が違うレコードがただ並ぶだけ。  
RIGHT JOINも主体が右である事をわかった上で考えないといけなかった。  

`COUNT(*)`を指定すると単純に全行を数えるため、NULLを含む行もカウントする。  
`COUNT(列名)`とすると、その列の値がNULL以外である行数をカウントする。  
というわけでCOUNTするなら身長列をCOUNTすればよかったという話。  

---

## ソフトウェア設計

26分 【成績】全5問中 5問 回答/4問 正解　正解率:80.0%  

前回は簡単だったので、同じ感覚で望んだら死んだ。  
DBを絡めて、順番を意識しないといけない問題は地味に難しい。  

■a 正解  

a,b,cは文脈から察することが出来たけど、最後自身がなくなった。  
結局解説を直書きする。  

解説 :  
〔aについて〕
本文中では以下の2つの事実に基づいてaが結論付けられています。
各情報は、いずれかのDBにだけ格納されている
各DBは、そのDBが提供するWebAPIと登録ツールだけからアクセスできる
これを踏まえて、本文及び表1「情報取得用WebAPIの説明」を読むと、各情報が格納されるDBが判断できます。
認証情報
「アクセスIDは，認証情報として認証DBに格納され」という記述から認証DBに格納されるとわかります。
利用者情報
図1を見ると、利用者情報登録ツールから認証サーバに登録するフローになっています。よって、利用者情報は認証DBに格納されるとわかります。
申込者情報
図1を見ると、申込者情報登録ツールから申込情報管理サーバに登録するフローになっています。よって、申込者情報は申込DBに格納されるとわかります。
また表1のWebAPIの説明を見ると、申込情報管理サーバには、申込者IDを用いて申込者情報を取得するAPIが提供されています。申込者IDは申込者情報の主キーですので、この点からも申込者情報は申込DBに格納されているとわかります。
検査農作物情報
WebAPIの説明を見ると、申込情報管理サーバには、検査農産物IDを用いて検査農産物情報を取得するAPIが提供されています。検査農産物IDは検査農産物情報の主キーですので、検査農産物情報は申込DBに格納されているとわかります。
検査検査情報
WebAPIの説明を見ると、検査結果管理サーバには、検査IDを用いて検査結果情報を取得するAPIが提供されています。検査IDは検査結果情報の主キーですので、検査結果情報は検査結果DBに格納されているとわかります。
∴a＝カ：申込者情報及び検査農作物情報

■b 正解  

〔bについて〕
検査システムに登録された検査結果は、最終的に申込者に報告されます。図2の各情報には、申込を受け付けた検査農作物と申込者を紐づける情報がないため、bには申込者IDが入ります。
∴b＝オ：申込者ID

■c 正解  
〔cについて〕
検査結果管理サーバのWebAPIの説明を見ると、検査農産物IDを用いて指定した農産物の全ての検査結果情報を取得する"getResultInfoForProduct"が提供されています。検査管理情報を検査農作物ごとのレコードに絞るには、検査IDに検査農作物を紐づける情報が必要です。よってcには検査農産物IDが入ります。

∴c＝エ：検査農作物ID

■d 不正解  
認証APIは除外して考えたつもりだったけど、何を考えて4つとしたんだっけ？  
しかも、よく見てみるとデータベースのフィールド名と一致している。  
問題文をよく読むのもそうだけど、よく観察する事も大切だなと思いました。  

あー、getResultInfoForProductまではよかったけど、結果一覧から更に何かを検索しようとした結果だろうか。  
解説を読めば3つ以外内容に見えるのだが・・・。  
次からごちゃごちゃしゃべりながらやってみるか？  

解説 :  
報告アプリケーションへのログイン後、1件の検査農産物IDから画面の情報を得る手順は以下のようになります（※1は2,3の後でもOK）。
検査結果管理サーバの"getResultInfoForProduct"に検査農産物IDを指定して、その農産物に関連付けられている全ての検査結果情報を取得する。
申込情報管理サーバの"getProductInfo"に検査農産物IDを指定して、その検査農産物の検査農産物名・申込者IDを取得する。
申込情報管理サーバの"getOffererInfo"に、2.で取得した申込者IDを指定して、申込者の団体名・住所・電話番号を取得する。
よって、画面の表示が完了するまでには最低3回のWebAPIの実行が必要です。

■e 正解  
これは案外わかった。  
検査結果情報から逆算して考えられる構成になっていたので、最初に結果を10件取得して、それぞれのレコードの検査農産物とその農産物を依頼した申込者情報という風にたどっていけばいいだろうと考えたらその通りだった。

--

## アルゴリズム

--

## Java

30分 【成績】全6問中 6問 回答/4問 正解　正解率:66.7%  

厳しいねぇ。普通に難しかった。  
言っていることはわかるが、プログラムに落とし込むには時間が足りない。  
結構当てずっぽうなところもあるので、本当に理解して解けたわけではない。  
というか、ここまで出来ないことがわかると、精神的に来るな。  
でも、解説を読んだ後だと、1問は仕方がないとしても、もう1問は救えただろうから、実質5問正解で80％は取れたことになるな。  
方向性も間違っては無くて、ただ焦っただけだったので、もっと訓練を積んでいけば何とかなるかな。  

■a 正解  

■b正解  
先にbの解説。  
そのメソッドがどこから呼ばれているのかを確認するところから。  

aとbは何とか求めることが出来た感じ。  
それでもロジックを落ち着いて紐解く事は出来ず、かなり焦りながら「こうだろうな」ってやったらいけた。  
やっぱり座標系の計算は焦るな。  

■c 正解  
これは少しプログラムを見ればそうとしか思えなかったので、特に見ていない。  
明らかに次の座標を判定しているので、現在位置と次の方角を足し合わせないと意味がない。  

■d 不正解  
rightの動作をトレースして求めるべきだった。  
ろくに調べもせずに当てずっぽうでやったのはこの問題だった。  
解説を読むと、確かに「ア」か「ウ」であるのは確かだったが、「ウ」をトレースすると、誤りであることがわかるので必然的に「ア」になる模様。  

NOATH(enum型の0番目) → EAST(enum型の1番目)
EAST(enum型の1番目) → SOUTH(enum型の2番目)
SOUTH(enum型の2番目) → WEST(enum型の3番目)
WEST(enum型の3番目) → NOATH(enum型の0番目)
すなわち、列挙定数の定義順を示す ordinal() に1を足した値を values として返してあげれば、右の方角を返すためのメソッドとしての役割を果たすことができることになります（4番目の次は0番目になるため、4で割って余りを求めている）。

次に left メソッドによって列挙型の定義順がどうなっていくかを考えます。left メソッドは現在の方角の左の方角を返すので、以下のように遷移します。
NOATH(enum型の0番目) → WEST(enum型の3番目)
WEST(enum型の3番目) → SOUTH(enum型の2番目)
SOUTH(enum型の2番目) → EAST(enum型の1番目)
EAST(enum型の3番目) → NOATH(enum型の0番目)
選択肢を見ると、上記の定義通りの結果を返す「ア」か「ウ」に絞られることがわかります。しかし left メソッドによって
NOATH(enum型の0番目) → WEST(enum型の3番目)
と遷移する場合を考えてみてください。ordinal() の値が0だと、「ウ」の (ordinal() - 1) % 4 という計算結果は-1になってしまいます。Javaのenum型はList型と同様、インデックスに負数は許されておりません。よって、dには「(ordinal() + 3) % 4」が入ります。

■e 正解 
eとfは完璧にイメージ出来なかった。  

[e]はプログラムの意味を考えることなく解くことができます。  
for文内部の1行目にある history.get(i - 1) に注目してみてください。[e]ではforループの初期値を定義することになりますが、「ア」の-1、「イ」の0だと get の引数が負数となりエラーが発生してしまいます。よって、エラーにならない「1」が正解となります。  
→  
あれま～・・・  
そういうのありか・・・
うんうん悩んでいた俺がバカみたいだったな。  

■f 不正解  
これが一番わからなかった。  
全然イメージ出来なかった。具体的にいうと、historyって何が入ってくるのか。leftleftで何したいの？要素を消して何の意味があるのってつまり全般的にわからなかったわけだな。  
解説をそのまま乗せる。  

`if (history.get(i - 1) == history.get(i).left().left())`
history の要素には方角を表すenum型の direction が入り、left メソッドは左の方角を返す関数であることから、上記のif文ではあるインデックスの位置の要素に対して、次のインデックスの位置の要素が正反対の方角であるかどうかを確認する条件分岐であることがわかります。

仮に i に3が入るとして、
history.get(2)の値がNOATH
history.get(3)の値がSOUTH
だったときのことを考えてみましょう。このとき、SOUTH に2回の left メソッドを実行すれば NORTH になるのでif文は真となります。

設問2の問題文の「リストの方角の順に1升ずつ進むと，直前の升に戻る(正反対の方角に向きを変えて進む)ことなく，ゴール地点に至る」という表現があります。**北に進んで南に進む等は直前の升に戻るだけで無駄ですから取り除いてしまおうというわけです。**  
→あぁ・・・。  

上記の例では history の2番目の要素と history の3番目の要素の2つを削除することが必要となってきます。i=3として場合の各選択肢の動作は次の通りです（List型の最初の要素を0番目とします）。
ア
historyの3番目の要素を削除
↓
historyの4番目の要素が、3番目に移動する
↓
historyの3番目の要素を削除

結果としてhistoryの3、4番目を削除することになるので不適切です。

イ
historyの4番目の要素を削除
↓
historyの5番目の要素が、4番目に移動する
↓
historyの4番目の要素を削除

結果としてhistoryの4、5番目を削除することになるので不適切です。

ウ
historyの2番目の要素を削除
↓
historyの3番目の要素が、2番目に移動する
↓
historyの3番目の要素を削除

結果としてhistoryの2、3番目を削除することになるので適切な処理です。

なるほどねー。意味が分かれば確かにそうだとしか思えないけど、そこにたどり着くまでの洞察力というか、そういうのが必要だなって思った。  
後、根本的な勘違いをしてた。  
問題文で渡されたリストに対してこのロジックを当てて考えてたけど、これはあくまで最短距離の場合を示したものであって、
こういう風に直せば最短で行けるから、それを求めるロジックを考えろって事だったわけか。  
これも、時間のない焦りで問題文をうまく読めない事から始まったあれだろうな。  
応用の時と何も変わってないな。  
