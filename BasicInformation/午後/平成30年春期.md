# 平成30年春季

■ a 不正解  
■ b 不正解  
■ c 不正解  
■ d 不正解  
■ e 不正解  
■ f 不正解  
■ g 不正解  
■ h 不正解  

うーん。この年の問題は油断しすぎたor深く考えすぎたって感じかなぁ。  
前半2つはいいとして、問題は後半2つだ。  
SQL系はなんとなくやって来たツケが回ってきた感じ。  
主にNULLを含めた動作を再確認する必要があると思った。  
ネットワークに関しては計算問題が出たら諦める方向でいいかなって思った。  
単純な計算問題何だろうけど、何と何を比較すればいいか全然検討がつかなかった。  

ORDER BY 句で昇順にすると、いつもNULLが後ろにくるのが嫌！  
降順にすると、いつもNULLが先頭にくるのが嫌！  
SQL の ORDER BY において、NULL 値は一番大きな値として扱われてしまうので、昇順の場合の表示順はいつも最後になってしまいます。  
なるほどね。  

COUNTではカウントされないし、ORDER BYでは常に最大値として認識される。  
各命令文に置けるNULLの動作をまとめる必要があるな。  
ここは明日やろう。  
少し頭を冷やして復習することにする。  

Javaとアルゴリズムは成績がよかったので、多分受かったと思うが、全然うれしくないので、この機会に確認する。  

絵があるなら絵を見ながら、プログラムがあればプログラムを見ながら解読する事をおすすめする。  
日本語ベースでイメージを膨らませていくよりも、絵を見て照合しながらやったほうが理解が早い。  

今回の午後問題は、問題文を読む作業は特に苦痛ではなかった。  
最初の時よりも、スムーズに読めるようになったので、完全に慣れの問題だと思われる。  

---

## セキュリティー

12分 【成績】全5問中 5問 回答/4問 正解　正解率:80.0%  

話は全部わかったのだが、最後の問題の答えがどちらも有り得そうで間違えてしまった。  
ストレッチングという単語の意味を知っていれば問題はなかったのかもしれないので、新しく覚えることにする。  

**ストレッチング**  
元データに対してハッシュ化の計算を数千回から数万回繰り返して、その結果をパスワードファイル等に記録しておく手法です。  
ハッシュ関数には一方向性がありますから、あるハッシュ値が示すパスワードを特定するためには、攻撃者側でも1つのパスワード候補に対して同じ数だけのハッシュ化操作を行わなくてはならなくなります。  

オフライン攻撃では、単位時間当たりに膨大な数の試行を行えます。ストレッチングなしの場合には、1つのパスワード候補に対して行われるハッシュ計算は1回なので短時間でパスワードを特定されてしまう恐れがあります。ストレッチングの実施により、1つのパスワード候補の検証に要する計算量を多くすることで、攻撃が成立するまでにかかる時間を長くすることができます。  

∴エ：一つのパスワードの候補からハッシュ値を求める時間が増加する

比較回数も増えるがそれ以上に時間がかかることが、この手法のメインと言ったところか。  

---

## ネットワーク

29分 【成績】全5問中 5問 回答/3問 正解　正解率:60.0%  

ネットワークを諦める口実が出来たかもしれない。  
どちらかというと計算問題だったな。  
ネットワークの効率と処理量から簡単に計算問題に持っていけるので、その手の問題が出たら切り捨てたほうがいいかも。  

レプリケーションサーバー  
レプリケーションの意味は複製。  
主にデータベースで使われる言葉で、オリジナルDBにも記録しつつ、レプリカDBにも同じ内容を記録する。  
こうやって複製を作ることをレプリケーションという。  
それを踏まえて考えれば、レプリケーションサーバーは何かしらの複製ってことになるな。  

■ a 不正解  
■ b 不正解  
■ c 不正解  

---

## データベース

11分 【成績】全4問中 4問 回答/2問 正解　正解率:50.0%  

やべぇ。簡単だと思ってなめてたら結構落とし穴があった。  
簡単だと思って油断してかかったらこの様だ。割とショック。

CはCount(*)かSUMで迷った。  
ということは、SQLの仕様を理解していないということなので、重点的な復習が必要。  

■ c 不正解  
SUM()は合計値を求める集計関数です。"イベント番号"の値の合計が表示されるので誤りです。  
→  
単純な事だった・・・。  
そうだよな。SUMが件数のフィールドだったらまだしも、数値列にそんなことしたら数値の合計が取得されるよな。  

COUNT(*)は行数を数えてくれる。  
だがそれだけではないだろう。解説サイトを探そう。  
[COUNT(*)　が何を意味しているのかわからない](https://ja.stackoverflow.com/questions/42915/count-%E3%81%8C%E4%BD%95%E3%82%92%E6%84%8F%E5%91%B3%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84)  

``` txt
OracleではCOUNT(*)とCOUNT(age)の結果は異なります。
ageにnullが入っているとCOUNT(age)では件数にカウントされません。
グループ化していても同様で、ageがnullのグループのみ0件となります。
COUNT(*)ではageにnullが入っていてもレコードの件数をカウントします。

COUNT(*)ではレコードの内容を取得するため、COUNT('X')やSUM(1)を使った方が高速化できると教わったことがあります。(10年ほど前に聞いたノウハウなので現在も適用されるのかは不明ですが…)
```

なるほど。COUNTはNULLはカウントしないのね。  
動作的にCOUNT(name)見たいにフィールド名を指定したほうが高速化できるっぽいけど、単純にレコード数を取得したいならCOUNT(*)でいいのか。  

■ d 不正解  
ポカミス。
流れを見れば普通にわかる問題だった。  
7って数字が見えて、嬉々として飛びついてしまったわけだ。  
こういうところが自分にはあるので、いやまてよ？って習慣を作らないといけない。  

---

## ソフトウェア設計

29分 【成績】全5問中 5問 回答/2問 正解　正解率:40.0%  

この年、俺落ちたかもな。  
ショックが確定的になった。  

問題文中に穴埋め系の問題が無ければ、全部の問題文を把握して回答するパターンになる。  
俺はこれを怠ったので、その時点までの状況で回答してしまった。  
確かによくよく見てみれば、その通りの事しか書いていない。  

ORDER BY の下りがわからなかった。  
社員コードはいいとして、nullを含んだ場合の昇順、降順がどうなるのかまとめる必要がある。  

---

## アルゴリズム

16分 【成績】全5問中 5問 回答/4問 正解　正解率:80.0%  

ヒープソートの問題だったので、難なく行けた。  
やっぱり前提を知っているだけでかなり違う。  

間違った問題は、大小関係の虫食い問題で、間違っていないと思っていたはずなのだが、どうにも少し違ったらしい。  
それだけ復習してアルゴリズムは終わりだ。  
あー・・・プログラムが「以上」の不等号記号使ってるから以上って答えればいいだけだった。  
感覚的には同じ値だったら右も左も関係ないから、大きいで十分だと思っていたのだが・・・。  
まぁ、やっぱり簡単だと思ってかかると、こういう小さい点を見逃してしまうということですね。  

---

## Java

30分 【成績】全7問中 7問 回答/7問 正解　正解率:100.0%  

思わずガッツポーズしたが、自信を持って答えることが出来ない箇所があったのでしっかり復習する。  

### import static 命令

クラスのメンバーをクラス名を指定せずに呼び出せるようになる。  

``` Java
// Mathクラスの全てのメンバ指定
import static java.lang.Math.*;
public class Sample{
    public static void main(String[] args) {
        // 普通Math.absって呼び出すけどそうする必要がない。
        System.println(abs(-10));
    }
}
```

### toStringが実行されるタイミングは？

``` txt
図1「メソッドmainの出力結果」の通り、"(2 + 5)"と表示するコードです。
Addition クラスの toString メソッドが正解なので add.toString() としたいですが、選択肢にはありません。
Javaの言語仕様上、System.out.println() の引数にオブジェクトを渡すと、内部ではそのオブジェクトの toString() メソッドが呼び出されます。
このため、add オブジェクトのみでも同様の動作となり、整形式が出力されます。よって、解答は「ア」です。
```

Javaの言語仕様上、System.out.println() の引数にオブジェクトを渡すと、内部ではそのオブジェクトの toString() メソッドが呼び出されます。  
なるほどね。まぁ、選択肢をヒントにして考えてみても、そういう動作してくれないと答えにならないからね。  
実行されるタイミングというよりも、何が実行するのかってのが適切かな。  

### ==とEqualsの比較の違いは？

オブジェクトの同一性、同値性に関する設問です。  

**同一性**  
同じオブジェクトを参照していることです。「==」で比較します。  

**同値性**  
オブジェクトの値が等しいことです。比較する値は各クラスによって独自に実装します。  
全てのクラスの親であるObjectクラスが実装しているequalsメソッドでのチェックは同一性チェック。  

問題文に「二つのインスタンスを表す値が等しいので true になるべきだが、今のクラス Constant の実装では false になる」という記述があります。  
「値」なので同値性チェックとなる。  
同値性チェックで true にしたい場合、Javaでは equals() メソッドをオーバーライドします。  
equals() メソッドは、java.lang.Object クラスに実装されており、全てのクラスは Object クラスのサブクラスです。  
よって、オーバーライドしない場合、Object クラスの equals() メソッドが呼ばれます。  
そして、Objectクラスのequalsメソッドでのチェックは同一性チェックです。  

new Constant(9) == new Constant(9)
同一性チェックのため問題文に合いません。

new Constant(9).equals(new Constant(9))
正しい。

new Constant(9).evaluate() == new Constant(9).evaluate()
同一性チェックのため問題文に合いません。

new Constant(9).evaluate().equals(new Constant(9).evaluate())
コンパイルエラーです。evaluate() メソッドの戻り値はプリミティブ型(int型)です。

``` Java : Constantクラスにequalsメソッドを実装する場合の例
@Override
public boolean equals(Object obj) {
　　if (obj instanceof Constant) {
　　　　return this.evaluate() == ((Constant)obj).evaluate();
　　} else {
　　　　return false;
　　}
}
```
