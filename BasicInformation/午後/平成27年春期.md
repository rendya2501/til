# 平成27年春期

■ a 不正解  
■ b 不正解  
■ c 不正解  
■ d 不正解  
■ e 不正解  
■ f 不正解  
■ g 不正解  
■ h 不正解  

---

## セキュリティー

11分 【成績】全5問中 4問 回答/4問 正解　正解率:100.0%  

特にいうことなし。  
最初の問題だけ少し迷ったが、よく読めば答えが書いてあったので問題なし。  

---

## データベース

10分 【成績】全5問中 5問 回答/3問 正解　正解率:60.0%  

途中で便意が来たこともあり、もう少し吟味したがったが仕方なし。  
10分で解いたけど、所々怪しいままで解いたらこのざまである。  
とくにCOUNT(DISTINCT)は全く知らなかったのでまとめたい。  
因みに、最初の問題は正規形に関する問題だったのだが、当日(2021/10/09 Sat)に正規形についてまとめた後だったので、よくわかった。  

■2 不正解  
世帯番号が欲しいのに、会員番号もGROUP BYに含めたら意味ないでしょ。
なんでこれを選んでしまったのか。  
いくら目の疲れがいつもより和らいだといっても、頭がこんな状態では勉強の意味がないのでは。  
COUNT知らなかったのは仕方がないとしてもこれは普通に正解だったな。  
惜しいことをした。  

■3 不正解  
COUNT(DISTINCT テーブル.フィールド名),COUNT(*)  
最近COUNT(*)はレコード数ってのは学習したが、COUNTの中にDISTINCT書けるのは知らなかった。  

まず俺が間違えた奴。
COUNT(*),COUNT(会員表.会員番号)は同じ値になるので意味がないそうだ。  
フィールド名をCOUNTとした場合の動作って何なんだろう。  

[【SQL】COUNT(*)とCOUNT(カラム名)の違い](https://qiita.com/TomoProg/items/5ba5779b3015ac02f577)  
すげードンピシャな記事があった。  
正直会社では恥ずかしくて聞けない内容だな。  

・COUNT(*)はNULL値かどうかに関係なく、取得された行の数を返す  
・COUNT(カラム名)はNULL値でない値の行数を返す  

``` txt
+----+--------+-------+
| id | name   | price |
+----+--------+-------+
|  1 | apple  |   100 |
|  2 | banana |   120 |
|  3 | grape  |   140 |
|  4 | melon  |  NULL |
|  5 | kiwi   |   120 |
+----+--------+-------+
```

select count(*) from shohin; → 5  
select count(price) from shohin; → 4  

以下解説  
COUNT(\*)はグループ内のレコード数を取得する集計関数なので、上記のグループ化された表に対してCOUNT(*)を指定することで班ごとの会員数を表示することができます。
また班ごとの世帯数は、班ごとにグループされた中に何種類の世帯番号が存在するかを調べればよいので、COUNT(世帯表.世帯番号)にDISTINCTを指定し、COUNT(DISTINCT 世帯表.世帯番号)とすることで重複行をカウントしないようにします。  

[SQL | COUNT(DISTINCT column_name) は「同じ値の種類数」をカウントする](https://qiita.com/YumaInaura/items/1a1123ed4f33d30d9548)  
初歩だって。トホホ・・・。  
[COUNT句内でDISTINCTを使う／重複を排除したカウント](https://nyoe3.hatenadiary.org/entry/20100313/1268468670)  

つまり、重複行を除いたカウントをしたい場合に有効な構文というわけだ。  
そうなると次はDISTINCTとはどこまで含めることができるのか気になってきたぞ。  

``` txt
+-------+--------+-------+
| name  | sex    | score |
+-------+--------+-------+
| Alice | female |    60 |
| Bob   | male   |    70 |
| Carol | female |    70 |
| David | male   |    80 |
| Eric  | male   |    80 |
+-------+--------+-------+
```

sex には male / famale の二種類がある。  
SELECT COUNT(DISTINCT(sex)) AS sex_kind FROM scores; → 2  

score には 60点 / 70点 / 80点の三種類がある。  
SELECT COUNT(DISTINCT(score)) AS score_kind FROM scores; → 3  

---

## ソフトウェア設計

21分 【成績】全6問中 6問 回答/5問 正解　正解率:83.3%  

全部いけたと思ったのだが、やはり詰めが甘かったか・・・。  
今回の問題は、仕様書をよく読めば、答えが書いてあるタイプの問題なので特にまとめることがない。  
ER図も基本的なことばかりだし、間違った問題に関しても文中にそう書いてあるからとしか言えないし、ミスリードしてしまっただけである。  

---

## アルゴリズム

30分オーバー 【成績】全6問中 6問 回答/5問 正解　正解率:83.3%  

間にトレイを挟んでしまったけど、体感的には40分位かかってしまっただろうか。  
もっと丁寧にわかりやすくトレース記録を残しておけば苦労しなかっただろうなと思う。  
ちょっとトレースの仕方が雑過ぎた。  
内容はクイックソートの問題だったのだが、知識はあってもトレースは必要だったので時間がかかってしまった。  
8割正解したけど、トレースが雑過ぎて時間がかかってしまったので、個人的にはあまりうれしくない。  
こんなんじゃダメだって気持ちのほうが強い。  
しかも、よく見るとトレースの仕方間違ってたな。  
よく見てみると、ループ処理の順番が違う。  
はぁ・・・。気が重くなるぜ。  

1問目に関しては、トレースというより状況から察することが出来た。  
こういう問題ってどうしてもトレースに依存してしまって全体が見えないことがあるので、その意味では気が付けてよかったと思う。  
というか、クイックソート自体、ピボットとなった値が適切な一にソートされるソート法なので、  
ピボットになった時には既に場所は決まっているようなものだ。  

配列のトレースの仕方を考えなおしたほうがいい。  
数列の中にx[i]やx[j]をおいて、変数のほうを動かして考えたほうがいいのかも。  

---

## Java

19分 【成績】全6問中 6問 回答/5問 正解　正解率:83.3%  

Javaは30分かかる場合と一瞬で終わる場合がある。  
今回は一瞬で終わるほうだった。  
トレースではなく、日本語とプログラムをマッチさせるだけのほうが個人的には楽でよい。  

最後の問題はミスリードしてしまった。`<script>`と`</script>`の間は除くって意味は,  
`<script>alert('注意!');</script>`を全部をやらないのでは無く、`<script>`と`</script>`はやらなくて、`alert('注意!');`はやるって意味らしい。  
日本語って難しいね。  
あぁ。よく読めば確かにそうだ。  
`<script>`自体がタグなのだ。  
だからこのタグの間はやるってのはそのまんまだ。  
選択肢に0を用意したのは俺のような間抜けをおびき出すための罠だったんだ。  
クソ。意地汚いことしてくれる。  

``` txt
サニタイズが必要な場面は2つあり、1つ目がHTMLタグの間（scriptタグの間は除く）、2つ目がJavaScriptの文字列、すなわちscriptタグ内部です。
2つ目のケースがscriptタグ内の文字列を指しているので、1つ目のHTMLタグから除外しているのだと思います。
設問2のプログラムは、HTMLタグ用のHtmlEncoderを使っているため、1つ目の変換規則に基づいてサニタイズされることとなります。
HTMLタグ内にscriptタグを含む文字列を表示する場合に、正しくサニタイズされるかどうかをテストしていると考えると良いでしょう。
```

``` txt
クラス HtmlEncoder の内部でメソッド encode が呼ばれるのは、convertionTable.get(c) の結果がnull、
すなわち convertionTable に登録されていない文字に遭遇した場合です。
クラス HtmlEncoder で登録対象となっているのは以下の文字です。
英数字 0-9a-zA-Z
記号 !#$%()*＋,－.:;=?@[\]^_`{|}~
<>&"
したがって〔プログラム4〕でサニタイズの対象となっている文字列のうち、上記に含まれない以下の5文字についてメソッド encode が呼ばれることになります。
よって、呼び出される回数は5回です。
```

あれ？  
スクリプトはやらないと言っておきながら、タグの〆の\マークは対称になっているな・・・。  
うーん・・・。結局全部やるって事でいいんじゃないかこれ。  
どちらにせよ、登録されている文字との比較では絶対に5文字判定されることになるんだからやっておけばよかったってわけだ。  

どうでもいいけど、C#でabstractを実装したクラスと親クラスとの動作がわからなかったけど、このJavaの問題でそれが解決したのでまとめておこう。

``` java
abstract public class Encoder{
    // 実装強制。HtmlEncoderクラスに実装されるメソッド。
    abstract protected String encode(char c);
    // 1.テストクラスから呼び出されるencodeメソッド
    public String encode(String s) {
        String result = "";
        for (char c : s.toCharArray()){
            String t = conversionTable.get(c);
            // 2.文字列を1文字ずつ読みこんだ時に、登録された文字では無かったら、abstractを実装したクラスのencodeメソッドを実行する。
            if (t == null) {
                // 3.ここで呼び出すのが、HtmlEncoderのencodeメソッド
                t = encode(c);
            }
            result += t;
        }
        return result;
    }
}

public class HtmlEncoder extends Encoder {
    // 3.というわけで色々やってHtmlEncoderのencodeメソッドが呼び出されるわけである。
    protected String encode(char c){
        // ごにょごにょ
    }
}

public class HtmlEncoderTest {
    static public void main(String[] args){
        // 1.この時呼ばれるencodeメソッドはEncoderクラスのencodeメソッド。その証拠にstring型だ。
        // HtmlEncoderクラスのencodeメソッドを呼び出しているように見えるけど、引数の関係で親クラスのメソッドを呼び出している状態である。
        // C#のAPI側の保存メソッドの時も、こういうからくりで動いているのだろう。
        // abstract側で定義されたメソッドから、各インスタンスのメソッドを呼び出していたわけだ。
        // 引数の型の違いによるオーバーロードはC#では出来ないと思ってたけど、普通に出来たしJavaでもできることを確認した.
        new HtmlEncoder().encode("<script>alert('注意');</script>");
    }
}
```

charとは？→Javaの中でまとめる。
int(char)のキャストはその文字コードに変換するという意味らしい。→これも詳しくはJavaで。
Javaのプログラム写経してみたけど、stringってS大文字じゃないと認識してくれないんだな。
