# データベース


---

## データ操作

**射影(しゃえい)**
表の中から特定の列だけを取り出す。
関係データベースを操作する関係演算の1つで、表から条件に合致する列を取り出す演算です。

**選択**
表から指定された行を抽出する操作

**商**
表Rのうち表Sの全ての項目を含む行の集合を返す演算


**ソートマージ結合法**
双方の結合属性の値を整列し、先頭から突き合わせていくことで効率的に結合していく手法です。
整列(ソート)と突合せ処理で併合(マージ)していくというのポイントです。

**入れ子ループ法(ネストループ法)**
一方の表の結合する列の値を順に読み出し，もう一方の表の結合する列と結合する。

**埋込みSQL**
VB6のカーソル処理が埋め込みSQLと呼ばれる手法らしい。
CやCOBOL、Pascalのような表データを直接扱えない手続き型プログラミングに、関係データベースを操作するためのSQLを埋め込むための手法です。
埋込みSQLでは、問合せによって得られた導出表を1行ずつ親プログラムに引き渡しながら処理をしていきますが、この操作において結果表内のある1行を参照する仕組みをカーソルといいます。
親プログラム内では、カーソルから値を取り出したり、カーソルに対して更新または削除処理を行ったりします。

設問のSQLにおいては、Xがカーソルに当たります。カーソル操作の流れは以下の通りです。
DECLARE CURSOR文でカーソルを定義する。
OPEN文でカーソルを開く。
1行ずつ目的の処理を行う。
CLOSE文でカーソルを閉じる。

``` C
EXEC SQL OPEN X; // カーソルを開く
//ごにょごにょ
EXEC SQL CLOSE X; // カーソル閉じる
```


平成28年秋期　問29
"社員"表と"部門"表に対し，次のSQL文を実行したときの結果はどれか。
結果より、FROMに2つのフィールドを指定してWHEREで結合した場合のSQLはINNER JOINを使った場合と同じということが重要。

``` SQL
SELECT COUNT(*) 
FROM 社員、部門
WHERE 社員.所属 = 部門.部門名 
AND 部門.フロア = 2

SELECT COUNT(*)
FROM 社員
JOIN 部門
ON 社員.所属 = 部門.部門名
WHERE 部門.フロア = 2
```


---

## トランザクション処理

**デッドロック**
共有資源を使用する2つ以上のトランザクションが、互いに相手トランザクションが必要とする資源を排他的に使用していて、
互いのトランザクションが相手が使用している資源の解放を待っている状態です。
デッドロックが発生するとトランザクションは永遠に待ち状態になってしまうため、処理の続行ができなくなってしまいます。
一般的に双方のトランザクションで資源の専有順序が同じ場合にはデッドロックが発生しないことが知られています。

**共有ロック**
データを読込むときに使うロックで、この状態の場合は他のトランザクションによる更新処理ができなくなる(読込みは可能)。

**専有ロック**
データを更新するときに使うロックで、この状態の場合は他のトランザクションによる読込みや更新ができなくなる。
専有がかかった地点でトランザクションは取れない。
唯一共有中に共有を掛ける事はできる。

　　専有　共有
専有　×　　×
共有　×　　○

**2相ロッキングプロトコル**
トランザクション処理で読書きが必要になったデータにその都度ロックをかけていき、**全てのロックを獲得した後にだけロックの解除を行うルールを課すロック方式**です。
つまり、ロックの解除が行われるのはトランザクションの終了時になります。
各処理が終わる度に当該ロックを解除するわけではないので注意しましょう。

**ロックの粒度**
ロックは、表、ブロック、行といった単位で掛けられる。
この単位をロックの粒度という。

粒度小さい
・資源の競合やロック解除の待ち時間が少なくなり、トランザクションの並行実行度(スループット)が高まる。
・ロック制御のためのオーバーヘッド(管理が煩雑になるのでCPUの負荷)が増大する。

粒度大きい
・トランザクション管理が容易になる。
・他のトランザクションのロック解除待ちが長くなり、並行実行度(スループット)が低下する。

設問では表単位のロックと行単位のロックを比較しているので、ロックの競合が起こりやすいのは、より広い範囲をロックする表単位です。

メモリ使用領域は、同時に実行されるトランザクションが増えるほど多く必要になります。
その理由は、1つのトランザクションを実行するときよりも、複数のトランザクションを並列に実行したときの方が、同時に管理するロックの絶対数が増えるからです。
つまりメモリ使用領域が多く必要になるのは、トランザクションの同時実行数が多い行単位です。



**ロールバック**
トランザクションの途中、プログラムのバグなどでアプリケーションから の応答がなくなったり強制終了した場合に、
更新前ジャーナル(ログ)を用いてデータベースをトランザクション開始直前の状態に戻す処理です。

**ロールフォワード(前進復帰)**
データベースシステムに障害が起こったときに、更新後ログを用いて今まで処理したトランザクションを再現し、
システム障害直前までデータベース情報を復帰させることをいいます。
チェックポイントを跨いだ場合はこれ。チェックポイントまで復元できる。


**ACID特性**
データベースのトランザクション処理を行う上で必要不可欠とされる４つの性質(Atomicity・Consistency・Isolation・Durability)の頭文字を並べた言葉です。
ACID特性は、DBMSがもつトランザクションログの記録、ロールバックとロールフォワード、ロックなどを組み合わせて実現されています。

**Atomicity ： 原子性**
トランザクション内の処理がすべて実行されるか、または全く実行されないことを保証する性質。
**Consistency ： 一貫性**
トランザクションによりデータの矛盾が生じないこと。常にデータベースの整合性が保たれていることを保証する性質。
**Isolation ： 独立性**
複数のトランザクションを同時に実行した場合と、順番に実行した場合の結果が等しくなることを保証する性質。一般にロックなどをかけることで直列可能性を保証する。
隔離性と呼ばれる場合もある。
**Durability ： 永続性**
一旦正常終了したトランザクションの結果は、以後システムに障害が発生しても失われないことを保証する性質。
耐久性と呼ばれる場合もある。


**再編成**
データベースの処理効率は、レコードの追加や削除の繰り返しによるガーベジの増加や、同じレコードが非連続の場所に格納されることによって徐々に低下していきます。
このような状態を改善するために定期的に行われる処理が再編成。
低下した処理効率を回復させることができます。
ハードディスクのデフラグのDB版。

**データベースダンプ**
データベースの内容をファイルに書き出して保存することです。

**排他制御**
複数のトランザクション処理プログラムが同一データベースを同時に更新する場合，論理的な矛盾を生じさせないために用いる技法。
トランザクションの整合性を保つために、1つのタスクがデータ更新のトランザクションを実行している間は、
その処理が終わるまで同じデータに対する他のトランザクション要求を待機させる仕組みです。
複数のトランザクションが同じデータを更新しようとしたときに、データを「ロック」することで同時更新による更新消失を防ぎます。


**インデックス**
データベースに格納されているデータの取出しや並べ替えを高速で行うための仕組みです。
インデックスには幾つかの種類がありますが、設問に登場する「B+木インデックス」と「ハッシュインデックス」は次のような特徴を持っています。

**B+木インデックス**
キーを指定することで挿入・検索・削除が効率的に行える木構造の一種で、木構造のインデックスツリー（索引木）により検索を高速化するアルゴリズムです。
RDBMSで最も一般的に使用されている。
節ごとにキー値の範囲とその子要素へのポインタを保持しているので範囲検索をスムーズに行えるほか、次のような性質があります。
・木構造の深さが一定になっているので、どのようなキー値であっても探索コストが大きく変わらない 計算量 $logX$
・大量のデータに対する操作であっても、ある程度の速度が期待できる
・インデックスノードはソートされた状態になっているので整列処理が高速に行える

節…木構造を図示した場合のノード部分のことを言います。
枝…各節の上下関係のことを言います。
親…上位の節のことを言います。
子…下位の節を子といいます。
根…最上位の節のことを言います。
葉…最下位の節のことを言います。

**ハッシュインデックス**
ハッシュ関数を使用してキー値とレコードの格納場所を直接関連つける方式。
格納場所をキー値から一意に検索できるので、いくつもの階層の節をたどって格納場所にアクセスするB+木インデックスより高速にアクセスが可能。
ただし範囲検索やキー値を順番に読み込んで処理を行う用途には使用できない。
また、「異なったキー値でも同一の算出結果が得られてしまう可能性がある」という性質があるので、キー値の衝突(シノニム)が起こる可能性があります。

**ビットマップインデックス**
キーの濃 (カーディナリティ，cardinality)が低い場合に適したインデックスで、それぞれのキー値ごとにビットマップ (ビットの配列) を作成し、
その各ビットはレコードがキーを含んでいるかを表します。


**インデックスによる検索まとめ**
・範囲検索はB+木インデックスが強い
・単一レコードへのアクセスはハッシュインデックスが強い


---

## データベース設計

**参照制約**
外部キーを持つ表にレコードを追加する場合に、その外部キー列の値は参照先の表の主キーとして存在するものでなければならない、
また、別表から主キーの値を参照されている行は削除することができないという制限を課す制約です。
参照制約は、関係データベースの整合性を保つために設定され、その指定には次のように"FOREIGN KEY"と"REFERENCES"が使われます。
`FOREIGN KEY 列リスト REFERENCES 親テーブル(列リスト)`

**検査制約**
CHECK句を用いて指定します。

**キー制約**
PRIMARY KEY句やFOREIGN KEY句を用いて指定します。

**外部キー制約**
関係データベースの2つのテーブルの間の参照整合性を保つための制約で、SQLでは設定する属性に対して「FOREIGN KEY句」を指定します。
正規化された表同士を外部キーで結合することでデータの一貫性・正当性を保つことができます。


**関数従属**
関係データベースにおける「関数従属」とは、「社員ID→社員名」や「保険証番号→{個人名，住所，生年月日}」などのように、
ある属性の値によって別の属性の値が一意に決まる関係をいいます。



令和元年秋期　問25
UMLを用いて表した図の概念データモデルの解釈
`部署 1..* --- 0..* 従業員`

| 多重度表記 | 意味 |
| :- | :- |
| 0..1 | 0か1 |
| 1(1..1) | 常に1 |
| \*(0..*) | 0以上 |
| 1..* | 1以上 |

部署から見た従業員は0人以上
従業員から見た部署は1以上

ということで、0人の部署が存在する。複数の部署に跨る従業員がいると見ることができる。

---

## データベース方式

**スキーマ(schema)**
データの内容，データの論理構造，記憶形式や編成などデータベースの構造を記述したものです。
これを決めるDBMSの機能は「定義機能」

**障害回復機能**
ロールバック、ロールフォワード、チェックポイント、更新前／更新後ログの記録などによってデータベースを障害から発生する機能です。

**機密保護機能**
ユーザ認証、アクセス権限、利用ログの記録、暗号化などによってデータを安全に保つ機能です。

**保全機能**
排他制御や参照制約、表制約などによってデータの完全性を保つ機能です。


**3層スキーマ構造(ANSI/SPARCモデル)**
概念スキーマ、外部スキーマ、内部スキーマ の3つのグループに分けてデータ定義を行うデータベースモデルです。
スキーマの役割は、データベースの論理的・物理的なデータ構造が変更されたときの影響をユーザやアプリケーションに与えないようにすることです。(プログラムからの独立性を保証すること)

**概念スキーマ**
データベース化対象の業務とデータの内容を論理的な構造として表現したもの。テーブルの正規化やCREATE TABLEによる表定義が概念スキーマに相当する。
**外部スキーマ**
データの利用者からの見方を表現したもの。SQLのビューが外部スキーマに相当する。
**内部スキーマ**
データを記憶装置上にどのような形式で格納するかを表現したもの。ファイル編成やインデックスの設定などが内部スキーマに相当する。



関係データベースにおいて、関係は表、属性は列(カラム)、組(タプル)は行(レコード)に対応します。
・属性につける名前は、関係内で一意でなければならない。
・必ず属性名が必要。
・属性の並びに意味はない。組の並びにも意味がない。
・定義域(ドメイン)とは属性が取り得る値の集合」の事で、つまりはデータ型と同じ意味になる。
　なので、定義域の重複は問題ない。


DBMSが提供する機能のうち，データ機密保護を実現する手段はどれか。
→
データに対するユーザーのアクセス権限を管理する。
→
「データ機密保護」ですからセキュリティを向上させるための機能ということです。
DBMSは、表やスキーマおよびビューなどに対する操作権限をユーザごとに設定できる機能をもちます。
データベースは、組織内の様々な役職・部門の人が利用しますが、データに対して権限がある者とない者を区別することで、
アクセス権をもたない者からのアクセスを遮断できます。これによりデータの機密性が確保されます。

---

## データベース応用

**キーバリューストア(KVS)**
NoSQLで用いられるデータ型の1つです。
プログラミングで使用される連想配列のように、1つのキーに1つの値を結びつけてデータを格納します。
構造が単純な分、スケーラビリティや処理速度に優れるためビッグデータの処理に使われています。

NoSQLで用いられる他の主要なデータ型についても簡単にまとめておきます。
**カラム指向**
行キーに対してカラム（名前と値の組み合わせ）を結びつけて格納する
**ドキュメント指向**
XMLやJSONなどの構造でデータを格納する
**グラフ指向**
グラフ理論に基づいてデータ間の関係性を表現する


**データディクショナリ**
データベースやシステム開発においてデータの属性・性質などデータに関する情報の定義を保存するための辞書です。

**データウェアハウス**
企業内に散らばっているデータの有効活用を目的に、過去から現在までの基幹系データベースや外部データベースを統合し、
効果的な戦略的意思決定を支援するためのデータベースのことです。

**メタデータ**
データについてのデータという意味で、データベースであればデータベース名やテーブル名、フィールド属性など本来のデータ付随する情報のことをいいます。

**データマイニング**
ビッグデータ等、大量のデータから統計学的手法などを用いて新たな知識(傾向やパターン)を見つけ出すプロセス。

---

フルバックアップ
→
毎回、全ファイルのバックアップを行う方式。復旧時間は短くなるが、バックアップに必要な容量が多い分バックアップに要する時間は長い。

差分バックアップ
→
定期的にフルバックアップを行い、フルバックアップの間の期間は、フルバックアップ以降に変更のあった全てのファイルを記録する方式。
障害発生時にはフルバックアップと直前の差分バックアップ1つを使用して復旧する。

増分バックアップ
→
定期的にフルバックアップを行い、フルバックアップの間の期間は、前回の増分バックアップ以降に変更のあったファイルだけを記録する方式。
一度にバックアップする量は少なくて済むが、回復にはフルバックアップと複数の増分バックアップが必要になるので、障害発生時の復旧時間は長くなる。

---


---

## 1回目に間違えた問題

DBMSが，3層スキーマアーキテクチャを採用する目的として，適切なものはどれか。
→
普通にわからなかったわ。
物理とか論理とかそんな感じでそもそも覚えていなかったので覚えましょう。
答えはズバリ、プログラムからの独立性を保障するためです。



データベースのアクセス効率を低下させないために，定期的に実施する処理はどれか。
→
答えは再編成。
始めて聞いた。何それまとめたい。



RDBMSが二つの表を結合する方法のうち，ソートマージ結合法に関する記述はどれか。
→
ある列をソートして、その結果についてマージする。
当たり前といえば当たり前。
答えを全部見る前にそれっぽいものを選んでしまった。
