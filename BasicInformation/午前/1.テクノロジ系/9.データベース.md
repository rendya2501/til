# データベース

---

## データ操作

**射影(しゃえい)**  
表の中から特定の列だけを取り出す。
関係データベースを操作する関係演算の1つで、表から条件に合致する列を取り出す演算です。

**選択**  
表から指定された行を抽出する操作

**商**  
表Rのうち表Sの全ての項目を含む行の集合を返す演算

**直積**  
2つの関係(表)に含まれる要素のすべての組合せから成る表を得る演算です。
`SELECT * FROM R，S`

**自然結合**  
内部結合や外部結合を行うときに、 結合条件としてそれぞれのテーブルで同じ名前のカラムを結合する場合に NATURAL を指定することで結合条件を省略することができます。
このような結合を自然結合といいます。
テーブルXとテーブルYに学部コードってあったら、そいつどうしてくっついてくれるのが自然結合ってこと。


**ソートマージ結合法**  
双方の結合属性の値を整列し、先頭から突き合わせていくことで効率的に結合していく手法です。
整列(ソート)と突合せ処理で併合(マージ)していくというのポイントです。

**入れ子ループ法(ネストループ法)**  
一方の表の結合する列の値を順に読み出し，もう一方の表の結合する列と結合する。

**埋込みSQL**  
VB6のカーソル処理が埋め込みSQLと呼ばれる手法らしい。
CやCOBOL、Pascalのような表データを直接扱えない手続き型プログラミングに、関係データベースを操作するためのSQLを埋め込むための手法です。
埋込みSQLでは、問合せによって得られた導出表を1行ずつ親プログラムに引き渡しながら処理をしていきますが、この操作において結果表内のある1行を参照する仕組みをカーソルといいます。
親プログラム内では、カーソルから値を取り出したり、カーソルに対して更新または削除処理を行ったりします。

設問のSQLにおいては、Xがカーソルに当たります。カーソル操作の流れは以下の通りです。
DECLARE CURSOR文でカーソルを定義する。
OPEN文でカーソルを開く。
1行ずつ目的の処理を行う。
CLOSE文でカーソルを閉じる。

``` C
EXEC SQL OPEN X; // カーソルを開く
//ごにょごにょ
EXEC SQL CLOSE X; // カーソル閉じる
```


**EXISTS**  
親表の行を1行ずつ処理し、続く相関副問合せによって返された結果行が1つ以上存在すれば真、1つもなければ偽を返す句です。


平成28年秋期　問29
"社員"表と"部門"表に対し，次のSQL文を実行したときの結果はどれか。
結果より、FROMに2つのフィールドを指定してWHEREで結合した場合のSQLはINNER JOINを使った場合と同じということが重要。

``` SQL
SELECT COUNT(*) 
FROM 社員、部門
WHERE 社員.所属 = 部門.部門名 
AND 部門.フロア = 2

SELECT COUNT(*)
FROM 社員
JOIN 部門
ON 社員.所属 = 部門.部門名
WHERE 部門.フロア = 2
```


---

## トランザクション処理

**トランザクション**  
口座から振込みを行う場合における送金側の残高減と振込先口座の残高増のように関連する1つ以上の処理をまとめた単位です。
トランザクションは、データの整合性を保つために「全ての処理が完了する」か「全く処理が行われなかったか」のどちらかで終了しなくてはなりません。

設問中のアクティブ、アボート、コミットには次の意味があります。
**アクティブ**  
トランザクションを処理中の状態
**アボート**  
トランザクションの途中で処理を強制的に中断してトランザクションをロールバックする処理
**コミット**  
トランザクションの一連の処理が成功した際に、その結果を確定させる処理

コミット処理中からアボート処理中に遷移することはありますが、その逆はありません。コミットは全ての処理が正常に終了したときの処理だからです。


**デッドロック**  
共有資源を使用する2つ以上のトランザクションが、互いに相手トランザクションが必要とする資源を排他的に使用していて、
互いのトランザクションが相手が使用している資源の解放を待っている状態です。
デッドロックが発生するとトランザクションは永遠に待ち状態になってしまうため、処理の続行ができなくなってしまいます。
一般的に双方のトランザクションで資源の専有順序が同じ場合にはデッドロックが発生しないことが知られています。

**共有ロック**  
データを読込むときに使うロックで、この状態の場合は他のトランザクションによる更新処理ができなくなる(読込みは可能)。

**専有ロック**  
データを更新するときに使うロックで、この状態の場合は他のトランザクションによる読込みや更新ができなくなる。
専有がかかった地点でトランザクションは取れない。
唯一共有中に共有を掛ける事はできる。

　　専有　共有
専有　×　　×
共有　×　　○

**2相ロッキングプロトコル**  
トランザクション処理で読書きが必要になったデータにその都度ロックをかけていき、**全てのロックを獲得した後にだけロックの解除を行うルールを課すロック方式**です。
つまり、ロックの解除が行われるのはトランザクションの終了時になります。
各処理が終わる度に当該ロックを解除するわけではないので注意しましょう。


**2相コミット(Two Phase Commit)**  
トランザクションのコミットを次の2つの段階に分けて行うことで、分散データベース環境でのトランザクションの原子性・一貫性を保証する仕組みです。
分散データベースシステムにおいて，一連のトランザクション処理を行う複数サイトに更新処理が確定可能かどうかを問い合わせ，すべてのサイトが確定可能である場合，更新処理を確定する方式。

第1フェーズ
他のサイトに更新可能かどうかを確認する
第2フェーズ
全サイトからの合意が得られた場合に更新を確定する
具体的には、コミットの調整を行う1つのノードを「調停者(主サイト)」、ネットワーク上の他のノードを「参加者(従サイト)」として、次の手順でコミットが行われます。

[第1相(投票層)]
1.主サイトはネットワーク上の全ての従サイトにコミットの可否を問い合わせる。
2.全ての従サイトは主サイトにコミットの可否を応答する。
[第2相(決定相)]
3.全ての従サイトからコミットの合意を得られた場合は、全ての従サイトにコミットの実行要求を発行する。コミットの停止を応答した従サイトがあった場合、またはタイムアウトとなった場合は、全ての従サイトにロールバックの実行要求を発行する。
4.全ての従サイトは、コミット(またはロールバック)の完了とともに主サイトに処理完了のメッセージを送る。
5.主サイトが、全ての従サイトからの処理完了メッセージを受け取り、トランザクションの完了となる。


**ロックの粒度**  
ロックは、表、ブロック、行といった単位で掛けられる。
この単位をロックの粒度という。

粒度小さい
・資源の競合やロック解除の待ち時間が少なくなり、トランザクションの並行実行度(スループット)が高まる。
・ロック制御のためのオーバーヘッド(管理が煩雑になるのでCPUの負荷)が増大する。

粒度大きい
・トランザクション管理が容易になる。
・他のトランザクションのロック解除待ちが長くなり、並行実行度(スループット)が低下する。

設問では表単位のロックと行単位のロックを比較しているので、ロックの競合が起こりやすいのは、より広い範囲をロックする表単位です。

メモリ使用領域は、同時に実行されるトランザクションが増えるほど多く必要になります。
その理由は、1つのトランザクションを実行するときよりも、複数のトランザクションを並列に実行したときの方が、同時に管理するロックの絶対数が増えるからです。
つまりメモリ使用領域が多く必要になるのは、トランザクションの同時実行数が多い行単位です。



**ロールバック**  
トランザクションの途中、プログラムのバグなどでアプリケーションから の応答がなくなったり強制終了した場合に、
更新前ジャーナル(ログ)を用いてデータベースをトランザクション開始直前の状態に戻す処理です。

**ロールフォワード(前進復帰)**  
データベースシステムに障害が起こったときに、更新後ログを用いて今まで処理したトランザクションを再現し、
システム障害直前までデータベース情報を復帰させることをいいます。
チェックポイントを跨いだ場合はこれ。チェックポイントまで復元できる。


**ログファイル**  
トランザクション開始前とコミット後の状態を保存したファイルで、ロールバックやロールフォワードによって障害から復旧するときに用いられます。
ジャーナルファイルとも呼ばれます。ログファイルによってデータベースの永続性が保たれています。

**ダンプファイル**  
データベース移行のときなどに用いられるデータベースの内容をそのまま書き出したファイルです。

**チェックポイントファイル**  
コミットされたトランザクションをデータベースに書き出すときに、その情報を記録したファイルです。


**トランザクション障害**  
更新前ログを使用したロールバックを行い、トランザクション開始直前の状態に戻す。

**システム障害**  
直前のチェックポイントまで戻り、コミットされたトランザクションを更新後ログを使用したロールフォワードでデータベースに反映させる。

**媒体障害**  
バックアップファイルと更新後ログを使用したロールフォワードで障害発生直前の状態に戻す。

「記憶媒体に故障が発生した」という記述から媒体障害とわかるのでロールフォワードが適切な操作となります。



**ACID特性**  
データベースのトランザクション処理を行う上で必要不可欠とされる４つの性質(Atomicity・Consistency・Isolation・Durability)の頭文字を並べた言葉です。
ACID特性は、DBMSがもつトランザクションログの記録、ロールバックとロールフォワード、ロックなどを組み合わせて実現されています。

**Atomicity ： 原子性**  
トランザクション内の処理がすべて実行されるか、または全く実行されないことを保証する性質。
**Consistency ： 一貫性**  
トランザクションによりデータの矛盾が生じないこと。常にデータベースの整合性が保たれていることを保証する性質。
**Isolation ： 独立性**  
複数のトランザクションを同時に実行した場合と、順番に実行した場合の結果が等しくなることを保証する性質。一般にロックなどをかけることで直列可能性を保証する。
隔離性と呼ばれる場合もある。
**Durability ： 永続性**  
一旦正常終了したトランザクションの結果は、以後システムに障害が発生しても失われないことを保証する性質。
耐久性と呼ばれる場合もある。


**再編成**  
データベースの処理効率は、レコードの追加や削除の繰り返しによるガーベジの増加や、同じレコードが非連続の場所に格納されることによって徐々に低下していきます。
このような状態を改善するために定期的に行われる処理が再編成。
低下した処理効率を回復させることができます。
ハードディスクのデフラグのDB版。

**データベースダンプ**  
データベースの内容をファイルに書き出して保存することです。

**排他制御**  
複数のトランザクション処理プログラムが同一データベースを同時に更新する場合，論理的な矛盾を生じさせないために用いる技法。
トランザクションの整合性を保つために、1つのタスクがデータ更新のトランザクションを実行している間は、
その処理が終わるまで同じデータに対する他のトランザクション要求を待機させる仕組みです。
複数のトランザクションが同じデータを更新しようとしたときに、データを「ロック」することで同時更新による更新消失を防ぎます。


**インデックス**  
データベースに格納されているデータの取出しや並べ替えを高速で行うための仕組みです。
インデックスには幾つかの種類がありますが、設問に登場する「B+木インデックス」と「ハッシュインデックス」は次のような特徴を持っています。

**B+木インデックス**  
キーを指定することで挿入・検索・削除が効率的に行える木構造の一種で、木構造のインデックスツリー（索引木）により検索を高速化するアルゴリズムです。
RDBMSで最も一般的に使用されている。
節ごとにキー値の範囲とその子要素へのポインタを保持しているので範囲検索をスムーズに行えるほか、次のような性質があります。
・木構造の深さが一定になっているので、どのようなキー値であっても探索コストが大きく変わらない 計算量 $logX$
・大量のデータに対する操作であっても、ある程度の速度が期待できる
・インデックスノードはソートされた状態になっているので整列処理が高速に行える

節…木構造を図示した場合のノード部分のことを言います。
枝…各節の上下関係のことを言います。
親…上位の節のことを言います。
子…下位の節を子といいます。
根…最上位の節のことを言います。
葉…最下位の節のことを言います。

**ハッシュインデックス**  
ハッシュ関数を使用してキー値とレコードの格納場所を直接関連つける方式。
格納場所をキー値から一意に検索できるので、いくつもの階層の節をたどって格納場所にアクセスするB+木インデックスより高速にアクセスが可能。
ただし範囲検索やキー値を順番に読み込んで処理を行う用途には使用できない。
また、「異なったキー値でも同一の算出結果が得られてしまう可能性がある」という性質があるので、キー値の衝突(シノニム)が起こる可能性があります。

**ビットマップインデックス**  
キーの濃 (カーディナリティ，cardinality)が低い場合に適したインデックスで、それぞれのキー値ごとにビットマップ (ビットの配列) を作成し、
その各ビットはレコードがキーを含んでいるかを表します。


**インデックスによる検索まとめ**  
・範囲検索はB+木インデックスが強い
・単一レコードへのアクセスはハッシュインデックスが強い


---

## データベース設計

**参照制約**  
外部キーを持つ表にレコードを追加する場合に、その外部キー列の値は参照先の表の主キーとして存在するものでなければならない、
また、別表から主キーの値を参照されている行は削除することができないという制限を課す制約です。
参照制約は、関係データベースの整合性を保つために設定され、その指定には次のように"FOREIGN KEY"と"REFERENCES"が使われます。
`FOREIGN KEY 列リスト REFERENCES 親テーブル(列リスト)`

**検査制約**  
CHECK句を用いて指定します。

**キー制約**  
PRIMARY KEY句やFOREIGN KEY句を用いて指定します。

**外部キー制約**  
関係データベースの2つのテーブルの間の参照整合性を保つための制約で、SQLでは設定する属性に対して「FOREIGN KEY句」を指定します。
正規化された表同士を外部キーで結合することでデータの一貫性・正当性を保つことができます。

**整合性制約**  
「一意制約」とか「NOT NULL制約」とかのこと。
データベースの中のデータを良い感じに保つためにデータベースの項目に付ける「この項目に入れる値は空だとダメですよ」とか「この項目に入れる値は重複しちゃダメですよ」のような「この項目に入れられるのは、こんな値だけですよ」な制限のこと

データベースに記録するデータの中には、特定の値の種類しか取らないものや、何らかの規則や基準に従った内容である必要があるものがある。
そのような制約条件を各フィールド（カラム）の仕様として組み込み、データが追加・更新・削除される時点でシステム側でチェックする仕組みが整合性制約である。

**一意制約**  
特定の列が一意であることを保証します。

**NOT NULL制約**  
NULL値が許されないことを保証します。


**正規化**  
データとかを使いやすいように整理したり変形したりすること
正規化の目的は冗長性の排除することで更新時異状を回避し、データベースの一貫性を確保すること。
DB上で扱うデータの重複を排除し、「矛盾」の発生を「設計レベル」で防ぐこと。
正規化はパフォーマンス向上のために行うわけではない。

**第1正規形**  
同一行内に置ける重複の排除

**第2正規形**  
部分関数従属の排除。
複合主キーの部分キーによって一意に定まる属性を別表に移したもの。
主キーに部分従属している属性を分離したもの。
ポイント：テーブルの主キーに着目し、その項目に関数従属する非キー項目を見つける。

**第3正規形**  
推移的関数従属の排除。
主キー又は主キーの一部に推移的に関数従属する属性を別表に移します。
どのテーブルであってもすべての属性が主キーに対して完全従属であるテーブルにします。
`a→b→{f，g，h}、受注番号→顧客コード→顧客名`
ポイント：非キー項目に着目して、関数従属する項目を見つける


**関数従属**  
「〇〇と決めれば××と1つに決まる」ような状態の事。
関係データベースにおける「関数従属」とは、「社員ID→社員名」や「保険証番号→{個人名，住所，生年月日}」などのように、
ある属性の値によって別の属性の値が一意に決まる関係をいいます。

**部分関数従属**  
ある関数従属$｛A,B｝→C$が成り立つとして、$A→C,B→C$のいずれかが成り立つ場合、Cは｛A,B｝に部分関数従属しているといいます。
例えば、クラス番号と出席番号の両方が特定できていれば、クラス名は特定される状況にあった場合、
$｛クラス番号，出席番号｝→クラス名$
が成り立ちます。しかし、そもそもクラス番号と出席番号の両方を特定しなくとも、クラス番号さえ特定できればクラス名はわかります。つまり
$クラス番号→クラス名$
も成り立っています。これらのことから、クラス名は｛クラス番号,出席番号｝に部分関数従属している、ということになります。

**完全関数従属**  
ある関数従属$｛A,B｝→C$が成り立ち、かつ、$A→C,B→C$のいずれも成り立たない場合、「Cは｛A,B｝に完全関数従属している」といいます。
主キー1つもしくは複合主キーの全ての項目を使って値が決定する関係。
マスターテーブルが大体この状態。

**推移従属関係**  
「X -> Y」「Y -> Z」があるとき「X -> Z」が成り立つことを推移関数従属性といいます。
$A→B,B→C$がいずれも成り立ち（これをA→B→Cと表します）、かつ$B→A$が成り立たないとき、CはAに推移的に関数従属しているといいます。


**主キー**  
テーブル内で、ある項目を指定することでテーブル内の一つのレコードを一意に識別できる項目のこと

**非キー**  
主キー以外の項目のこと

**複合主キー**  
テーブル内の一意のレコードを識別するときに、2つ以上の項目を主キーとして扱うもののこと


[関数従属に関する一連の説明](https://www.fe-siken.com/bbs/0581.html)
次のような表があったとします。

社員(社員ID, 社員名, 住所)

社員IDが決まれば、社員名と住所が決まります。
ここで、「決まる」というのは、1つに定まるということです。
このとき、
「社員名は社員IDに関数従属している」
「住所は社員IDに関数従属している」
と言います。
これを次のように書くことがあります。
社員ID -> 社員名, 住所

※ ->は矢印です。

関数従属の詳細-----------------
関数従属には、「部分関数従属」、「完全関数従属」、「推移関数従属」があります。

次のような表があったとします。

受注(受注No, 受注日付, 顧客コード, 顧客名, 商品コード, 商品名, 単価, 数量)

主キーは、{受注No, 商品コード}で、次の関数従属があったとします。

受注No -> 受注日付, 顧客コード, 顧客名
顧客コード -> 顧客名
商品コード -> 商品名, 単価
{受注No, 商品コード} -> 数量

主キーの一部に関数従属するものを「部分関数従属」といいます。
たとえば、この例では主キーが{受注No, 商品コード}なので、
「受注No -> 受注日付, 顧客コード, 顧客名」、「商品コード -> 商品名, 単価」
が部分関数従属です。

部分関数従属を排除したものを、第2正規形といいます。
上の例では、次のように正規化されます。
(受注No, 受注日付, 顧客コード, 顧客名)
(商品コード, 商品名, 単価)
(受注No, 商品コード, 数量)

X -> Yが「完全関数従属」とは、X -> Y とあるときに、YがXの一部には関数従属しないことを言います。
たとえば、元の表(受注)の「{受注No, 商品コード} -> 商品名」は完全関数従属ではありません。(「商品コード -> 商品名」があるから。)
第2正規形では、主キーでない属性は、主キーに完全関数従属します。

推移関数従属とは、「X -> Y」「Y -> Z」があるとき「X -> Z」が成り立つことを推移関数従属性といいます。
(受注No, 受注日付, 顧客コード, 顧客名)の表の例では、
「受注No -> 顧客コード」「顧客コード -> 顧客名」があるので、
「受注No -> 顧客名」という推移関数従属があります。

主キーでない属性が、主キーから推移関数従属しないとき、第3正規形といいます。
(受注No, 受注日付, 顧客コード, 顧客名)から推移関数従属を排除すると
(受注No, 受注日付, 顧客コード)、(顧客コード, 顧客名)に分解されます。



**E-R図**  
業務で扱う情報をエンティティ及びエンティテイ間のリレーションシップとして表現する図。
データベース化の対象となる実体(エンティティ)と、実体の持つ属性(アトリビュート)、及び実体間の関連(リレーションシップ)を表現する図です。
関係データベースの概念モデル設計によく利用されますが、記法自体は関係モデルに限らず任意のオブジェクトとその関連の記述が可能になっています。



令和元年秋期　問25
UMLを用いて表した図の概念データモデルの解釈
`部署 1..* --- 0..* 従業員`

| 多重度表記 | 意味 |
| :- | :- |
| 0..1 | 0か1 |
| 1(1..1) | 常に1 |
| \*(0..*) | 0以上 |
| 1..* | 1以上 |

部署から見た従業員は0人以上
従業員から見た部署は1以上

ということで、0人の部署が存在する。複数の部署に跨る従業員がいると見ることができる。


**不整合**  
不整合とは，例えば商品表に商品コードAの商品名は「アンパン」になっているのに，
売上表の商品コードAの商品名は「コッペパン」になってる状態です。
商品コードAに対する商品名を「商品表」にも「売上表」にも持っているためこういった不整合が起こります。


---

## データベース方式

**スキーマ(schema)**  
データの内容，データの論理構造，記憶形式や編成などデータベースの構造を記述したものです。
データの性質，形式，ほかのデータとの関連などのデータ定義の集合である。
これを決めるDBMSの機能は「定義機能」

**障害回復機能**  
ロールバック、ロールフォワード、チェックポイント、更新前／更新後ログの記録などによってデータベースを障害から発生する機能です。

**機密保護機能**  
ユーザ認証、アクセス権限、利用ログの記録、暗号化などによってデータを安全に保つ機能です。

**保全機能**  
排他制御や参照制約、表制約などによってデータの完全性を保つ機能です。


**3層スキーマ構造(ANSI/SPARCモデル)**  
概念スキーマ、外部スキーマ、内部スキーマ の3つのグループに分けてデータ定義を行うデータベースモデルです。
スキーマの役割は、データベースの論理的・物理的なデータ構造が変更されたときの影響をユーザやアプリケーションに与えないようにすることです。(プログラムからの独立性を保証すること)

**概念スキーマ**  
データベース化対象の業務とデータの内容を論理的な構造として表現したもの。テーブルの正規化やCREATE TABLEによる表定義が概念スキーマに相当する。
**外部スキーマ**  
データの利用者からの見方を表現したもの。SQLのビューが外部スキーマに相当する。
**内部スキーマ**  
データを記憶装置上にどのような形式で格納するかを表現したもの。ファイル編成やインデックスの設定などが内部スキーマに相当する。


**関係モデル**  
データの関係を数学的な集合論と述語論によって表現するモデルで、関係データベースは関係モデルをコンピュータ上に実装したものです。
よくわからんけど覚えるだけなら実際に業務で使用するDBのテーブル、列、行、データ型の言い換えってことかも。

関係モデル　　　　　関係データベース
関係(relation)　　↔ 表・テーブル
属性(attribute)　 ↔ 列・カラム
タプル(tuple)・組 ↔ 行・レコード
定義域(domain)　　↔ 文字テル型、整数型等のデータ型

タプルも行も，ともに重複しない。
→
関係モデルのタプルは重複を許しませんが、関係データベースの場合では関係演算の結果如何によっては重複行が生じることがあります。

属性も列も，左から右に順序付けられる。
→
関係モデルは純粋な数学的モデルであるため属性には順序という概念がありません。しかし、関係データベースはデータを2次元の表で管理するため列順が生じます。



**オプティマイザ(Optimizer)**  
直訳すると「最適化するもの」という意味で、SQL文の処理を最適化する機能です。

SQL文に対する結果は1つでも、RDBMSの内部ではインデックスの使用有無、結合の順番などからいくつかの実行方法が考えられます。
オプティマイザは、SQL文を処理するために考えられる実行計画を全て検証し、最も効率が良いと予想される実行計画の決定を行います。

さらに最適な実行方法を決める基準には、アクセスパスに対して付けられた優先順位をもとに選択する「ルールベース」、
アクセスする表やインデックスの統計情報を基に見積もられたコストをもとに選択する「コストベース」の2種類があります。



**DBMSが受け付けたクエリを実行するまでの処理の流れ**  
`クエリ→構文解析→最適化→コード生成→実行`

**1．構文解析**  
パーサーが受け付けたSQLクエリを解析し、内容を解釈する
**2．最適化**  
クエリを最も効率よく実行できる方法を検討し決定する。(クエリオプティマイズによる問合せの最適化)
**3．コード生成**  
決定された方法でDBにアクセスするためのコードを生成する



関係データベースにおいて、関係は表、属性は列(カラム)、組(タプル)は行(レコード)に対応します。
・属性につける名前は、関係内で一意でなければならない。
・必ず属性名が必要。
・属性の並びに意味はない。組の並びにも意味がない。
・定義域(ドメイン)とは属性が取り得る値の集合」の事で、つまりはデータ型と同じ意味になる。
　なので、定義域の重複は問題ない。


DBMSが提供する機能のうち，データ機密保護を実現する手段はどれか。
→
データに対するユーザーのアクセス権限を管理する。
→
「データ機密保護」ですからセキュリティを向上させるための機能ということです。
DBMSは、表やスキーマおよびビューなどに対する操作権限をユーザごとに設定できる機能をもちます。
データベースは、組織内の様々な役職・部門の人が利用しますが、データに対して権限がある者とない者を区別することで、
アクセス権をもたない者からのアクセスを遮断できます。これによりデータの機密性が確保されます。

---

## データベース応用

**キーバリューストア(KVS)**  
NoSQLで用いられるデータ型の1つです。
プログラミングで使用される連想配列のように、1つのキーに1つの値を結びつけてデータを格納します。
構造が単純な分、スケーラビリティや処理速度に優れるためビッグデータの処理に使われています。

NoSQLで用いられる他の主要なデータ型についても簡単にまとめておきます。
**カラム指向**  
行キーに対してカラム（名前と値の組み合わせ）を結びつけて格納する
**ドキュメント指向**  
XMLやJSONなどの構造でデータを格納する
**グラフ指向**  
グラフ理論に基づいてデータ間の関係性を表現する


**データディクショナリ**  
データベースやシステム開発においてデータの属性・性質などデータに関する情報の定義を保存するための辞書です。

**データウェアハウス**  
企業内に散らばっているデータの有効活用を目的に、過去から現在までの基幹系データベースや外部データベースを統合し、
効果的な戦略的意思決定を支援するためのデータベースのことです。

**メタデータ**  
データについてのデータという意味で、データベースであればデータベース名やテーブル名、フィールド属性など本来のデータ付随する情報のことをいいます。

**データマイニング**  
ビッグデータ等、大量のデータから統計学的手法などを用いて新たな知識(傾向やパターン)を見つけ出すプロセス。

---

## コラム

### 外部キー制約(FOREIGN KEY)
外部キー制約とは、リレーショナルデータベース（RDB）でテーブルにデータを追加・更新する際の制約の一つで、外部の他のテーブルの特定の列の値しか指定できないようにするもの。  
萬君の質問にまたしても答えられなかったので、改めて復習。
よく見てみると、対して深くまとめているわけではなさそうですね。

<https://www.dbonline.jp/mysql/table/index11.html>
簡単に言えば、銀行台帳にコード1，2ってあるけど、銀行支店に銀行コード3を追加しようとしたらエラーになるって制約の事みたいです。
後、銀行支店台帳で銀行コード1を使っているのに銀行台帳の銀行コード1を削除しようとした場合もエラーになし、更新しようとしたら子テーブルも更新されたりするみたい。
というわけで、外部キー制約を設けると、親テーブルと子テーブルの間で値の整合性が保たれるというわけ。

<https://qiita.com/SLEAZOIDS/items/d6fb9c2d131c3fdd1387>
ここもしっくり来ること言ってるな。
「他のテーブルのデータに参照(依存)するようにカラムに付ける制約」

詳しくはこの記事読んで欲しいけど、何でもかんでも外部キーを貼らないほうがいいのかも。
時と場合によることがよくわかる。
というか、ちゃんと設計出来ていれば問題はないはずなんだけどね。

---

## 1回目に間違えた問題

DBMSが，3層スキーマアーキテクチャを採用する目的として，適切なものはどれか。
→
普通にわからなかったわ。
物理とか論理とかそんな感じでそもそも覚えていなかったので覚えましょう。
答えはズバリ、プログラムからの独立性を保障するためです。



データベースのアクセス効率を低下させないために，定期的に実施する処理はどれか。
→
答えは再編成。
始めて聞いた。何それまとめたい。



RDBMSが二つの表を結合する方法のうち，ソートマージ結合法に関する記述はどれか。
→
ある列をソートして、その結果についてマージする。
当たり前といえば当たり前。
答えを全部見る前にそれっぽいものを選んでしまった。



関係を第3正規形まで正規化して設計する目的はどれか。
→
第3正規形ってどこまでやったらそういえるの？
まずそこからだ。
関係を細かく分解する事？冗長性を排除する事？
そういうところも確認しないといけない。
割とナチュラルに間違った。ショック。



データ項目の命名規約を設ける場合，次の命名規約だけでは回避できない事象はどれか。
〔命名規約〕
データ項目名の末尾には必ず"名"，"コード"，"数"，"金額"，"年月日"などの区分語を付与し，区分語ごとに定めたデータ型にする。
データ項目名と意味を登録した辞書を作成し，異音同義語や同音異義語が発生しないようにする。
→
問題文に書いていない事を指摘すればよかっただけだった。
命名規則、データ型については名言されているが、値の範囲については指摘がないので、それを指摘しているのが答えだ。



平成28年春期　問26
関係モデルとその実装である関係データベースの対応に関する記述のうち，適切なものはどれか。
→
全く知らない。
どうやら関係モデルと関係データベースにはそれぞれ対応する概念があるらしい。
応用の参考書でも確認出来たが、覚えゲーである。
それぞれが何に対応するか覚えないと話にならない。
ドメインが型なのはいいとして、関係は表らしい。



平成29年秋期　問28
UMLを用いて表した図のデータモデルの解釈のうち，適切なものはどれか。
→
UMLの汎化、特価関係を復讐する必要がある。
以下答え全文。

社員は事業部に所属できる。
正しい。事業部クラスと部門クラスは汎化－特化関係にあり、事業部クラスは部門クラスを特化させた存在です。事業部は部門の一種であるため、親クラスである部門に社員が所属できるならば、子クラスの事業部にも社員が所属できます。

所属する社員がいない部門が存在する。
部門から見た社員の多重度は1以上です。すなわち社員が所属しない部門は存在しません。

部門は，いずれかの事業部が管理している。
部門から見た事業部の多重度は0または1です。すなわち事業部に管理されていない部門も存在し得ます。

事業部以外の部門が，部門を管理できる。
部門クラスとの間に"管理する"の関連名が付いているのは事業部→部門のみなので、事業部のみが部門を管理できます。



**平成26年秋期　問24**
ある企業では，顧客マスタファイル，商品マスタファイル，担当者マスタファイル及び当月受注ファイルを基にして，月次で受注実績を把握している。各ファイルの項目が表のとおりであるとき，これら四つのファイルを使用して当月分と直前の3か月分の出力が可能な受注実績はどれか。
→
こういう、テーブルからキーの連携をイメージする問題が苦手かも。
自分なりに落とし込む方法を解説を見ながら落とし込むしかないかな。
あー、でも当然といえば当然かもしれないが、各テーブルの連携項目を確認することがマストかな。
絶対にあるコードで連結できるので、連結させた結果、何が一番なのかってところまで最低限求めるべきかと思う。
→
それぞれのファイルを関係データベースの表と考えて表間の関連を整理すると次のようになります。
表の関連
関係データベースの結合演算で関係を持つことができるかどうかを考えてみましょう。
受注商品と顧客が関連つけられている受注記録は当月分しかなく、直前の3か月については顧客と商品についての対応が記録されているデータがありません。したがって〔イ〕と〔エ〕は出力できません。また商品と担当者間にも関連性がないため商品別の担当者別は出力できません。
唯一出力可能なのが〔ア〕で、顧客マスタファイルには担当者コードの列があるので、担当者コードと顧客コードをキーとして並び替えすることで当月と直前3か月分の担当者別顧客別受注実績が出力可能です。

担当者別の顧客別受注実績
正しい。各顧客は1人の担当者に関連つけられていて、顧客マスタには担当者コードがあるため、項目ごとに集計することで出力が可能です。

顧客別の商品別受注実績
受注商品と顧客が関連つけられている記録があるのは当月分だけで、前月～3カ月前についてはそれぞれの受注合計額のしかデータがないので出力できません。

商品別の担当者別受注実績
商品マスタファイルに受注した商品と担当者を関連付ける項目(担当者コード)がないので担当者別に出力することはできません。

商品別の顧客別受注実績
商品マスタファイルは顧客別には集計されていないので出力できません。
