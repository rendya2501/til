# データベース

---

## データ操作

### 射影(しゃえい)

表の中から特定の列だけを取り出す操作。  
関係データベースを操作する関係演算の1つで、表から条件に合致する列を取り出す演算です。  

SQLでは1つの表に同じ内容が2回以上出現することを許容しますが、数学の集合論に基づく関係モデルでは要素の重複が許されません。  
すなわち厳格に言えば、射影は「列の取り出し→重複の排除」を組み合わせた操作だということになります。  

SELECTでやってることがこれ。  

### 選択

表から指定された行を抽出する操作  

### 商

表Rのうち表Sの全ての項目を含む行の集合を返す演算

### 直積(cartesian product)

2つの関係(表)に含まれる要素のすべての組合せから成る表を得る演算です。  
演算後の行数は「Rの行数×Sの行数」になります。  
`SELECT * FROM R，S`  
`SELECT * FROM R CROSS JOIN SELECT * FROM S`

### 自然結合

内部結合や外部結合を行うときに、 結合条件としてそれぞれのテーブルで同じ名前のカラムを結合する場合に NATURAL を指定することで結合条件を省略することができます。  
このような結合を自然結合といいます。  
テーブルXとテーブルYに学部コードってあったら、そいつどうしてくっついてくれるのが自然結合ってこと。  

### ソートマージ結合法

双方の結合属性の値を整列し、先頭から突き合わせていくことで効率的に結合していく手法です。  
整列(ソート)と突合せ処理で併合(マージ)していくというのポイントです。  

### 入れ子ループ法(ネストループ法)

一方の表の結合する列の値を順に読み出し，もう一方の表の結合する列と結合する。  

### 埋込みSQL

VB6のカーソル処理が埋め込みSQLと呼ばれる手法らしい。  
CやCOBOL、Pascalのような表データを直接扱えない手続き型プログラミングに、関係データベースを操作するためのSQLを埋め込むための手法です。  
埋込みSQLでは、問合せによって得られた導出表を1行ずつ親プログラムに引き渡しながら処理をしていきますが、  
この操作において結果表内のある1行を参照する仕組みをカーソルといいます。  
親プログラム内では、カーソルから値を取り出したり、カーソルに対して更新または削除処理を行ったりします。  

設問のSQLにおいては、Xがカーソルに当たります。カーソル操作の流れは以下の通りです。  
DECLARE CURSOR文でカーソルを定義する。  
OPEN文でカーソルを開く。  
カーソル位置のデータ取得および次データへの移動に"FETCH"文を使います。  
CLOSE文でカーソルを閉じる。  

``` C
EXEC SQL OPEN X; // カーソルを開く
//ごにょごにょ
EXEC SQL CLOSE X; // カーソル閉じる
```

### 導出表

1つ以上の基礎となる実表(DBに実データを持つ表)から関係演算・集合演算といったSQL問合せによって作成される仮想的な表全般を指します。  
SELECT文で得られる結果の他にも、GROUP BY句やWITH句を処理する際に内部的に作られる一時的な表も導出表の1つです。  
ビューは導出表の一つの形態であり、導出表に名前を付けて実表と同じように参照(条件次第では更新も)できるようにしたものです。  

導出表は実データを持たず、参照・更新要求の度に、実表に関係演算・集合演算を行って作り出されています。  

### LIKE

指定したパターンと文字列比較を行うための演算子で、次の特殊記号を用いて文字列のパターンを指定します。  

**"%"(パーセント)**  
0文字以上の任意の文字列  

**"_"(アンダースコア)**  
任意の1文字  

平成27年春期　問26  
パターン"010%"は、"010"から始まる任意の文字列を表すパターンなので、LIKE "010%"は電話番号が"010"で始まるもの、すなわち"取引先"表の1行目だけにマッチします。  
WHERE句の条件式である NOT LIKE "010%" は、これに"NOT"を付けたものなので1行目以外の4行にマッチすることになります。  
ただし、NULL値に関しては IS NULL 以外の条件ではすべて"偽(False)"を返す性質があるので、結果はNULLの値を持つ行を除いた「3行」になります。  

### IN

結果セットの値のうちいずれかに一致すれば真を返し、そうでなければ偽を返す。  

### ANY

比較演算子(＝,≧,≦,<>)と共に使用され、副問合せの結果セットの値のうち、いずれかが条件を満たせば真を返し、そうでなければ偽を返す。  

### ALL

比較演算子と共に使用され、副問合せの結果セットの値の全てが条件を満たした場合にだけ真を返し、そうでなければ偽を返す。  

### EXISTS

副問合せの結果セットが1行以上あれば真を返し、そうでなければ偽を返す。  
親表の行を1行ずつ処理し、続く相関副問合せによって返された結果行が1つ以上存在すれば真、1つもなければ偽を返す句です。  

平成28年秋期　問29  
"社員"表と"部門"表に対し，次のSQL文を実行したときの結果はどれか。  
結果より、FROMに2つのフィールドを指定してWHEREで結合した場合のSQLはINNER JOINを使った場合と同じということが重要。  

``` SQL
SELECT COUNT(*) 
FROM 社員、部門
WHERE 社員.所属 = 部門.部門名 
AND 部門.フロア = 2

SELECT COUNT(*)
FROM 社員
JOIN 部門
ON 社員.所属 = 部門.部門名
WHERE 部門.フロア = 2
```

### UNION句

和集合演算を行う演算子で、複数のSELECT文の結果セットを1つに統合する機能を持ちます。  
通常のUNIONでは、2つの結果セットに全く同じレコードがあった場合に重複行が削除された結果を返します。

### UNION ALL

重複行を含めた結果を返します。  

### INTERSECT

共通  
2つの関係に共通集合を得る演算です。  

### CROSS JOIN

直積  
2つの関係に存在する行のすべての組み合わせを得る演算です。  
`SELECT * FROM R,S`  

### INNER JOIN

内部結合  
2つの関係を共通する属性で結び付ける演算です。  

### GRANT文

1人または複数のユーザに表などのオブジェクトに関する特定の権限を付与するSQL文です。  

``` sql
GRANT 権限名 ON オブジェクト名
TO { ユーザ名 | ロール名 | PUBLIC }
[ WITH GRANT OPTION ] ;
```

### REVOKE文

アクセス権限を取り消すSQL文。  

``` sql
REVOKE 権限名 ON オブジェクト名
FROM { ユーザー名 | ロール名 | PUBLIC }
```

### 参照整合性関係

関係データベース管理システムでは、参照整合性を維持する観点から、ある行が削除・更新された後に当該の行の値を参照する他の行が別表に残ってしまうことを許しません。  
SQLでは、データ操作によってこのようなことが起きた場合に発生させる5種類の参照操作(CASCADE，RESTRICT，NO ACTION，SET NULL，SET DEFAULT)を規定しています。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/27a.gif9)  

### CASCADE

参照先データの更新または削除に伴い、対応する参照元レコードを削除する。  

``` sql
CREATE TABLE 注文明細 (
…
FOREIGN KEY(注文番号) REFERENCES 注文(注文番号)
　ON DELETE CASCADE
…
);
```

### RESTRICT

参照制約性を損なうデータの更新または削除を禁止する。  

### NO ACTION

RESTRICTと同じく更新・削除を禁止するが、エラー発せいがタイミングが異なる。  

### SET NULL

参照先データの更新または削除されると、対応する参照元レコードの属性値にNULLを設定する。  

### SET DEFAULT

参照先データの更新または削除されると、対応する参照元レコードの属性値にデフォルト値を設定する。  

### 検査制約

テーブルに格納されるデータの種類を一定の範囲や種類に限定するための方法です。  
検査制約を設けるには、CREATE TABLE文でテーブルを作成するときの属性(列)の定義を  

CHECK(属性名 検査式)  

という形式で記述することで、特定の列の値が任意の式を満たすように指定できます。  

設問では"学生番号"列に LIKE 'K%'(Kから始まる任意の文字列)という制約が定義されているので、各SQL文がこれに反する操作を行っていないかを検証します。  

---

## トランザクション処理

### トランザクション

口座から振込みを行う場合における送金側の残高減と振込先口座の残高増のように関連する1つ以上の処理をまとめた単位です。  
トランザクションは、データの整合性を保つために「全ての処理が完了する」か「全く処理が行われなかったか」のどちらかで終了しなくてはなりません。  

トランザクションがコミットされると、DBMSはその更新情報をメモリ上のバッファとログファイルに書き出します。  
ログファイルについてはディスクへ即時書出しされますが、メモリバッファの内容については入出力効率向上のために、一定の間隔ごとにまとめてディスクに反映する方式をとっています。  
このディスクと同期を取るタイミングを「チェックポイント」といいます。  
この仕組みによりチェックポイント以前にコミットしたトランザクションに関してはディスクへの反映が保証されます。  

**チェックポイント法**を用いると、システム障害が発生した場合、  
ロールバック／ロールフォワードの対象を最後のチェックポイントから障害発生時点の間に実行していたトランザクションに限定できます。  
これによって障害発生直前の状態へと効率良く回復を行えます。  

システム障害が発生すると、チェックポイントより後にコミットされたトランザクションがディスクに反映されていないため、  
更新後ログを使用して障害発生直前の状態までロールフォワード(前進復帰)を行います。  
また障害発生時にコミットされていないトランザクションは、ACID特性の原子性も基づき更新前ログを使用したロールバック(後退復帰)でトランザクション開始時点の状態に戻します。  

![!](https://www.ap-siken.com/kakomon/28_aki/img/30_1.gif)  

平成28年秋期　問30  
![!](https://www.ap-siken.com/kakomon/28_aki/img/30.gif)  

設問中のアクティブ、アボート、コミットには次の意味があります。  

**アクティブ**  
トランザクションを処理中の状態  

**アボート**  
トランザクションの途中で処理を強制的に中断してトランザクションをロールバックする処理  

**コミット**  
トランザクションの一連の処理が成功した際に、その結果を確定させる処理  
コミット処理中からアボート処理中に遷移することはありますが、その逆はありません。コミットは全ての処理が正常に終了したときの処理だからです。  

### デッドロック

共有資源を使用する2つ以上のトランザクションが、互いに相手トランザクションが必要とする資源を排他的に使用していて、  
互いのトランザクションが相手が使用している資源の解放を待っている状態です。  
デッドロックが発生するとトランザクションは永遠に待ち状態になってしまうため、処理の続行ができなくなってしまいます。  
一般的に双方のトランザクションで資源の専有順序が同じ場合にはデッドロックが発生しないことが知られています。  

### 共有ロック

データを読込むときに使うロックで、この状態の場合は他のトランザクションによる更新処理ができなくなる(読込みは可能)。  

### 専有ロック

データを更新するときに使うロックで、この状態の場合は他のトランザクションによる読込みや更新ができなくなる。  
専有がかかった地点でトランザクションは取れない。  
唯一共有中に共有を掛ける事はできる。  

``` txt
     専有 共有
専有   ×   ×
共有   ×   ○
```

### 排他制御

複数のトランザクション処理プログラムが同一データベースを同時に更新する場合，論理的な矛盾を生じさせないために用いる技法。  
トランザクションの整合性を保つために、1つのタスクがデータ更新のトランザクションを実行している間は、  
その処理が終わるまで同じデータに対する他のトランザクション要求を待機させる仕組みです。  
複数のトランザクションが同じデータを更新しようとしたときに、データを「ロック」することで同時更新による更新消失を防ぎます。  

### 2相ロッキングプロトコル

トランザクション処理で読書きが必要になったデータにその都度ロックをかけていき、**全てのロックを獲得した後にだけロックの解除を行うルールを課すロック方式**です。  
つまり、ロックの解除が行われるのはトランザクションの終了時になります。  
各処理が終わる度に当該ロックを解除するわけではないので注意しましょう。  

### 2相コミットプロトコル(Two Phase Commit)

トランザクションのコミットを次の2つの段階に分けて行うことで、分散データベース環境でのトランザクションの原子性・一貫性を保証する仕組みです。  
分散データベースシステムにおいて，一連のトランザクション処理を行う複数サイトに更新処理が確定可能かどうかを問い合わせ，  
すべてのサイトが確定可能である場合，更新処理を確定する方式。  

トランザクションを他のサイトに更新可能かどうかを確認する第1相と、更新を確定する第2相の2つのフェーズに分け、  
各サイトのトランザクションをコミットもロールバックも可能な中間状態(セキュア状態)にした後、  
全サイトがコミットできる場合だけトランザクションをコミットするという方法で分散データベース環境でのトランザクションの原子性・一貫性を保証する手法です。  

第1フェーズ  
他のサイトに更新可能かどうかを確認する  
第2フェーズ  
全サイトからの合意が得られた場合に更新を確定する  
具体的には、コミットの調整を行う1つのノードを「調停者(主サイト)」、ネットワーク上の他のノードを「参加者(従サイト)」として、次の手順でコミットが行われます。  

[第1相(投票層)]  
1.主サイトはネットワーク上の全ての従サイトにコミットの可否を問い合わせる。  
2.全ての従サイトは主サイトにコミットの可否を応答する。  
[第2相(決定相)]  
3.全ての従サイトからコミットの合意を得られた場合は、全ての従サイトにコミットの実行要求を発行する。  
コミットの停止を応答した従サイトがあった場合、またはタイムアウトとなった場合は、全ての従サイトにロールバックの実行要求を発行する。  
4.全ての従サイトは、コミット(またはロールバック)の完了とともに主サイトに処理完了のメッセージを送る。  
5.主サイトが、全ての従サイトからの処理完了メッセージを受け取り、トランザクションの完了となる。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/30.gif)  

### ロックの粒度

ロックは、表、ブロック、行といった単位で掛けられる。  
この単位をロックの粒度という。  

粒度小さい  
・資源の競合やロック解除の待ち時間が少なくなり、トランザクションの並行実行度(スループット)が高まる。  
・ロック制御のためのオーバーヘッド(管理が煩雑になるのでCPUの負荷)が増大する。  

粒度大きい  
・トランザクション管理が容易になる。  
・他のトランザクションのロック解除待ちが長くなり、並行実行度(スループット)が低下する。  

メモリ使用領域は、同時に実行されるトランザクションが増えるほど多く必要になります。  
その理由は、1つのトランザクションを実行するときよりも、複数のトランザクションを並列に実行したときの方が、同時に管理するロックの絶対数が増えるからです。  
つまりメモリ使用領域が多く必要になるのは、トランザクションの同時実行数が多い行単位です。  

### ロールバック(後退復帰)

トランザクションの途中、プログラムのバグなどでアプリケーションから の応答がなくなったり強制終了した場合に、  
更新前ジャーナル(ログ)を用いてデータベースをトランザクション開始直前の状態に戻す処理です。  

### ロールフォワード(前進復帰)

データベースシステムに障害が起こったときに、更新後ログを用いて今まで処理したトランザクションを再現し、  
システム障害直前までデータベース情報を復帰させることをいいます。  

チェックポイントを跨いでコミットが完了しているものはロールフォワードによりデータを修復する事ができる。  

![!](https://www.ap-siken.com/kakomon/27_aki/img/30.gif)  
T4とT5がロールフォワード可能  

### ログファイル

トランザクション開始前とコミット後の状態を保存したファイルで、ロールバックやロールフォワードによって障害から復旧するときに用いられます。  
ジャーナルファイルとも呼ばれます。ログファイルによってデータベースの永続性が保たれています。  

### ダンプファイル  

データベース移行のときなどに用いられるデータベースの内容をそのまま書き出したファイルです。  
メモリやレジスタ、ファイルのある瞬間の中身を丸ごと記録したファイル  
DBではバックアップのためにある瞬間のDBの内容を丸ごとコピーしたファイルのことをいう  

### 障害回復

**チェックポイントファイル**  
コミットされたトランザクションをデータベースに書き出すときに、その情報を記録したファイルです。  

**トランザクション障害**  
更新前ログを使用したロールバックを行い、トランザクション開始直前の状態に戻す。  

**システム障害**  
直前のチェックポイントまで戻り、コミットされたトランザクションを更新後ログを使用したロールフォワードでデータベースに反映させる。  

#### 媒体障害

ハードディスクなどの装置や機器自体の不具合により生じる障害で、その時の一般的な回復手順は次の通りです。  

1.機器を正常に動作するものに取り換える。  
2.バックアップデータを使用して、正常なディスクにバックアップ時点の状態を復元する。  
3.バックアップ取得時点以後にコミットされたトランザクションについて、更新後ログを用いてデータベースに結果を反映させる「ロールフォワード処理(前進復帰)」を行う。  

バックアップファイルと更新後ログを使用したロールフォワードで障害発生直前の状態に戻す。  

まず最初に新しい媒体にバックアップデータを適用してバックアップ時点の状態を復元します。  
その後、更新後ログを用いてロールフォワード処理(前進復帰)を行うことで、バックアップ時点から障害発生までにコミットしたトランザクションの結果をデータベースに反映させます。  
この手順で回復することでデータベースを障害発生直前の状態まで回復することができます。  

「記憶媒体に故障が発生した」という記述から媒体障害とわかるのでロールフォワードが適切な操作となります。  

#### 媒体障害以外の障害（システム障害やトランザクション障害）

DBMSは、ディスクに対する入出力効率を向上させるために、トランザクションの更新をメモリ上のバッファとログファイルに記憶しておき、  
一定の間隔ごとにまとめてディスクに反映させるという方式をとっています。  
このディスクと同期を取るタイミングをチェックポイントといいます。  
チェックポイントまでのトランザクションはディスクに反映済みなので、  
媒体障害以外の障害（システム障害やトランザクション障害）のときにはチェックポイント以前にコミットしたトランザクションについて回復作業は行う必要はありません。  

令和3年秋期　問27  

### ACID特性

データベースのトランザクション処理を行う上で必要不可欠とされる４つの性質(Atomicity・Consistency・Isolation・Durability)の頭文字を並べた言葉です。  
ACID特性は、DBMSがもつトランザクションログの記録、ロールバックとロールフォワード、ロックなどを組み合わせて実現されています。  

**Atomicity ： 原子性**  
トランザクション内の処理がすべて実行されるか、または全く実行されないことを保証する性質。  

**Consistency ： 一貫性**  
トランザクションによりデータの矛盾が生じないこと。常にデータベースの整合性が保たれていることを保証する性質。  

**Isolation ： 独立性**  
複数のトランザクションを同時に実行した場合と、順番に実行した場合の結果が等しくなることを保証する性質。一般にロックなどをかけることで直列可能性を保証する。  
隔離性と呼ばれる場合もある。  

**Durability ： 永続性**  
一旦正常終了したトランザクションの結果は、以後システムに障害が発生しても失われないことを保証する性質。  
耐久性と呼ばれる場合もある。  

### 再編成

データベースの処理効率は、レコードの追加や削除の繰り返しによるガーベジの増加や、同じレコードが非連続の場所に格納されることによって徐々に低下していきます。
このような状態を改善するために定期的に行われる処理が再編成。
低下した処理効率を回復させることができます。
ハードディスクのデフラグのDB版。

### データベースダンプ

データベースの内容をファイルに書き出して保存することです。  

### インデックス

データベースに格納されているデータの取出しや並べ替えを高速で行うための仕組みです。  

### B+木インデックス

木の深さが一定で、節点はキー値と子部分木へのポインタをもち、葉のみが値をもつ平衡木(バランス木)を用いたインデックス法です。  
関係データベースのインデックス法として現在最も普及しています。  

![!](https://www.ap-siken.com/kakomon/30_haru/img/26_1.gif)  

キーを指定することで挿入・検索・削除が効率的に行える木構造の一種で、木構造のインデックスツリー（索引木）により検索を高速化するアルゴリズムです。  
RDBMSで最も一般的に使用されている。  

節ごとにキー値の範囲とその子要素へのポインタを保持しているので範囲検索をスムーズに行えるほか、次のような性質があります。  
・木構造の深さが一定になっているので、どのようなキー値であっても探索コストが大きく変わらない 計算量 $logX$  
・大量のデータに対する操作であっても、ある程度の速度が期待できる  
・インデックスノードはソートされた状態になっているので整列処理が高速に行える  

節…木構造を図示した場合のノード部分のことを言います。  
枝…各節の上下関係のことを言います。  
親…上位の節のことを言います。  
子…下位の節を子といいます。  
根…最上位の節のことを言います。  
葉…最下位の節のことを言います。  

#### 計算量

B+木インデックスでは探索範囲を1／nに狭めながら検索していきますが、B+木の深さはどの葉でも一定であるため、どの値を探索する場合でもほぼ同じアクセス回数になります。  
この深さは各節点が持つエントリ数(次数)で決まり、深さがh 、次数がbであるB+木における葉の最大数(X)は次の式で表せます。  

$b^h＝X (上の例でいえば3^3＝27)$  

つまりX件のデータを探索する際のアクセス回数を示す深さhは、  

$h＝log_bX$  

このため、アクセス回数のオーダはXの対数「O(logX)」になります。  

#### 性能改善が最も期待できる操作

B+木は、根および節にはキー値の範囲と下層のブロックへのポインタ、葉にはキー値と表内の行の位置情報と前後の葉へのポインタが格納されていて、  
根から節をたどっていくことで目的のデータを検索します。  
すべてのキー値が同じ深さにあるので、データ量が増加してもパフォーマンスの低下が少なく、  
どのキー値に対してもランダム検索や範囲検索、挿入・更新・削除を効率よく行える特徴を持ちます。  
また葉に含まれている前後の葉へのポインタによって一致検索だけでなく、**"<"，">"，"BETWEEN"などの範囲検索を効率よく行えます。**  
**しかしデータの分布に偏りがある場合や、NULL値及び否定を含む検索条件では効果を発揮できません。**  

### ハッシュインデックス

ハッシュ関数を使用してキー値とレコードの格納場所を直接関連つける方式。  
格納場所をキー値から一意に検索できるので、いくつもの階層の節をたどって格納場所にアクセスするB+木インデックスより高速にアクセスが可能。  
ただし範囲検索やキー値を順番に読み込んで処理を行う用途には使用できない。  
また、「異なったキー値でも同一の算出結果が得られてしまう可能性がある」という性質があるので、キー値の衝突(シノニム)が起こる可能性があります。  

### ビットマップインデックス

キーの濃 (カーディナリティ，cardinality)が低い場合に適したインデックスで、それぞれのキー値ごとにビットマップ (ビットの配列) を作成し、  
その各ビットはレコードがキーを含んでいるかを表します。  

### インデックスによる検索まとめ

・範囲検索はB+木インデックスが強い  
・単一レコードへのアクセスはハッシュインデックスが強い  

### ストアドプロシージャ(stored procedure)

データベースに対する一連の処理をまとめた手続きにして、データベース管理システムに保存したものです。  
利用者は通常のクエリを発行する代わりに、データベース管理システム内の手続きを呼び出すことによって目的の処理を実行させることができます。  
クライアントからサーバに対してのストアドプロシージャ1回の要求で、データベースに複数のクエリを発行することができるので、  
クライアントから直に同数のクエリを発行する場合と比較して、クライアント－サーバ間のネットワーク負荷の軽減が期待できます。  

---

## データベース設計

### 参照制約

外部キーを持つ表にレコードを追加する場合に、その外部キー列の値は参照先の表の主キーとして存在するものでなければならない、  
また、別表から主キーの値を参照されている行は削除することができないという制限を課す制約です。  

参照制約は、関係データベースの整合性を保つために設定され、その指定には次のように"FOREIGN KEY"と"REFERENCES"が使われます。  
`FOREIGN KEY 列リスト REFERENCES 親テーブル(列リスト)`  

平成28年春期　問29  
関係データベースにおける整合性制約の一つで「ある表で参照しようとしている値が、参照先の表で候補キーとして存在しなければならない」というものです。  

本問の関係では、"在庫"表の"製造番号"列の値が、"製品"表の主キー("製造番号"列)の値として存在しなければならないという制約になります。  
これは、"製品"表に存在しない製品を、"在庫"表で指定することができないことを意味しています。  

参照制約では、行の追加と削除の際に注意が必要になります。  
外部キーを持つ行を追加する場合に、その外部キーの値は参照先の表で主キーの値として存在するものでなければなりません。  
また、別表から主キーの値を参照されている行は削除することができません。  

### 検査制約

CHECK句を用いて指定します。  

### キー制約

PRIMARY KEY句やFOREIGN KEY句を用いて指定します。  

### 外部キー制約

関係データベースの2つのテーブルの間の参照整合性を保つための制約で、SQLでは設定する属性に対して「FOREIGN KEY句」を指定します。  
正規化された表同士を外部キーで結合することでデータの一貫性・正当性を保つことができます。  

### 整合性制約

「一意制約」とか「NOT NULL制約」とかのこと。  
データベースの中のデータを良い感じに保つためにデータベースの項目に付ける「この項目に入れる値は空だとダメですよ」とか「この項目に入れる値は重複しちゃダメですよ」のような「この項目に入れられるのは、こんな値だけですよ」な制限のこと  

データベースに記録するデータの中には、特定の値の種類しか取らないものや、何らかの規則や基準に従った内容である必要があるものがある。  
そのような制約条件を各フィールド（カラム）の仕様として組み込み、データが追加・更新・削除される時点でシステム側でチェックする仕組みが整合性制約である。  

### 一意制約

特定の列が一意であることを保証します。  

### NOT NULL制約

NULL値が許されないことを保証します。  

### 正規化

データとかを使いやすいように整理したり変形したりすること  
正規化の目的は冗長性の排除することで更新時異状を回避し、データベースの一貫性を確保すること。  
DB上で扱うデータの重複を排除し、「矛盾」の発生を「設計レベル」で防ぐこと。  
正規化はパフォーマンス向上のために行うわけではない。  

[令和2年秋期 問28]が超参考になる。  

### 第1正規形

同一行内に置ける重複の排除  

### 第2正規形

部分関数従属の排除。  
複合主キーの部分キーによって一意に定まる属性を別表に移します。  

主キーに部分従属している属性を分離したもの。  
ポイント：テーブルの主キーに着目し、その項目に関数従属する非キー項目を見つける。  

### 第3正規形

推移的関数従属の排除。  
主キー以外の属性によって一意に定まる属性を別表に移します。  
これにより、データの冗長性が排除され、第2正規形における行の挿入・削除および更新時の異常が発生しなくなります。  

主キー又は主キーの一部に推移的に関数従属する属性を別表に移します。  
どのテーブルであってもすべての属性が主キーに対して完全従属であるテーブルにします。  
`a→b→{f，g，h}、受注番号→顧客コード→顧客名`  
ポイント：非キー項目に着目して、関数従属する項目を見つける  

例えば次の表があったとします。  
![!](https://www.ap-siken.com/kakomon/29_aki/img/27_1.gif)  

この表は、非キー属性"顧客コード"→"顧客名"という関数従属性が存在しているので第2正規形です。  
しかしこの表には、非キー属性からの関数従属性が残るがゆえに、次に挙げる異常が発生する可能性があります。  

**行の挿入時**  
未受注の(受注番号をもたない)顧客を登録できない。  
**行の削除時**  
受注番号1055の行を削除すると、A7053:鈴木電気の顧客情報が失われるように、情報の損失が生じる恐れがある。  
**値の更新時**  
B7060:中村商会の顧客名を変更する際、一部の行の値だけを変更すると同じ顧客コードで複数の顧客名が存在することになってしまう。  

上記の表を第3正規形にすると、これらの異常が発生しなくなるため整合性を保ちやすくなります。  
![!](https://www.ap-siken.com/kakomon/29_aki/img/27_2.gif)  

### 関数従属

「〇〇と決めれば××と1つに決まる」ような状態の事。  
関係データベースにおける「関数従属」とは、「社員ID→社員名」や「保険証番号→{個人名，住所，生年月日}」などのように、  
ある属性の値によって別の属性の値が一意に決まる関係をいいます。  

[関数従属に関する一連の説明](https://www.fe-siken.com/bbs/0581.html)  
次のような表があったとします。  

社員(社員ID, 社員名, 住所)  

社員IDが決まれば、社員名と住所が決まります。  
ここで、「決まる」というのは、1つに定まるということです。  
このとき、  
「社員名は社員IDに関数従属している」  
「住所は社員IDに関数従属している」  
と言います。  
これを次のように書くことがあります。  
社員ID -> 社員名, 住所  

※ ->は矢印です。  

関数従属の詳細-----------------  
関数従属には、「部分関数従属」、「完全関数従属」、「推移関数従属」があります。  

次のような表があったとします。  

受注(受注No, 受注日付, 顧客コード, 顧客名, 商品コード, 商品名, 単価, 数量)  

主キーは、{受注No, 商品コード}で、次の関数従属があったとします。  

受注No -> 受注日付, 顧客コード, 顧客名  
顧客コード -> 顧客名  
商品コード -> 商品名, 単価  
{受注No, 商品コード} -> 数量  

主キーの一部に関数従属するものを「部分関数従属」といいます。  
たとえば、この例では主キーが{受注No, 商品コード}なので、  
「受注No -> 受注日付, 顧客コード, 顧客名」、「商品コード -> 商品名, 単価」  
が部分関数従属です。  

部分関数従属を排除したものを、第2正規形といいます。  
上の例では、次のように正規化されます。  
(受注No, 受注日付, 顧客コード, 顧客名)  
(商品コード, 商品名, 単価)  
(受注No, 商品コード, 数量)  

X -> Yが「完全関数従属」とは、X -> Y とあるときに、YがXの一部には関数従属しないことを言います。  
たとえば、元の表(受注)の「{受注No, 商品コード} -> 商品名」は完全関数従属ではありません。(「商品コード -> 商品名」があるから。)  
第2正規形では、主キーでない属性は、主キーに完全関数従属します。  

推移関数従属とは、「X -> Y」「Y -> Z」があるとき「X -> Z」が成り立つことを推移関数従属性といいます。  
(受注No, 受注日付, 顧客コード, 顧客名)の表の例では、  
「受注No -> 顧客コード」「顧客コード -> 顧客名」があるので、  
「受注No -> 顧客名」という推移関数従属があります。  

主キーでない属性が、主キーから推移関数従属しないとき、第3正規形といいます。  
(受注No, 受注日付, 顧客コード, 顧客名)から推移関数従属を排除すると  
(受注No, 受注日付, 顧客コード)、(顧客コード, 顧客名)に分解されます。  

### 部分関数従属

ある関数従属$｛A,B｝→C$が成り立つとして、$A→C,B→C$のいずれかが成り立つ場合、Cは｛A,B｝に部分関数従属しているといいます。  
例えば、クラス番号と出席番号の両方が特定できていれば、クラス名は特定される状況にあった場合、  
$｛クラス番号，出席番号｝→クラス名$  
が成り立ちます。しかし、そもそもクラス番号と出席番号の両方を特定しなくとも、クラス番号さえ特定できればクラス名はわかります。つまり  
$クラス番号→クラス名$  
も成り立っています。これらのことから、クラス名は｛クラス番号,出席番号｝に部分関数従属している、ということになります。  

### 完全関数従属

ある関数従属$｛A,B｝→C$が成り立ち、かつ、$A→C,B→C$のいずれも成り立たない場合、「Cは｛A,B｝に完全関数従属している」といいます。  
主キー1つもしくは複合主キーの全ての項目を使って値が決定する関係。  
マスターテーブルが大体この状態。  

### 推移従属関係

「X -> Y」「Y -> Z」があるとき「X -> Z」が成り立つことを推移関数従属性といいます。  
$A→B,B→C$がいずれも成り立ち（これをA→B→Cと表します）、かつ$B→A$が成り立たないとき、CはAに推移的に関数従属しているといいます。  

### 推移律

X→Y かつ Y→Z が成立するならば、X→Z が成立する  

### 主キー

テーブル内で、ある項目を指定することでテーブル内の一つのレコードを一意に識別できる項目のこと  

### 非キー

主キー以外の項目のこと  

### 複合主キー

テーブル内の一意のレコードを識別するときに、2つ以上の項目を主キーとして扱うもののこと  

### 候補キー(Candidate Key)

主キーの候補となるキーのことで、表の中の1つのレコードを特定できる性質を持つ属性、または属性の組合せです。  

平成27年秋期　問28  
〔関数従属〕  
A→B，A→F，B→C，C→D，{B，C}→E，{C，F}→A  
![!](https://www.ap-siken.com/kakomon/27_aki/img/28_1.gif)  
![!](https://www.ap-siken.com/kakomon/27_aki/img/28_2.gif)  

### 外部キー制約(FOREIGN KEY)

外部キー制約とは、リレーショナルデータベース（RDB）でテーブルにデータを追加・更新する際の制約の一つで、外部の他のテーブルの特定の列の値しか指定できないようにするもの。  
萬君の質問にまたしても答えられなかったので、改めて復習。  
よく見てみると、対して深くまとめているわけではなさそうですね。  

<https://www.dbonline.jp/mysql/table/index11.html>
簡単に言えば、銀行台帳にコード1，2ってあるけど、銀行支店に銀行コード3を追加しようとしたらエラーになるって制約の事みたいです。
後、銀行支店台帳で銀行コード1を使っているのに銀行台帳の銀行コード1を削除しようとした場合もエラーになし、更新しようとしたら子テーブルも更新されたりするみたい。
というわけで、外部キー制約を設けると、親テーブルと子テーブルの間で値の整合性が保たれるというわけ。

<https://qiita.com/SLEAZOIDS/items/d6fb9c2d131c3fdd1387>
ここもしっくり来ること言ってるな。
「他のテーブルのデータに参照(依存)するようにカラムに付ける制約」

詳しくはこの記事読んで欲しいけど、何でもかんでも外部キーを貼らないほうがいいのかも。
時と場合によることがよくわかる。
というか、ちゃんと設計出来ていれば問題はないはずなんだけどね。

### E-R図

業務で扱う情報をエンティティ及びエンティテイ間のリレーションシップとして表現する図。  

データベース化の対象となる実体(エンティティ)と、実体の持つ属性(アトリビュート)、及び実体間の関連(リレーションシップ)を表現する図です。  
関係データベースの概念モデル設計によく利用されますが、記法自体は関係モデルに限らず任意のオブジェクトとその関連の記述が可能になっています。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/26.gif)  

**多重度**  
関連するクラス同士において、あるクラスの1つのインスタンスに別のクラスのインスタンスが対応する数を表します。  

#### 令和元年秋期 問25

UMLを用いて表した図の概念データモデルの解釈  
`部署 1..* --- 0..* 従業員`  

``` txt
多重度表記 | 意味  |
0..1       | 0か1  |
1(1..1)    | 常に1 |
\*(0..*)   | 0以上 |
1..*       | 1以上 |
```

部署から見た従業員は0人以上  
従業員から見た部署は1以上  

ということで、0人の部署が存在する。複数の部署に跨る従業員がいると見ることができる。  

#### 平成30年秋期 問26

![!](https://www.ap-siken.com/kakomon/30_aki/img/26_2.gif)  

#### 令和3年春期　問29

「顧客は何度も注文を行い」  
→1人の顧客について複数（0つ以上）の注文が存在し、1つの注文は1人の顧客によって行われるので、顧客クラスと注文クラスの関係は「1対多」となります。  

「一度に一つ以上の商品を注文でき」  
→1つの注文エンティティについて、1つ以上の注文明細エンティティが存在するので、注文クラスと注文明細クラスの関係は「1対多」となります。  

「注文明細はそれぞれ1種類の商品に対応している」  
→1つの注文明細は1種類の商品に対応し、1種類の商品は複数の注文明細に関連し得るので、注文明細クラスと商品クラスの関係は「多対1」となります。  

以上を整理すると、データ間の関連を適切に表すのは次の概念データモデルです。  
　顧客(1)－(多)注文(1)－(多)注文明細(多)－(1)商品  

### 不整合

不整合とは，例えば商品表に商品コードAの商品名は「アンパン」になっているのに，  
売上表の商品コードAの商品名は「コッペパン」になってる状態です。  
商品コードAに対する商品名を「商品表」にも「売上表」にも持っているためこういった不整合が起こります。  

---

## データベース方式

### スキーマ(schema)

データの内容，データの論理構造，記憶形式や編成などデータベースの構造を記述したものです。  
データの性質，形式，ほかのデータとの関連などのデータ定義の集合である。  
これを決めるDBMSの機能は「定義機能」  

### 3層スキーマ構造(ANSI/SPARCモデル)

概念スキーマ、外部スキーマ、内部スキーマ の3つのグループに分けてデータ定義を行うデータベースモデルです。  
物理的・論理的データの独立性を達成するためにDBMSがサポートすべきアーキテクチャとして提案されたものです。  

スキーマの役割は、データベースの論理的・物理的なデータ構造が変更されたときの影響をユーザやアプリケーションに与えないようにすることです。  
(プログラムからの独立性を保証すること)  

![!](https://www.ap-siken.com/kakomon/28_aki/img/26.gif)  

#### 概念スキーマ

データベース化対象の業務とデータの内容を論理的なデータモデルとして表現したもの。  
概念スキーマを記述するために記号系にはリレーショナルデータモデルの他にも、ネットワークデータモデル、階層型データモデルなどがある。  
リレーショナルデータモデルでは表の正規化やCREATE TABLEによる表定義が概念スキーマに相当する。  

#### 外部スキーマ(サブスキーマ)

概念スキーマで定義されたデータモデル上に利用者ごとの目的に応じた見方を表現したもの。  
リレーショナルデータモデルのビューやネットワークデータモデルのサブスキーマが外部スキーマに相当する。  

サブスキーマは外部スキーマーの別称。  

#### 内部スキーマ

[1]  
概念スキーマで定義されたデータモデルを記憶装置上にどのような形式で格納するかを表現したもの。  
ファイル編成やインデックスの設定などが内部スキーマに相当する。  

[2]  
データを記憶装置上にどのような形式で格納するかを記述したものです。  
ファイル編成やインデックスの設定などが内部スキーマに相当する。  

### 関係モデル

データの関係を数学的な集合論と述語論によって表現するモデルで、関係データベースは関係モデルをコンピュータ上に実装したものです。  
よくわからんけど覚えるだけなら実際に業務で使用するDBのテーブル、列、行、データ型の言い換えってことかも。  

``` txt
関係モデル　　　　　関係データベース
関係(relation)　　↔ 表・テーブル
属性(attribute)　 ↔ 列・カラム
タプル(tuple)・組 ↔ 行・レコード
定義域(domain)　　↔ 文字テル型、整数型等のデータ型
```

タプルも行も，ともに重複しない。
→
関係モデルのタプルは重複を許しませんが、関係データベースの場合では関係演算の結果如何によっては重複行が生じることがあります。

属性も列も，左から右に順序付けられる。
→
関係モデルは純粋な数学的モデルであるため属性には順序という概念がありません。しかし、関係データベースはデータを2次元の表で管理するため列順が生じます。

### オプティマイザ(Optimizer)

[1]  
直訳すると「最適化するもの」という意味で、SQL文の処理を最適化する機能です。  

SQL文に対する結果は1つでも、RDBMSの内部ではインデックスの使用有無、結合の順番などからいくつかの実行方法が考えられます。  
オプティマイザは、SQL文を処理するために考えられる実行計画を全て検証し、最も効率が良いと予想される実行計画の決定を行います。  

さらに最適な実行方法を決める基準には、アクセスパスに対して付けられた優先順位をもとに選択する「ルールベース」、  
アクセスする表やインデックスの統計情報を基に見積もられたコストをもとに選択する「コストベース」の2種類があります。  

[2]  
SQL文が実行された際、対象となるレコードの取得時間を最小とするようにアクセスパスを最適化するデータベース管理システム(DBMS)の機能です。  
レコードを取得するためには、インデックスの使用や表全体の読込みなどの複数の方法が考えられます。  
オプティマイザはクエリの実行計画を評価し、問合せ内容に応じて最も効率がよい方法を選択します。  

アクセスパスを選択する基準には「コストベースアプローチ」と「ルールベースアプローチ」の2つがあり、コストベースアプローチが一般的です。  

#### コストベースアプローチ

DBMSに蓄積された表やインデックスの統計情報をもとにコストを見積り、その結果に基づいて最も効率的な実行計画を作成する方法です。  
コストベースアプローチにおいて実行計画を得る際に必要となる情報は「統計情報」が適切です。  

#### ルールベースアプローチ

あらかじめ決めておいたアクセスパスの優先順位などのルールに、実行しようとするSQL構文と表やインデックスの定義情報を当てはめて実行計画を作成する方法です。  

### DBMSが受け付けたクエリを実行するまでの処理の流れ

クエリ→構文解析→最適化→コード生成→実行  

**1．構文解析**  
パーサーが受け付けたSQLクエリを解析し、内容を解釈する

**2．最適化**  
クエリを最も効率よく実行できる方法を検討し決定する。(クエリオプティマイズによる問合せの最適化)

**3．コード生成**  
決定された方法でDBにアクセスするためのコードを生成する

関係データベースにおいて、関係は表、属性は列(カラム)、組(タプル)は行(レコード)に対応します。
・属性につける名前は、関係内で一意でなければならない。
・必ず属性名が必要。
・属性の並びに意味はない。組の並びにも意味がない。
・定義域(ドメイン)とは属性が取り得る値の集合」の事で、つまりはデータ型と同じ意味になる。
　なので、定義域の重複は問題ない。

DBMSが提供する機能のうち，データ機密保護を実現する手段はどれか。
→
データに対するユーザーのアクセス権限を管理する。
→
「データ機密保護」ですからセキュリティを向上させるための機能ということです。
DBMSは、表やスキーマおよびビューなどに対する操作権限をユーザごとに設定できる機能をもちます。
データベースは、組織内の様々な役職・部門の人が利用しますが、データに対して権限がある者とない者を区別することで、
アクセス権をもたない者からのアクセスを遮断できます。これによりデータの機密性が確保されます。

---

## データベース応用

### NoSQL(Not only SQL)

データへのアクセス方法をSQLに限定しないデータベース管理システムの総称で、  
長い間決まったように使用されてきた関係データベース管理システム以外のDBMSという意味で用いられます。  

RDBMSは長い歴史をもち、厳密なスキーマ定義や数学的に定義されたモデル理論、トランザクションのACID特性などによって信頼性に秀でています。  
しかし、それゆえにデータを扱う際のコストも高くなり、ビッグデータなどの高頻度で膨大なデータを扱う場面ではパフォーマンス面での劣化が現れてきました。  
NoSQLは、スキーマレスで軽量なのでデータの参照や追加を低コストで実行できます。  
さらにスケーラビリティにも優れるため大量に蓄積されていくデータを扱うのに適しています。  

代表的なNoSQL
・Google BigTable  
・Amazon DynamoDB  
・Apache Cassandra  
・MongoDB  

NoSQLには大まかに分けて4つのタイプがあります。  
・キー・バリュー型  
・カラム指向  
・ドキュメント指向  
・グラフ指向  

### キー・バリュー型 キーバリューストア(KVS)

NoSQLで用いられるデータ型の1つです。  
プログラミングで使用される連想配列のように、1つのキーに1つの値を結びつけてデータを格納します。  
構造が単純な分、スケーラビリティや処理速度に優れるためビッグデータの処理に使われています。  

### カラム指向

行キーに対してカラム（名前と値の組み合わせ）を結びつけて格納する  

### ドキュメント指向

XMLやJSONなどの構造でデータを格納する

### グラフ指向

有向グラフと呼ばれるデータ構造でデータを格納するデータベースで、データエンティティ(実体)を表す「ノード」、  
ノード間の関連をタイプと方向をもって表す「エッジ」、ノードとエッジの属性情報を"key-value"形式で保持する「プロパティ」の3要素で構成されます。  
SNSにおけるユーザの関係やWebサイト同士のリンク構造などの高度な"つながり"を表すデータモデルに適しています。  

![!](https://www.ap-siken.com/kakomon/03_haru/img/28.gif)  

### データディクショナリ(DD)

データベースのメタデータやデータ定義情報を効率よく管理する情報の保管庫です。  
データディクショナリは、他のデータベースと同じく表とビューで構成されていて次のような情報が格納されています。  

・概念スキーマ、外部スキーマ、内部スキーマとそれらの変換定義情報  
・表、ビュー、インデックス、その他オブジェクトの定義情報  
・参照制約、検査制約の定義情報  
・ユーザ情報  
・アクセス権と機密保護に関する情報  

データディクショナリ/ディレクトリは、それぞれのサイトに存在するデータベースごとに存在しますが、  
分散データベースでは「資源位置に対する透過性」を満たすためにこれに加えて、  
どのサイトからもアクセスが可能なグローバルなデータディクショナリ/ディレクトリを用意する必要があります。  

このグローバルなDD/Dの配置方式には「集中管理方式」と「分散管理方式」があります。  

**集中管理方式**  
1つのサイトが代表してすべてのDD/Dを保有する方式。  
管理は容易になるが、負荷が集中してしまう点やサイトの障害によって分散データベースが利用できなくなってしまう欠点がある。  

**分散管理方式**  
DD/Dを複数のサイトに分散して保有する方式。さらに分散管理は、全てのサイトで重複してDD/Dを保有する方式と、重複なく保有する方式に分類することができる。  

[重複保有あり]  
自サイトが必ず必要な情報をもっているので、他のサイトに問い合わせる必要がないが、データ更新の際には全てのサイトのDD/Dを修正する必要がある。  

[重複保有なし]  
自サイトがもたない情報は他のサイトに問い合わせる必要があるが、データの更新の際にはその情報をもつサイトの内容だけを修正するだけで済む。  

### データウェアハウス

企業内に散らばっているデータの有効活用を目的に、過去から現在までの基幹系データベースや外部データベースを統合し、  
効果的な戦略的意思決定を支援するためのデータベースのことです。  

### データマート

データウェアハウスに格納されたデータから特定の用途に必要なデータだけを取り出し、構築する小規模なデータベースです。  

### データレイク(Data Lake)

川の流れのように絶えず流れ込んでくる多種多様な生データを、その規模にかかわらず、本来のフォーマットのまま蓄積しておく巨大な"貯水湖"です。  
蓄積するデータの生成元には、Webサイトやソーシャルメディア、モバイルアプリ及びIoTデバイスなどを含みます。  
蓄積されたデータは、機械学習、予測分析、データ検出、プロファイリングなどに役立てられますが、どのように使用するかは基本的に利用者に任せられています。  
収集する範囲を決めずにそのままのデータが一元的に管理されているため、分析の際に求めるデータが不足したり、他システムから寄せ集めたりといった問題がなくなります。  

### メタデータ

データについてのデータという意味で、データベースであればデータベース名やテーブル名、フィールド属性など本来のデータ付随する情報のことをいいます。  

### ビッグデータ（Big Data）

市販されているデータベース管理ツールや従来のデータ処理アプリケーションで処理することが困難なほど巨大で複雑なデータ集合の集積物を表す用語  

### データマイニング

1. データウェアハウスに蓄積されている大量の生データから、統計学的手法、数学的手法を用いて今まで知られていなかった規則性や因果関係を見つけ出す手法です。  
2. ビッグデータ等、大量のデータから統計学的手法などを用いて新たな知識(傾向やパターン)を見つけ出すプロセス。  
3. ニューラルネットワークや統計解析などの手法を使って，大量に蓄積されているデータから，特徴あるパターンを探し出す。  

### 分散データベースシステム

地理的に離れた場所にある複数のデータベースを論理的にまとめて1つのデータベースとしてアクセスできるようにしたものです。  
分散データベースを利用する際に、データベースが複数の場所に離れていることを意識せずに利用するために求められる性質を「透過性」といい、次の6つの種類があります。  

**位置に対する透過性(location transparency)**  
利用者はそれが配置されている位置を意識せずにデータベースを利用できること  

**移動に対する透過性(migration transparency)**  
データの格納サイトが変更されても、利用者のアプリケーションや操作方法に影響がないこと  

**分割に対する透過性(fragmentation transparency)**  
一つの表が複数のサイトに分割されて格納されていても、利用者はそれを意識せずに利用できること  

**複製に対する透過性(replication transparency)**  
同一のデータが複数のサイトに格納されていても、利用者はそれを意識せずに利用できること  

**障害に対する透過性(failure transparency)**  
あるサイトで障害が発生しても、利用者はそれを意識することなく利用できること  

**データモデルに対する透過性(data model transparency)**  
各サイトのDBMSが扱うデータモデルが異なっていても、利用者はそれを意識することなく利用できること  

### スタースキーマ

多次元データモデルを表現するように設計されたスキーマで、データウェアハウスの実装で用いられます。  
スタースキーマは、1つ以上のファクトテーブルと外部キーを介して関連付けられている1つ以上のディメンションテーブルで構成され、  
中心となるファクトテーブルに各ディメンションテーブルが結ばれた星(スター)型構造をもつため、このように呼ばれます。  

![!](https://www.ap-siken.com/kakomon/28_haru/img/31_1.gif)  

データウェアハウスでは多くの場合、データソースから抽出した分析対象の（トランザクション）データを少数のテーブル（ファクトテーブル）に格納します。  
そして、ファクトテーブルの外部キーから参照する主キーを持つマスタ系テーブル（ディメンションテーブル）に分析軸を格納します。  
このようにファクトテーブルを中心にして、ディメンションテーブルが周囲に配置されるデータモデルの構造を「スタースキーマ」と言い、  
関係データベースにおける多次元データベースの実装の一つです。  
スタースキーマでは、表の結合を少なくして処理を高速化するため、ディメンションテーブルはあえて冗長データをもたせて第2正規化までに留める（階層化しない）ことが一般的です。  

### スノーフレークスキーマ

スタースキーマのディメンションテーブルを正規化（階層化）した構造です。  
図3のデータモデルではディメンションテーブルが1階層に留まっているので、スノーフレークスキーマではありません。  

![!](https://www.ap-siken.com/kakomon/03_haru/img/pm06_6.gif)  

---

## 1回目に間違えた問題

DBMSが，3層スキーマアーキテクチャを採用する目的として，適切なものはどれか。
→
普通にわからなかったわ。
物理とか論理とかそんな感じでそもそも覚えていなかったので覚えましょう。
答えはズバリ、プログラムからの独立性を保障するためです。



データベースのアクセス効率を低下させないために，定期的に実施する処理はどれか。
→
答えは再編成。
始めて聞いた。何それまとめたい。



RDBMSが二つの表を結合する方法のうち，ソートマージ結合法に関する記述はどれか。
→
ある列をソートして、その結果についてマージする。
当たり前といえば当たり前。
答えを全部見る前にそれっぽいものを選んでしまった。



関係を第3正規形まで正規化して設計する目的はどれか。
→
第3正規形ってどこまでやったらそういえるの？
まずそこからだ。
関係を細かく分解する事？冗長性を排除する事？
そういうところも確認しないといけない。
割とナチュラルに間違った。ショック。



データ項目の命名規約を設ける場合，次の命名規約だけでは回避できない事象はどれか。
〔命名規約〕
データ項目名の末尾には必ず"名"，"コード"，"数"，"金額"，"年月日"などの区分語を付与し，区分語ごとに定めたデータ型にする。
データ項目名と意味を登録した辞書を作成し，異音同義語や同音異義語が発生しないようにする。
→
問題文に書いていない事を指摘すればよかっただけだった。
命名規則、データ型については名言されているが、値の範囲については指摘がないので、それを指摘しているのが答えだ。



平成28年春期　問26
関係モデルとその実装である関係データベースの対応に関する記述のうち，適切なものはどれか。
→
全く知らない。
どうやら関係モデルと関係データベースにはそれぞれ対応する概念があるらしい。
応用の参考書でも確認出来たが、覚えゲーである。
それぞれが何に対応するか覚えないと話にならない。
ドメインが型なのはいいとして、関係は表らしい。



平成29年秋期　問28
UMLを用いて表した図のデータモデルの解釈のうち，適切なものはどれか。
→
UMLの汎化、特価関係を復讐する必要がある。
以下答え全文。

社員は事業部に所属できる。
正しい。事業部クラスと部門クラスは汎化－特化関係にあり、事業部クラスは部門クラスを特化させた存在です。事業部は部門の一種であるため、親クラスである部門に社員が所属できるならば、子クラスの事業部にも社員が所属できます。

所属する社員がいない部門が存在する。
部門から見た社員の多重度は1以上です。すなわち社員が所属しない部門は存在しません。

部門は，いずれかの事業部が管理している。
部門から見た事業部の多重度は0または1です。すなわち事業部に管理されていない部門も存在し得ます。

事業部以外の部門が，部門を管理できる。
部門クラスとの間に"管理する"の関連名が付いているのは事業部→部門のみなので、事業部のみが部門を管理できます。



**平成26年秋期　問24**
ある企業では，顧客マスタファイル，商品マスタファイル，担当者マスタファイル及び当月受注ファイルを基にして，月次で受注実績を把握している。各ファイルの項目が表のとおりであるとき，これら四つのファイルを使用して当月分と直前の3か月分の出力が可能な受注実績はどれか。
→
こういう、テーブルからキーの連携をイメージする問題が苦手かも。
自分なりに落とし込む方法を解説を見ながら落とし込むしかないかな。
あー、でも当然といえば当然かもしれないが、各テーブルの連携項目を確認することがマストかな。
絶対にあるコードで連結できるので、連結させた結果、何が一番なのかってところまで最低限求めるべきかと思う。
→
それぞれのファイルを関係データベースの表と考えて表間の関連を整理すると次のようになります。
表の関連
関係データベースの結合演算で関係を持つことができるかどうかを考えてみましょう。
受注商品と顧客が関連つけられている受注記録は当月分しかなく、直前の3か月については顧客と商品についての対応が記録されているデータがありません。したがって〔イ〕と〔エ〕は出力できません。また商品と担当者間にも関連性がないため商品別の担当者別は出力できません。
唯一出力可能なのが〔ア〕で、顧客マスタファイルには担当者コードの列があるので、担当者コードと顧客コードをキーとして並び替えすることで当月と直前3か月分の担当者別顧客別受注実績が出力可能です。

担当者別の顧客別受注実績
正しい。各顧客は1人の担当者に関連つけられていて、顧客マスタには担当者コードがあるため、項目ごとに集計することで出力が可能です。

顧客別の商品別受注実績
受注商品と顧客が関連つけられている記録があるのは当月分だけで、前月～3カ月前についてはそれぞれの受注合計額のしかデータがないので出力できません。

商品別の担当者別受注実績
商品マスタファイルに受注した商品と担当者を関連付ける項目(担当者コード)がないので担当者別に出力することはできません。

商品別の顧客別受注実績
商品マスタファイルは顧客別には集計されていないので出力できません。
