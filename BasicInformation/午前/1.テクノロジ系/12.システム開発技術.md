# システム開発技術

---

## ソフトウェア要件定義

### アクティビティ図

ビジネスプロセスの流れやプログラムの制御フローのような一連の手続きを可視化できる図です。  
フローチャートのUML版を言えるでしょう。  
フローチャートと似た表記法で処理の流れを記述できるほか、処理の分岐やマージ、並行処理のフォークやジョイン、タイマ制御や例外処理なども表現できるようになっています。  

・ある振る舞いから次の振る舞いへの制御の流れを表現する。  
・多くの並行処理を含むシステムの，オブジェクトの振る舞いが記述できる。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/47.gif)  

### ユースケース図

システムが外部に提供する機能と，それを利用する者や外部システムとの関係を表現する。  

UMLの1つでシステムに要求される機能を、利用者(アクタ:actor)の視点から示した図です。  
主に要求分析段階でユーザの要件を特定するために作成され、ユースケース図を有効に活用することにより、  
システムの全体像を開発者と利用者が一緒に評価しやすくなる利点があります。  

#### アクタ

システムのユーザが果たす役割を表し、システムと活発に情報交換をしたり、システムから受動的に情報を受け取ったりする。人間、ハードウェア、外部システムがアクタになりえる。

#### ユースケース

アクタとシステムとの間の対話をモデル化したもので、アクタによって開始され、システムのある機能を実行する。システムのユーザがシステムを利用して遂行する単位業務のひとつを抽象化したもの。

#### 関連

アクタとユースケースの関連を表す実線

#### 対象

システム化対象範囲を表す長方形

![ユースケース図](https://www.ap-siken.com/kakomon/28_aki/img/46.gif)  

### 状態遷移図

一つのオブジェクトの状態がイベントの発生や時間の経過とともにどのように変化するかを表現する。
時間の経過や状態の変化に応じて状態が変わるようなシステムの振る舞いを記述するときに適した図式化手法です。
プロセス制御などの事象駆動(イベントドリブン)による処理の仕様を表現するときに適しています。

 50/ジュース
↓←←←
↓　　↑
○→○⇔○
みたいな感じの図。

### シーケンス図

オブジェクト間の相互作用を時系列で表現する。
横にオブジェクトを並べて縦を時系列として、左から右に矢印書いて、矢印の先の処理が終わったら左から右に矢印が戻る感じの図。

### コミュニケーション図

オブジェクト同士の関係の観点から表現する。
NAPTの解説で、クライアント↔ルーター↔サーバーってあって、各時点でのIPアドレスとポート番号の状態を表現する図があったじゃない。
あんな感じの書き方するのがコミュニケーション図。
シーケンス図もコミュニケーション図もオブジェクト間のメッセージのやり取りを表現する図。

### DFD(Data Flow Diagram)

構造化分析手法の一つでデータの流れに着目して、その対象となる業務のデータの流れと処理の関係をわかりやすく図式化する手法です。

○ : プロセス(処理)  
□ : データの発生源、行き先  
→ : データフロー  
＝ : データストア(一時的なデータの保管場所)  

![!](https://www.ap-siken.com/kakomon/27_aki/img/46.gif)  

データストアは、データが蓄積される場所を論理的に表現したものです。  
データストアは要求されたデータをプロセスに渡したり、プロセスから渡されたデータを蓄積する場所です。  
データストア同士がデータフローで結ばれることはありません。  

データの流れは必ずデータフローによって記述されます。  

### ペトリネット(Petri Net)

プレース、トランジション、トークンの3つの要素を使用した有向グラフでシステムの動作を記述する図法です。  
並行する処理同士の制御の流れや同期のタイミングを分析・設計するために用いられます。  
トランジションは入力プレースと出力プレースに連結され、プレースがトークンをもつとき条件を満たしていることを表します。  
入力プレースのトークンが所定数に達するとトランジションが発火し、トークンは入力プレースから出力プレースに移動します。  
このようにペトリネットでは、トークンの流れや処理の連鎖によってシステムの動作を分析します。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/46.gif)  

### CRUDマトリクス(クラッド図)

システムで管理対象となっているデータがどの機能によって生成(Create)され、参照(Read)され、更新(Update)され、削除(Delete)されるかを表形式で一覧化したものです。  
Create、Read、Update、Deleteの4つの操作の頭文字を取ると「CRUD」になります。  
CRUDマトリクスを作成すると、データと機能およびデータ操作のタイミングの関係性を俯瞰的に把握することができるので、  
設計段階において処理の矛盾や漏れといった課題を発見することに役立ちます。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/46.gif)  

### SysML(Systems Modeling Language)

ソフトウェア設計の用いられるUMLを、ハードウェアに関する記述を含めたものに拡張し、システム設計を行えるようにしたモデリング言語です。  
全部で次の9つの図法があり、UMLと全く同じもの、UMLの図を拡張したもの、SysML独自のものがあります。  

構造図
ブロック定義図、パッケージ図、内部ブロック図、パラメトリック図

振る舞い図
シーケンス図、ユースケース図、アクティビティ図、状態遷移図

要求図
要求図

### 決定表(デシジョンテーブル)

条件の組合せとそれに対する動作とを表現したものである。
ある事象について条件や選択肢を表形式で整理し、記述された条件・選択肢の組合せによってどのような処理を行うべきかを列挙したものです。
下記の例でいえば、表中の二重線より上が条件を記述する部分で、条件が成立するときは「Y」(Yes)、不成立の時は「N」(No)を記入します。
二重線より下が実行される処理を記述する部分で、条件の組合せによって実行すべき処理に「X」(eXecute=実行)を記入します。

平成26年秋期　問46

### E-R図(Entity-relationship Model)

データベース化の対象となる実体（エンティティ）と実体の持つ属性（アトリビュート）、実体間の関連（リレーションシップ）を表現する図です。
データをモデリングする方法で、関係データベースの設計によく利用されます。

**UMLのクラス図**  
クラス間の静的な関連を表現する図です。

**集約名**  
集約は、クラス間の「集約－分解」を表し、ひし形の白抜きを使用した矢印で記述します。

**クラス名**  
クラスは四角形で記述し、内部に、上段からクラス名、属性、操作が書かれます。(図のように属性と操作部分を省略してしまうこともあります)

**関連名**  
関連は、クラス間の結びつきを表し、クラス間の実線で記述します。
関連(association) -
集約(aggregation) ◇-
コンポジション(composition) ◆-
依存(dependency) ←+点線
汎化(generalization) ◁-
実現(realization) ◁-+点線

### 外部設計

ユーザからのシステム要件をもとにシステムの機能を確定する作業工程です。
ユーザの立場からみた業務機能を中心に設計を行うことが目的で、この作業工程ではサブシステムの定義と機能分割，
論理データモデル設計，画面・帳票・コードの設計などが実施されます。
画面レイアウト等

### 内部設計

外部設計の要件をコンピュータまたはシステム上でいかに効率よく動作させるかというシステム開発側の視点で設計が行われ、  
さらに次のプログラム設計ではプログラム内部構造の詳細設計が行われます。  
物理データベース仕様等  

### プラットフォーム開発

製造業の設計・開発において、複数の製品で共用する基盤部分(プラットフォーム)を最初に設計し、その共用部分を土台として複数の製品を実現していく手法のことです。  
多くのソフトウェアで同一のプラットフォームを用いることで、全てを専用の設計するよりも開発コストを抑えられる利点があります。  
従来、組込みソフトウェアはハードウェア上に直接ソフトウェアを構築するものでした。  
しかし、複雑化・肥大化を続ける組込みソフトウェア開発を効率化するために、ハードウェアとの間にリアルタイムOSとミドルウェアを置き、  
その上にソフトウェアを構築するスタイルが主流になっています。  

### 2段階エディット法

2つの別のチームに分かれて1つの対象プログラムに対してテストを行い、共通バグの発見率から全体の総エラー数を推定する手法を2段階エディット法といいます。  

まず、総エラー数のうちグループA，Bのバグ検出確率"P(A)"，"P(B)"は、

　P(A)＝NA／N　…(1)
　P(B)＝NB／N　…(2)

と定義することができ、そこからP(A)，P(B)が共に発生する"P(AB)"を、

　P(AB)＝
　P(A)×P(B)＝NAB／N　…(3)

と導くことができます。

![!](https://www.ap-siken.com/kakomon/27_aki/img/48.gif)  

(3)の式に(1)と(2)を代入すると、

　(NA／N)×(NB／N)＝NAB／N
　(NA×NB)／N2＝NAB／N

この式を次のように変形すると、

　(NA×NB)／N2＝NAB／N
　NA×NB＝NAB×N
　N＝NA×NB／NAB

---

## ソフトウェア方式設計・詳細設計

### オブジェクト指向

システムの構築や設計で、そのシステムの構成を処理や操作の対象となるもの(オブジェクト)同士のやり取りの関係として捉える考え方です。  
データと手続きをひとまとまりにしてカプセル化することで実現します。  

### カプセル化(情報隠ぺい)

オブジェクトの独立性を高めるため、内部をブラックボックス化することです。  
オブジェクトのデータとそれに対する操作をセットで定義し、外部からは特定の手続きだけの使用を許すことで実現します。  
この概念によって、たとえオブジェクト内部の仕様変更があった場合でも、使う人はそれを気にすることなく以前と同様にオブジェクトを扱えます。  

### 多様性(ポリモルフィズム)

オブジェクトへの操作呼び出しが、呼び出し側でなく受け手側の特性で決まる特性のこと。  
同じメッセージを送っても受け手によって行われる操作が異なる様子を示す。  

### 継承(インヘリタンス)

基底クラスの性質を派生クラスに受け継がせること。  
ある上位のクラスをもとに下位クラスを定義するとき、下位クラスに上位クラスの属性が引き継がれる性質のこと。  

### 抽象化

ある実体とてのオブジェクト群から共通する性質・要素・動作を引き出して、それらの事実を包括する概念を定義すること。  
例えば、人間がもつ性質を定義した人間クラスを作成すること、または人間、ゴリラ、サルから共通する要素を引き出し、霊長類クラスを作成することなどが抽象化に該当する。  

### 具体化

抽象化とは反対に、一般化されたクラスに、ある実体が持つ固有の性質・要素・動作を加えることで、その実体に特化した概念を定義すること。  
例えば、自動車クラスを特化させた、バス、トラック、自家用車などのクラスを定義することなどが具体化に該当する。  

### 委譲(デリゲーション)

あるオブジェクトに対する操作をその内部で他のオブジェクトに依頼する仕組み。  
オブジェクト指向において、あるオブジェクトに依頼されたメッセージの処理を、他のオブジェクトに委ねることをいいます。  

### 汎化

クラス間に共通する性質を抽出し，基底クラスを作ること。

### is-a(汎化－特化)関係

「動物－犬」や「家電－テレビ」などのように「…は、○○である」で表される関係。

### part-of(集約－分解)関係

「コンピュータ－CPU」や「自転車－サドル」などのように「…は、○○の一部である」で表される関係。

### クラス

いくつかの似ているオブジェクトに共通する性質を抜き出して、属性・手続きを一般化(抽象化)して新しく定義したもの。  
オブジェクトに共通する性質を定義したものがクラスであり，クラスを集めたものがクラスライブラリである。  

### サブクラス

基本クラス(スーパークラス)から派生して新しく定義されたクラスで、派生クラスや子クラスなどとも呼ばれます。  
基本クラスの属性やメソッドを継承し、それを基にサブクラス独自の特性を追加することができます。  
スーパークラスとサブクラスには「汎化－特化」関係、すなわち「サブクラスはスーパークラスである」という関係が成り立ちます。  

選択肢の中で「汎化－特化」関係なのは「トラックは自動車である」と言える〔エ〕だけなのでこれが正解となります。  
その他の選択肢「エンジン」「製造番号」「タイヤ」と「自動車」の関係は「×は○の一部である」という「集約－分解」関係に該当します。  

### オーバライド(Override)

上位クラスで定義されたメソッド(メンバ関数)を、下位クラスの役割に応じて再定義することです。  
オブジェクト指向ではこの方法によって「同じメッセージを送ってもオブジェクトごとに異なる操作が行われる」特性である**多相性**を実現しています。  
「オーバー(上に)　ライド(乗る=上書きする)=>スーパークラスのメソッドを上書きする」と覚えるといいかも  

### オーバーロード(Overload)

「引数や戻り値が異なるが名称が同一のメソッドを複数定義する」というオブジェクト指向プログラミングのテクニックである。  
「オーバー(上に) ロード(読み込む)=>メソッドを複数読み込む(上書きするわけじゃないから似たようなメソッドが沢山ある状態)」と覚えるといいかも。  

### MVC(model-view-control)

対話型アプリケーションを、モデル、ビュー、コントローラという3つのコンポーネントに分割して設計・実装するアーキテクチャパターンです。

#### モデル層

そのアプリケーションが扱う領域のデータと手続きを表現する要素。  
多くのアプリケーションにおいてはデータベースの機能が、この層に該当する。  

#### ビュー層

モデル層のデータを取り出してユーザが見るのに適した形で表示する要素。  
WebシステムではHTMLを生成して、動的にデータを表示するためのプログラムなどが、この層に該当する。  

#### コントローラ層

ユーザの入力に対して応答し、それを処理する要素。  
受け取った入力に応じてモデル層やビュー層に処理を依頼する。  

### データ中心アプローチ(DOA:Data Oriented Approach)

様々な要因により変更される可能性のある業務プロセスと比較して、データが安定した資源である事に注目して、  
データやデータ構造を中心に据えてシステム及びソフトウェアの設計を行う手法です。  

### 共通フレームによる、開発プロセスのうち設計部分

「システム要件定義→システム方式設計→ソフトウェア要件定義→ソフトウェア方式設計→ソフトウェア詳細設計」の順に行われると定義されています。  

### ソフトウェア方式設計

ソフトウェア品目に対する要件を，最上位レベルの構造を表現する方式であって，かつ，ソフトウェアコンポーネントを識別する方式に変換する。  
ソフトウェア方式設計は、ソフトウェアで実現する要件をソフトウェア方式に変換し、要件を達成するために必要なソフトウェア部品を定義するアクティビティです。  

作業項目  
1.ソフトウェア構造とコンポーネントの方式設計  
2.外部，コンポーネント間の各インターフェースの方式設計  
3.データベースの最上位レベルでの設計  
4.利用者文書(暫定版)の作成  
5.ソフトウェア結合のためのテスト要求事項の定義  
6.ソフトウェア方式設計の評価  
7.ソフトウェア方式設計の共同レビューの実施  

### 要件定義プロセス

顧客に意見を求めて仕様を決定する。

### ソフトウェアコード作成

プログラムを，コード化した1行ごとの処理まで明確になるように詳細化する。

### ソフトウェア詳細設計

要求内容を図表などの形式でまとめ，段階的に詳細化して分析する。

### 継承の分割

1つの継承階層で、2つの仕事をまとめて行っているときに、継承階層を2つに分け、一方を委譲によって呼び出すように再構成するリファクタリングのテクニックです。  
設問のクラス図を見ると、図形の継承階層において形状と線種の2つの仕事を行っているため、サブクラスで太線の描画機能に関するコードの重複が生じていることがわかります。  
コードの重複は機能の追加や変更を困難にする弊害があるため、これを解消することが目的となります。  

"継承の分割"では、補助的な仕事をするクラス及び継承階層を作成し、そのインスタンスを共通のスーパクラスに変数として持たせます。  
そして補助的な仕事をするクラスにサブクラスの変数やメソッドを移動します。  
サブクラスで保持する変数やメソッドがなくなれば、そのサブクラスは削除することができます。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/48u.gif)  
正しい。線種を図形から分離し、図形に線種を保持させているため"継承の分割"に当たります。  
乱れた継承が解消され、図形を追加するときも、線種を追加するときも、また別の描画機能を追加するのも容易になっています。  

---

## モジュール分割

![!](https://www.ap-siken.com/kakomon/28_aki/img/pm08_6.gif)  

### STS分割

プログラムを入力(Source)、変換(Transform)、出力(Sink)の3種類のモジュールに分割する

### TR分割（トランザクション分割）

トランザクションが分岐する地点を見つけて、主要データフローごとにモジュールを分割する

### 共通機能分割

分割したモジュールの中に同じ機能を持つものがある場合、それを共通モジュールとして独立させる

### ジャクソン法

入力データの構造と出力データの構造の関係を木構造で比較し、1対1に対応させ、そこからプログラムの構造を作成する
本問の図3～図5がジャクソン法による分割例です。

### ワーニエ法

データが「いつ・どこで・何回」使われるかを3つの制御構造(順次・選択・繰返し)で表し、それをそのままプログラム構造とする

---

## モジュール結合度

モジュール同士の関連性の強さを表す概念です。  
モジュール結合度が弱いほど関連するモジュールに変更があった場合の影響を受けにくくなるので、モジュールの独立性が高まり保守性が向上します。  

### データ結合 (結合が弱い↑、独立性が高い↑)

処理に必要なデータだけを単一のパラメータ（引数や返り値など）として受け渡している。  

### スタンプ結合

処理に必要なデータだけをデータ構造（レコードや構造体など）として受け渡している。  
struct

### 制御結合

もう1つのモジュールの制御要素(フラグなど)を受け渡している。  
他のモジュールを呼び出すときに，呼び出されたモジュールの論理を制御するための引数を渡す。  
フラグ引数とか、状態を定義したEnumを渡す見たな感じかな。  

### 外部結合

プログラムの外部で定義されたデータ形式やプロトコルを共有している。  
外部宣言された共通データを参照している。  
他のモジュールとデータ項目を共有するためにグローバルな領域を使用する。  

### 共通結合

共通域に宣言された共通データ(グローバル変数)を参照している。  

### 内容結合(結合が強い↓、独立性が低い↓)

お互いのモジュール内部を直接参照・分析している。  

---

## モジュール強度

モジュール内部の関連性の強さを表し、暗合的強度から機能的強度までの7種類があります。  
モジュール強度(結束性)が高いほど独立したソフトウェア部品として再利用や拡張がしやすくなります。  

### 暗合的強度(低)

関係のない機能をまとめたモジュール

### 論理的強度

関連する複数の機能をまとめたモジュール  
例)  
二つの機能A, Bのコードは重複する部分が多いので，A, Bを一つのモジュールにまとめ，A，Bの機能を使い分けるための引数を設けた。  

### 時間的強度

プログラムの開始時など、ある特定の時期に実行する機能をまとめたモジュール  
例)  
複数の機能のそれぞれに必要な初期設定の操作が，ある時点で一括して実行できるので，一つのモジュールにまとめた。  

### 手順的強度

関連ある逐次的な機能をまとめたモジュール

### 連絡的強度

関連ある逐次的な機能で要素が連絡し合うものをまとめたモジュール  
例)  
二つの機能A, Bは必ずA, Bの順番に実行され，しかもAで計算した結果をBで使うことがあるので，一つのモジュールにまとめた。  

### 情報的強度

同じデータ構造や資源を扱う機能を一つにまとめたモジュール  
例)  
ある木構造データを扱う機能をデータとともに一つにまとめ，木構造データをモジュールの外から見えないようにした。  

### 機能的強度(高)

一つの機能を実現するためだけのモジュール

---

## ISO/IEC9126(JIS X 0129)

ソフトウェアの品質特性として使用性を含んだ次の6つと、品質特性をブレークダウンした21の品質副特性を定めています。

### 機能性(Functionality)

目的から求められる必要な機能の実装の度合い  
副特性として合目的性，正確性，相互運用性，標準適合性，セキュリティが含まれる。  

### 信頼性(Reliability)

機能が正常動作し続ける度合い，障害の起こりにくさの度合い  
副特性として成熟性，障害許容性，回復性が含まれる。  

### 使用性（Usability）

分かりやすさ、使いやすさの度合い  
副特性として理解性，習得性，運用性が含まれる。  

### 効率性(Efficiency)

目的達成のために使用する時間や資源の度合い  
副特性として時間効率性，資源効率性が含まれる。  

### 保守性(Maintainability)

保守(改訂)作業に必要な労力の度合い  
副特性として解析性，変更性，安定性，試験性が含まれる。  

### 移植性（Portability）

移植のしやすさ，別の環境へ移した際そのまま動作する度合い
副特性として環境適用性，設置性，規格適合性，置換性が含まれる。

---

## ソフトウェア構築

### ホワイトボックステスト

プログラムの内部仕様に着目して行うテスト。
・プログラムの処理手順や内部構造に基づいて，テストケースを設計する。
・プログラムのすべての条件判定で，真と偽をそれぞれ1回以上実行させることを基準に，テストケースを設計する。
・プログラム仕様書の作成又はコーディングが終了した段階で，仕様書やソースリストを参照して，テストケースを設計する。

#### 命令網羅(網羅性:低い↑)

すべての命令を少なくとも1回は実行する。
命令を1回でも実行することが目的なので、判定条件の全ての組み合わせを実行する必要はない。
Trueの先だけに命令があれば、Trueのルートだけ検証して、Falseは全く考慮しない。

#### 分岐網羅(判定条件網羅)

判定条件の真偽を少なくとも１回は実行する。
2つ分岐があったら真-真、偽-偽の2パターンやればいいということ。

#### 条件網羅

判定条件が複数ある場合に、それぞれの条件が真・偽の場合を組み合わせたテストケースを設計する。  

お腹が空いたor嫌なことがあった→ケーキを食べる。という命題があった場合、
お腹が空いた→YES

お腹が空いた→NO
嫌なことがあった→YES

お腹が空いた→NO
嫌なことがあった→NO

の3つを調べればいいということ。

#### 判定条件・条件網羅

判定条件網羅と条件網羅を組み合わせてテストケースを設計する。

#### 複数条件網羅(網羅性:高↓)

判定条件のすべての可能な結果の組合せを網羅し、かつ、すべての命令を少なくとも1回は実行するようにテストケースを作成する。
お腹が空いたor嫌なことがあった→ケーキを食べる。という命題があった場合、
お腹が空いた→YES
嫌なことがあった→YES

お腹が空いた→YES
嫌なことがあった→NO

お腹が空いた→NO
嫌なことがあった→YES

お腹が空いた→NO
嫌なことがあった→NO

全て試すのが複数条件網羅。

#### ブラックボックステスト

入力と出力だけに着目して様々な入力に対して仕様書どおりの出力が得られるかどうかを確認します。  
手法としては「同値分割」「限界値分析」「原因－結果グラフ」「エラー推測」などがあります。  

システムの内部構造とは無関係に外部から見た機能について検証するテスト方法です。  
したがってプログラムの内部構造とは無関係にテストケースを作成する  
→プログラムの機能仕様やインタフェースの仕様に基づいて，テストケースを設計する。  

ブラックボックステストではプログラムの内部構造に着目しないため、被テストプログラムに冗長なコードがあっても検出できない。  

同値分割と境界値分析はブラックボックステストのテストケース作成手法です。  

#### 同値分割

正しい入力値のデータクラス、正しいデータ範囲の上限を超えて無効であるデータクラス、
正しいデータ範囲の下限を下回って無効であるデータクラスの3つのデータクラスに分割し、その中から1つの代表値を選んでテストケースとする。
入力値が整数に限定されており有効値が 0～50 である場合、「有効なデータ範囲 0～50」「有効値を下回る無効なデータ範囲 -∞～-1」「有効値を上回る無効なデータ範囲 51～∞」の中から、それぞれ適当な値を選択しテストケースとする。
例えば、-10,30,100等がテストデータとなり得る。

#### 境界値分析(限界値分析)

同値分割と同じようにデータ範囲を「有効値」及び「有効値超過」「有効値未満」の3つに分類するところまでは同じだが、
テストケースには有効範囲の上限値とそれを1つ上回る値、および下限値とそれを1つ下回る値を利用する。
入力値が整数に限定されており有効値が 0～50 である場合、境界分析のテストケースには「-1, 0, 50, 51」の4つが選ばれる。

![!](https://www.ap-siken.com/kakomon/30_aki/img/49.gif)  

### 静的テスト

プログラムを実行しない状態でプログラムの検証を行う手法で、構文チェッカ，コードオーディタ，モジュールインターフェイスチェックなどがあります。  

### 静的テストツール

構文チェッカ、コードオーディタ、モジュールインターフェイスチェックツールなどのプログラムを**実行しない状態**でプログラムの検証を行うためのツール。
構文チェッカー : プログラム中に文法上の誤りや論理的な誤りなどがあるかどうかを，ソースコードを分析して調べる。

### 動的テストツール

インスペクタ、トレーサ、スナップショット、メモリダンプ、カバレッジモニタ、アサーションチェッカなどのプログラムを**実行しながら**検証を行うためのツール。
カバレッジモニタ : テストの実行結果を基に，命令の網羅率や分岐の網羅率を自動的に計測し，分析する。
プロファイラ : モジュールの呼出し回数や実行時間，実行文の実行回数などの，プログラム実行時の動作特性に関するデータを計測する。

### 環境設定ツール

テストベッドツール、テストデータ生成ツールなどのテスト環境を準備するためのツール。
テストケース作成ツール : 指定された条件のテストデータや，プログラムの入力ファイルを自動的に生成する。
テストベッドツール : テスト対象モジュールに必要なドライバ又はスタブを生成する。

### バグ管理図

縦軸に検出バグ数、横軸にテストに要した時間またはテスト消化件数をとり、
一般的な信頼度曲線(S字カーブ)と比較することでプログラムの品質を判断するために用いられるグラフです。
テストの対象が設計・開発が問題なく進んだシステム／ソフトウェアであり、テストの質が妥当であれば、テストの中盤以降では内在するバグが徐々に少なっていくためバグの検出数は少なくなっていきます。

しかし図を見ると X の時点でのテスト当たりのバグの検出数がテスト初期と比較しても増加傾向にあることがわかります。
これはテスト対象の品質が著しく悪く、未だバグが数多く内在することを示しています。

令和元年秋期　問47
埋め込まれたエラー数をS，埋め込まれたエラーのうち発見されたエラー数をm，埋め込まれたエラーを含まないテスト開始前の潜在エラー数をT，発見された総エラー数をnとしたとき，S，T，m，nの関係を表す式はどれか。  
→

``` txt
$m/S=n−m/T$
→
埋め込んだエラー:S | 潜在エラー:T
                ↓ | ↓
                m  | x
            発見エラー総数:n
```

潜在エラーのうちテストで発見されたエラー数 = n－m (発見された総エラー数－埋め込まれたエラーのうち発見されたエラー数)

埋め込まれたエラーの発見率$m/S$ と潜在エラーの発見率$n-m/T$は同程度と考えられるので、 $m/S=n−m/T$ の関係式が成り立ちます。

### ソフトウェアの品質特性

ソフトウェアの品質を評価する基準となるものです。  

JIS X 25010:2013(ISO/IEC 25010)においては、機能適合性、性能効率性、互換性、使用性、信頼性、セキュリティ、  
保守性、移植性の8つの特性と、それぞれの品質特性をさらに細分化した32の副特性が定められています。  

![!](https://www.ap-siken.com/kakomon/28_haru/img/46.gif)  
![!](https://www.ap-siken.com/kakomon/01_aki/img/47.gif)  

#### 機能適合性(functional suitability)

明示された状況下で使用するとき，明示的ニーズ及び暗黙のニーズを満足させる機能を，製品又はシス テムが提供する度合い  

#### 性能効率性(performance efficiency)

明記された状態（条件）で使用する資源の量に関係する性能の度合い  

#### 互換性(compatibility)

同じハードウェア環境又はソフトウェア環境を共有する間，製品，システム又は構成要素が他の製品，  
システム又は構成要素の情報を交換することができる度合い，及び／又はその要求された機能を実行することができる度合い  

#### 使用性(usability)

明示された利用状況において，有効性，効率性及び満足性をもって明示された目標を達成するために，明示された利用者が製品又はシステムを利用することができる度合い  

#### 信頼性(reliability)

明示された時間帯で，明示された条件下に，システム，製品又は構成要素が明示された機能を実行する度合い  

中断時又は故障時に，製品又はシステムが直接的に影響を受けたデータを回復し，システムを希望する状態に復元することができる度合い  
信頼性の副特性である「回復性」の説明です。  

#### セキュリティ(security)

人間又は他の製品若しくはシステムが，認められた権限の種類及び水準に応じたデータアクセスの度合いをもてるように，製品又はシステムが情報及びデータを保護する度合い  

#### 保守性(maintainability)

意図した保守者によって，製品又はシステムが修正することができる有効性及び効率性の度合い  

製品若しくはシステムの一つ以上の部分への意図した変更が製品若しくはシステムに与える影響を総合評価すること，欠陥若しくは故障の原因を診断すること，  
又は修正しなければならない部分を識別することが可能であることについての有効性及び効率性の度合い  
保守性の副特性である「解析性」の説明です。  

#### 移植性(portability)

一つのハードウェア，ソフトウェア又は他の運用環境若しくは利用環境からその他の環境に，システム，製品又は構成要素を移すことができる有効性及び効率性の度合い  

---

## ソフトウェア結合・適格性テスト

### トップダウンテスト

上位モジュールをテストするテスト。
下位モジュールは未完成なので、代わりのモジュールであるスタブを使って適当な値を返してもらって、上位モジュールのテストを行う。
後ろから指す、もとい上に指すので、スタブという言葉はピッタリ。
トップダウンなので上から下にテストしていくイメージ。なので下から突き刺していく。

### ボトムアップテスト

下位モジュールをテストするテスト。
上位モジュールが未完成なので、代わりのモジュールであるドライバを使って適切に呼び出してもらって、下位モジュールのテストを行う。

モジュールの結合テストを行う場合に、モジュール構成の下位のモジュールから上位のモジュールへと順に結合しながらテストをしていく手法です。
未完成の上位モジュールの代わって下位モジュールの手続きを呼び出すドライバとよばれるテスト用のモジュールが必要になります。

テスト済みの上位モジュールが必要である。
上位モジュールはテスト用モジュール(ドライバ)を使用します。

開発の初期の段階では，並行作業が困難である。
開発初期の段階から下位モジュールを並行開発することが可能です。

### スタブ

モジュール結合テストの手法であるトップダウンテストにおいて必要となるテスト用のモジュールです。  
未完成の下位モジュールの代わりとして、テスト対象の上位モジュールからの呼び出しに対して、下位モジュールが返すべき適切な値を返却するなどの役割を担います。  

### ドライバ

未完成の上位モジュールに代わり、テスト対象の下位モジュールに適切な引数を与えて呼び出すなどの役割を担います。  

![スタブとドライバ](https://www.ap-siken.com/kakomon/29_aki/img/47.gif)  

### 状態遷移テスト

設計されたイベントと内部状態の組合せどおりにシステムが動作することを確認する手法。
設計段階でシステム要求事項をもとに作成した「状態遷移図」「状態遷移表」を使用して、システムが正しく挙動するかを検証するホワイトボックステストの手法です。
状態遷移図は、文章だけによる仕様書よりもシステムの持つ機能や全体像を感覚的に把握しやすくする役割を持ちます。
さらに状態遷移表は、システムの内部状態とイベントの組合せを漏れなくリストアップできるため、正常な動作だけでなく不正な遷移についても可視化できるメリットがあります。
この2つを組み合わせることで仕様書の漏れ・抜けをテストで発見しやすくし開発作業の手戻りを少なくする目的があります。

---

## 保守・廃棄

### リグレッションテスト

[1]  
退行テスト／回帰テストとも呼ばれ、システムに変更作業を実施した場合に、  
それによって以前まで正常に機能していた部分に不具合や影響が出ていないかを検証するためのテストです。  

[2]  
情報システムに変更作業を実施した場合に、それによって以前まで正常に機能していた部分に不具合や影響が出ていないかを検証するテストです。  
退行テストともいいます。  

### 運用テスト

システムの運用者が業務の流れに沿ってシステムのテストを行い、実際の稼働状況において不具合が発生しないかを検証するために実施されます。
業務の担当者がシステムの操作に慣れることも目的の一つです。

### 結合テスト

単体テストが終了したモジュール同士を組み合わせて行うテストで、主にモジュール間のインターフェイス(接点)が設計通りに機能するかを検証するために実施されます。

### システムテスト

システムとしての要件が満たされているかを検証するために行われるテストで、システム要件定義で定められた機能や能力がすべて備わっているかを確認する工程です。

### 是正保守

ソフトウェア製品の引渡し後に発見された問題を訂正するために行う受身の修正

### 予防保守

引渡し後のソフトウェア製品の潜在的な障害が運用障害になる前に発見し，是正を行うための修正

### 適応保守

引渡し後，変化した又は変化している環境において，ソフトウェア製品を使用できるように保ち続けるために実施するソフトウェア製品の修正

### 完全化保守

引渡し後のソフトウェア製品の潜在的な障害が，故障として現れる前に，検出し訂正するための修正  
※予防保守との違いは、利用者のための改良、ソフトウェア製品の性能強化、または保守性を改善するための修正という点  

訂正を目的とする保守のうち、(c)発見された問題に対して行うのが是正保守、(a)潜在化しているうちに問題を訂正するのが予防保守です。  
また、改良を目的とする保守のうち、(d)環境の変化に合わせるために行うのが適応保守、(b)潜在的な障害を見つけ改良を行うのが完全化保守です。  

---

平成31年春期　問49
条件に従うとき，アプリケーションプログラムの初年度の修正費用の期待値は，何万円か。

〔条件〕
1.プログラム規模：2,000kステップ
2.プログラムの潜在不良率：0.04件／kステップ
3.潜在不良の年間発見率：20％／年
4.発見した不良の分類
→影響度大の不良：20％，影響度小の不良：80％
5.不良1件当たりの修正費用
→影響度大の不良：200万円，影響度小の不良：50万円
6.初年度は影響度大の不良だけを修正する

→

プログラムの潜在不良率は1kステップ当たり0.04件なので、2,000kステップであるアプリケーションプログラムに含まれる総不良数は、以下のように計算できます。
　2,000×0.04件＝80個
このうち1年間に発見される不良数は全体の20%なので、初年度に発見される不良数は、
　80個×0.2＝16個
条件(6)より、初年度に修正対象となるのは影響度大の不良だけとわかります。不良数のうち影響度大の不良は、発見した不良数全体の20%なので、
　16個×0.2＝3.2個
影響度大の不良には1個当たり200万円の修正費用が掛かるので、修正費用の期待値は、
　3.2個×200万円＝640万円

→

なぜか正解した。
3番目の20%/年を2000kステップに対して当てはめるのか求めた80件に対して使うのか怪しかったが、
2000kに使うと数字がすごそうだったので、80件に使ってそのまま最後までやったらそれっぽい数字になった。
なので意味はわかっていないので解説を読むことにする。
