# 基礎理論

---

## 離散数学

### 基数関係

10進数→n進数 : 割り算 257mod2 = 1 余りをつなげていくやつ。少数は逆に掛け算。整数になるまで続ける。
n進数→10進数 : 掛け算 10の位 * n^2 + 1の位 + n^1


平成30年秋期　問1
16進数の小数0.248を10進数の分数で表したものはどれか。

→
小数点ではない場合、 $10の位*16^2+1の位*16^1$ ってやって10進に変換していたので、これも同じ要領でやればおｋ。
小数点だから指数の部分は-1乗されていく。

$2*16^{-1}+4*16^{-2}+8*16^{-3}$
$= 1/8 + 1/64 + 1/512$
$= 64/512 + 8/512 + 1/512$
$=73/512$


平成26年秋期　問1
10進数の分数1／32を16進数の小数で表したものはどれか。

→
16進を分数に変換してから当てはめるやり方でもいけるけど、少数の場合は掛ける事でも求められるはず。
解説サイトにはその方法が乗っていなかった。どちらもまとめる。
16進小数の各桁は、小数点の右に進むにつれて、

$0.1(16)→1／16(10)，$
$0.01(16)→1／256(10)，$
$0.001(16)→1／4096(10)，$
$0.00…00(16)→1／16n(10)$

というように、16-nを表しています。
1／32の分母を16進小数の小数点第2位の1／256と通分すると8／256になるので、小数点第2位を8にした0.08が正解となります。

まず、分数から整数(小数点）に変換します。
$１／３２＝０．０３１２５$
これを１６進数に変換するのですが、
小数点以下の数字を１６進数に変換する場合、整数部は１６で割っていきますが、少数点以下は逆に１６を整数になるまで、かけていきいきます。

０．０３１２５×１６ ＝０．５ なので、０．０です。
＝０．５×１６ ＝８ なので、８はそのまま数字を残し
０．０８ と、なります。
よって、１／３２の１６進数は０．０８ と、なります。



平成31年春期　問1
10進数の演算式7÷32の結果を2進数で表したものはどれか。

→
7/32 = 0.21875
0.21875 * 2 = 0.4375 : 0.0
0.4375 * 2 = 0.875 : 0.00
0.875 * 2 = 1.75 : 0.001
0.75 * 2 = 1.5 : 0.0011
0.5 * 2 = 1 : 0.00111

ってやったけど、分数に分解するとか2進数に変換してからビットシフト演算するとかやり方は色々あるみたいね。

【別解】
7÷32は7／32と表記できるので、これを
　4／32＋2／32＋1／32

と3つに分解します。さらに約分を施し、
　1／8＋1／16＋1／32

次のように分母を2の累乗で表すと、
　1／2^3＋1／2^4＋1／2^5

というように変換できるので、2進小数で表すと「0.00111」になります。

【別解】
10進数の7を2進数に変換すると111になります。さらに10進数の32を2の累乗で表現すると2^5になります。

つまり10進数の演算式「7÷32」は「7×(1／2^5)」というように、2進数の111を右に5ビットシフトする操作に置換えられる。
111を右に1ビットシフトすると11.1
111を右に2ビットシフトすると 1.11
111を右に3ビットシフトすると 0.111
111を右に4ビットシフトすると 0.0111
111を右に5ビットシフトすると 0.00111



平成26年秋期　問2
0000～4999のアドレスをもつハッシュ表があり，レコードのキー値からアドレスに変換するアルゴリズムとして基数変換法を用いる。キー値が55550のときのアドレスはどれか。
ここで，基数変換法とは，キー値を11進数とみなし，10進数に変換した後，下4桁に対して0.5を乗じた結果(小数点以下は切捨て)をレコードのアドレスとする。

→
n進数で表された数を10進数に変換できるかがポイントです。
キー値 55550 が11進数だとすると、桁ごとに11の累乗になっているので、10進数に変換するには、

　5×11^4＋5×11^3＋5×11^2＋5×11^1

という式の値を求めることになります。これを地道に計算してもよいのですが、ここでは速く解くために、まず式を変形(下線部分)してから解いています。

　5×11^4＋5×11^3＋5×11^2＋5×11^1
＝(11^3＋11^2＋11＋1)×55 ※
＝(1331＋121＋11＋1)×55
＝80520

最後に 80520 の下4けた「0520」に0.5を乗じると参照すべきアドレス0260が求められます。

※補足　式の変形
　5×11^4＋5×11^3＋5×11^2＋5×11^1
＝(11^4＋11^3＋11^2＋11^1)×5
＝(11^3＋11^2＋11＋1)×5×11
＝(11^3＋11^2＋11＋1)×55



### 無限少数

平成26年春期　問1
次の10進小数のうち，2進数で表すと無限小数になるものはどれか。

0.05
これに2を書けて行くと、小数部分が0にならない。そうなったら無限小数になる。

2進数の小数は以下のように1桁下がるごとに値が1／2ずつ小さくなっていきます。
0.1(2)＝1／21＝0.5(10)
0.01(2)＝1／22＝0.25(10)
0.001(2)＝1／23＝0.125(10)
0.0001(2)＝1／24＝0.0625(10)
0.00001(2)＝1／25＝0.03125(10)
2進小数で有限となるかどうかは、上記の値の組合せで表現できるか否かで判断します。
0.5
10進数0.5は2進数0.1で表現できます。
0.125
10進数0.125は2進数0.001で表現できます。
0.05
正しい。2進小数の各桁の組合せで表現できないので、0.05は無限小数となります。
0.375
0.375＝0.25＋0.125 なので、10進数0.375は2進数0.011で表現できます。



### 確立・比率計算

平成28年秋期　問2
ある工場では，同じ製品を独立した二つのラインA，Bで製造している。ラインAでは製品全体の60%を製造し，ラインBでは40%を製造している。ラインAで製造された製品の2%が不良品であり，ラインBで製造された製品の1%が不良品であることが分かっている。いま，この工場で製造された製品の一つを無作為に抽出して調べたところ，それは不良品であった。その製品がラインAで製造された確率は何%か。

→
60%で1%,40%で1%ならAの確立は60%と言えるだろう。
2%なのだから、60より上なのは間違いないが、なぜ75%と言えるのか求めることができなかったが、単純に比率で考えたらそうなるしかないのだ。

製品全体に対するラインAで製造された不良品の割合は、
　0.6×0.02＝0.012

同様にラインBで製造された不良品の割合は、
　0.4×0.01＝0.004

不良品の比率は、
　0.012：0.004＝3：1

であるため、調べた不良品がラインAで製造された確率は、
　3／4＝75(%)



### 丸め誤差、打ち切り誤差、情報落ち、桁落ち
<https://mathwords.net/marumegosa>  

#### 丸め誤差
ある桁以降を無視することによって生じる誤差のことです。
「0.1212121212 を 0.12 とみなして計算する」
桁数が多い小数を、途中で四捨五入したり、切り捨て・切り上げする場合。

#### 打ち切り誤差
無限級数のある項以降を無視することによって生じる誤差のことです。
「1+12+14+18+… という無限級数を計算したいが、18 までで打ち切る」

#### 情報落ち
絶対値が大きく異なる数を足したり引いたりすることで、小さい方の情報が無視されてしまう現象のことです。
「1.0000+0.0001 を計算したいが、有効数字５桁で計算すると計算結果が 1.0000 になってしまい、足し算の意味がない」

#### 桁落ち
近い数を引き算することで有効数字が少なくなる現象のことです。
「1.2345−1.2344 を計算したいが、答えは 0.0001 になってしまい、有効数字が5桁から1桁に減少する」
強引に有効数字5桁のように表すと、1.0000×10^−4 となりますが、小数点以下の4つの 0 は正しい保証が(意味が無い) 0 です。

##### ごにょごにょ
丸め誤差と打ち切り誤差はわかる。  
言葉通りだからね。  
情報落ちと桁落ちが毎回怪しい。  

情報落ちは物凄く大きな値と物凄く小さな値を足したり引いたりすることで発生する誤差。  
桁落ちは物凄く近い値同士を足したり引いたりすることで発生する誤差。  

桁落ちのほうが大きい値と小さい値を足して小さい値が反映されない(桁が落ちてる)=切り捨てられる感じがして、  
言葉のイメージ的に、しっくりくるのだが、世間ではそうではないらしい。  
まぁ、情報落ちもあっているいえばあっているか。  
小さい情報が丸々抜け落ちていることになるからな。  

桁落ちの本質は、有効桁以降の値を捨てること=落ちることにある。  
そのトリガーが近似値の加減算。
演算の結果が0.000001とかになるから、有効数字に合わせようと頑張った結果、存在しない桁は0で埋める。
その0埋め部分の結果が保証されない。  


### 浮動小数点表示における正規化
仮数部と指数部を調整することで、仮数部の最上位桁が0以外になるように桁合わせする操作です。
正規化の目的は、有効桁数を最大化し、丸め誤差をできるだけ少なくすることです。

例）小数第1位を仮数部の最上桁とする正規化
$10.75_{(10)} → 1010.11_{(2)} →(4ビット右にシフト)→ 0.101011_{(2)}×2^4$
$0.1875_{(10)} → 0.0011_{(2)} →(2ビット左にシフト)→ 0.11_{(2)}×2^{-2}$




### 逆ポーランド表記法(後置表記法)
演算子を演算の対称である演算数の右側に記述する記法。
構文木を深さ優先順で、帰りがけなぞりとして走査することで実現できる。

通常の式を、逆ポーランド表記法で表現するための基本は、A＋B(項 演算子 項) を AB＋(項 項 演算子)で表すことです。
これと一回使った演算子は2度使わないことに注意して、普通に計算式を解くのと同じ要領で行っていくことで逆ポーランド表記法の式になります。

<https://kojimanotech.com/2021/07/03/324/>

#### 中置→逆ポーランド

順序
1.１番目に計算する「数字演算子数字」を「数字数字演算子」に並び替える
2.１の後また並び替えができるか確かめる
3.並び替えができたら１に戻る。並び替えができなくなったらカッコをはずす
4.=があれば後ろに持っていく
5.並び替え終わったら終了

平成24年度 春期 基本情報技術者試験 午前 問4
後置表記法(逆ポーランド表記法)では，例えば，式 Y＝(A－B)×C を YAB－C×＝ と表現する。
　次の式を後置表記法で表現したものはどれか。
　　Y＝(A＋B)×(C－(D÷E))

１：(A+B)、(C-(D÷E))をそれぞれひとつの数字としてみなして並び替え
Y=(A+B)(C-(D÷E))×

２：D÷Eを並び替え
Y=(A+B)(C-(DE÷))×

３：(C-(DE÷))を並び替え
(DE÷)は一つの数字としてみなします。
Y=(A+B)(C(DE÷)-)×

４：A+Bを並び替え
Y=(AB+)(C(DE÷)-)×

５：カッコをはずす
Y=AB+CDE÷-×

６：=を後ろに持っていく
YAB+CDE÷-×=

#### 逆ポーランド→中置

ポイント
カッコは一つの数字とみなす。
順序

1.=があれば１つ目の数字の後ろに持っていく
2.左から見ていき、「数字数字演算子」の並びをみつける
3.２で見つけた「数字数字演算子」を「数字演算子数字」に並び替える
4.３で並び変えたらカッコをつける
5.２～４を繰り返す
6.並び替え終わったら終了

平成21年度 秋期 基本情報技術者試験 午前 問3
逆ポーランド表記法（後置表記法）で，“EF－G÷CD－AB＋÷＋”と表現される式はどれか。

１：EF-を並び替えてカッコつける
(E-F)G÷CD－AB＋÷＋

２：(E-F)G÷を並び替えてカッコつける
((E-F)÷G)CD－AB＋÷＋

３：CD－を並び替えてカッコつける
((E-F)÷G)(C-D)AB＋÷＋

４：AB＋を並び替えてカッコつける
((E-F)÷G)(C-D)(A+B)÷＋

５：(C-D)(A+B)÷を並び替えてカッコつける
((E-F)÷G)((C-D)÷(A+B))＋

６：((E-F)÷G)((C-D)÷(A+B))＋を並び替えてカッコつける
((E-F)÷G)+((C-D)÷(A+B))


### 集合演算

#### 分配法則


``` math
A∪(B∩C)＝(A∪B)∩(A∪C)\\
A∩(B∪C)＝(A∩B)∪(A∩C)
```

[理式の変形]
``` math
\bar{x}
　\bar{A}・\bar{B}・C＋A・\bar{B}・C＋A・B・C＋A・B・C\\
＝C・(\bar{A}・\bar{B}＋\bar{A}・B＋A・B＋A・B)　//分配の法則\\
＝C・(\bar{B}・(\bar{A}＋A)＋B・(\bar{A}＋A))　//分配の法則\\
＝C・(\bar{B}＋B)　\bar{A}＋A＝1\\
＝C　\bar{B}＋B＝1\\
```

$\bar{A}+A = 1 : ∀$
$\bar{A}・A = 0 : Φ$

### ドモルガンの法則

$\bar{A}\bar{∪}\bar{B} = \bar{A}∩\bar{B}$
$\bar{A}\bar{∩}\bar{B} = \bar{A}∪\bar{B}$


### その他

平成28年秋期　問1
8ビットのビット列の下位4ビットが変化しない操作はどれか。

一般に任意のビット列から特定のビット列を取り出したいときにはAND演算、
任意のビット列のうち特定のビット列を反転させたいときにはXOR演算を使うことができるので覚えておくといいでしょう。



平成28年春期　問1
数値を2進数で格納するレジスタがある。このレジスタに正の整数xを設定した後，"レジスタの値を2ビット左にシフトして，xを加える"操作を行うと，レジスタの値はxの何倍になるか。ここで，あふれ(オーバフロー)は，発生しないものとする。

→
下記の例のように、2進数のビット列をnビット左にシフトする操作は、元の数値を2n倍することと同じです（逆に右シフトの場合は1／2n倍です）。
2進数 11 を左に1ビットシフト → 2進数 110
数値（10進数、以下同じ）は、3 → 6 と 21倍＝2倍 になる
2進数 11 を左に2ビットシフト → 2進数 1100
数値は、3 → 12 と 22倍＝4倍 になる
2進数 11 を左に3ビットシフト → 2進数 11000
数値は、3 → 24 と 23倍＝8倍 になる
本問の操作を2つに分解して考えると、
**レジスタに格納された2進数(x)を2ビット左にシフト**
xを2^2倍、つまり4倍する
xを加える
**xを4倍した数値にxを足す**
という組合せなので、操作後のレジスタの値は元のxの値の5倍になります。


---

## 応用数学

### 正規分布
平均値を中心とする左右対称で釣鐘状の連続確率分布のこと
平均値を中心に左右対称の山のようなカーブを描く確率分布で、平均と標準偏差だけで分布に関する全ての特性が規定できるという特徴があります。

#### 標準偏差
データの分布のばらつきを表す尺度で、正規分布では平均値と標準偏差(σ[シグマ])、および度数の間に次の関係が成り立っています。
平均±σの範囲に全体の約68%が含まれる
平均±2σの範囲に全体の約95%が含まれる
平均±3σの範囲に全体の約99%が含まれる

例：平均が60、標準偏差が10の場合、標準偏差±σの範囲(60±10=)は50～70となる。

### ワイブル分布
故障確率に用いられ，バスタブのような形状をした連続確率分布のこと

### ポアソン分布
離散的に発生し，発生確率は一定である離散確率分布のこと

### 一様分布
全ての事象の起こる確率が等しい現象を表す確率分布のこと




令和元年秋期　問6
Random(n)は，0以上n未満の整数を一様な確率で返す関数である。整数型の変数A，B及びCに対して次の一連の手続を実行したとき，Cの値が0になる確率はどれか。
　　A＝Random(10)
　　B＝Random(10)
　　C＝A－B

→
Random(10)の返す値は整数0～9なので、Aがとり得る値は10種類、Bも同様に10種類となります。これより、確率の分母となるAとBの組合せ総数は次のように計算できます。
　10通り×10通り＝100通り

Cの値が0、すなわち「A－B＝0」となるのは、AとBが同じ値のときのみです。これは、A=B=0，A=B=1，…，A=B=9 というように全部で10通りあります。
したがって、Cの値が0になる確率は、
　10通り／100通り＝1／10



平成30年春期　問2
図の線上を，点Pから点Rを通って，点Qに至る最短経路は何通りあるか。

→
どの経路も「上方向に2回，右方向に2回」の移動を行うことは同じです。
4回行われる移動のうち上2回の位置が決まると自動的に右2回の位置も決定することから、経路の組合せ数は、4つの中から2つを選ぶ組合せ数と同様の計算で求めることができることになります。

つまり点Pから点Rに至る経路数は、組合せの公式※を用いて次のように求められます。
4C2＝(4×3)／2＝6(通り)

同様に点Rから点Qに至る最短経路数は、
5C3＝(5×4×3)／(3×2)＝10(通り)

最終的に求める点Pから点Rを通って，点Qに至る最短経路ですが、点Pから点Rに至る6通りのそれぞれに対して、点Rから点Qに至る10通りが存在するので、
6×10＝60(通り)

正解は60通りになります。


### 組合せ数の公式

n個の物からr個を選ぶ組み合わせ
$nCr = n! / (n-r)!r!$
$例:10C2 = 10*9 / 2*1 = 45$

---

## 計測・制御に関する理論

### フィードバック制御
出力結果と目標値とを比較して，一致するように制御を行う制御方式。
制御対象の現在の状態を定期的に測定し、その測定値を目標値に近づけるように動作する自動制御方式です。
室内の温度を一定に保つなどの自動制御システムで多く用いられています。
フィードバック制御では、外乱を検知せず、その修正動作は目標値と測定値の差異によってのみ決定されます。
したがって外乱が生じてもそれに対する修正動作は測定値に影響が現れてからになります。

### フィードフォワード制御
外乱の影響が出力に現れる前に制御を行う制御方式。
外乱自体を検知し、前もって出力への影響を打ち消すように動作します。
一般的に、フィードフォワード制御はフィードバック制御と組み合わせて使用されます。



平成28年春期　問4
PCM伝送方式によって音声をサンプリング(標本化)して8ビットのディジタルデータに変換し、圧縮せずにリアルタイムで転送したところ、転送速度は64,000ビット／秒であった。このときのサンプリング間隔は何マイクロ秒か。

→
**"転送速度は64,000ビット／秒であった"ということは、1秒ごとに64,000ビットのデータが生成されているということです。**
1回のサンプリング(標本化)で生成されるデータは8ビットですから、64,000を8で割れば、1秒間に何回サンプリングが行われているかがわかります。
　64,000÷8＝8,000回

1秒間に8,000回のサンプリングを行うためには、以下の周期(サンプリング周波数)でデータを取得する必要があります。
　1秒÷8,000回＝125マイクロ秒

因みに標本化→量子化→符号化ね。
量子化はアナログの数値をデジタル化できるように近似する作業。
符号化は0，1に変換する作業。


### アナログ,ディジタル変換

平成28年秋期　問5
アナログ信号からディジタル信号への変換では標本化、量子化、符号化の3段階で処理をします。

#### 標本化
時間的に連続したアナログ信号(振幅、周波数、電圧など)を一定の時間間隔で測定する

#### 量子化
標本化で得られた数値を整数などの離散値で近似する

#### 符号化
量子化で得られた整数値を2進数のビットに対応付ける


---

## 通信に関する理論

### CRC方式(Cyclic Redundancy Check，巡回冗長検査)
送信側では，ビット列をある生成多項式で割った余りをそのビット列に付加して送信し，
受信側では，受信したビット列が同じ生成多項式で割り切れるか否かで誤りの発生を判断する誤り検査方式。
送信データから生成多項式によって誤り検出用のデータを付加して送信します。
受信側では送信側と同じ生成多項式を用いて受信データを除算し、送信されてきた誤り検出用のデータと比較することで誤りの有無を判断することができます。
単純なパリティチェックでは検出できない偶数個の誤りやバースト誤りを検出できるという特長があります。
「生成多項式」というキーワードが出たらCRC方式と覚えましょう。この方式は他の誤り検出方式では使用されません。

### ハミング符号方式
ハミング符号は、情報ビットに対して検査ビットを付加することで、2ビットの誤り検出と1ビットの自動訂正機能をもった方式です。

### 垂直パリティチェック方式
垂直パリティチェック方式は、データに検査用のパリティビットを付加することによって誤りを検出する方式です。


### 水平パリティチェック方式
水平パリティチェック方式は、パリティビットを付加する方向が違うだけで垂直パリティチェックと同じです。

---

## 情報に関する理論

### 機械学習(Machine Learning)
コンピュータに大量の学習データを与え、数学的アプローチによって自律的にデータの特徴点を見出して、
コンピュータに人間のようなパターン認識や分類能力をもたせるAIの分野です。教師あり学習、教師なく学習、強化学習などの学習方法があります。
学習方法をプログラムしたコンピュータに大量の訓練データを与えることで、コンピュータ自らに事象の認識や分類方法を学習させ、
未知のデータに対しても学習結果に基づく推論を行うシステムを作る手法の総称です。

キーワード「大量のデータ。特定パターン。」

機械学習:
入力層→中間層→出力層

機械学習は、訓練データの性質によって「教師あり学習」「教師なし学習」「強化学習」の3つに大別できます（※強化学習を教師なし学習に含めることもあります）。

#### 教師あり学習
訓練データとして、ラベル(正解)付きデータを使用する学習方法。入力に対する正しい出力の例を与えることで、入力と出力の関係を学習させる。
例:正解のデータを提示したり，データが誤りであることを指摘したりすることによって，未知のデータに対して正誤を得ることを助ける。

#### 教師なし学習
訓練データとして、ラベルなしデータを使用する学習方法。クラスタリングなどのためにデータ構造を学習させる。
例:
正解のデータを提示せずに，統計的性質や，ある種の条件によって入力パターンを判定したり，クラスタリングしたりする。
教師なし学習の一つであるクラスタリングの説明です。
コンピュータ利用者の挙動データを蓄積し，挙動データの出現頻度に従って次の挙動を推論する。
教師なし学習の一つである協調フィルタリングの説明です。

#### 強化学習
正解データの代わりに、与えられた環境における個々の行動に対して得点や報酬を与える学習方法。一連の行動に対して評価値を与えることで、高い得点を取る、すなわち最良の行動を自律的に学習させる。
例:個々の行動に対しての善しあしを得点として与えることによって，得点が最も多く得られるような方策を学習する。

### ディープラーニング(Deep Learning)
中間層を増やして更なる推論をした奴。
人間や動物の脳神経をモデル化したアルゴリズム(ニューラルネットワーク)を多層化したものを用意し、
それに「十分な量のデータを与えることで、人間の力なしに自動的に特徴点やパターンを学習させる」ことをいいます。
人工知能分野における要素技術の1つで、深層学習とも呼ばれます。
従来の機械学習と異なり、中間層の多層化によって複雑なパターンの表現と計算を可能にしていることが特徴です。

キーワード「人間の脳を模倣。ニューラルネットワーク。」

ディープラーニング:
入力層→中間層→中間層→中間層→...→出力層


### オートマトン
現在の状態と入力信号の組合せだけによって次に遷移する状態が決まるモデルです。
初期状態のS1を例に挙げると、入力信号が0であれば再度S1に遷移し、入力信号が1であればS2に遷移するといった具合です。


### ハフマン符号化
可変長の符号化方式で、出現確率が高いデータには短い符号を、低いデータには長い符号を与えることで圧縮を効率よく行う方法です。
ハフマン符号では、符号化のビット列に全く同じ符号の並びが存在しないように、ある文字に対応する符号が、他の文字に対応する符号の接頭辞にならないように設定されます。
これにより単純に先頭から読んでいくだけでデコードができます。
```
010000111101011000101110111001
↓
01 00 00 111 10 10 110 00 10 111 01 110 01
↓
BAAECCDACEBDB
```
設問の表を見ると"00"、"01"、"10"、"111"は既に割当て済なので、Dにはこれ以外のビット列から開始する符号を与える必要があります。



平成27年秋期　問4
アナログ電圧をディジタル化した後に演算処理することの利点として，適切なものはどれか。

→
演算結果が部品精度，温度変化及び外来雑音の影響を受けにくい。

→
アナログ電圧は、値が時間的に連続的に変化する波として表されます。
ディジタル値への変換は、ある一定周期ごとにサンプリングした電圧値を8ビット(256段階)、10ビット(1,024段階)などで表現することで行います。

例として0V～8Vの範囲で変化するアナログ電圧を2ビットのディジタル値に変換する場合を考えてみます。
2ビットでは「00」「01」「10」「11」の4種類のビットパターンを表現できるので、次のように4段階に分けて数値化します。
2V以下 → 00
2V超～4V以下 → 01
4V超～6V以下 → 10
6V超～8V以下 → 11
アナログ値では外来ノイズが測定される値にダイレクトに影響しますが、ディジタル化ではある一定範囲内の値はすべて同じディジタル値に変換されることになります。
少々のノイズが有っても範囲内に収まっていれば変換後の値に変化はないので、ディジタル化された値はノイズの影響を受けにくい特徴があります。


### BNF(Backus-Naur Form)
バッカス・ナウア記法とも呼ばれ、XMLをはじめ多くのプログラム言語の構文定義に用いられている記法です。
BNFで使われている各記号は、「::＝」が左辺と右辺の区切り、「｜」がor(または)、「＜＞」は非終端記号を表しています。
それぞれのBNFは次のように解釈することができます。

＜数字＞
1～9までの1文字
＜英字＞
A～Fまでの1文字
＜英数字＞
＜数字＞または＜英字＞または"_"
＜変数名＞
＜英字＞1文字、または＜変数名＞の後ろに＜英数字＞が付いたもの

ある文字列が特定の非終端記号に合致するかどうかを判断する場合、文字を非終端記号に置き換えることを繰り返して、
最終的に目的の非終端記号(本問では＜変数名＞)の形になるかを考えていきます。


令和元年秋期　問7
次のBNFで定義される＜変数名＞に合致するものはどれか。

　＜数字＞::＝ 0｜1｜2｜3｜4｜5｜6｜7｜8｜9
　＜英字＞::＝ A｜B｜C｜D｜E｜F
　＜英数字＞::＝＜英字＞｜＜数字＞｜_
　＜変数名＞::＝＜英字＞｜＜変数名＞＜英数字＞

_B39
↓
＜英数字＞＜英字＞＜数字＞＜数字＞
↓
＜英数字＞＜英字＞＜英数字＞＜英数字＞
↓
＜英数字＞＜変数名＞＜英数字＞
↓
＜英数字＞＜変数名＞
先頭文字が"_"なので＜変数名＞には合致しません。

3E5
↓
＜数字＞＜英字＞＜数字＞
↓
＜数字＞＜英字＞＜英数字＞
↓
＜英数字＞＜変数名＞
先頭文字が＜数字＞なので＜変数名＞には合致しません。

F5_1
↓
＜英字＞＜数字＞＜英数字＞＜数字＞
↓
＜英字＞＜英数字＞＜英数字＞＜英数字＞
↓
＜変数名＞＜英数字＞＜英数字＞
↓
＜変数名＞＜英数字＞
↓
＜変数名＞
最終的に＜変数名＞に置き換え可能なので、BNFに合致する文字列となります。よって正解です。

【別解】
＜変数名＞は＜英字＞1文字、または＜変数名＞の後ろに＜英数字＞が付いたもの
解答群は、前者ではないため、後者でしかない。
＜変数名＞の後ろに＜英数字＞が付いたもの
↓
(＜変数名＞の後ろに＜英数字＞が付いたもの)の後ろに＜英数字＞が付いたもの
↓
((＜変数名＞の後ろに＜英数字＞が付いたもの)の後ろに＜英数字＞が付いたもの)の後ろに＜英数字＞が付いたもの
↓
・・・
つまり
＜変数名＞の後ろに＜英数字＞が一つ以上付いたもの
つまり
＜英字＞1文字の後ろに＜英数字＞が一つ以上付いたもの


---

## コラム

### じょう‐すう【乗数】
乗法（掛け算）で、掛けるほうの数。a×bのb。

### ひじょう‐すう【被乗数】
掛算で、掛けられるほうの数。a×b のa。


### SI単位系
10^15 : ペタ
10^12 : テラ
10^9 : ギガ
10^6 : メガ
10^3 : キロ
0
10^-1 : デシ
10^-2 : センチ
10^-3 : ミリ
10^-6 : マイクロ
10^-9 : ナノ
10^-12 : ピコ


### 指数・対数

指数と対数は根本的には同じもので、何を求めるかによって呼び方が変わります。

指数
a のべき乗「a^p=M」の答え M を求めるときの p の部分。

対数 log
その指数 p を求めるための道具。
log_aM は「a を底とする M の対数」と呼ぶ。

$M = a^p$
$p = log_aM$

M:真数
a:低
p:指数



### 仮数

か‐すう【仮数】
1.常用対数の値の、整数部分を除いた小数部分の値。
2.浮動小数点数における、基数および指数を除いた数値。「1.25×10^－4」の場合、基数「10」、指数「－4」を除いた「1.25」を仮数という。

<https://mathwords.net/kasuubu>  
ある数を、A×B^C という形で表現したとき、A を仮数部、B を基数、C を指数部と言う。

例えば、128 という数は、1.28×10^2 という形で表現することができます。
このように、A×B^C という形（ただし、A は 1 以上、B 以下）で表現された数を浮動小数点数と言います。
1.28 が仮数部、10 が基数、2 が指数部になります。
また、128 という数は、1×2^7 というように表現することもできます。この表現に対しては、1 が仮数部、2 が基数、7 が指数部になります。

練習問題
20.25 を（基数が 2 の）浮動小数点数として表現せよ。

解答
STEP1 20.25 を二進数で表す：
20.25=16+4+14=2^4+2^2+2^−2 なので，
20.25 を二進法で表現すると、10100.01 となります。

STEP2 仮数部の頭が 1 になるようにシフトする
二進法で 10100.01 という数は、1.010001×2^4 と表現することができます（4桁シフトしました）。
よって、答えは1.010001×2^4です。仮数部が 1.010001 で、指数部が 4 です。


これだけではなく、浮動小数点の構成の中でも色々あるみたいなのでまとめる。

### 浮動小数点

<https://www.macnica.co.jp/business/semiconductor/articles/intel/133327/>

浮動小数点とは、小数点の位置を固定せずに表現された数です。  
やってみればわかるけど、小数点の位置を自由に移動させられるので浮動というわけだ。
ふどう
【浮動】
《名・ス自》浮きただようように、定まらずに揺れ動くこと。
固定しないであちこちと移動すること。

参考のためにC#の浮動小数点型を記載しておく。

float   :  4バイト( 32ビット) ±1.5 x 10^−45 から ±3.4 x 10^38 6～9 桁  符号部に1ビット、仮数部に23ビット、指数部に8ビット
double  :  8バイト( 64ビット) ±5.0 x 10^−324 - ±1.7 x 10^308           符号部に1ビット、仮数部に52ビット、指数部に11ビット
decimal : 16バイト(128ビット) ±1.0 x 10^-28 から ±7.9228 x 10^28       符号部に1ビット、謎

一番小さいfloat型で考えたほうがいい。
基本として、符号部、指数部、仮数部で並ぶ。

符号部(1ビット) 指数部(8ビット) 仮数部(23ビット)

例題 : -10.25を浮動小数点で表現する。

①10.25を2進数に変換する。

10 = 1010
0.25 = 1 / 4 = 1 / 2^2 = 0.01
10.25 = 1010.01

1010.01を左に3ビットシフトする。
1.01001 * 2^3  

で、なぜか知らないが、先頭の1.の部分は破棄するらしい。  
01001

この地点での浮動小数点は  
1 _______ 0100 1000 0000 0000~~~


②指数部を求める  
左に3ビットシフトしたので、指数はもちろん3
0000 0011

それだけならいいのだが、指数部はオフセットバイナリ形式なので、バイアス値127との論理和となる模様。
0000 0011
0111 1111
1000 0010

1 1000 0010 0100 1000 ~~~~

というわけで完成らしい。
小数点を表さなければ単純に32ビット分の整数表示ができるのかなー。
概要はわかったけど色々謎である。
しかし、-10.25を変換できたわけだが、復元するときはこの逆をするってことか？メンド。

#### 浮動小数点の計算

<https://dobon.net/vb/dotnet/beginner/floatingpointerror.html>

要は、0.1は無限小数で絶対に誤差が生じるものだから、そんなものを足し合わせたら誤差が出て当たり前って事。

### 補数

<https://agency-star.co.jp/column/2-complement/>
元の数字に足すと次の桁上がりを起こす「最小」の数字のこと。
例えば、10進数の7の補数は3、77の補数は23といった具合です。
基数の補数ともいう。

補数作成手順
①ビット反転させる
②1を足す

例：
433-114 = 319
114の補数 = 886
433+886=1,319

最上位の桁を取り除けば加算でも減算と同様の結果が得られることが分かる。


8ビットの場合、2の補数表現を用いて表現できる範囲は「-128～127」です。
ビット数を「n」とした時に「-2^(n-1)〜2^(n-1)-1」の範囲が表現できる。
          符号なし 符号付き
0000 0000 0 0
0000 0001 1 1
0000 0010 2 2
0111 1111 127 127
1000 0000 128 -128
1000 0001 129 -127
1111 1110 254 -2
1111 1111 255 -1

127をマイナスにする。
0111 1111 : 127
→ビット反転して1を足す
1000 0001 : -127
→１を引く
1000 0000 : -128
というわけで、-128まで表現可能。

ちなみに128が本当に1000 0000についてだが、
1000 0000 : 128
→反転
0111 1111
→1を足す
1000 0000 : -128

128 + -128 = 0
 1000 0000
+1000 0000
 0000 0000
というわけで、辻褄はあっている。

先頭1ビットを符号と見立てる。0ならプラス。1ならマイナス。
0111 1111 がプラスの最大表現となるので、127がプラスの最大値となる。
先頭に1がついた場合の表現は上記表を参照。


補数表現の他に絶対値表現なるものがある。
先頭の0をプラス、1ならマイナスは補数と同じだが、その下の数をそのまま使う方式。

8ビット 27と-27の表記は以下のようになる。
0001 1011 : 27
1001 1011 : -27

ただ、こちらの方式は見た目のためにあるだけで、あまり使われない模様。
実際に計算させると意味が違うし、あくまでそういう表現もできるよねって物だけなのかもしれない。


#### 減基数の補数
元の数に足して桁上がりを起こさない最大の数。
7であれば2、77であれば22になるといった具合です。

1の補数ともいう。
ビットを反転させるだけで1の補数になる。


### 0.1を2進数で表す

<https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q148448134>

なんかしょっちゅう忘れる。  
0.25は簡単。
0.25 = 1 / 4 = 1 / 2^2 = 0.01

しかしこの考えで0.1を作ろうとすると死ぬ。
で、忘れたので調べた。
整数部分は割り算で求めるなら、少数は掛け算で求めるのだった。

小数部分が0になるまで繰り返す。
0.1は無限小数なので、綺麗になることはないが、とりあえずそれで求められる。

0.1
0.2
0.4
0.8
1.6
1.2
0.4
0.8
1.6
1.2
0.4
0.8
000011001100
最上位が整数部なので小数点を差し込んで0.00011001100。

0.25
0.5
1.0
0.01

因みに8進数だろうと16進数だろうとやることは変わらない。

試しに10進数の0.8359375を8進数に変換する。
0.8359375*8
=6.6875*8
=5.5*8
=4.0

というわけで、0.654。

---

## 1回目に間違えた問題

### 平成27年秋期　問4
アナログ電圧をディジタル化した後に演算処理することの利点として，適切なものはどれか。

→

電圧が変化してから演算結果を得るまでの遅延時間が発生しない。
先にデジタル化してから演算するので、遅延がないと思っていたけど、デジタル化に時間がかかればそもそも遅延となってしまうか。
ディジタル化に要する時間によって遅延が発生することがあります。

演算結果が部品精度，温度変化及び外来雑音の影響を受けにくい。
はて、回答だけ見てもさっぱりである。


### 平成30年秋期　問4
出現頻度の異なるA，B，C，D，Eの5文字で構成される通信データを，ハフマン符号化を使って圧縮するために，符号表を作成した。aに入る符号として，適切なものはどれか。

→
出現頻度が高ければ短くなって、低ければ長くなる程度でしか覚えていなかった。
後は、他の文字列と組み合わせた時に、被るか被らないかの違い。
被らない奴を選んだつもりだったのだが、よく見るとほとんど被るので、それっぽいやつを選んだらダメだった。

→

110
正しい。既存のどの符号からも始まっていないため適切です。
010
Bの符号"01"が接頭辞になっています。デコードの際に先頭部分がBに変換されてしまうため不適切です。
101
Cの符号"10"が接頭辞になっています。デコードの際に先頭部分がCに変換されてしまうため不適切です。
001
Aの符号"00"が接頭辞になっています。デコードの際に先頭部分がAに変換されてしまうため不適切です。

そういうことね。先頭から解読した時に、既にあるパターンはだめという事か。
そのパターンに合致した瞬間、その文字だと認識されてしまうから。


### 平成29年秋期　問4
図のような黒色で描かれた円に沿って車が走るように，左右の後輪に独立に取り付けられたモータL及びRの回転速度を制御する。センサL及びRは反射型光センサであり，センサが黒色に掛かる比率が大きいと出力値が小さくなり，黒色に掛かる比率が小さいと出力値が大きくなる。この車を円に沿って走行させるためのモータ回転速度の制御方法として，適切なものはどれか。ここで，二つのセンサの出力値が一致するときには，二つのモータの回転速度を初期値に戻すものとする。

→
日本語を読み解く問題です。
やりたいことはわかりますが、notだの何だの、多重に変換が設けられているので、頭の中だけでは限界があります。
ちゃんとメモ帳に書き出しながらやればワンちゃんあったのではないでしょうか。


### 令和元年秋期　問4
a及びbを定数とする関数 $f(x)=a/{t+1}$ 及び $g(t)=b/{t^2-t}$ に対して，  はどれか。
ここで，a≠0，b≠0，t＞1とする。

→
無限に発散した場合、例えばt=10の地点で見れば、
f(t) = a/11
g(t) = b/100-10
となって、g(t)の増加率が大きいので、無限に発散すると思ったが、よく考えてみると、分母がって話なんだよな。
g(t)だけを無限に発散させたら0に収束するわけで、それが分子にいるんだから、自然と0に収束していくはずなんだ。
なのに、無限と応えたのは最初のインスピレーションだけで、よく検証しないで答えたからだろう。
こういうところで自分が嫌になる。

→
まず、式中の lim について簡単な例を交えて少し説明しておきます。

式中のある変数が限りなく0に近づいたときや、無限大(またはマイナスの無限大)に限りなく近づいたときの式の値を考えることを数列の極限といいます。
極限値は lim の記号を用いて次の例のように表します。
$\lim_{h\to 0}(2+h) = 2$  … hが限りなく0に近づいたとき 2＋h の極限値は2である。  
$\lim_{h\to \infty}(2+h) = \infin$… hが限りなく無限大(∞)に近づいたとき 2＋h の極限値は∞である。
同様に関数中のある変数が0又は無限大に限りなく近づいたときの関数の値を関数の極限といいます。

これを踏まえて $\lim_{t\to \infin}{g(t)/f(t)}$ の値を求めます。
$g(t)/f(t)$  を変換すると次のような形になります。
$g(t)/f(t) = {b/{t^2-t}} ÷ {a/{t+1}} = b(t+1) / a(t^2-t)$
tが増えると、 
 
 というように分子の増加量よりも分母の増加量が多く0に近づいていくので、t→∞のとき $g(t)/f(t)$ の値は限りなく0に近づきます。


### 平成30年春期　問1
ある整数値を，負数を2の補数で表現する2進表記法で表すと最下位2ビットは"11"であった。10進表記法の下で，その整数値を4で割ったときの余りに関する記述として，適切なものはどれか。ここで，除算の商は，絶対値の小数点以下を切り捨てるものとする。

→
負数を2の補数での表現。
いつぞや、ネットで記事を漁って納得したが、忘れた。
マイナスになるって事は11が単純に4になるわけではないとは思ったんので、それっぽい奴を選んだが、
まさか整数値が正の時に3になるとは思わなんだ。
回答をそのまま使う。
あと、余りがマイナスになることがあるのか不思議でならなかったので、解説を読み込むことにする。

→
設問では「ある整数値を…2進数記法で表すと最下位ビットが"11"であった。」としていますが、最下位2ビットが"11"となる整数値の特徴は正負によって異なります。

[正の数の場合]
正の数に対しては2の補数を適用しないので、2進数表現 xx…x11 をそのまま10進数に直すことを考えます（xは任意のビット）。最下位2ビットが"11"となる正の数は、
・111(2) → 7(10)
・1011(2) → 11(10)
・10111(2) → 23(10)
・110011(2) → 51(10)
というように、常に「4で割った余りが3である数」になります。これは4で割るという行為が2進数のビット列を右に2つシフトさせることと同義だからです。ビット列全体を右に2つシフトさせると、"11"（＝10進数で3）の部分が端数（＝除算の余り）となります。

[負の数の場合]
2の補数に変換したときと逆の手順で、その負数の絶対値を示すビット列を求めます。
1.xx…x11 から1を引く。
　xx…x10
2.全てのビットを反転させる。
　xx…x01 //絶対値の2進数表現
これにより、2の補数表現で最下位2ビットが"11"となる負数があるとき、その負数の絶対値の最下位2ビットは必ず"01"になることがわかります。最下位2ビットが"01"となる数は、
・101(2) → (絶対値)5(10) → (負数)－5(10)
・1001(2) → (絶対値)9(10) → (負数)－9(10)
・10101(2) → (絶対値)21(10) → (負数)－21(10)
・110001(2) → (絶対値)49(10) → (負数)－49(10)
というような数の集合になります。これらの負数を4で割ると余りは 3 または －1 になります。ここで、設問の「除算の商は，絶対値の小数点以下を切り捨てるものとする。」という条件を適用すると、
・－5÷4＝－1.25 → 絶対値の小数点以下を切り捨てると商は－1
商が－1ならば余りは－1
・－9÷4＝－2.25 → 絶対値の小数点以下を切り捨てると商は－2
商が－2ならば余りは－1
というように、常に「4で割った余りは－1」になります。

以上より、最下位2ビットが"11"である整数値を4で割った余りは、その整数値が正ならば3、負ならば－1になります。よって〔ウ〕の記述のみが適切です。

**2の補数**
マイナスの数をプラスの数で表す表現方法を「補数（ほすう）」という。
2進数で負数を表現する方法の一つです。ある負の数を2の補数で表すには、①その負の数の絶対値を2進数に直し、②すべてのビットを反転して、③その結果に1を加えます。

例えば、10進数表記の -10 は以下の手順で2の補数に変換します。
1.-10の絶対値である10を2進数に直す。
10(10) →　1010(2)
2.1010(2)の全ビットを反転させる。
1010(2) → 0101(2)
3.②の結果に1を加える。
0101(2) → 0110(2)

-10の補数は6。
例えば正の12と計算をしてみる。

12+(-10) = 2
1100 + 0110 = 10010

先頭の1を無視すると答えは2になるので辻褄はあっているというわけ。


### 平成29年春期　問2
0以外の数値を浮動小数点表示で表現する場合，仮数部の最上位桁が0以外になるように，桁合わせする操作はどれか。ここで，仮数部の表現方法は，絶対値表現とする。

→
正規化なの！？しらねー。まじか。
こういうのがあるから油断できないんだよな。
