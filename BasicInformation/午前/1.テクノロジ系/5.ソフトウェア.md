# ソフトウェア

---

## オペレーティングシステム

### プリエンプティブとノンプリエンプティブ

プリエンプティブとノンプリエンプティブは、共にマルチタスクOS上で実行されているプログラムを切り替えるときの方式です。  

preemptive :  
先買の、先取権のある、先制の  
→プログラムの実行を先取り  

※実行プログラムの切り替えのことを「コンテキストスイッチ」と呼びます。  
※1つのCPUで複数のタスクを実行するときに、PSW(Program Status Word)や主記憶アドレス空間の内容をタスクごとに切り替る操作  

### プリエンプティブ(プリエンプション方式)

OSがCPUやシステム資源を管理し、CPU使用時間や**優先度**などにより複数のタスクを実行状態や実行可能状態へ切替えながら実行していくマルチタスク方式をプリエンプション方式といいます。  

※プリエンプティブ方式を実現するには，OSがプロセスを強制的に切り替えて実行する機構が必要になる。  

※残余処理時間順は、残りの処理時間が短いと推定されるタスクから優先的に処理していく方式です。  
実行中のタスクよりも残り処理時間が短いタスクが実行可能状態になった場合、OSによりタスクの切替えが行われます。  
※優先度順方式では、実行中のタスクよりも優先度の高いタスクが実行可能状態になった場合、OSによりタスクの切替えが行われます。  
※ラウンドロビン方式は、実行可能状態となった順に従ってタスクに一定のCPU時間(タイムクウォンタム)を与えていくタスクスケジューリング方式です。  
一定時間内に処理が終わらなかったタスクは、OSにより実行可能状態の待ち行列の最後尾に移されます。  

### ノンプリエンプティブ

マルチタスクOS上で実行されているタスクの切替をプログラム自身に任せ、プログラムがCPUを自発的に開放したタイミングで他のタスクへの切り替えを行うマルチタスク制御方式のことをいいます。  
OSがCPUを管理しないので、1つのプログラムを実行中は、その他のプログラムの実行は制限されます。  

※到着順方式は、実行中のタスクが終了するまでタスクの切替えが行われないという特徴があるため、ノンプリエンプション方式に分類されます。  

### ディスパッチ

実行可能状態から実行状態にすること。  

実行可能なタスクに対してプロセッサの使用権を割り当てること。  
OSによるタスク管理の制御機能の1つで、実行可能状態のタスクの中から優先度順などによって次に実行すべきタスクを選択して、CPUの使用権を割り当てることです。  
ディスパッチを行うプログラムをディスパッチャ(Dispatcher)と呼びます。  

disから始まるので、イメージ的には使用権を剝奪する印象を受けるが逆なんだよなー。  

### プリエンプション(Preemption)

[1]  
実行状態にあるタスクがOSの制御によりCPUの使用権を奪われ**実行可能状態**に移されることをいい、以下の状態を満たした場合に起こります。  

・実行状態のタスクより優先度の高いタスクが実行可能状態になる  
・実行状態のタスクに割り当てられたCPU使用時間が満了する  

![!](https://www.ap-siken.com/kakomon/30_aki/img/17.gif)  

[2]  
コンピュータ上で実行中のプログラム（タスク）を強制的に一時中断し、他をプログラムの実行に切り替えること。  
オペレーティングシステム（OS）のタスクスケジューラが実行中のアプリケーションに対して行う操作の一つ。  

OSの動作は、A・Bの優先度及びA・Bの状態によって変わります。  

[Aの実行中にBに起動がかかる]  
タスクの優先度は「A＞B」なので、Bは実行可能状態となり、Aの実行が継続されます。  
待ち状態は、入出力待ちなどですぐにCPU処理に移れないタスクが遷移する状態なので、Bは待ち状態ではなく実行可能状態に移されます。  

[Bの実行中にAに起動がかかる]  
タスクの優先度は「A＞B」なので、Bは実行可能状態に移され、AにCPU使用権が与えられます。  

**実行状態**  
**実行可能状態**  
**待ち状態**  
実行状態のタスクに入出力要求が入ったら待ち状態になり、入出力が完了したら実行可能状態になる。

### タスクスケジューリング

各タスクの実行順序を決定すること

### マルチタスクまたはコンカレント処理

一つのプロセッサで複数のタスクを同時に実行しているかのように見せかけた状態のこと  

コンカレント:同時並行  

### タスクの内部状態、置かれた状況、タスクID及び優先度などを保持するTCB(Task Control Block，タスク制御ブロック)

タスクの実行に必要な情報であるコンテキストのこと

### リアルタイムOS(RTOS)

リアルタイム制御が必要とされるシステム用に特化したOSです。  
リアルタイム制御とは、ジョブの実行が命令された時、限られた資源を使用して、その処理を決められた時刻(デッドライン)までに終了させること目的とする制御方式をいいます。  
**リアルタイム処理では目標時間内に処理を完了させることが最重要です。**  
そのため重要度が高い、あるいはデッドラインが近いタスクに、より高い優先度を与えることで、実行するタスクの順序を強制的に入れ替えることのできる優先度制御方式が適しています。  

### 到着順方式

起動が早いタスクから順番に処理を行う場合に利用される。  

### ラウンドロビン

実行可能状態となった順に従って、タスクに一定のCPU時間(タイムクウォンタム)ずつ与えていくタスクスケジューリング方式です。  
一定時間内に処理が終わらなかったタスクは、実行可能状態の待ち行列の最後尾に移され、次にCPU使用権が与えられるまでの間は待ち状態となります。  
各タスクに均等にCPU時間が与えられるためタイムシェアリングシステムに適しています。  

### タイムシェアリングシステム

1台のコンピュータをCPU時間で分割し、複数のユーザで利用できるようにしたシステム  

### 処理時間順方式(Shortest Processing Time First)

タスクの横取りがない（ノンプリエンプティブな）スケジューリング方式で、処理時間の短いタスクを優先的に実行します。  
新たなタスクが到着すると処理の待ち行列に加わり、CPUが空くと待ち行列の中から最も（予想）処理時間の短いタスクが選択され、実行状態に移されます。  

### 残余処理時間順方式

処理時間が短いタスクから順番に処理を行う場合に利用される。  

### ポーリング制御

主となるシステムが他のシステムに対して一定間隔で順繰りに要求がないか尋ねる方式。  
ループにより各部の情報を一定時間ごとに順番に収集し、その情報をもとにソフトウェアの状態を判断して処理を行う制御方式です。  
システム上でいつ発生するか分からないイベントを監視する目的で設定されます。  
CPUが状態レジスタ又はビジー信号などを読み出して，入出力装置の状態を監視する。  

### 排他制御

複数のタスクが利用する共有資源を，一つのタスクが占有できるようにする。  

### タスク間同期制御

送信側のタスクがメモリにデータを格納し，受信側のタスクにそのアドレスを伝える。  

### 割込み

実行中の処理を一時的に中断して，緊急度の高い別の処理を実行する。

### 仮想メモリ

メモリっぽい役割が与えられたハードディスクの一部分。  
メインメモリが足りなくなった時にハードディスクの一部を無理やりメモリとして使う。  
Linuxのswap領域のあれ。  

1.メモリの内容をハードディスクにしまう  
2.使いたくなったらハードディスクから取り出す  

の2つの動きです。  
「メモリとハードディスクの間でメモリの内容を移動させる」ということになる。  

### 仮想記憶

仮想記憶は、磁気ディスク装置などの補助記憶装置を使用して、主記憶の見掛け上の容量を増加させる仕組みです。  
現在実行中のプログラムで使う部分を主記憶に、優先度の低い部分を補助記憶装置（仮想記憶）に退避させ、プログラムの実行に合わせて主記憶と仮想記憶の間でデータの入れ替えを行うことで、主記憶の実容量で扱えるよりも大きな、または多くのプログラムを同時に展開できるようにしています。  

仮想記憶の代表的な方式であるページング方式は、主記憶をページという固定長のブロックで分割、仮想記憶も同じようにページ単位に分割してページ単位で管理します。  
補助記憶には主記憶で使われることを待っているページが格納されていて、あるページがプログラムから要求されると、補助記憶から主記憶にはそのページが移されます。  
逆に主記憶から追い出されたページは補助記憶上に格納されています。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/19.gif)  

※ページアウトによって主記憶から追い出されたページは、補助記憶に格納され、次にページインするときを待ちます。  
※仮想記憶は主記憶のバックアップではありません。  
※仮想記憶方式において，論理アドレスから物理アドレスへの変換を行うのは「主記憶に存在するページをアクセスするとき」  

### ページテーブル

仮想(論理)アドレスと実(物理)アドレスへの変換は、ページテーブルというアドレス対応表を使って次の手順で行われます。  

1. 仮想アドレスから、ページテーブル内の対象ページの先頭アドレスを得る  
2. ページテーブルのページ情報に設定されているフラグ(ページフォールトビット)を見て、対象ページが主記憶に存在しているかを知る  
3. ページフォールトであればページアウト・ページイン処理を行う  
4. ページテーブルから対象ページの主記憶上の位置を取得し、それに仮想アドレスのページ内変位を加えて求める主記憶上のアドレスを得る  

仮想アドレスから実アドレスへの変換は、動的アドレス変換機構(DAT)というハードウェア機構が**命令実行の度**に上記の処理を行い、仮想アドレスから実アドレスを算出しています。  
アドレス変換はアクセスごとに行われるので、正しい記述は「主記憶に存在するページをアクセスするとき」です。  

### ページング

プログラムやデータを分割して記憶領域を管理しコンピュータの仮想記憶を実現するための方式です。  
ページングでは、仮想記憶(補助記憶装置)と実記憶(主記憶)間のデータの受け渡しをページという固定長の単位で行いますが、このページのやり取りは「ページフォールトが発生したときに主記憶のどのページを置換えるか」および「どのページをどのタイミングで主記憶に読み込むか」という二つのアルゴリズムに基づいて管理が行われます。  

前者の置換え対象を決定する方法としては、LRU(Least Recently Used)やFIFO(First In First Out)があり、後者の読込み対象と読込むタイミングを決定するアルゴリズムとしては、この設問で問われている「デマンドページング方式」や「プリページング方式」があります。

### デマンドページング

デマンド(demand)とは要求を意味する英語で、その名の通りアクセス要求があった時に要求があったページのみを主記憶に読み込む方式。  
メモリ使用量を節約できる、プログラム開始時の主記憶へのロードによる遅延がない、ページの読込みが最小限で済むなどの利点があり、実際のOSでは基本的にこの方式が用いられている。  

### プリページング

ページにアクセス要求がある前に、前もって参照されそうなページを主記憶に読み込んでおく方式。  
アクセス要求があった時に周辺のページも同時に主記憶に読み込んだり、プログラムのロード時にたくさんのページを読み込んでおくことで、メモリ使用量は増加するがメモリアクセスの効率を向上させることができる。  

### ページング方式

仮想記憶管理方式の一つで仮想アドレス空間を「ページ」と呼ばれる**固定長**の区画に分割するとともに主記憶のアドレス空間（実アドレス空間）も同じように固定長に分割して、このページ単位で主記憶と仮想記憶（補助記憶装置）のアドレス変換を行う方式です。  

ページング方式の仮想記憶において、プログラムの実行に必要なページが主記憶（実メモリ）上に存在しない場合、システムは「ページフォールト」という割込みを発生させます。  
ページフォールトが発生すると、主記憶と仮想記憶間でページの入替えが行われます。  
この入替え動作において、主記憶から仮想記憶にページを退避することを「ページアウト」、仮想記憶から主記憶にページをロードすることを「ページイン」といいます。  

※ページは固定長  
※ページインはページフォールトを契機にして実行されます。  
※ページング方式はフラグメンテーションは発生しない。  
※主記憶を効率よく使える  
→
処理に必要なページを動的に主記憶に割り当てることによって，主記憶を効率的に使用できる。  
ページング方式ではプログラムに割り当てるメモリが連続である必要がなく、大きなフラグメンテーションがほとんど発生しないため、メモリを無駄にしないというメリットがあります。  

ページング処理の順番としては、次のような流れになります。

1. 主記憶上に必要なデータが存在しない状態が発生する（ページフォールト）  
2. **主記憶に空きがなければ**、置換アルゴリズム(FIFOやLRU)が主記憶上から仮想記憶に移すページを決定する  
3. 置換え対象のページを主記憶から仮想記憶に退避させる（ページアウト）  
4. 実行に必要なページを仮想記憶から主記憶に移す（ページイン）  

[わかりそう](https://wa3.i-3-i.info/word13352.html)  

仮想メモリの話でよく出てくる用語で、メモリを決まった大きさのページ単位で管理するやり方。  
仮想記憶管理方式の一つで仮想アドレス空間を「ページ」と呼ばれる固定長の区画に分割，同時に主記憶上も同じように固定長に分割して、  
このページ単位で主記憶と補助記憶装置のアドレス変換を行う方式です。  
エクセルとかワードをメモリにロードしたときに、それらを十字に切って、1つ1つ(ページ)を仮想メモリとやり取りするイメージ。  

#### 令和3年春期　問19

ページフォールトは、必要なページが主記憶上に存在しないときに起こるので、必ずそれに伴いページインが発生します。  
よって、ページフォールト＝ページインです。  
一方、ページフォールトが発生しても主記憶上に空きがある場合には、ページアウトを行わずにその空き領域に必要なページを移動すれば済みます（上記②③が実行されない）。  
すなわち、ページアウトの回数はページフォールトの回数よりも少なくなる可能性があります。  
よって、ページフォールト≧ページアウトです。  

ページフォールト＝ページイン≧ページアウト  

### ページフォールト

[1]
プログラムの実行に必要なページが主記憶に存在していないときに発生する割込みです。  
ページフォールトが発生すると、ページアウトやページインなどのページ置換え処理が実行されます。  

[2]
ページフォールトは、主記憶に存在しないページへのアクセス要求があって初めて発生します。  
すなわち主記憶に存在するページにアクセスしている限りは発生しません。  
つまりページフォールトの増加原因として適切な事象は、「主記憶に存在しないページへのアクセスが増加すること」です。  

### ページイン

仮想記憶上のページを主記憶に移動させる処理

### ページアウト

主記憶上のページを仮想記憶に移動させる処理

### セグメント方式

ページングがページと呼ばれる単位に細切れにして管理する方式なら、こちらはファイルごと移動させるやり方。  
まとめて移動させる固まりを「セグメント」として、メモリとやり取りする。  

### スプーリング

プリンタなどの低速な入出力装置に対するデータの転送を磁気ディスク装置などを介して実行する機能のことです。  
入出力装置とCPUでは動作速度の差が大きく、CPUが処理の途中で入出力命令をだすと入出力動作が終了するまでの間はCPUの待ち時間が増加しスループットが低下してしまいます。  
スプーリングでは、入出力装置とやり取りするデータを一旦、外部記憶装置などへ転送し、外部記憶装置と入出力装置の間でデータをやり取り方法をとります。  
これによってCPUは低速な入出力装置の動作完了を待つことなく、次の処理に移れるためスループットの大幅な向上が期待できます。  

### バッファ(Buffer)

「緩衝するもの」の意味で、周辺機器とCPUの間にデータのやり取りが発生したときに、そのデータを一時的に蓄積しておくためのメモリ領域のことです。
入出力装置とCPUでは動作速度の差が大きく、CPUが処理の途中で入出力命令をだすと、入出力動作が終了するまでの間はCPUの待ち時間が増加し、スループットが低下してしまいます。
バッファを用いた場合は、バッファメモリと入出力装置の間でデータのやり取りが行われるため、CPUは低速な入出力装置の動作完了を待つことなく、次の処理に移ることができます。
これによってスループットを大幅に向上させることが可能です。
プリンタ出力を行う時のスプーリングもバッファ機能の一種です。

### ブロッキング

ブロッキングは、バリアブル方式の磁気ディスク装置で複数の論理レコードを1つの物理レコードにまとめることです。  

### スワッピング

主記憶を効率よく使用するための方法で、実行中のプログラムが何らかの理由で停止したりして待ち状態が長く続く場合、そのプログラムを実行中のまま補助記憶装置に移動し、別のプログラムを補助記憶装置から主記憶に戻します。  

### ディスクキャッシュ

多数のバッファからなるバッファプールを用意し，主記憶にあるバッファにアクセスする確率を上げることによって，補助記憶装置のアクセス時間を短縮する。

### メモリリーク(MemoryLeak)

コンピュータの動作中に使用可能な主記憶容量が徐々に減少していく状態を表します。
アプリケーションが「自身で獲得したメモリの解放忘れる」などのプログラム不備などが原因で発生します。leakは漏えい、漏れ出すなどの意味です。
OSやアプリケーションのバグなどが原因で，動作中に確保した主記憶が解放されないことであり，これが発生すると主記憶中の利用可能な部分が減少する。

### オーバレイ方式

実行時のプログラム領域の大きさに制限があるときに，必要になったモジュールを主記憶に取り込む手法である。  
記憶に格納できない大きいプログラムをいくつかのブロック(セグメント)に分割し、その時の処理に必要なブロックだけを主記憶にロードして実行する仕組みです。  

### ファーストフィット方式

空き領域割り当てを制御するアルゴリズムの1つで、空きブロックをメモリの先頭から検索していき要求サイズ以上の空きブロックが見つかった時点でそれを割り当てるというものです。  

### ベストフィット方式

メモリ割り当てを制御するアルゴリズムで、空き領域の大きさ順リストを先頭から探索し、要求サイズに最も合致する空きブロックを割り当てる方式です。("最も合致する"とは要求サイズよりも大きく、割り当て後の残り領域が最も小さくなること)  
最もフィットする領域を使用するのでメモリ割り当てごとに小さい空き領域が生じ、最終的には使用するのが難しいほど小さな領域が多数残る傾向があります。  

### フラグメンテーション

[1]  
ディスク装置の記憶領域の中に使用されない領域の断片が存在した状態になりアクセス効率が低下する現象です。  

[2]  
主記憶で利用可能な空き領域の総量は足りているのに，主記憶中に不連続で散在しているので，大きなプログラムをロードする領域が確保できないことである。  

### スラッシング

[1]  
仮想記憶システムにおいて主記憶の容量が十分でない場合にプログラムの多重度が増加すると、ページング処理が多発します。  
このようにシステムのオーバヘッドが増加したことによりアプリケーションのCPU使用率が減少し、処理速度が遅くなる状態をスラッシング(Thrashing)といいます。  
アプリケーションの同時実行数を増やした場合に，主記憶容量が不足し，処理時間のほとんどがページングに費やされ，スループットの極端な低下を招くことである。  

[2]  
仮想記憶方式のひとつであるページング方式では、主記憶と仮想記憶の置き換えをページ単位で行います。(ページイン＆ページアウト)  

主記憶の容量が十分でない場合に、多数のプログラムを同時に実行するとページ置き換え処理が多発します。  
スラッシングとは、これによりシステムのオーバーヘッドが増加し、実行中のプログラムがCPUを使用している割合が極端に少なくなる現象のことです。  

### アーカイバ(archiver)

複数のファイルを一つのファイルにまとめたり元に戻したりするソフトウェアで、まとめられたファイルのことをアーカイブといいます。
またアーカイバにはデータ圧縮機能があります。
メールに添付するときやインターネット上で配布する場合は、転送サイズを少なくできるアーカイブ状態にすることが推奨されます。
LPICでやったので問題ない。

### ガーベジコレクション(Garbage Collection)

プログラムが動的に確保したメモリ領域のうち、不要になった部分を自動的に解放して、再び使用可能にする機能です。  
ガーベジ(garbage)には「ゴミ」とか「くず」といった意味があるので、直訳するとゴミ拾い、くず集めみたいな感じです。  
不要になった部分を集めるのでこのような名前になっています。  

従来の（ガーベジコレクションがない）プログラム言語では、プログラマが必要なメモリを確保する命令を記述し、使用後に明示的に解放する必要がありましたが、ガーベジコレクションが採用されている処理系では、不要と判断された時点で自動的にメモリの解放が行われます。  

### スタック

スタックは、後入先出し方式でデータを入出力するデータ記憶構造です。  

### ヒープ

ヒープは、プログラム上から動的(任意)に確保できるメモリ領域です。  

### 動的再配置

プログラムの実行中に主記憶内でモジュールの格納位置を移動させることを，動的リンキングという。  

### 動的リンキング

プログラムの実行中に必要になった時点でモジュールをロードすることを，動的再配置という。  

### 可変区画方式

可変区画方式は、実行するプログラムの大きさに応じて主記憶を区画して割り当てる方式です。  
可変区画方式で区画の割当てと解放を繰り返していくと、主記憶上に不連続な未使用領域が発生します。  
この主記憶の細かな空き領域を結合して一つの連続した領域にすることをメモリコンパクション(またはデフラグ)といいます。  

### デッドロック

デッドロックとは、共有資源を使用する2つ以上のプロセスが、互いに相手プロセスが必要とする資源を排他的に使用していて、互いのプロセスが相手が使用している資源の解放を待っている状態です。  
デッドロックが発生すると、両方のプロセスが永久的な待ち状態に陥ってしまうため、処理の続行ができなくなってしまいます。  

![!](https://www.ap-siken.com/kakomon/02_aki/img/17a.gif)  

※デッドロックは、資源の占有順序が異なる場合に発生する可能性があります。  
※デッドロックの発生を防ぐには共有資源の占有順序を同じにします。  

### セマフォ(semaphore)

直訳すれば信号機の意味で、並行動作している複数のタスク間で共通して使用する資源へのアクセスを制御するメカニズムです。  
整数型の共有変数である「セマフォ変数」と、それを操作する「P操作」「V操作」で同時更新によってエラーを引き起こす処理部分の排他制御を行います。  

※共有資源を管理する  

**セマフォ変数**  
現時点で利用可能な資源数を表す整数型の変数  

**P操作**  
セマフォ変数が0でなければ資源のアクセス権を獲得し、セマフォ変数の値を1だけ減らす  

**V操作**  
資源を解放し、セマフォ変数の値を1だけ増やす  

セマフォの値は同時に利用可能な資源数を表しています。  
平成26年春期 午後問7の例であれば同時に給水できるのは最大2ユニットまでですので、セマフォの初期値は「2」となります。  
排他を獲得よりはセマフォの獲得の包夫が一般的な模様。  

### IOは競合しない  

IO中にCPUが実行可能。  
IO中にIOも可能。  

---

## オペレーティングシステム 問題

### 基本 平成28年秋期　問18

プロセスAの実行中に割込みが発生し、CPU使用権がプロセスBに移される過程を示しています。

1.プロセスAの実行状態をスタック領域に退避する
2.割込み処理を行うプロセスBを選択する
3.プロセスBの実行状態を回復(復元)する
という手順になります。

コンピュータは割込み処理が発生すると、その時点のプログラムカウンタ及びメモリの内容をスタック領域に退避して、
次に実行するプロセスの命令アドレスをプログラムカウンタに、実行状態をメモリにセットします。
これによってCPUで実行されるプロセスが変わります。

**プログラムカウンタ**  
次に実行すべき命令のアドレスが格納されているレジスタです。

### 基本 令和元年秋期　問17

図の送信タスクから受信タスクにT秒間連続してデータを送信する。1秒当たりの送信量をS，1秒当たりの受信量をRとしたとき，バッファがオーバフローしないバッファサイズLを表す関係式として適切なものはどれか。ここで，受信タスクよりも送信タスクの方が転送速度は速く，次の転送開始までの時間間隔は十分にあるものとする。

→

送信タスクが受信タスクよりも転送速度が速いため、バッファにあふれが生じる可能性があります。
例えば、送信が100バイト／秒、受信が80バイト／秒であったとすると、1秒当たり20バイトがバッファに留まることになります。
この20バイトは、送信タスクの送信量(S)から受信タスクの受信量(R)を引いたデータ量、すなわち「S－R」の式で表せます。

さらに「S－R」が1秒当たりの滞留量なので、T秒間の連続送信中にバッファに留まる最大量は以下の式で表せます。
$(S－R)×T$
オーバフローを生じさせないためには、バッファサイズ(L)にこの数値以上を設定する必要があります。
以上より、Lが最大滞留量「(S－R)×T」以上であることを示す$L≧(S－R)×T$が適切な関係式とわかります。

### 基本 平成26年秋期　問17

2台のCPUからなるシステムがあり，使用中でないCPUは実行要求のあったタスクに割り当てられるようになっている。このシステムで，二つのタスクA，Bを実行する際，それらのタスクは共通の資源Rを排他的に使用する。それぞれのタスクA，BのCPU使用時間，資源Rの使用時間と実行順序は図に示すとおりである。二つのタスクの実行を同時に開始した場合，二つのタスクの処理が完了するまでの時間は何ミリ秒か。ここで，タスクA，Bを開始した時点では，CPU，資源Rともに空いているものとする。

A : CPU 10ms → 資源R 50ms → CPU 60ms
B : CPU 40ms → 資源R 50ms → CPU 30ms

→

この問題のポイントは、二つのタスクは「共通の資源Rを排他的に使用する」ということです。

排他的ということはひとつのタスクが資源Rを使用している場合、もう一方のタスクは使用できずに待ち状態になります。
**CPUは2つ用意されているので、各タスクに占有的に割り当てることでCPU処理待ちはしないため**、資源Rの使用状態にさえ気を付ければ解ける問題です。
→ここ読めてない地点で間違ったようなものである。

資源Rが最初に割り当てられるのは、先にCPU処理が終わるタスクAで開始から10ミリ秒後です。その後開始から60ミリ秒後まで資源Rを占有し続けます。
タスクBは、開始からCPU処理を40ミリ秒に終え、資源Rを要求しますがタスクAが使用中なので、タスクAの使用が終わるまで20ミリ秒待たなければなりません。
両方のタスクとも待ち時間がなければ、処理は120ミリ秒で終了しますが、資源Rの使用待ちによってタスクBに生じた20ミリ秒の待ち時間だけ全体の終了時間が遅くなります。

したがって二つのタスクが処理完了するまでの時間は、
120＋20＝140
140ミリ秒が適切となります。

### 平成29年春期　問19

仮想記憶方式のコンピュータにおいて，実記憶に割り当てられるページ数は3とし，追い出すページを選ぶアルゴリズムは，FIFOとLRUの二つ考える。あるタスクのページアクセス順序が
1, 3, 2, 1, 4, 5, 2, 3, 4, 5

FIFO
"ページインしてからの時間が最も長いページ"を置換え対象とするアルゴリズム
1  14    4
 3    5    5
  2    23

LRU
1  1  2  5
 3  4  3
  2  5  4

→

LRUはよく出てくるからわかったけど、FIFOはわからなかった。
額面通りに受け止めてもしっくり来なかったが、追い出しに置けるFIFOはページインしてからの時間が最も長いページが対象だとは・・。
FIFOと言えば、上から入って下から抜けるアレだ。そのイメージでいくと、1が来た地点で1が抜けるのだが、そうではない。
同じものがあった場合は変化しない。違う数字が来た場合に、抜けるイメージか。そのルールさえ覚えれば、FIFOも大丈夫だ。

### 平成30年春期　問16

三つのタスクA～Cの優先度と，各タスクを単独で実行した場合のCPUと入出力装置(I/O)の動作順序と処理時間は，表のとおりである。A～Cが同時に実行可能状態になって3ミリ秒経過後から7ミリ秒間のスケジューリング状況を表したものはどれか。ここで，I/Oは競合せず，OSのオーバヘッドは考慮しないものとする。また，表の()の数字は処理時間を表すものとし，解答群の中の"待ち"はタスクが実行可能状態にあり，CPUの割当て待ちであることを意味する。

A:高:CPU(2)→I/O(2)→CPU(2)
B:中:CPU(3)→I/O(5)→CPU(2)
C:低:CPU(2)→I/O(2)→CPU(3)

→

3タスクが実行可能状態になってから全タスクが完了するまでのCPUとI/Oの使用状態は次のようになります。

1.まずCPUは、最も優先度の高いタスクAの処理を開始する。
2.開始から2秒後、タスクAがI/Oに移る。タスクAがI/Oを行っている間、CPUは次に優先度の高いタスクBを処理する。
3.開始から4秒後、タスクAのI/Oが完了する。優先度はタスクA＞タスクBなので、CPUはタスクBを実行可能状態に戻し、タスクAの処理を再開する。
4.開始から6秒後、タスクAが完了する。CPUは優先度の高いタスクBの処理を開始する。
5.開始から7秒後、タスクBがI/Oに移る。タスクBがI/Oを行っている間、CPUは残ったタスクCを処理する。
6.開始から9秒後、タスクCの前半のCPU処理が完了する。I/Oは競合しないのでタスクCはI/O処理を開始する。以降11秒後までCPUは待ち状態になる。
7.開始から11秒後、タスクCのI/Oが完了する。タスクBはI/O中なのでCPUはタスクCの処理を再開する。
8.開始から12秒後、タスクBのI/Oが完了する。優先度はタスクB＞タスクCなので、CPUはタスクCを実行可能状態に戻し、タスクBの処理を再開する。
9.開始から14秒後、タスクBが完了する。CPUは残ったタスクCの処理を再開する。
10.開始から16秒後、タスクCが完了する。

I/Oは競合しない→CPU使用中でもI/O中でも並列して動くことができる。
I/Oが競合しないとは、一つの装置の奪い合いにならず、
同時にI/Oの処理ができる、ということです。

同時実行可能になって3ミリ秒という問題文に注意する。0秒から追っていてはダメ。

### 基本 平成29年春期　問16

四つのジョブA～Dを次の条件で実行し印刷する。全ての印刷が完了するのは，ジョブを起動してから何秒後か。

〔条件〕
ジョブは一斉に起動され，多重度1で実行される。
優先順位はAが最も高く，B，C，Dの順に低くなる。
各ジョブの実行後，スプーリング機能が1台のプリンタを用いて逐次印刷を行う。
各ジョブを単独で実行した場合の実行時間と印刷時間は，表のとおりである。
その他のオーバヘッドは考慮しない。

A 30 50
B 30 40
C 20 30
D 40 20

→

スプーリングという地点でCPUは関与しないので、CPUの時間とプリンタの時間は被って良い。
多重度1ってのはCPU使用に関しての話。多重度2なら平行して実行できるが、そうではない。

### 平成31年春期　問16

五つのジョブA～Eに対して，ジョブの多重度が1で，処理時間順方式のスケジューリングを適用した場合，ジョブBのターンアラウンドタイムは何秒か。ここで，OSのオーバヘッドは考慮しないものとする。  

![!](https://www.ap-siken.com/kakomon/31_haru/img/16.gif)  

``` txt
1 開始時点で到着しているのはジョブAだけなので、CPUはジョブAの処理を開始する。
2 開始から1秒後にジョブBが到着する。CPUはジョブAの処理を続ける。
3 開始から2秒後にジョブCが到着する。同時にジョブAの処理が完了する。
4 未処理のタスクの処理時間を比較するとC＜Bなので、CPUはジョブCの処理を開始する。
5 開始から3秒後にジョブDが到着する。CPUはジョブCの処理を続ける。
6 開始から4秒後にジョブEが到着する。CPUはジョブCの処理を続ける。
7 開始から5秒後にジョブCの処理が完了する。
  未処理のタスクの処理時間を比較するとE＜D＜Bなので、CPUはジョブEの処理を開始する。
8 開始から6秒後にジョブEの処理が完了する。
  未処理のタスクの処理時間を比較するとD＜Bなので、CPUはジョブDの処理を開始する。
9 開始から8秒後にジョブDの処理が完了する。
  CPUは最後に残ったジョブBの処理を開始する。

開始から12秒後にジョブBの処理が完了し、全てのジョブの処理が完了する。
このようにタスクの完了順は「A→C→E→D→B」になり、開始から1秒後にジョブBが到着してから処理が終了するまでには11秒を要します。
```

![!](https://www.ap-siken.com/kakomon/31_haru/img/16a.gif)  

### 平成29年春期　問13

CPUと磁気ディスク装置で構成されるシステムで，表に示すジョブA，Bを実行する。この二つのジョブが実行を終了するまでのCPUの使用率と磁気ディスク装置の使用率との組み合わせのうち，適切なものはどれか。ここで、ジョブA，Bはシステムの動作開始時点ではいずれも実行可能状態にあり，A、Bの順で実行される。CPU及び磁気ディスク装置は，ともに一つの要求だけを発生順に処理する。ジョブA，Bとも，CPUの処理を終了した後，磁気ディスク装置の処理を実行する。

![!](https://www.ap-siken.com/kakomon/29_haru/img/13.gif)  

→

問題文の条件を考慮してCPUと磁気ディスク装置の使用状況を図にすると以下のようになります。

![!](https://www.ap-siken.com/kakomon/29_haru/img/13_1.gif)  

2つのジョブが終了するまでの時間は25秒で、そのうち色が付いている部分が機器を使用している時間です。

CPUの使用率は、15(秒)÷25(秒)＝0.60  
磁気ディスクディスクの使用率は、17(秒)÷25(秒)＝0.68  

### 平成28年秋期　問17

五つのタスクを単独で実行した場合のCPUと入出力装置(I/O)の動作順序と処理時間は，表のとおりである。優先度"高"のタスクと，優先度"低"のタスクのうち一つだけを同時に実行する。実行を開始してから，両方のタスクの実行が完了するまでの間のCPUの遊休時間が最も短いのは，どの優先度"低"のタスクとの組合せか。ここで，I/Oは競合せず，OSのオーバヘッドは考慮しないものとする。
　また，表の( )内の数字は処理時間を示すものとする。

→

時間の経過とCPUの使用状況を表にしながら考えるとわかりやすいと思います。  
![!](https://www.ap-siken.com/kakomon/28_aki/img/17_1.gif)  

まず優先度が"高"であるタスクは、他のタスクの実行によって待ち状態になることはないため、まずはこのタスクのCPU使用状況を表に描き入れます。  

他の優先度""低のタスクは優先度"高"のタスクがCPUを使用していない間だけCPUを使用できることを踏まえて、それぞれのタスクと組み合わせた場合のCPU使用状況を描き入れます。  

![!](https://www.ap-siken.com/kakomon/28_aki/img/17_2.gif)  

赤い文字で書かれている時間がCPUの遊休時間になります。  

### 平成27年春期　問18

500kバイトの連続した空き領域に，複数のプログラムモジュールをオーバレイ方式で読み込んで実行する。読込み順序Aと読込み順序Bにおいて，最後の120kバイトのモジュールを読み込む際，読込み可否の組合せとして適切なものはどれか。ここで，数値は各モジュールの大きさをkバイトで表したものであり，モジュールを読み込む領域は，ファーストフィット方式で求めることとする。

![!](https://www.ap-siken.com/kakomon/27_haru/img/18.gif)  

→

ファーストフィット方式に従って空き領域を割り当てていくと〔読込み順序A〕では以下のように最後の120kバイトの割り当てが可能です。  
![!](https://www.ap-siken.com/kakomon/27_haru/img/18_1.gif)  

しかし〔読込み順序B〕では以下のように連続した120kバイト以上の空き領域が無くなってしまうため割り当てができません。  
![!](https://www.ap-siken.com/kakomon/27_haru/img/18_2.gif)  

### 平成26年秋期　問17

固定区画方式を使用した主記憶において，大きさが100kバイト，200kバイト，300kバイト，400kバイトの区画をそれぞれ一つ設定する。この主記憶に，大きさが250kバイト，250kバイト，50kバイトのプログラムをベストフィット方式で割り当てた。この時点で，使用できない領域は合計で何kバイト生じているか。

→  

メモリ割り当ての様子を時系列に表すと次のようになります。
　100k，200k，300k，400k
1つ目の250kのプログラムに300kの区画を割り当てる。
　100k，200k，50k，400k
2つ目の250kのプログラムに400kの区画を割り当てる。
　100k，200k，50k，150k
50kのプログラムに100kの区画を割り当てる。
　50k，200k，50k，150k

赤字で示した空き領域ですが割当て済みなので、他のプログラムに割り当てることはできない部分です。よって使用できない領域の合計は250バイトです。

![!](https://www.ap-siken.com/kakomon/26_aki/img/17.gif)  

### 令和元年秋期　問17

ジョブ群と実行の条件が次のとおりであるとき，一時ファイルを作成する磁気ディスクに必要な容量は最低何Mバイトか。

〔ジョブ群〕
![!](https://www.ap-siken.com/kakomon/01_aki/img/17.gif)  

〔実行の条件〕
ジョブの実行多重度を2とする。
各ジョブの処理時間は同一であり，他のジョブの影響は受けない。
各ジョブは開始時に50Mバイトの一時ファイルを新たに作成する。
の関係があれば， ジョブXの開始時に作成した一時ファイルは，直後のジョブYで参照し，ジョブYの終了時にその一時ファイルを削除する。直後のジョブが複数個ある場合には，最初に生起されるジョブだけが先行ジョブの一時ファイルを参照する。
はジョブXの終了時に，ジョブY，ZのようにジョブXと矢印で結ばれる全てのジョブが，上から記述された順に優先して生起されることを示す。
は先行するジョブX，Y両方が終了したときにジョブZが生起されることを示す。
ジョブの生起とは実行待ち行列への追加を意味し，各ジョブは待ち行列の順に実行される。
OSのオーバヘッドは考慮しない。

→

``` txt
一時ファイルはジョブの開始時に作成され、直後のジョブが終了した時点で削除されます。問題文の条件に従ってジョブの実行状況を追跡すると次のようになります。

1.ジョブAが生起され実行開始される。
→50Mバイトの一時ファイルを作成
2.ジョブAが終了する。一時ファイルは直後のジョブB、Cで参照するので削除しない。
3.ジョブB、ジョブCが生起される。多重度は2なのでどちらも実行開始される。
→50×2で100Mバイトの一時ファイルを作成
4.ジョブB、ジョブCが終了する。ジョブAの一時ファイルが削除される。
5.ジョブD、ジョブEが生起される。多重度は2なのでどちらも実行開始される。
→50×2で100Mバイトの一時ファイルを作成
6.ジョブD、ジョブEが終了する。ジョブB、ジョブCの一時ファイルが削除される。
7.ジョブFが生起され実行開始される。
→50Mバイトの一時ファイルを作成
8.ジョブFが終了する。ジョブD、ジョブEの一時ファイルが削除される。

一時ファイルの容量が最も多くなるのは、4つの一時ファイルが同時に存在するジョブD・E実行中で、その容量は200Mバイトです。
したがって、一時ファイルを作成する磁気ディスクには少なくとも200Mバイトの容量が必要です。
```

![!](https://www.ap-siken.com/kakomon/01_aki/img/17a.gif)  

### 平成28年秋期　問18

プログラムで使用可能な実メモリ枠が3ページである仮想記憶システムにおいて，大きさ6ページのプログラムが実行されたとき，ページフォールトは何回発生するか。ここで，プログラム実行時のページ読込み順序は，0，1，2，3，4，0，2，4，3，1，4，5とする。ページング方式は，LRU(Least Recently Used)とし，初期状態では，実メモリにはいずれのページも読み込まれていないものとする。

![!](https://www.ap-siken.com/kakomon/28_aki/img/18.gif)  

### 平成30年秋期　問16

処理はすべてCPU処理である三つのジョブ A，B，C がある。それらを単独で実行したときの処理時間は，ジョブAは5分，ジョブBは10分，ジョブCは15分である。この三つのジョブを次のスケジューリング方式に基づいて同時に開始すると，ジョブBが終了するまでの経過時間はおよそ何分か。

〔スケジューリング方式〕
一定時間(これをタイムクウォンタムと呼ぶ)内に処理が終了しなければ，処理を中断させて，待ち行列の最後尾へ回す。
待ち行列に並んだ順に実行する。
タイムクウォンタムは，ジョブの処理時間に比べて十分に小さい値とする。
ジョブの切替え時間は考慮しないものとする。

→

``` txt
〔スケジューリング方式〕の説明から3つのジョブは同時並行的に実行されていくことがわかります。

処理時間が5分と最も短いジョブAの完了時には、ジョブBおよびジョブCも全体のうち5分間の処理を完了していることになり、開始からこの時点までの経過時間は「3ジョブ×5分で15分」となります。
さらに、ジョブA完了後は残りの2ジョブでCPUを使うことになります。先程と同様にジョブBの残り5分の処理が実行される間に同時にジョブCも5分間の処理が実行されているので、ジョブA完了後からジョブB完了までの経過時間は「2ジョブ×5分＝10分」となります。

以上のことから、開始からジョブB完了までに要する時間は25分とわかります。
```

![!](https://www.ap-siken.com/kakomon/30_aki/img/16.gif)  

### 平成30年春期　問17

三つのタスクA～Cの優先度と各タスクを単独で実行した場合のCPUと入出力(I/O)装置の動作順序と処理時間は，表のとおりである。優先順位方式のタスクスケジューリングを行うOSの下で，三つのタスクが同時に実行可能状態になってから，タスクCが終了するまでに，タスクCが実行可能状態にある時間は延べ何ミリ秒か。ここで，I/Oは競合せず，OSのオーバヘッドは考慮しないものとする。また，表中の()内の数字は処理時間を示すものとする。

![!](https://www.ap-siken.com/kakomon/30_haru/img/17.gif)  
→  
![!](https://www.ap-siken.com/kakomon/30_haru/img/17a.gif)  

### 平成30年秋期　問18

ページング方式の仮想記憶において，あるプログラムを実行したとき，1回のページフォールトの平均処理時間は30ミリ秒であった。ページフォールト発生時の処理時間が次の条件であったとすると，ページアウトを伴わないページインだけの処理の割合は幾らか。

〔ページフォールト発生時の処理時間〕
ページアウトを伴わない場合，ページインの処理時間は20ミリ秒である。
ページアウトを伴う場合，置換えページの選択，ページアウト，ページインの合計処理時間計60ミリ秒である。

→  

``` math
ページインだけの処理の割合を"P"とすると、ページアウトを伴う処理の割合は"1－P"で表すことができます。

それぞれの処理時間と平均処理時間の関係を表す次の式を解くと

　20×P＋60×(1－P)＝30
　20P＋60－60P＝30
　－40P＝－30
　P＝0.75

ページインだけの処理の割合"P"は0.75であるとわかります。
```

### 平成28年秋期　問19

タイムクウォンタムが2秒のラウンドロビン方式で処理されるタイムシェアリングシステムにおいて，プロセス1～3が逐次生成されるとき，プロセス2が終了するのはプロセス2の生成時刻から何秒後か。ここで，各プロセスはCPU処理だけで構成され，OSのオーバヘッドは考慮しないものとする。また，新しいプロセスの生成と中断されたプロセスの再開が同時に生じた場合には，新しく生成されたプロセスを優先するものとする。

![!](https://www.ap-siken.com/kakomon/28_aki/img/19.gif)  

→

![!](https://www.ap-siken.com/kakomon/28_aki/img/19a.gif)  

``` txt
「プロセス2の中断」と「プロセス3の生成」が同時に生じる6秒時点の部分だけ処理の流れを補足しておきます。

[5～6秒の間]
プロセス2が実行され、プロセス1は待ち行列の先頭に存在する。

[6秒時点]
① プロセス2の実行時間がタイムクォンタムに達したため、プロセス2が待ち行列の最後尾に移される。
② プロセス3が生成される。

[実行プロセスの決定]
設問には「新しいプロセスの生成と中断されたプロセスの再開が同時に生じた場合には，新しく生成されたプロセスを優先するものとする」という条件があり、プロセス3の生成とプロセス1の再開が同時に生じる6秒時点はちょうどこの条件に合致する。このため新しく発生した「プロセス3」にCPU使用権が割り当てられることになる※。

プロセス2の生成は開始から3秒後、終了は開始から17秒後なので、その差である14秒が生成から終了までに要した時間になります。したがって「イ」が正解です。


※ラウンドロビンでは実行待ち行列をキュー構造(FIFO)で管理するため、普通に考えれば生成されたばかりのプロセス3は一旦待ち行列の最後尾に配置され、先頭のプロセス1にCPU使用権が与えられるとも考えられます。しかし、この設問では待ち行列の存在が明示されているわけではなく、さらに出題者がわざわざ特定の条件をつけて実行順を指定をしていることから、設問の文章をそのまま解釈してプロセス3を実行するとしました。
```

### 令和3年秋期　問17

主記憶へのアクセスを1命令当たり平均2回行い，ページフォールトが発生すると1回当たり40ミリ秒のオーバヘッドを伴うシステムがある。ページフォールトによる命令実行の遅れを1命令当たり平均0.4マイクロ秒以下にするために許容できるページフォールト発生率は最大幾らか。ここで，ほかのオーバヘッドは考慮しないものとする。  

→  

``` math
仮に、1命令における2回の主記憶へのアクセスの両方でページフォールトが発生した（発生率100%だった）とすると、命令実行の遅れは80ミリ秒になります。この時間を0.4マイクロ秒以下にしたいので、次のような式を立てて条件を満たす発生率(n)を計算します。

　80ミリ秒×n≦0.4マイクロ秒
　80×10-3×n≦0.4×10-6
　n≦0.4×10-6÷80×10-3
　n≦(0.4÷80)×10-3
　n≦0.005×10-3＝5×10-6

上記の計算から、ページフォールト発生率(n)は5×10-6以下にすればよいとわかります。したがって「ア」が正解です。
```

---

## 置き換えアルゴリズム

Least : 最小

### LRU(Least Recently Used)

置き換え対象の中で最も長い時間参照されていないものを置き換え対象とするアルゴリズムです。  

この置換アルゴリズムは、「最近使用されたページは再び近い将来に参照される可能性が高く、長い間参照されていないページは今後も参照される可能性が低い」ということを根拠としていて、キャッシュメモリや仮想記憶におけるデータの置き換えを決定するアルゴリズムとして使われています。  

### LFU(Least Frequently Used)

置き換え対象の中で最も参照回数の少ないページを置き換えるアルゴリズムです。  

### FlFO(First-in First-out)

置き換え対象の中に最も古くから存在するページを追い出す"先入れ先出し"のアルゴリズムです。  

### LIFO(Last-in First-out)

置き換え対象の中に最後に追加されたデータを追い出す"後入れ先出し"のアルゴリズムです。  

---

## 置き換えアルゴリズム 問題

### 平成29年春期　問16

4ブロック分のキャッシュメモリC0～C3が表に示す状態である。ここで，新たに別のブロックの内容をキャッシュメモリにロードする必要が生じたとき，C2のブロックを置換の対象とするアルゴリズムはどれか。

![!](https://www.ap-siken.com/kakomon/29_haru/img/16.gif)  

→

LRU(Least Recently Used)は、"最後に参照された時刻"が、最も昔であるものを置換え対象とするアルゴリズムです。LRUで置換え対象を選択すると、4ブロックの中で最終参照時刻が最も古い"C2"が選ばれます。  
![!](https://www.ap-siken.com/kakomon/29_haru/img/16e.gif)  

First In First Outの略で先入先出しのこと。最も昔にロードされたものを置換え対象とするアルゴリズムです。この問題では"C0"が対象となります。  
![!](https://www.ap-siken.com/kakomon/29_haru/img/16a.gif)  

Least Frequently Usedの略。最も使用頻度(回数)の少ないものを置換え対象とするアルゴリズムです。この問題では"C1"が対象となります。  
![!](https://www.ap-siken.com/kakomon/29_haru/img/16i.gif)  

Last In First Outの略で後入先出しのこと。最も新しくロードされたものを置換え対象とするアルゴリズムです。この問題では"C3"が対象となります。  
![!](https://www.ap-siken.com/kakomon/29_haru/img/16u.gif)  

### 平成31年春期　問19

仮想記憶管理におけるページ置換えアルゴリズムとしてLRU方式を採用する。主記憶のページ枠が，4000，5000，6000，7000番地(いずれも16進数)の4ページ分で，プログラムが参照するページ番号の順が，1→2→3→4→2→5→3→1→6→5→4のとき，最後の参照ページ4は何番地にページインされているか。ここで，最初の1→2→3→4の参照で，それぞれのページは4000，5000，6000，7000番地にページインされるものとする。

LRU(Least Recently Used)は、置換え対象の中で最後に参照されてからの時間が最も長いページを置換え対象とするアルゴリズムです。

ページ枠の遷移を順を追って考えていきます。下記解説のページ枠は、左から4000，5000，6000，7000番地とします。
最初の1から4までは設問の指示通りにページインします。
1234
2は主記憶に存在するのでページアウトは発生しません。
1234
5は主記憶に存在しないのでページ置換えが必要になります。この時点で最も昔に参照されたページは1なので、1をページアウトしその位置に5をページインします。
5234
3は主記憶に存在するのでページアウトは発生しません。
5234
1は主記憶に存在しないのでページ置換えが必要になります。この時点で最も昔に参照されたページは4なので、4をページアウトしその位置に1をページインします。
5231
6は主記憶に存在しないのでページ置換えが必要になります。この時点で最も昔に参照されたページは2なので、2をページアウトしその位置に6をページインします。
5631
5は主記憶に存在するのでページアウトは発生しません。
5631
4は主記憶に存在しないのでページ置換えが必要になります。この時点で最も昔に参照されたページは3なので、3をページアウトしその位置に4をページインします。
5641
操作終了時点でページ4は左から3番目、つまり6000番地にページインしています。したがって「ウ」が正解です。

---

## ファイルシステム

### ハッシュ法

ハッシュ関数を用いて、データやデータのキーの値からデータの格納位置を直接計算する方法です。
線形探索法や2分探索法とは異なり、常に一定の時間（探索回数1回）で目的のデータを探索することができます。

### データマイニング

蓄積されている膨大なデータを検索し，経営やマーケティングにとって必要な傾向，相関関係，パターンなどを導き出すための技術や手法である。

### セマンティック検索

データとそれに対する処理を組み合わせたオブジェクトに，認識や判断の機能を加え，利用者の検索要求に対して，その意図を判断する高度な検索技術である。

### シソーラス

キーワード検索のヒット率を高めることを目的に作成した，一種の同義語・類義語リストを用いることによって，検索漏れを防ぐ技術である。

### フルバックアップ

毎回、全ファイルのバックアップを行う方式。復旧時間は短くなるが、バックアップに必要な容量が多い分バックアップに要する時間は長い。
言わずもがな、全部。

### 差分バックアップ

定期的にフルバックアップを行い、フルバックアップの間の期間は、フルバックアップ以降に変更のあった全てのファイルを記録する方式。
障害発生時にはフルバックアップと直前の差分バックアップ1つを使用して復旧する。
最初のバックアップの後，ファイル更新を示す情報があるファイルだけをバックアップし，ファイル更新を示す情報は変更しないでそのまま残しておく。
図解的には、階段状になっている。全開バックアップした部分も対象になっている。

### 増分バックアップ

定期的にフルバックアップを行い、フルバックアップの間の期間は、前回の増分バックアップ以降に変更のあったファイルだけを記録する方式。
一度にバックアップする量は少なくて済むが、回復にはフルバックアップと複数の増分バックアップが必要になるので、障害発生時の復旧時間は長くなる。
直前に行ったバックアップの後，ファイル更新を示す情報があるファイルだけをバックアップし，ファイル更新を示す情報はリセットする。
図解的には、一番てっぺんの部分が対象となる。

### 絶対パス

階層の最上位であるルートディレクトリを基点として，目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法。

### 相対パス

現在作業を行っているカレントディレクトリを基点として、目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法。

### デバイスファイル

入出力装置をファイルと同じように取り扱えるようにする。

### デバイスコントローラ

入出力装置と処理装置との間のデータ交換に階層を設けることによって，入出力装置固有の仕様を意識せずに利用できる。

---

## ファイルシステム 問題

### 令和元年秋期　問19

三つの媒体A～Cに次の条件でファイル領域を割り当てた場合，割り当てた領域の総量が大きい順に媒体を並べたものはどれか。

〔条件〕

1. ファイル領域を割り当てる際の媒体選択アルゴリズムとして，空き領域が最大の媒体を選択する方式を採用する。
2. 割当て要求されるファイル領域の大きさは，順に 90，30，40，40，70，30(Mバイト)であり，割当てられたファイル領域は，途中で解放されない。
3. 各媒体は容量が同一であり，割当て要求に対して十分な大きさをもち，初めはすべて空きの状態である。
4. 空き領域の大きさが等しい場合にはA，B，Cの順に選択する。

``` txt
条件(1)から(4)を総合して考えると、その都度使用量が最も少ない媒体にファイルを割り当てていけばよいことがわかります。

要求サイズがどの媒体に割り当てられていくかを1つずつ順番に見ていきましょう。
90
空き領域がすべて同じなので、Aに割り当てられます。
A(90), B(0), C(0)
30
BとCで空き領域が同じなので、Bに割り当てられます。
A(90), B(30), C(0)
40
まだ使用していないCに割り当てられます。
A(90), B(30), C(40)
40
使用量が最も少ないBに割り当てられます。
A(90), B(30・40), C(40)
70
使用量が最も少ないCに割り当てられます。
A(90), B(30・40), C(40・70)
30
使用量が最も少ないBに割り当てられます。
A(90), B(30・40・30), C(40・70)
ここまでに割り当てられたファイルの容量は「A＝90, B＝100, C＝110」ですので、これを多い順番に並べると「C，B，A」になります。
```

---

## 開発ツール

### コンパイラ(Compiler)

[1]
高水準語で記述されたソースコードを機械語などに一括して翻訳するソフトウェア。  
原始プログラムを，目的プログラムに翻訳するプログラムである。  
コンパイラにおける最適化とは、そのプログラムが動作するコンピュータの設計・仕様に合わせて実行速度が速くなるような機械語に変換することをいい「不要な変数の省略」「関数のインライン展開」「レジスタ割当て」などの手法を用いることで、与えられたソースコードを最適化された機械語に変換を行います。  

[2]
ソースコードを翻訳して、機械語の目的プログラム(実行ファイル／ロードモジュール)を生成する言語プロセッサです。  
実行ファイルを生成する前のソースコードを機械語に翻訳する過程において、ソースコードの解析が行われ、効率的、かつ、実行時間やメモリ使用量などを最少化するようにソースコードを調整する最適化処理が行われます。  

コンパイルの流れは次のようになっています。  
ソースコード→字句解析→構文解析→意味解析→最適化→目的プログラム  

### 字句解析

プログラムを表現する文字の列を、意味のある最小の構成要素の列に変換する。
コンパイルの最初に行われ、ソースコードを意味のある最小の構成要素(トークン)に分解する処理です。

### 構文解析

言語の文法に基づいてプログラムを解析し、文法誤りがないかチェックする

### 意味解析

変数の宣言と使用とを対応付けたり、演算におけるデータ型の整合性をチェックする

### 最適化

レジスタの有効利用を目的としたレジスタ割付けや、不要な演算を省略するためのプログラム変換を行う。  
処理時間や使用するメモリ量が少なくなるようにプログラムを再編成します。  
具体的には、  
・累乗を乗算に、乗算を加算にする。(加算のほうが処理速度が速い)  
・値の変わらない変数を定数にする。  
・ループを展開・関数のインライン展開。  
等の変換を行う。  

※累乗 : 同じ数を何回か掛け合わせること。2の3乗とか。  

#### 平成27年秋期　問19

繰返し回数の多いループは，繰返し回数がより少ないループを複数回繰り返すように変形する。例えば，10,000回実行するループは，100回実行するループを100回繰り返すようにする。
→
繰返し回数の多いループに対しては、ループの中身のコードを複数回配置してループ条件のチェック回数を減らしたり、分岐回数を減らすことによってオーバーヘッドを低減させる「ループ展開」と呼ばれる最適化が行われます。

算術式の中で，加算でも乗算でも同じ結果が得られる演算は乗算で行うように変更する。例えば，"X＋X"は"2＊X"で置き換える。
→  
CPUでは乗算よりも加算の方が高速に計算できます。実際には"2＊X"→"X＋X"というように乗算を加算に置き換える「演算子強度低減」と呼ばれる最適化が行われます。

定数が格納される変数を追跡し，途中で値が変更されないことが確認できれば，その変数を定数で置き換える。  
→
正しい。「定数畳み込み」及び「定数伝播」と呼ばれる最適化手法です。変数はメモリ上に動的に確保されますが、定数はプログラムコード上に埋め込まれるという違いがあるため、定数は変数よりも高速にアクセスできます。  

プログラム中の2か所以上で同じ処理を行っている場合は，それらをサブルーチン化し，元のプログラムのそれらの部分をサブルーチン呼出しで置き換える。  
→  
サブルーチンの呼び出しには余計なオーバーヘッドが生じます。このため、プログラムの実行に支障がない場合には、サブルーチンをメインプログラム中に展開してしまうことでオーバーヘッドを減らす「インライン展開」と呼ばれる最適化が行われます。  

### クロスコンパイラ

コンパイラが動作している以外のプラットフォーム向けに実行ファイルを生成する機能を持つコンパイラです。  
主に組込みシステム向けのコンパイラとして使われたり、マルチプラットフォーム対応のコンパイルに使われます。  

例えばWindows上で動作する開発環境で、Linux用の実行ファイルを生成するというようなことが可能になります。  

※あるコンピュータ上で，異なる命令形式のコンピュータで実行できる目的プログラムを生成する言語処理プログラム  

### インタプリタ(Interpreter)

プログラム言語の処理系の1つで、実行時にソースコードを1文ずつ解釈しながらプログラムを実行していくソフトウェアです。  
原始プログラムを，解釈しながら実行するプログラムである。  

インタプリタ方式は、コンパイラ方式と比較してプログラムの実行速度が遅くなる傾向にありますが、開発時にプログラム作成とテストの繰返しを容易に行える利点があります。JavaScript、PHP、Pythonなどのプログラム言語がインタプリタ方式を採用しています。  

Interpreter : 翻訳者,通訳者  

### リンカ(Linker)

相互参照の解決などを行い，複数の目的モジュールなどから一つのロードモジュールを生成する。  
複数個のコンパイル済みプログラムや、そのプログラムで使用するライブラリを連結・統合し、1つの実行可能なプログラムファイルとして出力するソフトウェアです。  

### ローダ(Loader)

実行に先立ってロードモジュールを主記憶にロードする。  

### デバッガ(Debugger)

プログラムの実行を監視し，ステップごとに実行結果を記録する。  

### パーサ

ソースコードの構文解析を行うソフトウェアです。  

### プロファイラ(Profiler)

プログラムを実行した際に、どの関数が何回実行され、その処理時間がどれくらいであったかなど計測する性能解析ツールです。  
ボトルネックの特定やパフォーマンスの改善に役立てることができます。  

![!](https://www.ap-siken.com/kakomon/30_aki/img/19.gif)  

### 静的テストツール

構文チェッカ、コードオーディタ、モジュールインターフェイスチェックツールなどのプログラムを**実行しない状態**でプログラムの検証を行うためのツール。  

構文チェッカー : プログラム中に文法上の誤りや論理的な誤りなどがあるかどうかを，ソースコードを分析して調べる。  

### 動的テストツール

インスペクタ、トレーサ、スナップショット、メモリダンプ、カバレッジモニタ、アサーションチェッカなどのプログラムを**実行しながら**検証を行うためのツール。  

カバレッジモニタ : テストの実行結果を基に，命令の網羅率や分岐の網羅率を自動的に計測し，分析する。  
プロファイラ : モジュールの呼出し回数や実行時間，実行文の実行回数などの，プログラム実行時の動作特性に関するデータを計測する。  

### 環境設定ツール

テストベッドツール、テストデータ生成ツールなどのテスト環境を準備するためのツール。  
テストケース作成ツール : 指定された条件のテストデータや，プログラムの入力ファイルを自動的に生成する。  
テストベッドツール : テスト対象モジュールに必要なドライバ又はスタブを生成する。  

### テストカバレージ分析

テストの網羅率(カバレッジ)を定量的に測定するためのツールです。  
網羅率は、ソフトウェアの品質やテスト妥当性を評価する際の指標になります。  

※ホワイトボックステストにおいて，プログラムの実行された部分の割合を測定するのに使うもの  

### アサーションチェッカ

アサーションチェッカは、プログラムの正当性を検査するために、変数間で論理的に成立する条件が満たされているかをチェックするツールです。  

### Git

各自が完全なリポジトリを保有できる分散型のバージョン管理ツールです。  
元々はLinuxのソースコード管理に用いるために開発されたツールですが、現在では多くのプロジェクトのソースコード管理に利用されています。  
Gitでは、リポジトリの完全なコピーをローカル環境に保持することができるので、中央リポジトリにアクセスできないときでも、変更履歴を調査したり変更を記録したりすることなどが可能です。  

### Apache Subversion

単一の中央リポジトリを全員が編集する集中型のバージョン管理ツールです。  
分散リポジトリのサポートはありません。  

### CVS(Concurrent Versions System)

ソースコードなどのテキストファイルを共有し、その変更を記録し管理するツールです。  
サーバ上の共有ファイルを全員が編集する集中型で、分散リポジトリのサポートはありません。  

### RCS(Revision Control System)

ファイル単位で変更を管理する初期のバージョン管理システムです。  
複数人での作業やプロジェクトのサポートがありません。  

---

## オープンソースソフトウェア

### OSS(Open Source Software)

ソフトウェア作者の著作権を守ったままソースコードを無償公開することを意味するライセンス形態、またはそのライセンス形態によって提供されるソフトウェアです。

・再頒布ができること
・ソースコードの入手が可能
・それをもとに派生物を作成可能
・再配布において追加ライセンスを必要としないこと
などの特徴があります。

### OSI(Open Source Initiative)

オープンソースソフトウェアを促進することを目的とする組織。  
OSI基本参照モデルが真っ先に思い浮かんだが、こちらはISO(国際標準化機構)が作ったものなので全く関係ない。  

### OSD(The Open Source Definition)

OSIが策定したオープンソースの定義  
オープンソースライセンスが満たす条件として以下の要件を掲げています。  

1. 自由な再頒布ができること  
2. ソースコードを入手できること  
3. 派生物が存在でき、派生物に同じライセンスを適用できること  
4. 差分情報の配布を認める場合には、同一性の保持を要求してもかまわない  
5. 個人やグループを差別しないこと  
6. 利用する分野を差別をしないこと  
7. 再配布において追加ライセンスを必要としないこと  
8. 特定製品に依存しないこと  
9. 同じ媒体で配布される他のソフトウェアを制限しないこと  
10. 技術的な中立を保っていること  

#### 基本 平成31年春期　問20

社内での利用などのようにオープンソースソフトウェアを改変しても再配布しない場合，改変部分のソースコードを公開しなくてもよい。
→
正しい。派生ソフトウェアを頒布するときには、ソースコードも共に頒布しなければなりません（2. ソースコード）。
しかし、再配布しない場合は改変部分のソースコードを公開する必要はありません。

オープンソースソフトウェアを第三者が製品として再配布する場合，そのオープンソースソフトウェアの開発者は第三者に対してライセンス費を請求することができる。
→
オープンソースソフトウェアは、当該ソフトウェアが販売及び無料で配布されることを制限してはならず、これらの販売に関して印税その他の報酬を要求してはなりません（1. 再頒布の自由）。

オープンソースソフトウェアを改変し再配布する場合，元のソフトウェアと同じ配布条件となるように，同じライセンスを適用して配布する必要がある。
→
オープンソースソフトウェアの定義では、派生ソフトウェアについて、元となったオープンソースソフトウェアと同じライセンスを適用できることを求めていますが、
同じライセンスを強制するものではありません（3. 派生ソフトウェア）。本肢は「同じライセンスを適用して配布する必要がある」としているため誤りです。

ある特定の業界向けに作成されたオープンソースソフトウェアは，ソースコードを公開する範囲をその業界に限定することができる。
→
オープンソースソフトウェアは特定の個人やグループを差別してはなりません（5. 個人やグループに対する差別の禁止）。
本肢は「その業界に限定することができる」としているため誤りです。

### ディストリビュータ(Distributor)

OSSとして個々に開発されている(狭義の)OS、ライブラリやコマンドなどのユーティリティ、GUI、サーバソフトウェア、アプリケーションソフトウェアなどを組み合わせた実用的なパッケージを提供する者や組織です。  
提供されるパッケージを「ディストリビューション」と言い、LinuxだとDebian系やRedHat系が有名です。  
ディストリビューションには基本的な機能が一式揃っているので、利用者はディストリビューションをインストールするだけで、複雑な環境設定等をせずに様々な機能を使えるようになります。  

### コミッタ

OSSを開発し，活動状況をWebで公開する。  

### コントリビュータおよびテスタやレビューア

OSSを稼働用のコンピュータにインストールし，動作確認を行う。  

### GNU GPL(GNU General Public License)

フリーウェア運動を具現化するために考案されたオープンソースライセンスです。  
GPLのもとで配付されたソフトウェアが何者かに独占されることを排除し、ソフトウェアが全ての利用者にとって自由であり続けられるようにすることを目的としています。  

GPLであるプログラムを使用する際は、著作権を許諾する条件として、複製物の所持者は以下の自由を認められます。  

1. プログラムを実行すること  
2. プログラムの複製物を配布すること  
3. ソースコードを一緒に配布するか、後から容易な方法で入手可能なこと  
4. プログラムを調べ修正すること  

BSDライセンスなどの他のフリーソフトウェアライセンスとの違いは、GPLが「二次的著作物についても、上記の4点の権利を保護する」という強力な自由を承認する点です。  
これにより、GPLライセンスされた著作物を使用または変更・改変して作成した著作物を配布した場合、有償・無償に関わらず、その二次著作物には無条件にGPLライセンスが適用されることになります。  
すなわち、その二次著作物が自由に使用されることを、下流の受領者に対して認めなければなりません。  
特にGPLソフトウェアを使用して商用ソフトウェアを作成する際には、ライセンスの特徴について熟知しておく必要があるでしょう。  

※GPLであるソースコードの派生物のライセンスは，無条件にGPLとなる。  

### コピーレフト(Copyleft)

"著作権を保持したまま，プログラムの複製や改変，再配布を制限せず，そのプログラムから派生した二次著作物(派生物)には，オリジナルと同じ配布条件を適用する"とした考え方。  
作成者が著作権を保持したまま、二次的著作物も含めて、すべての者が著作物を利用・再配布・改変できなければならないという考え方です。  

作品を不特定多数の人で共有して改善を加えるような場合に、著作者のみが著作権をもつという従来の仕組みが柔軟な創造活動の妨げになってしまうことがあります。  
しかし作品を「パブリックドメイン」にしてしまうと著作者の意思に反した利用がなされる可能性や、改変者が二次著作物の著作権を得てしまうなどの問題が出てきます。  
このような背景から、著作者の権利を保ったまま作品を不特定多数で共有し、共同での創造活動を可能にする「コピーレフト」の考え方が生まれました。  
コピーレフトの考え方は、GPL(General Public License),LGPL(Lesser General Public License),MPL(Mozilla Public License)などのオープンソースソフトウェアのライセンスで導入されています。  

### パブリックドメイン

著作者が著作権を放棄するなどして知的財産権が消滅している状態

### コピーライト

コピー・複写(copy)と権利(right)を合わせた言葉で、著作権や複製権を意味します。

### デュアルライセンス

ひとつのソフトウェアを2種類以上の異なるライセンスの元で配布するライセンス形態です。

### BSDライセンス

カリフォルニア大学によって策定されたフリーソフトウェアで使われるライセンス体系のひとつです。
BSDライセンスのソースコードを組み込んだソフトウェアは、著作権表示、ライセンス条文、無保証の旨の三点をドキュメント等に記載さえしておけば、
ソースコードを公開せずに頒布することが可能になっています。
BSDライセンスでは、ソースコードの公開が義務ではない。

### Apache Hadoop(ハドゥープ)

ペタバイト級の大規模データの蓄積・処理の分散処理を実現するミドルウェアです。  
Googleが論文として発表した分散処理フレームワーク「MapReduce」および分散ファイルシステム「Google File System」を基盤技術に、オープンソースとしてJavaで実装したものです。  
分散ファイルシステムのHDFS(Hadoop Distributed File System)と、分散処理のフレームワークであるHadoop MapReduceの2つから構成されます。  

### Apache Tomcat(トムキャット)

Javaサーブレット・JSPで処理を行うオープンソースのWebアプリケーションサーバです。

### Eclipse(イクリプス，エクリプス)

IBMによって開発されたオープンソースの統合開発環境です。
主にJavaの開発環境として使用されていますが、プラグインを組込むことで機能が拡張できるように設計されているため、
多様なプログラム言語への対応をはじめWeb開発などの様々な開発局面での使用が可能になっています。

### Linuxカーネル

メモリ管理、ファイルシステム、プロセス管理、デバイス制御など、OSとしてコンピュータやアプリケーションソフトを制御するための最も基本的機能だけを実装したソフトウェアです。  

カーネルだけでアプリケーションを動作させることはできないため、OSとして機能させるためには"glibc"などのライブラリや"GNUソフトウエア"を組合わせる必要があります。  

### glibc

標準入出力、文字列操作、数値演算などの機能がC言語で記述されたライブラリ  

### GNUソフトウエア

シェルのBash、CやC++コンパイラであるGCC、多数の外部コマンドなどが含まれるGPLライセンスで提供されるフリーソフトウェア群  

### GCC(GNU C Compiler)

GNUが開発・配布している様々なプログラム言語のコンパイラでOSSの条件に従って自由に使用できます。

### GNU

UNIX互換のソフトウェア環境を修正・再頒布自由なフリーソフトウェアの理念に従って実装しようとするプロジェクト、または、それらのソフトウェア群のこと

---

## ミドルウェア

### JavaBeans

プログラムの再利用を目的としてJavaで書かれたソフトウェアの部品のことです。  
既存のBeanを組み合わせることで開発効率が向上したり、プログラムの経験がなくてもアプリケーションソフトウェアに構築ができるという利点があります。  
EJB(Enterprise JavaBeans)は、このJavaBeansをサーバサイドで実現する技術仕様です。  

※コンピュータ機器やソフトウェアの部品のことを「コンポーネント」というため、部品の再利用について説明された「イ」が適切です。

---

## 1回目に間違えた問題

平成29年秋期　問17
ソフトウェア制御における，ポーリング制御はどれか。
→
俺が知っているポーリングはトークンをループさせて、トークンを獲得したソフトウェアがあれこれできるってイメージだったのだが、回答にはそんな感じの答えはなかった。
CPUが状態レジスタ股はビジー信号等を読みだして、入出力装置の状態を監視する。ってのが答えらしい。
もしかして、俺のポーリングの認識が間違っているのか？



平成26年春期　問16
ページング方式の仮想記憶を用いることによる効果はどれか。
→
わかりそうでの奴でやったはずだが、忘れてしまった。
まず仮想記憶方式であること。
というか、問題文をよく読んでみると、効果って書いてあるな。
それはメモリを効率的に使うためですよってか。



平成27年秋期　問16
システム全体のスループットを高めるために，主記憶装置と低速の出力装置とのデータ転送を，高速の補助記憶装置を介して行う方式はどれか。
→
これは普通に知らなかったです。応用でも出てきた記憶がないです。
完全に覚えゲーなので、今回で覚えましょう。
正解はスプーリングですって。どっかで聞いたような気もするなって感じの言葉ですね。
あー、印刷の時のキューがこれかもしれん。入出力装置って書いてあるもんね。



平成31年春期　問20
OSIによるオープンソースソフトウェアの定義に従うときのオープンソースソフトウェアに対する取扱いとして，適切なものはどれか。
→
答えを全て見ていなかった。
中にCopyLeftの答えがあったので、選んだらダメだった。
そもそもOSIってなんやねん。



平成30年秋期　問19
手続型言語のコンパイラが行う処理のうち，最初に行う処理はどれか。
→
これはナチュラルに知らなかったです。
コンパイラといえば構文解析や最適化くらいしか知らなかったので、いい機会なので覚えます。

字句解析→構文解析→意味解析→最適化



平成27年春期　問21
出力待ちの印刷要求を，同一機種の3台のプリンタA～CのうちAから順に空いているプリンタに割り当てる(Cの次は再びAに戻る)システムがある。印刷要求の印刷時間が出力待ちの順に，5，12，4，3，10，4(分)である場合，印刷に要した時間が長い順にプリンタを並べたものはどれか。ここで，初期状態ではプリンタはすべて空いているものとする。

→

1.プリンタAに、出力待ち順の先頭である5分の印刷要求が割り当てられる。
2.プリンタBに、2番目の12分の印刷要求が割り当てられる。
3.プリンタCに、3番目の4分の印刷要求が割り当てられる。
4.開始から4分後、プリンタCの印刷が終わる。空きとなったプリンタCには3分の印刷要求が割り当てられる。
5.開始から5分後、プリンタAの印刷が終わる。空きとなったプリンタAには10分の印刷要求が割り当てられる。
6.開始から7分後、プリンタCの印刷が終わる。空きとなったプリンタCには最後の4分の印刷要求が割り当てられる。
7.開始から11分後、プリンタCの印刷が終わる。
8.開始から12分後、プリンタBの印刷が終わる。
9.開始から15分後、プリンタAの印刷が終わる。
以上より、3台のプリンタを印刷に要した時間が長い順に並べると「A，B，C」になります。

→

問題文をよく読むとそう書いてある。Aから順に空いているプリンターに割り当てる。
これは最初の話だけではなく、4分経過してAが空いたなら、すぐに次の印刷要求を受け入れる。ってことだったのか。
それなら、確かに、時系列順に並べて見てみれば、そうなるわな。
この手の問題は時系列で考えることが重要ということか。



平成29年秋期　問19
図のメモリマップで，セグメント2が解放されたとき，セグメントを移動(動的再配置)し，分散する空き領域を集めて一つの連続領域にしたい。1回のメモリアクセスは4バイト単位で行い，読取り，書込みがそれぞれ30ナノ秒とすると，動的再配置をするのに必要なメモリアクセス時間は合計何ミリ秒か。ここで，1kバイトは1,000バイトとし，動的再配置に要する時間以外のオーバヘッドは考慮しないものとする。

→

セグメント2が解放されると、空き領域がセグメント3の前後に存在するようになります。最も少ない回数で空き領域を1つにする方法はセグメント3を前方(図の左側)に寄せることなので、セグメント3の800kバイトを移動させる時間を考えます。
1回のメモリアクセスは4バイト単位なので、800kバイトでは、
　800,000÷4＝200,000(回)
また、データの移動を行うには「読取り→書込み」の処理を繰り返さなければならないので、総メモリアクセス回数は2倍の400,000回になります。したがってアクセス時間の合計は、
　400,000×30＝12,000,000(ナノ秒)＝12(ミリ秒)

→

これって解釈の問題だよな。
800k全体を移動させるって発想にならないとダメだったみたい。
俺は100k空いたなら、800の内100k拾って移動させればいいだろうって思ってたからそもそも間違ってる。
問題文をよく読んだら、セグメントを移動と書いてあるので、100kだけ取り出すのではなく、全体を移動させるってことになるから、それ以外の選択肢がなくなるってわけか。
俺って本当に頭悪いな。
