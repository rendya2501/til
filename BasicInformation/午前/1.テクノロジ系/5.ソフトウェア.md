# ソフトウェア

---

## オペレーティングシステム


プリエンプティブとノンプリエンプティブは、共にマルチタスクOS上で実行されているプログラムを切り替えるときの方式です。

**プリエンプティブ**  
OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。

**ノンプリエンプティブ**  
実行プロセスの切替をプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間でほかタスクを実行する。
OSがCPUを管理しないので、1つのプログラムを実行中は、かのプログラムの実行は制限される。


プリエンプティブなタスクスケジューリングでは、CPU資源の使用をOSが管理し、タスクを動的に切り替えながら実行していきます。
OSの動作は、A・Bの優先度及びA・Bの状態によって変わります。

[Aの実行中にBに起動がかかる]
タスクの優先度は「A＞B」なので、Bは実行可能状態となり、Aの実行が継続されます。
待ち状態は、入出力待ちなどですぐにCPU処理に移れないタスクが遷移する状態なので、Bは待ち状態ではなく実行可能状態に移されます。

[Bの実行中にAに起動がかかる]
タスクの優先度は「A＞B」なので、Bは実行可能状態に移され、AにCPU使用権が与えられます。


**ディスパッチ**  
実行可能なタスクに対してプロセッサの使用権を割り当てること。
実行可能状態から実行状態にすること。
OSによるタスク管理の制御機能の1つで、実行可能状態のタスクの中から優先度順などによって次に実行すべきタスクを選択して、CPUの使用権を割り当てることです。
ディスパッチを行うプログラムをディスパッチャ(Dispatcher)と呼びます。
disから始まるので、イメージ的には使用権を剝奪する印象を受けるが逆なんだよなー。

**プリエンプション**  
実行状態から実行可能状態にする。

**実行状態**  

**実行可能状態**  

**待ち状態**  
実行状態のタスクに入出力要求が入ったら待ち状態になり、入出力が完了したら実行可能状態になる。

**タスクスケジューリング**  
各タスクの実行順序を決定すること

**マルチタスクまたはコンカレント処理**  
一つのプロセッサで複数のタスクを同時に実行しているかのように見せかけた状態のこと
コンカレント:同時並行

**タスクの内部状態、置かれた状況、タスクID及び優先度などを保持するTCB(Task Control Block，タスク制御ブロック)**  
タスクの実行に必要な情報であるコンテキストのこと



**リアルタイムOS(RTOS)**  
リアルタイム制御が必要とされるシステム用に特化したOSです。
リアルタイム制御とは、ジョブの実行が命令された時、限られた資源を使用して、その処理を決められた時刻(デッドライン)までに終了させること目的とする制御方式をいいます。
**リアルタイム処理では目標時間内に処理を完了させることが最重要です。**  
そのため重要度が高い、あるいはデッドラインが近いタスクに、より高い優先度を与えることで、
実行するタスクの順序を強制的に入れ替えることのできる優先度制御方式が適しています。

**到着順方式**  
起動が早いタスクから順番に処理を行う場合に利用される。

**ラウンドロビン**  
実行可能状態となった順に従って、タスクに一定のCPU時間(タイムクウォンタム)ずつ与えていくタスクスケジューリング方式です。
一定時間内に処理が終わらなかったタスクは、実行可能状態の待ち行列の最後尾に移され、次にCPU使用権が与えられるまでの間は待ち状態となります。
各タスクに均等にCPU時間が与えられるためタイムシェアリングシステムに適しています。

**残余処理時間順方式**  
処理時間が短いタスクから順番に処理を行う場合に利用される。




**ポーリング制御**  
主となるシステムが他のシステムに対して一定間隔で順繰りに要求がないか尋ねる方式。
ループにより各部の情報を一定時間ごとに順番に収集し、その情報をもとにソフトウェアの状態を判断して処理を行う制御方式です。
システム上でいつ発生するか分からないイベントを監視する目的で設定されます。
CPUが状態レジスタ又はビジー信号などを読み出して，入出力装置の状態を監視する。

**排他制御**  
複数のタスクが利用する共有資源を，一つのタスクが占有できるようにする。

**タスク間同期制御**  
送信側のタスクがメモリにデータを格納し，受信側のタスクにそのアドレスを伝える。

**割込み**  
実行中の処理を一時的に中断して，緊急度の高い別の処理を実行する。


**仮想メモリ**  
メモリっぽい役割が与えられたハードディスクの一部分。
メインメモリが足りなくなった時にハードディスクの一部を無理やりメモリとして使う。
Linuxのswap領域のあれ。

1.メモリの内容をハードディスクにしまう
2.使いたくなったらハードディスクから取り出す
の2つの動きです。
「メモリとハードディスクの間でメモリの内容を移動させる」ということになる。


**メモリインタリーブ**  
主記憶装置を，同時に並行して読み書き可能な複数の領域に分ける方式。

**ページング方式**  
仮想メモリの話でよく出てくる用語で、メモリを決まった大きさのページ単位で管理するやり方
仮想記憶管理方式の一つで仮想アドレス空間を「ページ」と呼ばれる固定長の区画に分割，同時に主記憶上も同じように固定長に分割して、
このページ単位で主記憶と補助記憶装置のアドレス変換を行う方式です。
処理に必要なページを動的に主記憶に割り当てることによって，主記憶を効率的に使用できる。
ページング方式ではプログラムに割り当てるメモリが連続である必要がなく、大きなフラグメンテーションがほとんど発生しないため、
メモリを無駄にしないというメリットがあります。
ページは固定長のサイズ。

**セグメント方式**  
ページングがページと呼ばれる単位に細切れにして管理する方式なら、こちらはファイルごと移動させるやり方になる。
まとめて移動させる固まりを「セグメント」として、メモリとやり取りする。

**ページフォールト**  
プログラムの実行に必要なページが主記憶に存在していないときに発生する割込みです。
ページフォールトが発生すると、ページアウトやページインなどのページ置換え処理が実行されます。

ページフォールトは、主記憶に存在しないページへのアクセス要求があって初めて発生します。
すなわち主記憶に存在するページにアクセスしている限りは発生しません。
つまりページフォールトの増加原因として適切な事象は、「主記憶に存在しないページへのアクセスが増加すること」です。


**スプーリング**  
プリンタなどの低速な入出力装置に対するデータの転送を磁気ディスク装置などを介して実行する機能のことです。
入出力装置とCPUでは動作速度の差が大きく、CPUが処理の途中で入出力命令をだすと入出力動作が終了するまでの間はCPUの待ち時間が増加しスループットが低下してしまいます。
スプーリングでは、入出力装置とやり取りするデータを一旦、外部記憶装置などへ転送し、外部記憶装置と入出力装置の間でデータをやり取り方法をとります。
これによってCPUは低速な入出力装置の動作完了を待つことなく、次の処理に移れるためスループットの大幅な向上が期待できます。

**バッファ(Buffer)**  
「緩衝するもの」の意味で、周辺機器とCPUの間にデータのやり取りが発生したときに、そのデータを一時的に蓄積しておくためのメモリ領域のことです。
入出力装置とCPUでは動作速度の差が大きく、CPUが処理の途中で入出力命令をだすと、入出力動作が終了するまでの間はCPUの待ち時間が増加し、スループットが低下してしまいます。
バッファを用いた場合は、バッファメモリと入出力装置の間でデータのやり取りが行われるため、CPUは低速な入出力装置の動作完了を待つことなく、次の処理に移ることができます。
これによってスループットを大幅に向上させることが可能です。
プリンタ出力を行う時のスプーリングもバッファ機能の一種です。


**ブロッキング**  
ブロッキングは、バリアブル方式の磁気ディスク装置で複数の論理レコードを1つの物理レコードにまとめることです。

**スワッピング**  
主記憶を効率よく使用するための方法で、実行中のプログラムが何らかの理由で停止したりして待ち状態が長く続く場合、
そのプログラムを実行中のまま補助記憶装置に移動し、別のプログラムを補助記憶装置から主記憶に戻します。

**ディスクキャッシュ**  
多数のバッファからなるバッファプールを用意し，主記憶にあるバッファにアクセスする確率を上げることによって，補助記憶装置のアクセス時間を短縮する。


**メモリリーク(MemoryLeak)**  
コンピュータの動作中に使用可能な主記憶容量が徐々に減少していく状態を表します。
アプリケーションが「自身で獲得したメモリの解放忘れる」などのプログラム不備などが原因で発生します。leakは漏えい、漏れ出すなどの意味です。
OSやアプリケーションのバグなどが原因で，動作中に確保した主記憶が解放されないことであり，これが発生すると主記憶中の利用可能な部分が減少する。

**オーバレイ方式**  
実行時のプログラム領域の大きさに制限があるときに，必要になったモジュールを主記憶に取り込む手法である。

**フラグメンテーション**  
主記憶で利用可能な空き領域の総量は足りているのに，主記憶中に不連続で散在しているので，大きなプログラムをロードする領域が確保できないことである。

**スラッシング**  
仮想記憶システムにおいて主記憶の容量が十分でない場合にプログラムの多重度が増加すると、ページング処理が多発します。
このようにシステムのオーバヘッドが増加したことによりアプリケーションのCPU使用率が減少し、処理速度が遅くなる状態をスラッシング(Thrashing)といいます。
アプリケーションの同時実行数を増やした場合に，主記憶容量が不足し，処理時間のほとんどがページングに費やされ，スループットの極端な低下を招くことである。




**LRU(Least Recently Used)**  
置き換え対象の中で最も長い時間参照されていないものを置き換え対象とするアルゴリズムです。
この置換アルゴリズムは、「最近使用されたページは再び近い将来に参照される可能性が高く、長い間参照されていないページは今後も参照される可能性が低い」ということを根拠としていて、キャッシュメモリや仮想記憶におけるデータの置き換えを決定するアルゴリズムとして使われています。

**LFU(Least Frequently Used)**  
置き換え対象の中で最も参照回数の少ないページを置き換えるアルゴリズムです。

**FlFO(First-in First-out)**  
置き換え対象の中に最も古くから存在するページを追い出す"先入れ先出し"のアルゴリズムです。

**LIFO(Last-in First-out)**  
置き換え対象の中に最後に追加されたデータを追い出す"後入れ先出し"のアルゴリズムです。



**アーカイバ(archiver)**  
複数のファイルを一つのファイルにまとめたり元に戻したりするソフトウェアで、まとめられたファイルのことをアーカイブといいます。
またアーカイバにはデータ圧縮機能があります。
メールに添付するときやインターネット上で配布する場合は、転送サイズを少なくできるアーカイブ状態にすることが推奨されます。
LPICでやったので問題ない。



平成28年秋期　問18
プロセスAの実行中に割込みが発生し、CPU使用権がプロセスBに移される過程を示しています。

1.プロセスAの実行状態をスタック領域に退避する
2.割込み処理を行うプロセスBを選択する
3.プロセスBの実行状態を回復(復元)する
という手順になります。

コンピュータは割込み処理が発生すると、その時点のプログラムカウンタ及びメモリの内容をスタック領域に退避して、
次に実行するプロセスの命令アドレスをプログラムカウンタに、実行状態をメモリにセットします。
これによってCPUで実行されるプロセスが変わります。

**プログラムカウンタ**  
次に実行すべき命令のアドレスが格納されているレジスタです。



令和元年秋期　問17
図の送信タスクから受信タスクにT秒間連続してデータを送信する。1秒当たりの送信量をS，1秒当たりの受信量をRとしたとき，バッファがオーバフローしないバッファサイズLを表す関係式として適切なものはどれか。ここで，受信タスクよりも送信タスクの方が転送速度は速く，次の転送開始までの時間間隔は十分にあるものとする。

→

送信タスクが受信タスクよりも転送速度が速いため、バッファにあふれが生じる可能性があります。
例えば、送信が100バイト／秒、受信が80バイト／秒であったとすると、1秒当たり20バイトがバッファに留まることになります。
この20バイトは、送信タスクの送信量(S)から受信タスクの受信量(R)を引いたデータ量、すなわち「S－R」の式で表せます。

さらに「S－R」が1秒当たりの滞留量なので、T秒間の連続送信中にバッファに留まる最大量は以下の式で表せます。
$(S－R)×T$
オーバフローを生じさせないためには、バッファサイズ(L)にこの数値以上を設定する必要があります。
以上より、Lが最大滞留量「(S－R)×T」以上であることを示す$L≧(S－R)×T$が適切な関係式とわかります。



平成26年秋期　問17
2台のCPUからなるシステムがあり，使用中でないCPUは実行要求のあったタスクに割り当てられるようになっている。このシステムで，二つのタスクA，Bを実行する際，それらのタスクは共通の資源Rを排他的に使用する。それぞれのタスクA，BのCPU使用時間，資源Rの使用時間と実行順序は図に示すとおりである。二つのタスクの実行を同時に開始した場合，二つのタスクの処理が完了するまでの時間は何ミリ秒か。ここで，タスクA，Bを開始した時点では，CPU，資源Rともに空いているものとする。

A : CPU 10ms → 資源R 50ms → CPU 60ms
B : CPU 40ms → 資源R 50ms → CPU 30ms

→

この問題のポイントは、二つのタスクは「共通の資源Rを排他的に使用する」ということです。

排他的ということはひとつのタスクが資源Rを使用している場合、もう一方のタスクは使用できずに待ち状態になります。
**CPUは2つ用意されているので、各タスクに占有的に割り当てることでCPU処理待ちはしないため**、資源Rの使用状態にさえ気を付ければ解ける問題です。
→ここ読めてない地点で間違ったようなものである。

資源Rが最初に割り当てられるのは、先にCPU処理が終わるタスクAで開始から10ミリ秒後です。その後開始から60ミリ秒後まで資源Rを占有し続けます。
タスクBは、開始からCPU処理を40ミリ秒に終え、資源Rを要求しますがタスクAが使用中なので、タスクAの使用が終わるまで20ミリ秒待たなければなりません。
両方のタスクとも待ち時間がなければ、処理は120ミリ秒で終了しますが、資源Rの使用待ちによってタスクBに生じた20ミリ秒の待ち時間だけ全体の終了時間が遅くなります。

したがって二つのタスクが処理完了するまでの時間は、
120＋20＝140
140ミリ秒が適切となります。



平成29年春期　問19
仮想記憶方式のコンピュータにおいて，実記憶に割り当てられるページ数は3とし，追い出すページを選ぶアルゴリズムは，FIFOとLRUの二つ考える。あるタスクのページアクセス順序が
1, 3, 2, 1, 4, 5, 2, 3, 4, 5

FIFO
"ページインしてからの時間が最も長いページ"を置換え対象とするアルゴリズム
1  14    4
 3    5    5
  2    23

LRU
1  1  2  5
 3  4  3
  2  5  4

→

LRUはよく出てくるからわかったけど、FIFOはわからなかった。
額面通りに受け止めてもしっくり来なかったが、追い出しに置けるFIFOはページインしてからの時間が最も長いページが対象だとは・・。
FIFOと言えば、上から入って下から抜けるアレだ。そのイメージでいくと、1が来た地点で1が抜けるのだが、そうではない。
同じものがあった場合は変化しない。違う数字が来た場合に、抜けるイメージか。そのルールさえ覚えれば、FIFOも大丈夫だ。



平成30年春期　問16
三つのタスクA～Cの優先度と，各タスクを単独で実行した場合のCPUと入出力装置(I/O)の動作順序と処理時間は，表のとおりである。A～Cが同時に実行可能状態になって3ミリ秒経過後から7ミリ秒間のスケジューリング状況を表したものはどれか。ここで，I/Oは競合せず，OSのオーバヘッドは考慮しないものとする。また，表の()の数字は処理時間を表すものとし，解答群の中の"待ち"はタスクが実行可能状態にあり，CPUの割当て待ちであることを意味する。

A:高:CPU(2)→I/O(2)→CPU(2)
B:中:CPU(3)→I/O(5)→CPU(2)
C:低:CPU(2)→I/O(2)→CPU(3)

→

3タスクが実行可能状態になってから全タスクが完了するまでのCPUとI/Oの使用状態は次のようになります。

1.まずCPUは、最も優先度の高いタスクAの処理を開始する。
2.開始から2秒後、タスクAがI/Oに移る。タスクAがI/Oを行っている間、CPUは次に優先度の高いタスクBを処理する。
3.開始から4秒後、タスクAのI/Oが完了する。優先度はタスクA＞タスクBなので、CPUはタスクBを実行可能状態に戻し、タスクAの処理を再開する。
4.開始から6秒後、タスクAが完了する。CPUは優先度の高いタスクBの処理を開始する。
5.開始から7秒後、タスクBがI/Oに移る。タスクBがI/Oを行っている間、CPUは残ったタスクCを処理する。
6.開始から9秒後、タスクCの前半のCPU処理が完了する。I/Oは競合しないのでタスクCはI/O処理を開始する。以降11秒後までCPUは待ち状態になる。
7.開始から11秒後、タスクCのI/Oが完了する。タスクBはI/O中なのでCPUはタスクCの処理を再開する。
8.開始から12秒後、タスクBのI/Oが完了する。優先度はタスクB＞タスクCなので、CPUはタスクCを実行可能状態に戻し、タスクBの処理を再開する。
9.開始から14秒後、タスクBが完了する。CPUは残ったタスクCの処理を再開する。
10.開始から16秒後、タスクCが完了する。

I/Oは競合しない→CPU使用中でもI/O中でも並列して動くことができる。
I/Oが競合しないとは、一つの装置の奪い合いにならず、
同時にI/Oの処理ができる、ということです。

同時実行可能になって3ミリ秒という問題文に注意する。0秒から追っていてはダメ。

---

## ファイルシステム

**ハッシュ法**  
ハッシュ関数を用いて、データやデータのキーの値からデータの格納位置を直接計算する方法です。
線形探索法や2分探索法とは異なり、常に一定の時間（探索回数1回）で目的のデータを探索することができます。

**データマイニング**  
蓄積されている膨大なデータを検索し，経営やマーケティングにとって必要な傾向，相関関係，パターンなどを導き出すための技術や手法である。

**セマンティック検索**  
データとそれに対する処理を組み合わせたオブジェクトに，認識や判断の機能を加え，利用者の検索要求に対して，その意図を判断する高度な検索技術である。

**シソーラス**  
キーワード検索のヒット率を高めることを目的に作成した，一種の同義語・類義語リストを用いることによって，検索漏れを防ぐ技術である。



**フルバックアップ**  
毎回、全ファイルのバックアップを行う方式。復旧時間は短くなるが、バックアップに必要な容量が多い分バックアップに要する時間は長い。
言わずもがな、全部。

**差分バックアップ**  
定期的にフルバックアップを行い、フルバックアップの間の期間は、フルバックアップ以降に変更のあった全てのファイルを記録する方式。
障害発生時にはフルバックアップと直前の差分バックアップ1つを使用して復旧する。
最初のバックアップの後，ファイル更新を示す情報があるファイルだけをバックアップし，ファイル更新を示す情報は変更しないでそのまま残しておく。
図解的には、階段状になっている。全開バックアップした部分も対象になっている。

**増分バックアップ**  
定期的にフルバックアップを行い、フルバックアップの間の期間は、前回の増分バックアップ以降に変更のあったファイルだけを記録する方式。
一度にバックアップする量は少なくて済むが、回復にはフルバックアップと複数の増分バックアップが必要になるので、障害発生時の復旧時間は長くなる。
直前に行ったバックアップの後，ファイル更新を示す情報があるファイルだけをバックアップし，ファイル更新を示す情報はリセットする。
図解的には、一番てっぺんの部分が対象となる。


**絶対パス**  
階層の最上位であるルートディレクトリを基点として，目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法。

**相対パス**  
現在作業を行っているカレントディレクトリを基点として、目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法。


**デバイスファイル**  
入出力装置をファイルと同じように取り扱えるようにする。

**デバイスコントローラ**  
入出力装置と処理装置との間のデータ交換に階層を設けることによって，入出力装置固有の仕様を意識せずに利用できる。

---

## 開発ツール

**コンパイラ(Compiler)**  
高水準語で記述されたソースコードを機械語などに一括して翻訳するソフトウェア。
原始プログラムを，目的プログラムに翻訳するプログラムである。
コンパイラにおける最適化とは、そのプログラムが動作するコンピュータの設計・仕様に合わせて実行速度が速くなるような機械語に変換することをいい
「不要な変数の省略」「関数のインライン展開」「レジスタ割当て」などの手法を用いることで、与えられたソースコードを最適化された機械語に変換を行います。

コンパイルの流れは次のようになっています。
ソースコード→字句解析→構文解析→意味解析→最適化→目的プログラム

**字句解析**  
プログラムを表現する文字の列を、意味のある最小の構成要素の列に変換する。
コンパイルの最初に行われ、ソースコードを意味のある最小の構成要素(トークン)に分解する処理です。
**構文解析**  
言語の文法に基づいてプログラムを解析し、文法誤りがないかチェックする
**意味解析**  
変数の宣言と使用とを対応付けたり、演算におけるデータ型の整合性をチェックする
**最適化**  
レジスタの有効利用を目的としたレジスタ割付けや、不要な演算を省略するためのプログラム変換を行う
処理時間や使用するメモリ量が少なくなるようにプログラムを再編成します。
具体的には、
・累乗を乗算に、乗算を加算にする。(加算のほうが処理速度が速い)
・値の変わらない変数を定数にする。
・ループを展開・関数のインライン展開。
等の変換を行う。

※累乗 : 同じ数を何回か掛け合わせること。2の3乗とか。

**インタプリタ(Interpreter)**  
プログラム言語の処理系の1つで、実行時にソースコードを1文ずつ解釈しながらプログラムを実行していくソフトウェアです。
原始プログラムを，解釈しながら実行するプログラムである。

インタプリタ方式は、コンパイラ方式と比較してプログラムの実行速度が遅くなる傾向にありますが、開発時にプログラム作成とテストの繰返しを容易に行える利点があります。JavaScript、PHP、Pythonなどのプログラム言語がインタプリタ方式を採用しています。
Interpreter : 翻訳者,通訳者

**リンカ(Linker)**  
相互参照の解決などを行い，複数の目的モジュールなどから一つのロードモジュールを生成する。
複数個のコンパイル済みプログラムや、そのプログラムで使用するライブラリを連結・統合し、1つの実行可能なプログラムファイルとして出力するソフトウェアです。

**ローダ(Loader)**  
実行に先立ってロードモジュールを主記憶にロードする。

**デバッガ(Debugger)**  
プログラムの実行を監視し，ステップごとに実行結果を記録する。



**静的テストツール**  
構文チェッカ、コードオーディタ、モジュールインターフェイスチェックツールなどのプログラムを**実行しない状態**でプログラムの検証を行うためのツール。
構文チェッカー : プログラム中に文法上の誤りや論理的な誤りなどがあるかどうかを，ソースコードを分析して調べる。

**動的テストツール**  
インスペクタ、トレーサ、スナップショット、メモリダンプ、カバレッジモニタ、アサーションチェッカなどのプログラムを**実行しながら**検証を行うためのツール。
カバレッジモニタ : テストの実行結果を基に，命令の網羅率や分岐の網羅率を自動的に計測し，分析する。
プロファイラ : モジュールの呼出し回数や実行時間，実行文の実行回数などの，プログラム実行時の動作特性に関するデータを計測する。

**環境設定ツール**  
テストベッドツール、テストデータ生成ツールなどのテスト環境を準備するためのツール。
テストケース作成ツール : 指定された条件のテストデータや，プログラムの入力ファイルを自動的に生成する。
テストベッドツール : テスト対象モジュールに必要なドライバ又はスタブを生成する。

---

## オープンソースソフトウェア

**OSS(Open Source Software)**  
ソフトウェア作者の著作権を守ったままソースコードを無償公開することを意味するライセンス形態、またはそのライセンス形態によって提供されるソフトウェアです。
オープンソースソフトウェアには主に、
・再頒布ができること
・ソースコードの入手が可能
・それをもとに派生物を作成可能
・再配布において追加ライセンスを必要としないこと
などの特徴があります。

**OSI(Open Source Initiative)**  
オープンソースソフトウェアを促進することを目的とする組織。
OSI基本参照モデルが真っ先に思い浮かんだが、こちらはISO(国際標準化機構)が作ったものなので全く関係ない。
因みに頭文字はopen systems interconnectionの略見たい。

**OSD(The Open Source Definition)**  
OSIが策定したオープンソースの定義
オープンソースライセンスが満たす条件として以下の要件を掲げています。

1.自由な再頒布ができること
2.ソースコードを入手できること
3.派生物が存在でき、派生物に同じライセンスを適用できること
4.差分情報の配布を認める場合には、同一性の保持を要求してもかまわない
5.個人やグループを差別しないこと
6.利用する分野を差別をしないこと
7.再配布において追加ライセンスを必要としないこと
8.特定製品に依存しないこと
9.同じ媒体で配布される他のソフトウェアを制限しないこと
10.技術的な中立を保っていること

平成31年春期　問20

社内での利用などのようにオープンソースソフトウェアを改変しても再配布しない場合，改変部分のソースコードを公開しなくてもよい。
→
正しい。派生ソフトウェアを頒布するときには、ソースコードも共に頒布しなければなりません（2. ソースコード）。
しかし、再配布しない場合は改変部分のソースコードを公開する必要はありません。

オープンソースソフトウェアを第三者が製品として再配布する場合，そのオープンソースソフトウェアの開発者は第三者に対してライセンス費を請求することができる。
→
オープンソースソフトウェアは、当該ソフトウェアが販売及び無料で配布されることを制限してはならず、これらの販売に関して印税その他の報酬を要求してはなりません（1. 再頒布の自由）。

オープンソースソフトウェアを改変し再配布する場合，元のソフトウェアと同じ配布条件となるように，同じライセンスを適用して配布する必要がある。
→
オープンソースソフトウェアの定義では、派生ソフトウェアについて、元となったオープンソースソフトウェアと同じライセンスを適用できることを求めていますが、
同じライセンスを強制するものではありません（3. 派生ソフトウェア）。本肢は「同じライセンスを適用して配布する必要がある」としているため誤りです。

ある特定の業界向けに作成されたオープンソースソフトウェアは，ソースコードを公開する範囲をその業界に限定することができる。
→
オープンソースソフトウェアは特定の個人やグループを差別してはなりません（5. 個人やグループに対する差別の禁止）。
本肢は「その業界に限定することができる」としているため誤りです。


**コピーレフト(Copyleft)**  
"著作権を保持したまま，プログラムの複製や改変，再配布を制限せず，そのプログラムから派生した二次著作物(派生物)には，オリジナルと同じ配布条件を適用する"とした考え方
作成者が著作権を保持したまま、二次的著作物も含めて、すべての者が著作物を利用・再配布・改変できなければならないという考え方です。

作品を不特定多数の人で共有して改善を加えるような場合に、著作者のみが著作権をもつという従来の仕組みが柔軟な創造活動の妨げになってしまうことがあります。
しかし作品を「パブリックドメイン」にしてしまうと著作者の意思に反した利用がなされる可能性や、改変者が二次著作物の著作権を得てしまうなどの問題が出てきます。
このような背景から、著作者の権利を保ったまま作品を不特定多数で共有し、共同での創造活動を可能にする「コピーレフト」の考え方が生まれました。
コピーレフトの考え方は、GPL(General Public License),LGPL(Lesser General Public License),MPL(Mozilla Public License)
などのオープンソースソフトウェアのライセンスで導入されています。

**パブリックドメイン**  
著作者が著作権を放棄するなどして知的財産権が消滅している状態

**コピーライト**  
コピー・複写(copy)と権利(right)を合わせた言葉で、著作権や複製権を意味します。

**デュアルライセンス**  
ひとつのソフトウェアを2種類以上の異なるライセンスの元で配布するライセンス形態です。

**BSDライセンス**  
カリフォルニア大学によって策定されたフリーソフトウェアで使われるライセンス体系のひとつです。
BSDライセンスのソースコードを組み込んだソフトウェアは、著作権表示、ライセンス条文、無保証の旨の三点をドキュメント等に記載さえしておけば、
ソースコードを公開せずに頒布することが可能になっています。
BSDライセンスでは、ソースコードの公開が義務ではない。


**Apache Hadoop(ハドゥープ)**  
ペタバイト級の大規模データの蓄積・処理の分散処理を実現するミドルウェアです。
Googleが論文として発表した分散処理フレームワーク「MapReduce」および分散ファイルシステム「Google File System」を基盤技術に、
オープンソースとしてJavaで実装したものです。

**Apache Tomcat(トムキャット)**  
Javaサーブレット・JSPで処理を行うオープンソースのWebアプリケーションサーバです。

**GCC(GNU C Compiler)**  
GNUが開発・配布している様々なプログラム言語のコンパイラでOSSの条件に従って自由に使用できます。

**GNU**  
UNIX互換のソフトウェア環境を修正・再頒布自由なフリーソフトウェアの理念に従って実装しようとするプロジェクト、または、それらのソフトウェア群のこと

**Eclipse(イクリプス，エクリプス)**  
IBMによって開発されたオープンソースの統合開発環境です。
主にJavaの開発環境として使用されていますが、プラグインを組込むことで機能が拡張できるように設計されているため、
多様なプログラム言語への対応をはじめWeb開発などの様々な開発局面での使用が可能になっています。

---

## 1回目に間違えた問題


平成29年秋期　問17
ソフトウェア制御における，ポーリング制御はどれか。
→
俺が知っているポーリングはトークンをループさせて、トークンを獲得したソフトウェアがあれこれできるってイメージだったのだが、回答にはそんな感じの答えはなかった。
CPUが状態レジスタ股はビジー信号等を読みだして、入出力装置の状態を監視する。ってのが答えらしい。
もしかして、俺のポーリングの認識が間違っているのか？



平成26年春期　問16
ページング方式の仮想記憶を用いることによる効果はどれか。
→
わかりそうでの奴でやったはずだが、忘れてしまった。
まず仮想記憶方式であること。
というか、問題文をよく読んでみると、効果って書いてあるな。
それはメモリを効率的に使うためですよってか。



平成27年秋期　問16
システム全体のスループットを高めるために，主記憶装置と低速の出力装置とのデータ転送を，高速の補助記憶装置を介して行う方式はどれか。
→
これは普通に知らなかったです。応用でも出てきた記憶がないです。
完全に覚えゲーなので、今回で覚えましょう。
正解はスプーリングですって。どっかで聞いたような気もするなって感じの言葉ですね。
あー、印刷の時のキューがこれかもしれん。入出力装置って書いてあるもんね。



平成31年春期　問20
OSIによるオープンソースソフトウェアの定義に従うときのオープンソースソフトウェアに対する取扱いとして，適切なものはどれか。
→
答えを全て見ていなかった。
中にCopyLeftの答えがあったので、選んだらダメだった。
そもそもOSIってなんやねん。



平成30年秋期　問19
手続型言語のコンパイラが行う処理のうち，最初に行う処理はどれか。
→
これはナチュラルに知らなかったです。
コンパイラといえば構文解析や最適化くらいしか知らなかったので、いい機会なので覚えます。

字句解析→構文解析→意味解析→最適化



平成27年春期　問21
出力待ちの印刷要求を，同一機種の3台のプリンタA～CのうちAから順に空いているプリンタに割り当てる(Cの次は再びAに戻る)システムがある。印刷要求の印刷時間が出力待ちの順に，5，12，4，3，10，4(分)である場合，印刷に要した時間が長い順にプリンタを並べたものはどれか。ここで，初期状態ではプリンタはすべて空いているものとする。

→

1.プリンタAに、出力待ち順の先頭である5分の印刷要求が割り当てられる。
2.プリンタBに、2番目の12分の印刷要求が割り当てられる。
3.プリンタCに、3番目の4分の印刷要求が割り当てられる。
4.開始から4分後、プリンタCの印刷が終わる。空きとなったプリンタCには3分の印刷要求が割り当てられる。
5.開始から5分後、プリンタAの印刷が終わる。空きとなったプリンタAには10分の印刷要求が割り当てられる。
6.開始から7分後、プリンタCの印刷が終わる。空きとなったプリンタCには最後の4分の印刷要求が割り当てられる。
7.開始から11分後、プリンタCの印刷が終わる。
8.開始から12分後、プリンタBの印刷が終わる。
9.開始から15分後、プリンタAの印刷が終わる。
以上より、3台のプリンタを印刷に要した時間が長い順に並べると「A，B，C」になります。

→

問題文をよく読むとそう書いてある。Aから順に空いているプリンターに割り当てる。
これは最初の話だけではなく、4分経過してAが空いたなら、すぐに次の印刷要求を受け入れる。ってことだったのか。
それなら、確かに、時系列順に並べて見てみれば、そうなるわな。
この手の問題は時系列で考えることが重要ということか。
