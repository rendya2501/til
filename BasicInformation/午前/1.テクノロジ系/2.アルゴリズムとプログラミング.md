# アルゴリズムとプログラミング

---

## アルゴリズム

### 基本挿入法

既に整列済みのデータ列の正しい位置に，データを追加する操作を繰り返していく方法である。
対象集合から要素を順次取り出し，それまでに取り出した要素の集合に順序関係を保つよう挿入して，整列を行う。

### クイックソート

対象集合から基準となる要素を選び，これよりも大きい要素の集合と小さい要素の集合に分割する。この操作を繰り返すことで，整列を行う。

### 基本交換法(バブルソート)

隣り合ったデータの比較と入替えを繰り返すことによって，小さな値のデータを次第に端のほうに移していく方法である。

### 基本選択法

対象集合から最も小さい要素を順次取り出して，整列を行う。
データ中の最小値を求め，次にそれを除いた部分の中から最小値を求める。この操作を繰り返していく方法である。

### 2分探索法

"要素が昇順または降順に整列された集合"に対して、探索範囲の中央に位置する値と目的の値を比較して探索範囲を1／2に狭めることを再帰的に繰り返して目的のデータを探索するアルゴリズムです。
2分探索法を適用するには、探索対象の集合が値の昇順または降順に整列されていることが条件です。

この関係を立式すると
$n＝2^x$
2を底として対数(log)をとると、
$log_2n＝x$
つまり計算量のオーダは $O(log n)$になります。

単純に2分の1していく場合、log nの頭に変な定数はつかない。
2のn乗に置ける「2」は低。log_2nとしてかかれるのが正式だが、省略されている。

### ハッシュ法

データの探索キーの値からデータの格納位置をハッシュ関数を用いて直接計算する方法です。
線形探索法や2分探索法とは異なり常に一定の時間で目的のデータを探索することができます。
ハッシュ法では異なるキー値から同じ格納場所が計算されることがあり、本来格納されるべき所に格納できない事態が発生することがあります。衝突(シノニム)

### O(ビッグオー)記法

計算量をO(n)やO(n^2)ような形で表します。  
括弧の中に入る文字は、計算量を表す式から次数が最大の項以外を除き、さらにそこから係数を除いたものになります。  

例:平成29年秋プログラミング  
まずプログラムの各部分の計算量(ステップ数)は以下のようになっています。  

![!](https://www.ap-siken.com/kakomon/29_aki/img/pm03_7.gif)  

これを全て足すとプログラム全体の計算量を表す以下の式になります。  

2V＋3NV＋1＋2V＋1  
＝3NV＋4V＋2  

この式中で次数が最大の項は3NVなので、これ以外を式から除きます。  
さらに3NVの係数である3を除いたNVが計算量O(NV)となります。  

### 辞書式順

こういうソート

``` txt
a
aa
aaa
aab
ab
aba
abb
b
ba
baa
bab
bb
bba
bbb
```

---

## データ構造

### 2分探索木

2分木の各節にデータをもたせることで探索を行えるようにした木構造です。
各節がもつデータは「**その節から出る左部分木にあるどのデータよりも大きく、右部分木のどのデータよりも小さい**」という条件があり、
これを利用して効率的にデータを探索することができるようになっています。
「左部分木の値＜ノードの値＜右部分木の値」

### 2分木

各節からでる枝の数が2本以下で構成される木

### 配列

・要素を一列に並べて管理する
・最初から固定の要素数でメモリを確保する→固定長のデータを表現するのに適している
・用意した要素数が連続した領域にメモリとして確保される
・位置を指定して，任意のデータに直接アクセスすることができる
・添え字を使ってメモリアドレスを直接指定できるので要素へのアクセスが速い
・途中に要素を挿入したり追加したりするには元にあった要素をズラす必要があり大変

### リスト

・要素を一列に並べて管理する
・要素数が可変できる
・前後にポインタが付与されポインタで接続されながらあいているメモリ領域に要素が格納されていく
・要素にアクセスするには先頭からポインタを辿っていく必要があり時間がかかる
・途中に要素を挿入したり、削除したりするにはポインタの接続を変えるだけなので速い

### 線形リスト

線形で表現されるリスト構造の総称で、一般的には隣接するデータ同士をポインタで連結して表現します。

**ポインタによって指定されている要素の後ろに，新たな要素を追加する計算量は，要素の個数や位置によらず一定である。**
正しい。単方向リストの場合は新たな要素の追加は以下の手順で行われます。
1.ポインタで指定された要素(以降、元要素)を取得する
2.元要素のポインタを新要素のポインタに付け替える
3.元要素のポインタが新要素を指し示すようにする
元要素の取得後、その要素の後ろに新たな要素を追加する計算量は、リストの要素の個数や追加する位置によらず一定です。
一方、配列の場合は追加する位置以後の要素を1つずつ後ろにシフトしなければなりません。

### キュー(待ち行列)(FIFO)(先入れ先出し)

先に入ったものから先に取り出す「先入先出し方式」のデータ構造です。
キューは何かの処理の"待ち行列"を実現する際によく使われる構造で、例えば、プリンタの印刷待ち、CPUの処理待ちなどがキュー構造で処理されています。

### スタック(LIFO)(後入れ先出し)

後入先出し方式でデータを入出力するデータ構造で、データを追加するプッシュ命令(push)と最後に格納されたデータを取り出すポップ命令(pop)でデータ操作を行います。
サブルーチン終了後の戻りアドレスや局所変数などを保持するのに使用されます。

平成26年秋期　問5
加減乗除を組み合わせた計算式の処理において，スタックを利用するのが適している処理はどれか。
→
計算の途中結果を格納し，別の計算を行った後で，その計算結果と途中結果との計算を行う処理
→
スタックは後入先出しのデータ構造なので、最後に追加データとの演算を容易に行うことができます。

---

## プログラミング

### 再入可能(リエントラント,Reentrant)

複数のタスクから同時に呼び出されても、それぞれに正しい値を返すことできるプログラム構造のことを表します。
これを実現するには、プログラムをデータ部分と内容が共通である手続き部分に分離し、データ部分をタスクごとに用意する必要があります。

### 再使用可能 (リユーザブル,Reusable)  

主記憶へのプログラムの展開を初回実行時のみ行い、それ以降はロードせずとも何度でも正しく使用できる特性。  
一度実行した後，ロードし直さずに再び実行を繰り返しても、正しい結果が得られるプログラムの性質です。
逐次再使用可能ともいうらしい。

### 再帰可能(リカーシブ,Recursive)

手続の内部から自分自身を呼び出すことができる。

### 再配置可能(リロケータブル,Relocation)

主記憶上のどこのアドレスに配置しても，実行することができる。

### オーバレイ

必要な部分を補助記憶装置から読み込みながら動作する。主記憶領域の大きさに制限があるときに，有効な手法である。

### プログラムのコーディング規約

平成30年秋期　問7

**処理性能を向上させるために，ループの制御変数には浮動小数点型変数を使用する。**
ループの制御変数に浮動小数点型変数(float等)を用いると、インクリメントやデクリメントの際の誤差が積み重なり、期待した結果を得られないことがあります。このためループの制御変数には整数型を使用するべきです。

**局所変数は，用途が異なる場合でもデータ型が同じならば，できるだけ同一の変数を使うようにする。**
用途が異なる場合には別々の変数を定義し、用途がわかるように適切な命名を行うべきです。

**領域割付け関数を使用するときは，割付けができなかったときの処理を記述する。**
正しい。領域割付け関数は必ず成功するとは限りません。もしメモリブロックを確保できないまま後続の処理に進むと、そこでエラーになってしまうので、領域割付け関数の戻り値をチェックするなどして割付け失敗時の分岐処理を記述するべきです。

**同様の計算を何度も繰り返すときは，関数の再帰呼出しを用いる。**
同様の処理を繰り返すときには、そのコードを抽出して別の独立した関数にするべきです。再帰関数は、実行時のスタックサイズが予測できずオーバフローを起こす可能性があるのでコーディング規約で使用を禁止されることもあります。

### JavaBeans

プログラムの再利用を目的としてJava言語で記述されたソフトウェア部品のことです。
既存のBeanを組み合わせることで開発効率が向上したり、深いプログラムの知識がなくてもBeanを使用することでソフトウェアに必要な機能が実装可能になるという利点があります。

### Javaアプレット

Webを通してブラウザにダウンロードされクライアント側で実行されるJavaで書かれたプログラムのことです。

### Javaサーブレット

Javaを用いてWebページのためのHTML文書を動的に生成したり、データ処理をWebサーバ上で行うサーバサイドのプログラム技術のことです。
HTMLを動的に生成することで掲示板やショッピングサイト・オンラインバンキングなどの機能が実現されています。

### Javaアプリケーション

Javaで書かれたプログラムの実行形態のひとつで、JavaアプレットがWebからダウンロードされて、Webブラウザ上で実行される事が多いのに対し、Javaアプリケーションは主にローカルコンピュータ上のJava Runtime Environment (JRE) で実行されるプログラムを指します。

### Java言語仕様

平成30年秋期　問8

**整数や文字は常にクラスとして扱われる。**
整数型(int)や文字型(char)は、原則としてクラスではなく基本データ型(プリミティブ型)として扱われます。  
基本データ型自体はオブジェクトではないためクラスとして扱えませんが、Javaではそれぞれの基本データ型に対応するラッパークラス(int→Integer、char→Character)が用意されていて、これを使用してデータに対する操作を行うことができます。  
常にクラスとして扱われるわけではないので誤りです。  

**ポインタ型があるので，メモリ上のアドレスを直接参照できる。**
Javaはポインタ型をサポートしていないので、メモリ上のアドレスを直接参照することはできません。  

**オブジェクト指向言語であり，複数のスーパクラスを指定する多重継承が可能である。**
Javaはクラスの多重継承、すなわち複数の親クラスを指定した子クラスの定義をサポートしていません。  
よって、複数のスーパクラスを指定する多重継承はできません。  

**メモリ管理のためのガーベジコレクションの機能がある。**
正しい。ガーベジコレクションは、プログラムが動的に確保したメモリ領域のうち、不要になった部分を自動的に解放して、再び使用可能にする機能です。  
従来の（ガーベジコレクションがない）プログラム言語では、プログラマが必要なメモリを確保する命令を記述し、使用後に明示的に解放する必要がありましたが、ガーベジコレクションが採用されている処理系では、不要と判断された時点で自動的にメモリの解放が行われます。  
Java言語では、ガーベジコレクション機能が言語仕様に組み込まれているため、プログラマはメモリを確保したいときにだけコードを記述しますが、解放時には明示的にコードを記述する必要がなくなっています。  

### JavaScript

主にユーザの動きに反応する動的なWebページの構築のために、HTML内に記述されるスクリプト言語です。  
当サイトでも使用していますが入力漏れのチェックや、HTMLを動的に編集することで動きのあるWebページを作ることができます。  
名前が似ていますがプログラミング言語Javaは、JavaScriptとは全くの別物です。  

### Perl(パール)

Larry Wall氏によって開発されたテキスト処理用のプログラム言語です。  
インタプリタ言語であり、UNIXやWindowsなど多くのプラットフォーム上で動作します。  
以前はWebページのCGIの記述によく用いられていました。  

**実行にWebサーバを必要とする言語であり，CGIの開発に適している。**
Webサーバ上で動作するCGIを記述する言語として知られていますが、デスクトップアプリケーションも作成できます。

### オーバライド(Override)

スーパークラスで定義されたメソッドをサブクラスで再定義すること
上位クラスで定義されたメソッド(メンバ関数)を、下位クラス側の役割に応じて再定義し動作を変更することです。
オブジェクト指向ではこの方法によって「同じメッセージを送ってもオブジェクトごとに異なる操作が行われる」特性である多相性を実現しています。

### カプセル化

オブジェクト内の詳細な仕様や構造を外部から隠蔽すること

### 汎化

複数のクラスの共通する性質をまとめて，抽象化したクラスを作ること

### オーバーロード

同一クラス内に，メソッド名が同一で，引数の型，個数，並び順が異なる複数のメソッドを定義すること

### 階乗

1からある自然数nまでの相乗のことをいい、nの階乗は記号!を使って「n!」と表記されます。例えば 4! であれば、
$4×3×2×1＝24$
というように計算します。

### Ajax(Asynchronous JavaScript + XML)(エイジャックス、アジャックス)

Webブラウザ内で非同期通信とインターフェイスの構築などを行う技術の総称です。
実際にやりとりするデータはXML文書に限られず、任意のデータをHTTPリクエスト／レスポンスの仕組みを用いてサーバとブラウザの間でやりとり可能です。
Ajaxを用いると、画面遷移を伴わずにコンテンツを書き換えられるので、シングルページアプリケーション(SPA)の制作などに利用されています。
Ajaxを使用した有名なサービスにGoogleMapやGmailがあります。

### RSS

ニュースやブログなど各種のウェブサイトの更新情報を簡単にまとめ、配信するための幾つかの文書フォーマットの総称です。

---

## その他の言語

### XML(eXtensible Markup Language，拡張可能なマークアップ言語)

ユーザが定義したタグや属性を用いて文書構造を記述することのできるマークアップ言語です。
HTMLが、あらかじめ定義済みのタグを用いてWebページを記述するための言語であるのに対して、XMLでは、データ交換をするのための汎用のデータ形式で、
ユーザ独自のタグを用いて記述することが可能です。(タグ名に日本語を使うこともできます。)

### DTD(Document Type Definition)

XMLなどのマークアップ言語において文書構造を定義するスキーマ言語の一つです。
XMLでは、文書作成者が自由に要素名や属性名を付け文章構造を構築することができます。
DTDには、記述可能な要素名、属性名や発生順序・発生回数など文書作成のルールを定義でき、XML文書側では文書型宣言`<!DOCTYPE …>`で使用するDTDを指定できます。
作成された文書がDTDに適合するかどうかを検証することで、処理の正確性や安全性を高められます。

### CSS(Cascading Style Sheets)

HTMLの要素を、どのように修飾して表示させるかを定義する文書で、構造とデザインを別の文書に分離させるために提唱されたスタイルシートの仕様のひとつです。
Webサイトの構築においては、1998年5月にW3Cにより勧告されたCSS2を基本とし、
最新ブラウザに先行実装されている高機能なCSS3を併用してデザインを行うことが多くなっています。
現在のWebサイトデザインでは、文書の構造をHTML、デザインをCSS、インタラクティブ性をJavaScriptというように3つの技術で役割分担してWebサイトの構成を考えます。

---

平成29年春期　問5
流れ図は，シフト演算と加算の繰り返しによって，2進整数の乗算を行う手順を表したものである。この流れ図中のa，bの組合せとして，適切なものはどれか。ここで，乗数と被乗数は符号なしの16ビットで表される。X，Y，Zは32ビットのレジスタであり，けた送りは論理シフトを用いる。最下位ビットを第0ビットと記す。

流れ図を見ると、被乗数がX、乗数がY、結果としてZを出力するので「X × Y ＝ Z」が成立すれば良いことがわかります。

細かな説明がない流れ図の穴埋めでは論理的に答えを導くのは難しいので、XおよびYにトレースが簡単な数値を設定して、出力Zが適切な値かどうかで正しい組合せを探すのが確実な解法です。ここではX＝3，Y＝3を使います（16ビット表記だと「0000 0000 0000 0011）。また、あるビット列を左に1ビットシフトすると2倍、右に1ビットシフトすると1／2したのと同じになります（ビットあふれは無視します）。
Yの0ビット目は1なので、Z←(0＋3) //Z＝3
Xを1ビット左シフト //X＝6
Yを1ビット右シフト //Y＝1
i←(1＋1) //i＝2
Yの第0ビットは1なので、Z←(3＋6) //Z＝9
Xを1ビット左シフト //X＝12
Yを1ビット右シフト //Y＝0
以後、Yの第0ビットはi>16になるまで0なので、加算は行われずにループ終了
Zを出力する //Z＝9
Yの第0ビットは1なので、Z←(0＋3) //Z＝3
Xを1ビット右シフト //X＝1
Yを1ビット左シフト //Y＝6
i←(1＋1) //i＝2
Yを左にシフトすると第0ビットに0が挿入される。以後、Yの第0ビットはi>16になるまで常に0なので、加算は行われずにループ終了
Zを出力する //Z＝3
Yの第15ビットは0なので加算はなし
Xを1ビット左シフト //X＝6
Yを1ビット右シフト //Y＝1
i←(1＋1) //i＝2
Yを右にシフトすると第15ビットには0が挿入される。以後、Yの第15ビットはi>16になるまで常に0なので、加算は行われずにループ終了
Zを出力する //Z＝0
Yの第15ビットは0なので加算はなし
Xを1ビット右シフト //X＝1
Yを1ビット左シフト //Y＝6
i←(1＋1) //i＝2
Yの第15ビットは0なので加算はなし
Xを1ビット右シフト //X＝0
Yを1ビット左シフト //Y＝12
Xが0になったので、加算処理が行われたとしてもZは0のままでループ終了
Zを出力する //Z＝0
唯一"3×3"の正しい結果である"9"を出力する「ア」の組合せが適切とわかります。

このアルゴリズムを一言で言うならば、Yの第nビットが1であれば、ZにX×2^nを加算する処理を繰り返すものということになります。

おまけとしてこのアルゴリズムをJavaScriptで実装したソースプログラムを掲載します。実行環境で数値やシフト部分を変えてお試しください。

``` js
var x=10, y=20, z=0, i=1;
while(true) {
    document.write('i='+i+'( ');
    //yの0ビット目が1かを確認
    if ((y & 1) > 0) {
        z = z + x;
    }
    document.write('y[0]='+(y & 1)+', z='+z);  
    x = x << 1; //xを1ビット左シフト
    y = y >> 1; //yを1ビット右シフト
    i = i + 1;
    document.write(', x='+x+', y='+y+' )<br>');
    if (i > 16) {
        break;
    }
}
document.write('<b>出力Z='+z+'</b>');
```

乗数は掛ける数。
被乗数は掛けられる数。
2 × 3なら 2が掛けられる数で3が掛ける数。
小学校で習う概念だぞ。

---

## 1回目に間違えた問題

平成31年春期　問5
2分探索木として適切なものはどれか。ここで，1～9の数字は，各ノード(節)の値を表す。

→
いやー。やばいね。
なんだかんだ木構造も自信を持って説明できない。
2分と分けているので、その通りのものを選べばよかった。



平成30年春期　問8【選択肢ランダム】
XML文書のDTDに記述するものはどれか。

→
Document Type Definition なのでそのまま「文書型の定義」
これは覚えゲーなので覚えましょう。



平成30年秋期　問5【選択肢ランダム】
待ち行列に対する操作を，次のとおり定義する。
ENQ n:
待ち行列にデータnを挿入する。
DEQ :
待ち行列からデータを取り出す。
　空の待ち行列に対し，ENQ1，ENQ2，ENQ3，DEQ，ENQ4，ENQ5，DEQ，ENQ6，DEQ，DEQの操作を行った。次にDEQ操作を行ったとき，取り出されるデータはどれか。

→
待ち行列 = 先入れ先出し
スタックの後入れ先出し法だと思ってた。
そもそも先入れ先出しって待ち行列っていうんですね。
逆に後入れ先出し法って何行列っていうんだ？
軽く調べて見たけど特に何も出てこない。



平成28年秋期　問6
2分探索木になっている2分木はどれか。

→
また間違えた。
見たらわかるではなく言葉で説明できるようにしろ。
中央値で左右に分けるのはいいとして、子要素の上下関係があいまいだ。
いや、子要素にも最初の定義を当てはめればいいだけでは？
つまり、子要素で2分されているかということだ。
ルートを見て小さい値<中央値<大きい値となっていること。
それを子要素にも適応させていけばいいだけだ。



43問目／選択範囲の問題数48問
Perlの実行に関する記述のうち，適切なものはどれか。

→
普通に知らなかった。
サーバーサイドの言語でCGI関係ってところまでは覚えていた。
なので、「実行にWebサーバを必要とする言語であり，CGIの開発に適している。」を選んだが、デスクトップアプリケーションも作れるみたいですね。
それは知らん。
インタプリタ型なので、コンパイルは必要ないところはあいまいだったので、覚えられてよかった。




平成31年春期　問7【
次の流れ図は，2数 A，B の最大公約数を求めるユークリッドの互除法を，引き算の繰返しによって計算するものである。Aが876，Bが204のとき，何回の比較で処理は終了するか。

→
何回の比較ってあるので、最後の12 = 12も勘定に含めましょうって感じ。
問題自体は、トレースしていけば終わる。



平成30年春期　問6
リストを二つの1次元配列で実現する。配列要素 box[i] と next[i] の対がリストの一つの要素に対応し，box[i] に要素の値が入リ，next[i] に次の要素の番号が入る。配列が図の状態の場合，リストの3番目と4番目との間に値が H である要素を挿入したときの next[8] の値はどれか。ここで，next[0] がリストの先頭(1番目)の要素を指し，next[i] の値が0である要素はリストの最後を示し，next[i] の値が空白である要素はリストに連結されていない。

→
日本語読めないです。日本語難しい。
定義を完全に理解しないと解けない。
簡単そうに見えて、結局どういうことってなるばかりだ。
とりあえず、next[0]から始まる。これが全て。

next[0] = 1
box[1] = A
next[1] = 5
box[5] = E
next[5] = 3
box[3] = C
next[3] = 7
box[7] =G
next[7] = 2
box[2] = B
next[2] = 0

A,E,C,Gと来て、3番目と4番目の間に入る、CとGの間にHが入るわけです。
つまり3の次の4にHが入って5番目からいつも通りということ。

box[5] = E
next[5] = 8 ※前は3
box[8] = H
next[8] = 7
box[7] = G
next[7] = 2

というわけで、7になります。
パソコンで書いたほうがわかりやすいですね。
