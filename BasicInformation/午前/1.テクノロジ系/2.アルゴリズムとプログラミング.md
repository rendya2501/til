# アルゴリズムとプログラミング

---

## アルゴリズム

### モンテカルロ法

※モンテカルロ法は一様乱数を用いることが特徴  

数値解析の分野において、確率を近似的に求めるために使われる手法です。  
乱数によるn回のシミュレーションを行い、ある事象がm回起これば、その事象の起こる確率は m／nで近似できます。  
試行回数nが大きくなるほどよりよい近似値を得ることができます。  

モンテカルロ法の例としてよく用いられるのが円周率の近似値を求める方法で、正方形内に乱数を用いて多数の点を打ち、「内接円内にある点の数／点を打った数」を計算することで円の面積を近似的に求め、そこから円周率を導きます。  

以下は、プログラムを組んで正方形内へのランダムな打点を10,000回繰り返した結果です。  
正方形の面積を1とすると内接円の面積は、 $0.5×0.5×π＝0.25π＝π/4≒0.785$ ですから、  
10,000回試行に対して内接円の内部の点の数が7,844個という結果は、正方形と内接円の面積比を概ね正確に表していると言えます。  

![!](https://www.ap-siken.com/kakomon/02_aki/img/06.gif)  

### ユークリッドの互除法

2つの自然数の最大公約数を求める手法の一つ。  
応用平成29年春期問6  

``` js
var x=120, y=66;
while (y != 0) {
    var t = x % y;
    x = y;
    y = t;
    document.write("x="+x+",y="+y+"<br>");
}
document.write("最大公約数は"+x);
```

### 基本挿入法

既に整列済みのデータ列の正しい位置に，データを追加する操作を繰り返していく方法である。  
対象集合から要素を順次取り出し，それまでに取り出した要素の集合に順序関係を保つよう挿入して，整列を行う。  

### 基本選択法

対象集合から最も小さい要素を順次取り出して，整列を行う。  
データ中の最小値を求め，次にそれを除いた部分の中から最小値を求める。この操作を繰り返していく方法である。  

### 2分探索法

"要素が昇順または降順に整列された集合"に対して、探索範囲の中央に位置する値と目的の値を比較して探索範囲を1／2に狭めることを再帰的に繰り返して目的のデータを探索するアルゴリズムです。  
2分探索法を適用するには、探索対象の集合が値の昇順または降順に整列されていることが条件です。  

この関係を立式すると  
$n＝2^x$  
2を底として対数(log)をとると、  
$log_2n＝x$  
つまり計算量のオーダは $O(log n)$になります。  

単純に2分の1していく場合、log nの頭に変な定数はつかない。  
2のn乗に置ける「2」は底。  
log_2nとしてかかれるのが正式だが、オーダー記法では省略する。  

### 線形探索法

先頭から順番に探す値が見つかるまで探していく探索法  
配列を「直線的（リニア）に」探していくので「リニアサーチ」と呼ばれます。  

#### 平成26年春期　問6

従業員番号と氏名の対がn件格納されている表に線形探索法を用いて，与えられた従業員番号から氏名を検索する。この処理における平均比較回数を求める式はどれか。ここで，検索する従業員番号はランダムに出現し，探索は常に表の先頭から行う。また，与えられた従業員番号がこの表に存在しない確率をaとする。

``` txt
データ数がnの線形リストを先頭から探索する場合、最小探索回数は1回，最大探索回数はn回なので、平均探索回数は(n＋1)／2回で表されます。
またデータが存在しない場合は、必ずリストの最後まで検索することになるので探索回数は常にn回となります。

データが存在しない確率がaなので、データが存在する確率は(1－a)です。

この処理における平均探索回数は、

　対象がリストに存在する場合の平均探索回数×対象が存在する確率
　＝{(n＋1)／2}×(1－a)

と、

　対象がリストに存在しない場合の探索回数×対象が存在しない確
　n×a

を足し合わせた値になります。

この数式を整えると、(n+1)(1-a)/2 + naになります。
```

### 分割統治法

大きな問題を同じ構造をもつ複数の小さな問題に分割し、その小さな問題の解を統合することで最終的に元の大きな問題を解決しようとする考え方です。  
整列アルゴリズムだとクイックソートやマージソートが分割統治法の考え方に基づくアルゴリズムです。  

![!](https://www.ap-siken.com/kakomon/03_haru/img/07.gif)  

### ハッシュ法

データの探索キーの値からデータの格納位置をハッシュ関数を用いて直接計算する方法です。  
線形探索法や2分探索法とは異なり常に一定の時間で目的のデータを探索することができます。  
ハッシュ法では異なるキー値から同じ格納場所が計算されることがあり、本来格納されるべき所に格納できない事態が発生することがあります。  

※衝突(シノニム)  
※ホモニム(同名異義語): 同じ名称なのに異なる意味を持つもの  

### ハッシュ表

キーから算出されたハッシュ値を添え字とする配列で、キーと値の組を複数個格納するデータ構造です。  

ハッシュ表探索では、あるキーに対応するデータを取り出すときに、キー値にハッシュ関数を適用して得られたハッシュ値を使うことで格納アドレスを一意に特定し、目的のデータをすばやく参照することができます。  
ハッシュ関数からハッシュ値を計算する速度はほぼ一定のであるため、データを参照する速度は表に格納されているデータ数の多寡に関わらずほぼ一定になります。  

### ベストフィット方式

メモリ割り当てを制御するアルゴリズムで、空き領域の大きさ順リストを先頭から探索し、要求サイズに最も合致する空きブロックを割り当てる方式です。("最も合致する"とは要求サイズよりも大きく、割り当て後の残り領域が最も小さくなること)  
最もフィットする領域を使用するのでメモリ割り当てごとに小さい空き領域が生じ、最終的には使用するのが難しいほど小さな領域が残る傾向があります。  

### ファーストフィット方式

空きブロックをメモリの先頭から検索していき、要求サイズ以上の空きブロックが見つかった時点でそれを割り当てるアルゴリズム  

### ワーストフィット方式

ベストフィットと同様に空きブロック全体を検索後、最も大きな領域を割り当てるアルゴリズム  

### O(ビッグオー)記法

実行時に処理するデータ量によってアルゴリズムの計算量がどの程度増加するか、という視点でアルゴリズムを評価するものです。  
計算量をO(n)やO(n^2)ような形で表します。  

・括弧の中に入る文字は、計算量を表す式から次数が最大の項以外を除き、さらにそこから係数を除いたものになります。  
・O記法では通常、底を省略して記述します。(log_2 n × , log n ○)  
・想定される最大の計算量を求めるには、比較回数が最大になる場合を考えます。  

**空間計算量**  
処理を達成するために必要な記憶領域の大きさ  

必要とする記憶領域の大きさは、関数内で宣言する変数の数に依存します。  
変数の数は定数であり、与えられたnによらず一定です。  
計算量がデータ量に依存しない場合、O記法では「O(1)」と表します。  

**時間計算量**  
処理を達成するために必要な時間  

計算量がデータ量nに比例する場合、O記法では「O(n)」と表します。  

### 計算量

ソート対象のデータ数 n を基準とした計算量でアルゴリズムを分類できます。  
要は n が増加したときに、どれだけ実行時間が増えるかの目安です。  
計算量は、最悪と平均をそれぞれ考慮する必要があります。  

計算量が小さいほうが、基本的には性能のよいアルゴリズムとなります。  
これはソート以外のアルゴリズムでも当てはまるものです。  
主だった、計算量の大小関係は以下の通りです。  

$O(1) < O(log n) < O(n) < O(n log n) < O(n^{1.5}) < O(n^2)$  

#### 括弧の中に入る文字は、計算量を表す式から次数が最大の項以外を除き、さらにそこから係数を除いたものになります

例:平成29年秋プログラミング  
まずプログラムの各部分の計算量(ステップ数)は以下のようになっています。  

![!](https://www.ap-siken.com/kakomon/29_aki/img/pm03_7.gif)  

これを全て足すとプログラム全体の計算量を表す以下の式になります。  

2V＋3NV＋1＋2V＋1  
＝3NV＋4V＋2  

この式中で次数が最大の項は3NVなので、これ以外を式から除きます。  
さらに3NVの係数である3を除いたNVが計算量O(NV)となります。  

#### 想定される最大の計算量を求めるには、比較回数が最大になる場合を考えます

例:平成27年秋プログラミング  
![!](https://www.ap-siken.com/kakomon/27_aki/img/pm03_1.gif)  

問題文の〔2分探索木の計算量〕には、「2分探索木における計算量は、木の高さに依存する。」とあります。  
想定される最大の計算量を求めるには、比較回数が最大になる場合を考えます。  

探索において比較回数が最大になるのは、全てのノードが一つの子ノードを持つ構造になっていて、探索するキー値が木の葉部分に位置している場合です。  
このときのノードの数をnとすると、木の高さはn-1です（木の高さは根から一番遠い葉までの枝の数です）。  
最大比較回数は「木の高さ＋1」で求めることができるため、「n-1+1＝n回」になります。  
以上より、計算量はO(n)となるので、[ク]には「n」が入ります。  

#### 空間計算量,時間計算量

例:平成26年春プログラミング

![!](https://www.ap-siken.com/kakomon/26_haru/img/pm03_6.gif)  

与えられた n に基づき，O記法で表した場合，関数 junkan のプログラムが必要とする記憶域の大きさは[オ]となり，計算量は[カ]となる。

〔オについて〕空間計算量  
関数 junkan のプログラムが必要とする記憶領域の大きさを考えます。  

必要とする記憶領域の大きさは、関数内で宣言する変数の数に依存します。  
表1「関数junkanで使用する変数及び関数」より、関数junkanのプログラムでは、5つの変数を使用していることがわかります。  
変数の数は定数であり、与えられたnによらず一定です。  
計算量がデータ量に依存しない場合、O記法では「O(1)」と表します。  

∴オ＝O(1)  

〔カについて〕時間計算量  
関数 junkan のプログラムの計算量を考えます。  

関数 junkan のプログラムは、「余りが一致するまで」「循環節の先頭の検出」「循環節の末尾の検出」の3つの繰返し処理で構成されています。  
循環節の桁数が最大 n-1 であることから、3つの処理のいずれも最大 n-1 回で計算可能です。  
計算量がデータ量nに比例する場合、O記法では「O(n)」と表します。  

∴カ＝O(n)  

### 辞書式順

こういうソート

``` txt
a
aa
aaa
aab
ab
aba
abb
b
ba
baa
bab
bb
bba
bbb
```

---

## アルゴリズム(ソート)

逐次添加法  
バブルソート，基本選択法，基本挿入法，シェルソート  

分割統治法  
クイックソート，マージソート  

データ構造の利用  
ヒープソート，2分探索木  

安定なソート  
バブルソート  

``` txt : 早見表 <https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%BC%E3%83%88>
名称           平均計算時間  最悪計算時間 メモリ  安定性  手法        備考
-------------------------------------------------------------------------------
バブルソート    n^2          n^2          1      ○       交換
選択ソート      n^2          n^2          1      ×       選択        安定ソートとしても実装可能
挿入ソート      n^2          n^2          1      ○       挿入        
シェルソート    n log n      >=n^1.5      1      ×       挿入        
2分木ソート     n log n      n log n      n      ○       挿入        平衡2分探索木を使った場合
マージソート    n log n      n log n      n      ○       マージ      連結リストの場合はO(1)外部メモリ
ヒープソート    n log n      n log n      1      ×       選択
クイックソート  n log n      n^2          log n  ×       パーティショニング メモリはコールスタック
```

### 安定なソート

同じデータの順番がソート前後によって変化しないソート手法  

安定ソート（あんていソート、stable sort）とは、ソート（並べ替え）のアルゴリズムのうち、同等なデータのソート前の順序が、ソート後も保存されるものをいう。  
つまり、ソート途中の各状態において、常に順位の位置関係を保っていることをいう。  

### 内部ソート

ソートを実行する際に、ソート対象のデータの格納領域以外に、O(1) か O(log n) の領域しか必要としないソートを内部ソートと呼びます。  

内部ソートの例として、バブルソートがあります。  
バブルソートは要素の交換を繰り返しながらソートを行います。  
必要となるデータ領域は、格納領域のほかには、交換の際の O(1) のみです。よって内部ソートに分類されます。  

同じく内部ソートの例として、クイックソートが挙げられます。  
クイックソートは再帰的な呼び出しを用います。  
そのため O(log n) の外部領域を必要としますが、これは分類上、内部ソートとされます。  

### 外部ソート

外部ソートはソート対象のデータ格納領域以外に O(n) 以上の外部領域を必要とするソートアルゴリズムを指します。  
例えばマージソートが一例です。マージソートはマージの際に、最大 n/2 の外部領域を必要とします。  
つまり、O(n) の外部領域を必要とするため、外部ソートとなります。  

### 選択ソート（英: selection sort）

ソートのアルゴリズムの一つ。 配列から最小値を探し、配列の先頭要素と入れ替えていくことで並べ替える。  

最悪時間計算量は O(n2) と遅いため、一般にはクイックソートなどのより高速な方法が利用される。  
しかし、空間計算量が限られるため他の高速な手法が使えない場合や、ソートする配列が充分小さく、選択ソートが高速に動作することが保証されている場合に利用されることがある。  

選択ソートは内部ソートである。  
また、安定ソートではない。  
選択ソートの改良として、ヒープソートが挙げられる。  

選択ソートは以下の手順で行う：

1. 1 番目の要素から最後尾の要素までで最も値の小さいものを探し、それを 1 番目の要素と交換する（1番目の要素までソート済みとなる）  
2. 以降同様に、未ソート部分の最小要素を探索し、未ソート部分の先頭要素と交換する  
3. すべての要素がソート済みになったら処理を終了する  

上記は昇順への並べ替えだが、降順の場合も同様に、最小値でなく最大値を検索することで実現できる。  

``` txt
クラス          ソート
データ構造      配列
最悪計算時間    О(n²)
最良計算時間    О(n²)
平均計算時間    О(n²)
最悪空間計算量  О(n) total, O(1) auxiliary
```

### 挿入ソート（そうにゅうソート、英: insertion sort）あるいは基本挿入法

ソートのアルゴリズムの一つ。  
整列してある配列に追加要素を適切な場所に挿入すること。  

時間計算量は平均・最悪ケースでともに Ο(n2) であり、クイックソートやマージソートなどと比べれば遅い。  
しかし、

・アルゴリズムが単純で実装が容易  
・小さな配列に対しては高速  
・安定  
・in-placeアルゴリズム  
・オンラインアルゴリズム  

などの特徴から利用されることがある。
挿入ソートを高速化したソート法として、シェルソートが知られている。  

まず0番目と1番目の要素を比較し、順番が逆であれば入れ換える。  
次に、2番目の要素が1番目までの要素より小さい場合、正しい順に並ぶように「挿入」する（配列の場合、前の要素を後ろに一つずつずらす）。  
この操作で、2番目までのデータが整列済みとなる（ただし、さらにデータが挿入される可能性があるので確定ではない）。  
このあと、3番目以降の要素について、整列済みデータとの比較と適切な位置への挿入を繰り返す。  

動作例  
整列された部分（確定とは限らない）をアンダーライン、挿入する部分を太字で表す。  

``` txt
8    4    3    7    6    5    2    1    （初期データ）
4    8    3    7    6    5    2    1    （1回目のループ終了時）
3    4    8    7    6    5    2    1    （2回目のループ終了時）
3    4    7    8    6    5    2    1    （3回目のループ終了時）
3    4    6    7    8    5    2    1    （4回目のループ終了時）
3    4    5    6    7    8    2    1    （5回目のループ終了時）
2    3    4    5    6    7    8    1    （6回目のループ終了時）
1    2    3    4    5    6    7    8    （7回目のループ終了時。ソート完了）
```

``` txt
クラス         ソート
データ構造     配列
最悪計算時間   О(n²)
最良計算時間   O(n)
平均計算時間   О(n²)
最悪空間計算量 O(n) total, O(1) auxiliary
```

### クイックソート

[1]  
対象集合から基準となる要素を選び，これよりも大きい要素の集合と小さい要素の集合に分割する。  
この操作を繰り返すことで，整列を行う。  

[2]  
中間的な基準値を決めて，それよりも大きな値を集めた区分と，小さな値を集めた区分に要素を振り分ける。  
次に，それぞれの区分の中で同様な処理を繰り返す。  

[3]  
n個のデータをある基準値以下の値のグループと基準値以上の値のグループに分割し、さらにそれぞれのグループで基準値を選んで二つのグループに分割するという処理を繰り返してデータを整列するアルゴリズムです。  
下図のように全体を小集団に分けながら整列を行うので、分割統治型の整列法と言えます。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/08.gif)  

### バブルソート(基本交換法,単純交換法,隣接交換法)

隣り合ったデータの比較と入替えを繰り返すことによって，小さな値のデータを次第に端のほうに移していく方法である。  

### シェルソート(Shell sort)

ある間隔おきに取り出した要素から成る部分列をそれぞれ整列し，更に間隔を詰めて同様の操作を行い，間隔が1になるまでこれを繰り返す。  

シェルソートとは、与えられたデータ列を大小などの順序通りになるよう並べ替えるソート（整列）アルゴリズムの最も基本的な手法の一つで、挿入ソートを改良したもの。  
1959年にアメリカのコンピュータ科学者ドナルド・シェル（Donald Shell）が考案した。  

最良の場合の計算時間は挿入ソートと同じO（n）と高速。  
挿入ソートでは逆順の場合にO（n^2）かかっていた最悪の場合の計算時間がO（nlogn）で済むという利点がある。  
間隔の選び方によって性能は異なり、適切な間隔の決定方法について様々な手法が提唱されている。  

``` tex
データ構造     配列
最悪計算時間   間隔に依存
最良計算時間   O(nlog{n})
平均計算時間   間隔に依存
間隔については後述
最悪空間計算量 O
安定なソートではない
```

#### 平成31年春期　問6

次の手順はシェルソートによる整列を示している。データ列 7，2，8，3，1，9，4，5，6 を手順(1)～(4)に従って整列するとき，手順(3)を何回繰り返して完了するか。ここで，[ ]は小数点以下を切り捨てた結果を表す。

〔手順〕
"H←[データ数÷3]"とする。
データ列を，互いにH要素分だけ離れた要素の集まりからなる部分列とし，それぞれの部分列を，挿入法を用いて整列する。
"H←[H÷3]"とする。
Hが0であればデータ列の整列は完了し，0でなければ(2)に戻る。

9つの要素を手順に沿って整列していくと、次のようになります。
H ← 9÷3 //H=3
Hが3なので、要素ごとが互いに3つずつ離れた要素から成る3つの部分文字列に分解し、それぞれ整列する。

![!](https://www.ap-siken.com/kakomon/31_haru/img/06.gif)  

H ← 3÷3 //H=1、(3)の処理1回目
Hが0ではないので、(2)の処理に戻る
Hが1なので、要素ごとが互いに1つずつ離れた要素から成る 3,1,6,4,2,8,7,5,9 を整列し、1,2,3,4,5,6,7,8,9 とする。
H ← 1÷3 //H=0、(3)の処理2回目
Hが0なので、データ列の整列が完了
したがって完了までに(3)の処理が繰り返される回数は2回です。

### ヒープソート

[1]  
未整列の部分を順序木にし，そこから最小値(または最大値)を取り出して整列済の部分に移すという操作を繰り返して、未整列の部分を縮めていく整列アルゴリズムです。  

[2]  
未整列データを「親の値≦子の値」(または「親の値≧子の値」)の関係をもつ順序木として表現し、整列後の根の値(最小値または最大値)を取り出すことを繰り返して整列を行う方法です。  

### マージソート

整列対象を大きさ1の部分文字列に分割した後、隣り合う要素ごとに整列と併合を繰り返しながら整列を行うソート手法。  

![!](https://www.ap-siken.com/kakomon/26_aki/img/06a.gif)  

---

## アルゴリズム 問題

### 平成30年春期　問5

非負の整数m，nに対して次のとおりに定義された関数 Ack(m，n) がある。Ack(1，3) の値はどれか。  
![!](https://www.ap-siken.com/kakomon/30_haru/img/05.gif)  

→

``` txt
設問の再帰関数 Ack(1，3) を実行すると次のようになります。
　Ack(1，3)
//Ack(1，3)は、m＞0かつn＞0
＝Ack(0，Ack(1，2))
//Ack(1，2)は、m＞0かつn＞0
＝Ack(0，Ack(0，Ack(1，1)))
//Ack(1，1)は、m＞0かつn＞0
＝Ack(0，Ack(0，Ack(0，Ack(1，0))))
//Ack(1，0)は、m＞0かつn＝0
＝Ack(0，Ack(0，Ack(0，Ack(0，1))))
//Ack(0，1)は、m＝0
＝Ack(0，Ack(0，Ack(0，2)))
//Ack(0，2)は、m＝0
＝Ack(0，Ack(0，3))
//Ack(0，3)は、m＝0
＝Ack(0，4)
//Ack(0，4)は、m＝0
＝5
```

![!](https://www.ap-siken.com/kakomon/30_haru/img/05a.gif)  

### 平成30年秋期　問27

自然数を除数とした剰余を返すハッシュ関数がある。値がそれぞれ571，1168，1566である三つのレコードのキー値を入力値としてこのハッシュ関数を施したところ，全てのハッシュ値が衝突した。このとき使用した除数は幾つか。

もし、方程式で求めるならば次のようになります。

``` math
　571－ax＝1168－bx
　－ax＋bx＝597
　(b－a)x＝597
```

(b－a)は自然数なのでxは597の約数、選択肢の中で597の約数であるのは199しかありません。

### 平成28年春期　問6

流れ図に示す処理の動作の記述として，適切なものはどれか。ここで，二重線は並列処理の同期を表す。  
![!](https://www.ap-siken.com/kakomon/28_haru/img/06.gif)  

``` txt
図中には二重線が示す同期部分があるため、2つのタスクが協調し合いながら処理を進める同期制御の流れ図であることがわかります。
同期制御では、2つの処理の待ち合わせが行われます。一方の処理が先に終了した場合でも、その先の処理に進まず、二重線が示すポイントでもう一方の処理の終了を待ちます。

問題の流れ図ではまずAが実行され、その後BとCがほぼ同時に実行されます。すぐ下に同期のポイントがあるため、Bが先に終了した場合はCの終了を、Cが終了した場合にはBの終了を、それぞれ待つことになります。同期ポイントの存在によってB又はCの片方だけが連続して実行されることはなくなります。

この結果、Aが最初に一度だけ実行され、その後はBC又はCB、BC又はCB、…の実行が繰返し行われることになります。
```

![!](https://www.ap-siken.com/kakomon/28_haru/img/06a.gif)  

### 平成27年秋期　問5

キーが小文字のアルファベット1文字（a, b, …，z のいずれか）であるデータを，大きさが10のハッシュ表に格納する。ハッシュ関数として，アルファベットのASCIIコードを10進表記法で表したときの1の位の数を用いることにする。衝突が起こるキーの組合せはどれか。ASCIIコードでは，昇順に連続した2進数が，アルファベット順にコードとして割り当てられている。  

ASCIIコード上で、アルファベットは並び順どおりに連続した位置に配置されています。  
![!](https://www.ap-siken.com/kakomon/27_aki/img/05_1.gif)  

ハッシュ表の大きさが10であり、格納位置を求めるハッシュ関数にASCIIコードを10進表記法で表したときの1の位の数を使うことから、1の位が同じとなるアルファベット同士では、ハッシュ表上の格納位置が同じになってしまうシノニム（衝突）が発生することになります。  

つまりASCIIコード上のアルファベットを順番に並べたときの2つの文字の距離が、10の倍数になっているものが衝突が起こるキーの組合せです。  

d と x の距離は20で、10の倍数であるため衝突が発生します。  
![!](https://www.ap-siken.com/kakomon/27_aki/img/05_2.gif)  

### 令和2年秋期　問47

次の流れ図において，  
　①→②→③→⑤→②→③→④→②→⑥  
の順に実行させるために，①においてmとnに与えるべき初期値aとbの関係はどれか。ここで，a，bはともに正の整数とする。  

![!](https://www.ap-siken.com/kakomon/02_aki/img/47.gif)  

``` math
指定の順序通りに進むと次のように処理されていきます。
m ← a，n ← b
m＜n で⑤の処理に進む
n ← n－m
m＞n で④の処理に進む
m ← m－n
m＝nとなり処理終了
⑤でnを1回更新、④でmを1回更新して、⑥の段階でm＝nとなります。

まず直前の④の処理について考えます。
「m ← m－n」という処理をしているので、"更新前のm"の値は、"更新後のm"と"n"の和です。④の処理後は m＝n になっていますから、"更新前のm"の値は 2n で表すことができます。

次に⑤の処理について考えます。
「n ← n－m」という処理をしているので、"更新前のn"の値は、"更新後のn"と"m"の和です。m＝2n ですから、"更新前のn"の値は 3n で表すことができます。

これより前にはm及びnを更新する処理はないので、処理開始時に m：n＝2：3 であれば最終的に m＝n となることがわかります。mはa、nはbが代入される変数なので初期値aとbの関係は a：b＝2：3、これを式に変換した「3a＝2b」が正解です。

【別解】
① m←a、n←b
②→③→⑤ m<n(⇔a<b)より n←(n-m)=b-a
この時点で m=a、n=b-a
②→③→④ m>n(⇔a>b-a)より m←m-n=a-(b-a)=2a-b
この時点で m=2a-b、n=b-a
②→⑥ m=n⇔2a-b=b-a⇔3a=2b
```

### 平成28年秋期　問2

0≦x≦1の範囲で単調に増加する連続関数f(x)が f(0)≦0≦f(1) を満たすときに，区間内で f(x)＝0 であるxの値を近似的に求めるアルゴリズムにおいて，(2)は何回実行されるか。  

〔アルゴリズム〕  
(1) x0←0，x1←1とする。  
(2) x←とする。  
(3) x1－x＜0.001ならばxの値を近似値として終了する。  
(4) f(x)≧0ならばx1←xとして，そうでなければx0←xとする。  
(5) (2)に戻る。  

→  

仮に f(0.3)＝0 としてアルゴリズムを途中までトレースしていくと次のようになります。

``` txt
1: x0←0，x1←1
2: x←(0＋1)／2 //x=0.5
3: (1－0.5)＜0.001 は偽なので処理続行する
4: f(0.5)≧0 は真なので、x1←0.5
　　//(2)に戻る
5: x←(0＋0.5)／2 //x=0.25
6: (0.5－0.25)＜0.001 は偽なので処理続行する
7: f(0.25)≧0 は偽なので、x0←0.25
　　//(2)に戻る
8: x←(0.25＋0.5)／2 //x=0.375
9: (0.5－0.375)＜0.001 は偽なので処理続行する
10: f(0.375)≧0 は真なので、x1←0.375
　　//(2)に戻る
11: x←(0.25＋0.375)／2 //x=0.3125
12: (0.375－0.3125)＜0.001 は偽なので処理続行する
13: f(0.3125)≧0 は真なので、x1←0.3125
　　//以下、続く
```

このアルゴリズムでは2分探索法のように(2)～(5)を繰り返すごとにxの範囲を1／2ずつ狭めていきます。
1回目 0≦x≦0.5 (最大誤差0.5)
2回目 0.25≦x≦0.5 (最大誤差0.25)
3回目 0.25≦x≦0.375 (最大誤差0.125)
4回目 0.25≦x≦0.3125 (最大誤差0.0625)
このアルゴリズムの終了条件は誤差が0.001です。つまり1／1000未満になるまで(2)～(5)を繰り返します。上記の誤差の推移に注目すれば、処理回数n回目での誤差は「1／2n」の式で表せることがわかります。

2^10＝1,024 であることを考えれば、n＝10 のとき誤差0.001（1／1,000）未満を達成できます。

※補足としてJavaScriptによる実行例を示しておきます。  
![!](https://www.ap-siken.com/kakomon/28_aki/img/02a.gif)  

---

## データ構造

### 2分探索木

2分木の各節にデータをもたせることで探索を行えるようにした木構造です。  
各節がもつデータは「**その節から出る左部分木にあるどのデータよりも大きく、右部分木のどのデータよりも小さい**」という条件があり、
これを利用して効率的にデータを探索することができるようになっています。  
「左部分木の値＜ノードの値＜右部分木の値」  

### 2分木

各節からでる枝の数が2本以下で構成される木

### 完全2分木

全てのノードが2つの子ノードを持ち、根から葉までの距離がどこでも等しい木構造です。  
![!](https://www.ap-siken.com/kakomon/27_aki/img/pm03_10.gif)  

木の深さが「n」であれば葉の数は「2n」  
葉の数が「n」であれば、葉以外の節点の数(根を含む)は「n－1」であるという特徴を持っています。  

※深さとは根より下の階層の数である。  
深さ2の場合  
深さ0 → ルート  
深さ1 → ノード2つ  
深さ2 → ノード4つ  
![!](https://medium-company.com/wp-content/uploads/2021/09/fulltree-768x343.png)  

完全2分木の場合は、探索範囲を1／2ずつに狭めながら探索していきます。  
すなわち、n個のノードを1／2することをk回繰り返して、1つの値を見つけます。  
このことから、「n×1／2k＝1」の式を導くことができます。  

``` math
n×1／2k＝1
n＝1／(1／2k)
n＝1×2k
n＝2k
```

より「k=log2n」となります。  
O記法では通常、底を省略して記述しますので、[ク]には「log n」が入ります。  

※完全2分木を探索する計算量は、2分探索の計算量と同じです。  

### 行きがけ順(先行順)

訪問したタイミングで調べる  
![!](https://www.ap-siken.com/kakomon/03_haru/img/06_3.gif)  

### 帰りがけ順(後行順)

移動する子がなくなったタイミングで調べる  
![!](https://www.ap-siken.com/kakomon/03_haru/img/06_4.gif)  

### 通りがけ順(中間順)

左の子に移動できなくなったタイミングで調べる  
![!](https://www.ap-siken.com/kakomon/03_haru/img/06_5.gif)  

### 幅優先探索

根から近い順に階層ごとに探索する  
![!](https://www.ap-siken.com/kakomon/03_haru/img/06_2.gif)  

### 配列

・要素を一列に並べて管理する
・最初から固定の要素数でメモリを確保する→固定長のデータを表現するのに適している
・用意した要素数が連続した領域にメモリとして確保される
・位置を指定して，任意のデータに直接アクセスすることができる
・添え字を使ってメモリアドレスを直接指定できるので要素へのアクセスが速い
・途中に要素を挿入したり追加したりするには元にあった要素をズラす必要があり大変

### リスト構造

隣接するデータ同士をポインタで連結して表現するデータ構造です。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/06.gif)  

・要素を一列に並べて管理する  
・要素数が可変  
・前後にポインタが付与されポインタで接続されながらあいているメモリ領域に要素が格納されていく  
・要素にアクセスするには先頭からポインタを辿っていく必要があり時間がかかる  
・途中に要素を挿入したり、削除したりするにはポインタの接続を変えるだけなので速い  

先頭にデータを追加する処理  
1.追加するデータの次ノードポインタに、現在の先頭ポインタの値を設定  
2.先頭ポインタに、追加するデータを指すポインタを設定  
よって、ポインタをたどる回数は0回です。  

先頭のデータを削除する処理  
1.先頭ポインタをたどって先頭データを参照  
2.先頭ポインタに、先頭データが持つ次ノードポインタの値を設定  
よって、ポインタをたどる回数は「先頭ポインタ→先頭データ」で1回です。  

末尾にデータを追加する処理  
1.末尾ポインタをたどって末尾データを参照  
2.末尾データの次ノードポインタに、追加するデータを指すポインタを設定  
3.末尾ポインタに、追加するデータを指すポインタを設定  
よって、ポインタをたどる回数は「末尾ポインタ→末尾データ」で1回です。  

末尾のデータを削除する処理  
末尾のデータを削除するには、末尾の一つ前のデータの次ノードポインタを空にして、末尾ポインタに末尾の一つ前のデータを指すポインタを設定しなくてはなりません。  
単方向リストでは、末尾のデータから前のデータに遡ることはできないので、先頭から末尾の一つ前まで順番にポインタをたどっていく必要があります。  
つまり「末尾のデータを削除する処理」の場合、ポインタをたどる回数はリストが保持するデータ数にほぼ等しい回数となり、他の処理と比較してポインタをたどる回数が極端に多くなることがわかります。  

### 線形リスト

線形で表現されるリスト構造の総称で、一般的には隣接するデータ同士をポインタで連結して表現します。

![s](https://www.ap-siken.com/kakomon/02_aki/img/05.gif)  

**ポインタによって指定されている要素の後ろに，新たな要素を追加する計算量は，要素の個数や位置によらず一定である。**
単方向リストの場合は新たな要素の追加は以下の手順で行われます。  
1.ポインタで指定された要素(以降、元要素)を取得する  
2.元要素のポインタを新要素のポインタに付け替える  
3.元要素のポインタが新要素を指し示すようにする  
元要素の取得後、その要素の後ろに新たな要素を追加する計算量は、リストの要素の個数や追加する位置によらず一定です。  
一方、配列の場合は追加する位置以後の要素を1つずつ後ろにシフトしなければなりません。  

### キュー(待ち行列)(FIFO)(先入れ先出し)

先に入ったものから先に取り出す「先入先出し方式」のデータ構造です。  
キューは何かの処理の"待ち行列"を実現する際によく使われる構造で、例えば、プリンタの印刷待ち、CPUの処理待ちなどがキュー構造で処理されています。  

キューにおける先頭とは最初の要素。配列における0番目。  

### スタック(LIFO)(後入れ先出し)

後入先出し方式でデータを入出力するデータ構造で、データを追加するプッシュ命令(push)と最後に格納されたデータを取り出すポップ命令(pop)でデータ操作を行います。  
サブルーチン終了後の戻りアドレスや局所変数などを保持するのに使用されます。  

スタックにおける先頭とは要素の最後。配列におけるn-1番目。  

#### 平成26年秋期　問5

加減乗除を組み合わせた計算式の処理において，スタックを利用するのが適している処理はどれか。  
→  
計算の途中結果を格納し，別の計算を行った後で，その計算結果と途中結果との計算を行う処理  
→  
スタックは後入先出しのデータ構造なので、最後に追加データとの演算を容易に行うことができます。  

### スタック領域

一般にコールスタック・制御スタックと呼ばれている。  
LIFO方式で構成されプログラムの実行中サブルーチンの情報を記憶しておくメモリ領域。  
サブルーチン終了後の戻りアドレスや局所変数などを保持する。  

### ヒープ領域

2つのラベルを持つ**双方向リスト**で構成されプログラム上から動的(任意)に確保できるメモリ領域。  
動的にメモリ取得・解放を繰り返すことによりメモリ上にどこからも参照されない領域(ガベージ)が発生する。  

### 再帰

再帰とは、実行中に自分自身を呼び出すことをいい、再帰呼出しを行っても正しい結果を返すことができる性質をもつプログラムを「再帰的プログラム」といいます。  
少し長くなりますが、再帰関数の動作を理解するために例を挙げて説明します。  
例えば、nの階乗を再帰的に計算する関数F(n)が次のように定義されていたとします。(nは非負の整数です)  

　n＞0のとき、F(n)＝n×F(n－1)  
　n＝0のとき、F(n)＝1  

階乗とは、1からある自然数nまでの相乗のことをいい、n の階乗は記号 ! を使って「n!」と表記されます。  
例えば 3! であれば、 $3×2×1＝6$ というように計算します。  
関数F(n)を用いて 3! を計算すると、以下のように実行途中で自分自身の呼び出しを伴います。  

``` txt
F(3)＝3×F(3－1)
　//自分自身 F(2)を呼び出す
　F(2)＝2×F(2－1)
　　//F(1)を呼び出す
　　F(1)＝1×F(1－1)
　　　//F(0)を呼び出す
　　　F(0)＝1
　　//F(1)の処理に戻る
　　F(1)＝1×1＝1
　//F(2)の処理に戻る
　F(2)＝2×1＝2
//F(3)の処理に戻る
F(3)＝3×2＝6
```

上記のように再帰的な処理では、ある関数の処理中に同じ関数（自分自身）を呼び出し、呼び出した関数の処理が終わると呼出し元の処理に戻ります。  
このような手順で処理されるため、最終的に正しい結果を得るためには、自分自身を呼び出した時点での呼出し元側の途中経過を記憶しておかなければなりません。  
再帰的な処理では、実行中に自分自身が呼び出された場合にそこまでの実行途中の状態を、スタックと呼ばれるデータ構造に格納しておきます。  

![!](https://www.ap-siken.com/kakomon/30_haru/img/08_1.gif)  

そして、n＝0のときにF(0)が1を返し、呼出し元の処理に戻っていく過程では、最後に積み上げたものから順にF(1)、F(2)、F(3)と値が返ってきて計算されます。  

![!](https://www.ap-siken.com/kakomon/30_haru/img/08_2.gif)  

上記のように、再帰的な処理では A1→A2→A3 の順でプログラムを呼び出した場合、A3→A2→A1 というように後から入れたものから順にその値を使用します。  
つまり再帰的な処理は、LIFO（Last-In First-Out，後入れ先出し）の記憶管理方式を用いて実現されています。  

---

## データ構造 問題

### 平成31年春期　問5

要求に応じて可変量のメモリを割り当てるメモリ管理方式がある。要求量以上の大きさをもつ空き領域のうちで最小のものを割り当てる最適適合(best-fit)アルゴリズムを用いる場合，空き領域を管理するためのデータ構造として，メモリ割当て時の平均処理時間が最も短いものはどれか。  

空き領域の大きさをキーとする2分探索木  
正しい。要求サイズとキー値を比較しながら2分探索木の枝をたどることで効率よく探索することができます。  

アドレスに対応したビットマップ  
ビットマップインデックスは値の種類が少ない場合には有効ですが、範囲指定検索には適していません。  

### 平成29年秋期　問6

ノード1～5をもつグラフを隣接行列で表したもののうち，木となるものはどれか。ここで，隣接行列のi行j列目の成分は，ノードiとノードjを結ぶエッジがある場合は1，ない場合は0とする。  

![!](https://www.ap-siken.com/kakomon/29_aki/img/06aa.gif)  
![!](https://www.ap-siken.com/kakomon/29_aki/img/06ii.gif)  
![!](https://www.ap-siken.com/kakomon/29_aki/img/06uu.gif)  
![!](https://www.ap-siken.com/kakomon/29_aki/img/06ee.gif)  

### 平成28年秋期　問5

あるB木は，各節点に4個のキーを格納し，5本の枝を出す。  
このB木の根(深さのレベル0)から深さのレベル2までの節点に格納できるキーの個数は，最大で幾つか。  

→

最初に節点の総数を計算します。  
レベル0では根となる節点だけなので1個  
レベル0の節点から5本の枝がでるためレベル1の節点は1×5で5個  
レベル1の各節点から5本の枝がでるためレベル2の節点は5×5で25個  

節点の総数は、`1＋5＋25＝31(個)`です。  
各節点が4個のキーを格納しているため、キーの総数は、[31×4＝124(個)]  

※ルートノードも含むことに注意  

### 平成30年秋期　問7

2次元配列 A[i，j] (i，j はいずれも0～99の値をとる)の i＞j である要素 A[i，j] は全部で幾つか。

``` txt
次のように考えます。

i = 0 のとき、0個
i = 1 のとき、A[1, 0] の1個、
…
i = 98 のとき、A[98, 0]～A[98, 97]までの98個、
i = 99 のとき、A[99, 0]～A[99, 98]までの99個、

つまり、条件を満たす要素数は 0＋1＋…98＋99 で求められるので、ガウスの計算法を用いて、

(99＋0)×50＝4,950
```

1列目は99個
2列目は98個
...
98列目は1個
99列目は0個

これは数列の足し算なのでなんかそれっぽい公式があったはず。
$99*98 / 2*1 = 4851$ にしたが、0から始まるので、 $100 * 99 /2 = 4950$ だ。  

### 令和3年春期　問5

A，B，Cの順序で入力されるデータがある。  
各データについてスタックへの挿入と取出しを1回ずつ行うことができる場合，データの出力順序は何通りあるか。  

![!](https://www.ap-siken.com/kakomon/03_haru/img/05.gif)  

``` txt
A，B，Cの出力順序としては6種類があるので、それぞれが出力可能であるかを検証します。

[A，B，C]
push(A) → pop → push(B) → pop → push(C) → pop の順序で出力可能です。
[A，C，B]
push(A) → pop → push(B) → push(C) → pop → pop の順序で出力可能です。
[B，A，C]
push(A) → push(B) → pop → pop → push(C) → pop の順序で出力可能です。
[B，C，A]
push(A) → push(B) → pop → push(C) → pop → pop の順序で出力可能です。
[C，A，B]
push(A) → push(B) → push(C) → pop → pop ×
※Bより先にAを出力できません。
[C，B，A]
push(A) → push(B) → push(C) → pop → pop → pop の順序で出力可能です。

したがって、データの出力順序は5通りになります。
```

### 平成30年春期　問6

異なるn個のデータが昇順に整列された表がある。  
この表をm個のデータごとのブロックに分割し，各ブロックの最後尾のデータだけを線形探索することによって，目的のデータの存在するブロックを探し出す。  
次に，当該ブロック内を線形探索して目的のデータを探し出す。  
このときの平均比較回数を表す式はどれか。  
ここで，mは十分大きく，nはmの倍数とし，目的のデータは必ず表の中に存在するものとする。  

→

線形探索法を2回組み合わせて目的データを探し出すときの平均比較回数を求める問題です。  
探索するデータ数に注目して考えていきましょう。  

線形探索法とは、探索対象データの先頭から1つずつ順番に比較することによって目的のデータを探す方法です。  
線形探索法では、N個のデータの中から目的のデータを探すときの平均比較回数は **(N＋1)／2回** です。  

最初は、n個のデータをm個ごとのブロックに分割した最後尾のデータのみを探索します。  
表のデータは昇順に整列されているので、各ブロック最後尾の並びも昇順になっているはずです。この最後尾データの並びに対して「目的のデータ≦各ブロックの最後尾データ」を順次チェックし、目的のデータが存在するブロックを探します。  
この1回目の探索では、データを1つずつチェックしていくので線形探索の考え方を準用できます。  
探索するデータ数は n／m個 なので、目的のデータが存在するブロックが決定するまでの平均比較回数は、  

$(n／m＋1)／2 [回]$  

2回目は、1回目の探索によって見つけたブロック内を線形探索します。  
探索するデータ数は m個 なので、目的のデータを見つけるまでの平均比較回数は、  

$(m＋1)／2 [回]$  

2つの比較回数の合計は、  

$(n／m＋1)／2 + (m＋1)／2 [回]$  

となります。  
ここで、mは十分に大きいという条件が与えられていますが、n／mが十分に大きいとは限りませんので定数項の+1は無視できません。  
よって、以下のように式を変形します。  

``` math
　 (n／m＋1)／2 + (m＋1)／2
＝{(n／m＋1) + (m＋1)}／2
＝(n／m + m + 2)／2
＝n／2m + m／2 + 2／2
＝n／2m + m／2 + 1
```

"n／2m"は、nがmより十分大きい場合に十分大きくなり無視できない、"+1"はm／2が十分大きいので無視できると考えると、定数項の＋1を除いて n／2m＋m／2。つまり、1回目と2回目の平均比較回数を合わせるとになります。  

※補足  
上記の解説ではmが十分に大きいという理由で＋1を除外していますが、線形探索の特性上、目的のデータが必ず存在するならば、最後の1つ前（n－1番目）の要素までの比較で目的のデータが見つからなかった場合、最後の要素が目的のデータであることが確定します。  
このため最小比較回数を 1回、最大比較回数を n－1回、平均比較回数を n／2回 として考えることもできるでしょう。  
この考え方だと1回目の平均比較回数が n／2m回、2回目の平均比較回数が m／2回となり、正解の式と一致します。  

### 令和元年秋期　問7

自然数をキーとするデータを，ハッシュ表を用いて管理する。キーxのハッシュ関数h(x)を  
　　h(x) = x mod n  
とすると，任意のキーaとbが衝突する条件はどれか。  
ここで，nはハッシュ表の大きさであり，x mod nはxをnで割った余りを表す。  

→

``` math
aをnで割ったときの商をk、bをnで割ったときの商をl、余りがどちらもxとなる場合を式で表すと、  

　a＝kn＋x  
　b＝ln＋x  

となります。これをxについて解くと、  

　x＝a－kn  
　x＝b－ln  

と変換できます。余りであるxが等しくなるとき a－kn と b－ln は等しいので、方程式で関係を導きます。  

　a－kn＝b－ln  
　a－b＝kn－ln  
　a－b＝n(k－l)  

ここで、aとb及びnが自然数であることから商であるkとlも自然数となります。よって n(k－l) はnの倍数です。

　∴余りxが同じとき、a－bはnの倍数
　
以上より、キーの衝突には「a－bがnの倍数」という条件があるとわかります。したがって「イ」が正解です。

ここまでが論理的に解を導く方法ですが、計算結果が同じになるa・b・nを用意して選択肢の記述の正誤を判断することもできます。  
例えば、a＝51、b＝27、n＝12（どちらも余りが3）で試してみると、  

a＋bがnの倍数
a＋b＝78なので、12の倍数ではありません(×)。

a－bがnの倍数
a－b＝24なので、12の倍数になっています(〇)。

nがa＋bの倍数
a＋b＝78なので、12は78の倍数ではありません(×)。

nがa－bの倍数
a－b＝24なので、12は24の倍数ではありません(×)。
```

俺はa=7,b=5 , a=13,b=7とかで試したらイだけ絶対にかぶったのでそうした。  
元年の当時、倍数の意味が分かっていなかったので問題の意味がわかっていなかったのもあった。

---

## プログラミング(性質)

### 再入可能(リエントラント,Reentrant)

各プロセスごとに変数部分を割り当てることで、複数のプロセスで同時に実行できる性質。  

複数のタスクから同時に呼び出されても、それぞれに正しい値を返すことできるプログラム構造のことを表します。  
これを実現するには、プログラムをデータ部分と内容が共通である手続き部分に分離し、データ部分をタスクごとに用意する必要があります。  

共用ライブラリは、1つのプログラムを複数のプロセスが共用する前提で作られます。  
特にリアルタイムシステムにおいては、他のプロセスがライブラリを解放するのを待つようでは処理が遅延し、システムとして致命的となるため「リエントラント(再入可能)」なプログラム構造である必要があります。  

※再入可能かつ再配置可能なプログラムもあります。  
※コード領域は各タスクで共用し、データ領域は各タスクごとに持ちます。  

### 再使用可能(リユーザブル,Reusable)

主記憶へのプログラムの展開を初回実行時のみ行い、それ以降はロードせずとも何度でも正しく使用できる特性。  

一度実行した後，ロードし直さずに再び実行を繰り返しても、正しい結果が得られるプログラムの性質です。  
逐次再使用可能ともいうらしい。  

※再入可能であるとは限りません。  
※再使用の際に前の実行時データを使ってしまわないように、プログラムの最初または最後で変数を初期化する処理が必要。  

### 再帰可能(リカーシブ,Recursive)

プログラム中において自分自身を呼び出すことが可能な性質。  
このとき2つ以上のプロセスが同時に存在することになるため再入可能であることが求められます。  

※再入可能

### 再配置可能(リロケータブル,Relocation)

プログラムを主記憶上のどの位置においても処理が可能な性質。  

---

## プログラミング

### 値呼出し(call by value)

引数に変数が保持する値のコピーを入れて渡す方法。  
渡された変数は関数内でのみアクセスすることができる。  
関数内で値を保持する変数は新しいメモリ領域に作成されるため、関数内で変数の値を上書きしても元の変数の値には反映されない。  

### 参照呼出し(pass by reference)

引数として変数のポインタ(メモリアドレス)を渡す方法。  
呼び出された関数内で引数の内容に直接アクセスすることになるため、関数内で変数の値を上書きすると元の変数の値にも反映される。  

### オーバレイ

必要な部分を補助記憶装置から読み込みながら動作する。  
主記憶領域の大きさに制限があるときに，有効な手法である。  

### データ型

#### 実数型は，有限長の2進数で表現され，数学での実数集合と一致する

実数型は、実数の近似を表現するデータ型です。  
数学での実数集合は有理数と無理数の和集合ですが、コンピュータで扱えるデータが有限である以上、循環小数や無理数を正確に表現することはできません。  

#### 整数型は，2の補数表示を使用すると8ビットでは－128～127が扱える

正しい。nビットの2の補数表現で扱える値の範囲は、－2n-1～2n-1－1 です。  
8ビットの場合、－27～27－1＝－128～127 になります。  

#### 文字型は，英文字と数字の集合を定めたものである

文字型は、1文字を表現するためのデータ型で、英数字の他に記号やひらがな・カタカナ・漢字なども格納することができます。  

#### 論理型は，AND，OR，NOTの三つの値をもつ

論理型は、true(真)とfalse(偽)の2つの値をもちます。  

### プログラムのコーディング規約

平成30年秋期　問7

#### 処理性能を向上させるために，ループの制御変数には浮動小数点型変数を使用する

ループの制御変数に浮動小数点型変数(float等)を用いると、インクリメントやデクリメントの際の誤差が積み重なり、期待した結果を得られないことがあります。  
このためループの制御変数には整数型を使用するべきです。  

#### 局所変数は，用途が異なる場合でもデータ型が同じならば，できるだけ同一の変数を使うようにする

用途が異なる場合には別々の変数を定義し、用途がわかるように適切な命名を行うべきです。  

#### 領域割付け関数を使用するときは，割付けができなかったときの処理を記述する

正しい。領域割付け関数は必ず成功するとは限りません。  
もしメモリブロックを確保できないまま後続の処理に進むと、そこでエラーになってしまうので、領域割付け関数の戻り値をチェックするなどして割付け失敗時の分岐処理を記述するべきです。  

#### 同様の計算を何度も繰り返すときは，関数の再帰呼出しを用いる

同様の処理を繰り返すときには、そのコードを抽出して別の独立した関数にするべきです。  
再帰関数は、実行時のスタックサイズが予測できずオーバフローを起こす可能性があるのでコーディング規約で使用を禁止されることもあります。  

### JavaBeans

プログラムの再利用を目的としてJava言語で記述されたソフトウェア部品のことです。
既存のBeanを組み合わせることで開発効率が向上したり、深いプログラムの知識がなくてもBeanを使用することでソフトウェアに必要な機能が実装可能になるという利点があります。

### Javaアプレット

Webを通してブラウザにダウンロードされクライアント側で実行されるJavaで書かれたプログラムのことです。

### Javaサーブレット

Javaを用いてWebページのためのHTML文書を動的に生成したり、データ処理をWebサーバ上で行うサーバサイドのプログラム技術のことです。
HTMLを動的に生成することで掲示板やショッピングサイト・オンラインバンキングなどの機能が実現されています。

### Javaアプリケーション

Javaで書かれたプログラムの実行形態のひとつで、JavaアプレットがWebからダウンロードされて、Webブラウザ上で実行される事が多いのに対し、Javaアプリケーションは主にローカルコンピュータ上のJava Runtime Environment (JRE) で実行されるプログラムを指します。

### Java言語仕様

平成30年秋期　問8

#### 整数や文字は常にクラスとして扱われる

整数型(int)や文字型(char)は、原則としてクラスではなく基本データ型(プリミティブ型)として扱われます。  
基本データ型自体はオブジェクトではないためクラスとして扱えませんが、Javaではそれぞれの基本データ型に対応するラッパークラス(int→Integer、char→Character)が用意されていて、これを使用してデータに対する操作を行うことができます。  
常にクラスとして扱われるわけではないので誤りです。  

#### ポインタ型があるので，メモリ上のアドレスを直接参照できる

Javaはポインタ型をサポートしていないので、メモリ上のアドレスを直接参照することはできません。  

#### オブジェクト指向言語であり，複数のスーパクラスを指定する多重継承が可能である

Javaはクラスの多重継承、すなわち複数の親クラスを指定した子クラスの定義をサポートしていません。  
よって、複数のスーパクラスを指定する多重継承はできません。  

#### メモリ管理のためのガーベジコレクションの機能がある

正しい。  
ガーベジコレクションは、プログラムが動的に確保したメモリ領域のうち、不要になった部分を自動的に解放して、再び使用可能にする機能です。  
従来の（ガーベジコレクションがない）プログラム言語では、プログラマが必要なメモリを確保する命令を記述し、使用後に明示的に解放する必要がありましたが、ガーベジコレクションが採用されている処理系では、不要と判断された時点で自動的にメモリの解放が行われます。  
Java言語では、ガーベジコレクション機能が言語仕様に組み込まれているため、プログラマはメモリを確保したいときにだけコードを記述しますが、解放時には明示的にコードを記述する必要がなくなっています。  

### オーバーライド（Override）

上位クラスで定義されたメソッド(メンバ関数)を、下位クラス側の役割に応じて再定義し動作を変更すること  

スーパークラスで定義されたメソッドをサブクラスで再定義すること
上位クラスで定義されたメソッド(メンバ関数)を、下位クラス側の役割に応じて再定義し動作を変更することです。  
オブジェクト指向ではこの方法によって「同じメッセージを送ってもオブジェクトごとに異なる操作が行われる」特性である多相性を実現しています。  

### カプセル化

オブジェクト内の詳細な仕様や構造を外部から隠蔽すること

### 汎化

複数のクラスの共通する性質をまとめて，抽象化したクラスを作ること

### オーバーロード

同一クラス内に，メソッド名が同一で，引数の型，個数，並び順が異なる複数のメソッドを定義すること

### 抽象操作（抽象メソッド）

処理の内容が入っておらず、外部から呼び出すときのインタフェース、すなわち戻り値の型、メソッド名、引数の型、引数の数のみが定義されているメソッドです。  
抽象メソッドを1つ以上含むクラスは抽象クラスといいます。処理内容が定義されていないため、抽象クラスをインスタンス化することはできず、必ずサブクラスに継承してオーバーライドし、処理内容を確定する必要があります。  

### Ajax(Asynchronous JavaScript + XML)

Webブラウザ内で非同期通信とインターフェイスの構築などを行う技術の総称です。  
実際にやりとりするデータはXML文書に限られず、任意のデータをHTTPリクエスト／レスポンスの仕組みを用いてサーバとブラウザの間でやりとり可能です。  
Ajaxを用いると、画面遷移を伴わずにコンテンツを書き換えられるので、シングルページアプリケーション(SPA)の制作などに利用されています。  
Ajaxを使用した有名なサービスにGoogleMapやGmailがあります。  

読み方は「エイジャックス」、「アジャックス」  

---

## プログラミング言語

### Go

Goは、Googleが開発したオープンソースのプログラム言語です。  
静的型付け（ソースコードで変数や返り値の型が決まる）言語なので条件に当てはまりません。  

### Kotlin

Kotlin(コトリン)はAndroidアプリの開発言語です。  
Java仮想マシン上で動作するので、Javaの膨大なライブラリが使えます。  
しかし、静的型付け言語なので条件に当てはまりません。  

### R

R言語(アール)は、統計解析用に開発されたプログラム言語です。  
最近では機械学習にも使用されています。  
統計やデータ分析を支援するパッケージが多数公開されていて、高度なグラフ描画も簡単にできます。  
また、インタープリタ言語であり動的型付けであることも特徴です。  

### Scala

Scala(スカラ)は、オブジェクト指向をベースとしながら関数型言語の機能が使えるプログラム言語です。  
Java仮想マシン上で動作するので、Javaの膨大なライブラリが使えます。  
しかし、静的型付け言語なので条件に当てはまりません。  

### JavaScript

主にユーザの動きに反応する動的なWebページの構築のために、HTML内に記述されるスクリプト言語です。  
当サイトでも使用していますが入力漏れのチェックや、HTMLを動的に編集することで動きのあるWebページを作ることができます。  
名前が似ていますがプログラミング言語Javaは、JavaScriptとは全くの別物です。  

動的型付けのプログラム言語  

### ECMAScript

JavaScriptを標準化した言語仕様です。  
JavaScriptと同じく動的型付けのプログラム言語です。  

### Python(パイソン)

1991年にグイド・ヴァンロッサム氏によって開発された汎用の高水準プログラミング言語です。  
コードブロックのインデントが構文規則となっていることがソースコード上の特徴です。  
小さなプログラムから大規模なシステムまで、そしてデスクトップアプリケーションからWebアプリケーションの開発まで様々な場面で使用されています("YouTube"や"Dropbox"などが有名)。  
簡潔な文法と使いやすさ、対応するプラットフォームの多さ、優れたライブラリの存在等により、AI開発に適した言語としても人気が過熱しています。  

オブジェクト指向のプログラム言語であり，クラスや関数，条件文などのコードブロックの範囲はインデントの深さによって指定する仕様。  

### Perl(パール)

Larry Wall氏によって開発されたテキスト処理用のプログラム言語です。  
インタプリタ言語であり、UNIXやWindowsなど多くのプラットフォーム上で動作します。  
以前はWebページのCGIの記述によく用いられていました。  

**実行にWebサーバを必要とする言語であり，CGIの開発に適している。**  
Webサーバ上で動作するCGIを記述する言語として知られていますが、デスクトップアプリケーションも作成できます。  

### TypeScript

JavaScriptに省略可能な静的型付け、クラス定義、ジェネリックなどを追加した上位互換のプログラム言語です。  
マイクロソフトにより開発され、オープンソースとしてメンテナンスされています。  

JavaScriptは動的型付けのプログラム言語であり、変数の型があらかじめ決まっていないため、誤った変数名、変数への誤った代入などがあると実行時エラーが起こります。  
またデータ型の指定がないので、別の人が書いたソースコードをみるときコードから変数の型を読み取らなくてはなりません。  
これらの問題は開発に複数の人が関係する大規模開発でより顕著となってきます。  
TypeScriptは、JavaScriptのこのような問題を解消するため大規模開発のために必要な機能が追加されています。  
その一つが静的型付けで、ソースコードでデータ型を明示できる機能を追加し、コンパイル時にチェックすることで、大人数がかかわる大規模開発でもエラーを未然に防ぎやすいようになっています。  

### VBScript

VBScriptは、マイクロソフトがVisual Basicを元に開発したスクリプト言語です。  
Visual Basicは静的型付けですが、VBScriptは動的型付けのプログラム言語です。  

---

## その他の言語

### XML(eXtensible Markup Language，拡張可能なマークアップ言語)

ユーザが定義したタグや属性を用いて文書構造を記述することのできるマークアップ言語です。  

XMLでは各データを要素(Element)と呼び、要素名と属性(Attribute)をつけたタグで挟んで表現します。  
要素を自由に追加することができ、入れ子構造にもできるので汎用性が高いという特徴があります。  

HTMLが、あらかじめ定義済みのタグを用いてWebページを記述するための言語であるのに対して、XMLでは、データ交換をするのための汎用のデータ形式で、ユーザ独自のタグを用いて記述することが可能です。(タグ名に日本語を使うこともできます。)  

### DTD(Document Type Definition)

XMLなどのマークアップ言語において文書構造を定義するスキーマ言語の一つです。  
XMLでは、文書作成者が自由に要素名や属性名を付け文章構造を構築することができます。  
DTDには、記述可能な要素名、属性名や発生順序・発生回数など文書作成のルールを定義でき、XML文書側では文書型宣言`<!DOCTYPE …>`で使用するDTDを指定できます。  
作成された文書がDTDに適合するかどうかを検証することで、処理の正確性や安全性を高められます。  

### CSS(Cascading Style Sheets)

HTMLの要素を、どのように修飾して表示させるかを定義する文書で、構造とデザインを別の文書に分離させるために提唱されたスタイルシートの仕様のひとつです。  
Webサイトの構築においては、1998年5月にW3Cにより勧告されたCSS2を基本とし、最新ブラウザに先行実装されている高機能なCSS3を併用してデザインを行うことが多くなっています。  
現在のWebサイトデザインでは、文書の構造をHTML、デザインをCSS、インタラクティブ性をJavaScriptというように3つの技術で役割分担してWebサイトの構成を考えます。  

### CSV(Comma-Separated Values または Comma-Separated Variables)

日本語では「カンマ区切り」などと呼びます。  
テキストデータを複数のフィールド（項目）に分け、区切り文字カンマ「,」を使って区切ったデータ形式です。  

### RSS

ニュースやブログなど各種のウェブサイトの更新情報を簡単にまとめ、配信するための幾つかの文書フォーマットの総称です。  

### JSON(JavaScript Object Notation)

以下のように":(コロン)"で連結した名前と値の組を",(コンマ)"で区切って指定するデータ形式です。  

``` json
{
　名前1: 値1,
　名前2: 値2,
　名前3: [値5, 値6],
　名前4: {名前7: 値7, 名前8: 値8}
}
```

値には、単純なスカラ値や真偽値のほか、配列やオブジェクトを指定できるため多次元配列や複雑なオブジェクトを表現することができます。  
元来は、JavaScriptの書式のサブセットという位置付けでしたが、軽量であり汎用的に使用できるためRFC8259として標準化され、多くのプログラム言語で利用可能になっています。  
XMLに代わって、WebAPIやAjaxでのデータの受け渡しにもよく利用されます。  

### DOM(Document Object Model)

HTMLやXMLで記述された各要素をアプリケーションプログラムから取り扱うためのAPIです。  
DOMをスクリプトやCSSで操作することでインタラクティブな表現が可能になります。  

---

平成29年春期　問5
流れ図は，シフト演算と加算の繰り返しによって，2進整数の乗算を行う手順を表したものである。この流れ図中のa，bの組合せとして，適切なものはどれか。ここで，乗数と被乗数は符号なしの16ビットで表される。X，Y，Zは32ビットのレジスタであり，けた送りは論理シフトを用いる。最下位ビットを第0ビットと記す。

流れ図を見ると、被乗数がX、乗数がY、結果としてZを出力するので「X × Y ＝ Z」が成立すれば良いことがわかります。

細かな説明がない流れ図の穴埋めでは論理的に答えを導くのは難しいので、XおよびYにトレースが簡単な数値を設定して、出力Zが適切な値かどうかで正しい組合せを探すのが確実な解法です。ここではX＝3，Y＝3を使います（16ビット表記だと「0000 0000 0000 0011）。また、あるビット列を左に1ビットシフトすると2倍、右に1ビットシフトすると1／2したのと同じになります（ビットあふれは無視します）。
Yの0ビット目は1なので、Z←(0＋3) //Z＝3
Xを1ビット左シフト //X＝6
Yを1ビット右シフト //Y＝1
i←(1＋1) //i＝2
Yの第0ビットは1なので、Z←(3＋6) //Z＝9
Xを1ビット左シフト //X＝12
Yを1ビット右シフト //Y＝0
以後、Yの第0ビットはi>16になるまで0なので、加算は行われずにループ終了
Zを出力する //Z＝9
Yの第0ビットは1なので、Z←(0＋3) //Z＝3
Xを1ビット右シフト //X＝1
Yを1ビット左シフト //Y＝6
i←(1＋1) //i＝2
Yを左にシフトすると第0ビットに0が挿入される。以後、Yの第0ビットはi>16になるまで常に0なので、加算は行われずにループ終了
Zを出力する //Z＝3
Yの第15ビットは0なので加算はなし
Xを1ビット左シフト //X＝6
Yを1ビット右シフト //Y＝1
i←(1＋1) //i＝2
Yを右にシフトすると第15ビットには0が挿入される。以後、Yの第15ビットはi>16になるまで常に0なので、加算は行われずにループ終了
Zを出力する //Z＝0
Yの第15ビットは0なので加算はなし
Xを1ビット右シフト //X＝1
Yを1ビット左シフト //Y＝6
i←(1＋1) //i＝2
Yの第15ビットは0なので加算はなし
Xを1ビット右シフト //X＝0
Yを1ビット左シフト //Y＝12
Xが0になったので、加算処理が行われたとしてもZは0のままでループ終了
Zを出力する //Z＝0
唯一"3×3"の正しい結果である"9"を出力する「ア」の組合せが適切とわかります。

このアルゴリズムを一言で言うならば、Yの第nビットが1であれば、ZにX×2^nを加算する処理を繰り返すものということになります。

おまけとしてこのアルゴリズムをJavaScriptで実装したソースプログラムを掲載します。実行環境で数値やシフト部分を変えてお試しください。

``` js
var x=10, y=20, z=0, i=1;
while(true) {
    document.write('i='+i+'( ');
    //yの0ビット目が1かを確認
    if ((y & 1) > 0) {
        z = z + x;
    }
    document.write('y[0]='+(y & 1)+', z='+z);  
    x = x << 1; //xを1ビット左シフト
    y = y >> 1; //yを1ビット右シフト
    i = i + 1;
    document.write(', x='+x+', y='+y+' )<br>');
    if (i > 16) {
        break;
    }
}
document.write('<b>出力Z='+z+'</b>');
```

乗数は掛ける数。
被乗数は掛けられる数。
2 × 3なら 2が掛けられる数で3が掛ける数。
小学校で習う概念だぞ。

---

## 1回目に間違えた問題

平成31年春期　問5
2分探索木として適切なものはどれか。ここで，1～9の数字は，各ノード(節)の値を表す。

→
いやー。やばいね。
なんだかんだ木構造も自信を持って説明できない。
2分と分けているので、その通りのものを選べばよかった。



平成30年春期　問8【選択肢ランダム】
XML文書のDTDに記述するものはどれか。

→
Document Type Definition なのでそのまま「文書型の定義」
これは覚えゲーなので覚えましょう。



平成30年秋期　問5【選択肢ランダム】
待ち行列に対する操作を，次のとおり定義する。
ENQ n:
待ち行列にデータnを挿入する。
DEQ :
待ち行列からデータを取り出す。
　空の待ち行列に対し，ENQ1，ENQ2，ENQ3，DEQ，ENQ4，ENQ5，DEQ，ENQ6，DEQ，DEQの操作を行った。次にDEQ操作を行ったとき，取り出されるデータはどれか。

→
待ち行列 = 先入れ先出し
スタックの後入れ先出し法だと思ってた。
そもそも先入れ先出しって待ち行列っていうんですね。
逆に後入れ先出し法って何行列っていうんだ？
軽く調べて見たけど特に何も出てこない。



平成28年秋期　問6
2分探索木になっている2分木はどれか。

→
また間違えた。
見たらわかるではなく言葉で説明できるようにしろ。
中央値で左右に分けるのはいいとして、子要素の上下関係があいまいだ。
いや、子要素にも最初の定義を当てはめればいいだけでは？
つまり、子要素で2分されているかということだ。
ルートを見て小さい値<中央値<大きい値となっていること。
それを子要素にも適応させていけばいいだけだ。



43問目／選択範囲の問題数48問
Perlの実行に関する記述のうち，適切なものはどれか。

→
普通に知らなかった。
サーバーサイドの言語でCGI関係ってところまでは覚えていた。
なので、「実行にWebサーバを必要とする言語であり，CGIの開発に適している。」を選んだが、デスクトップアプリケーションも作れるみたいですね。
それは知らん。
インタプリタ型なので、コンパイルは必要ないところはあいまいだったので、覚えられてよかった。




平成31年春期　問7【
次の流れ図は，2数 A，B の最大公約数を求めるユークリッドの互除法を，引き算の繰返しによって計算するものである。Aが876，Bが204のとき，何回の比較で処理は終了するか。

→
何回の比較ってあるので、最後の12 = 12も勘定に含めましょうって感じ。
問題自体は、トレースしていけば終わる。



平成30年春期　問6
リストを二つの1次元配列で実現する。配列要素 box[i] と next[i] の対がリストの一つの要素に対応し，box[i] に要素の値が入リ，next[i] に次の要素の番号が入る。配列が図の状態の場合，リストの3番目と4番目との間に値が H である要素を挿入したときの next[8] の値はどれか。ここで，next[0] がリストの先頭(1番目)の要素を指し，next[i] の値が0である要素はリストの最後を示し，next[i] の値が空白である要素はリストに連結されていない。

→
日本語読めないです。日本語難しい。
定義を完全に理解しないと解けない。
簡単そうに見えて、結局どういうことってなるばかりだ。
とりあえず、next[0]から始まる。これが全て。

next[0] = 1
box[1] = A
next[1] = 5
box[5] = E
next[5] = 3
box[3] = C
next[3] = 7
box[7] =G
next[7] = 2
box[2] = B
next[2] = 0

A,E,C,Gと来て、3番目と4番目の間に入る、CとGの間にHが入るわけです。
つまり3の次の4にHが入って5番目からいつも通りということ。

box[5] = E
next[5] = 8 ※前は3
box[8] = H
next[8] = 7
box[7] = G
next[7] = 2

というわけで、7になります。
パソコンで書いたほうがわかりやすいですね。
