# 後でまとめる基本情報の基本的な事

## クロックの計算

<https://www.foresight.jp/blog/it/archives/964>  

1GHz = 10^9 = 10億  
1秒間に10億回のクロックが発生する。  
まずこれが基準。10億です。  

10億クロック / 1秒  
1命令 / 1クロック  
→  
あれ？単純にこういう関係が成り立つからでは？  

・1命令が1クロックで実行可能な場合→10億命令実行可能  
この時MIPSは1,000になる。  
1MIPSは10^6,100万命令なので、10^9/10^6 = 10^3で1000MIPS。  

●問 1命令が0.8クロックで実行可能な場合、何万命令実行できる？
→  
1命令が0.5クロックの場合は？  
1クロック実行する頃には2命令できているわけだ。  
じゃあ0.8クロックの場合は？1クロックになる頃には1.25命令実行できるわけだ。  
単純にそういう事では？  

10億クロック / 1秒  
1命令 / 1クロック  

1命令 / 0.8クロック
= 1.25命令 / 1クロック

10億クロック / 1秒に合わせるために 単純に10億倍して
= (1.25 * 10^9) / 10億クロック * (10億クロック / 1秒)
= 125000万命令 / 1秒

ということでよくね？  

●問 2GHzのプロセッサにおいて、一つの命令が5クロックで実行できるとき、1命令の実行に必要な時間は何ナノ秒か？  

1クロックにかかる時間は  
「1秒÷2,000,000,000クロック＝0.0000000005秒／クロック」0.5ナノ秒  

1命令に5クロックかかるるのですから、  
1命令に必要なクロック数は＝0. 000 000 000 5秒／クロック×5クロック＝0.000 000 002 5秒  
2.5ナノ秒  

まぁここまでしなくても、0.5ナノ求めたらそれに5掛けるだけで済むけどね。  


クロック周波数 / 平均クロック数
これで1秒間の命令実行回数がわかる。
まとめておこう。


## 1クロック何秒か？

1/10^9すればいいので1ナノ秒(10^-9)  

ミリ (milli)    , 10^−3, 0.001  
マイクロ (micro), 10^−6, 0.000 001  
ナノ (nano)     , 10^−9, 0.000 000 001  
10^9は1の後ろに0が9個ついている。  
10^-9は1の前に整数部分も含めて0が9個ついている。  

---

## MIPS(Million Instructions Per Seconds)

1秒間に何百万回の命令を実行できるのかを表した単位  
`MIPS = 命令数 / 命令実行に要する時間(秒) * 10^6`  

10億命令/sのMIPSは単純に10^6で割ったものになるわけだ。  
10^9 / 1 * 10^6 = 1000MIPS  

例1 平均命令実行時間が20ナノ秒のPCの性能は何MIPSか。  

20ナノって事は何GHzのクロック周波数持ちだ？  
$1/20 * 10^-9 = 0.05 * 10^9$  
0.05GHzか。  
じゃあそれを10^6で割ればいいんだな。

$0.05 * 10^9 / 19^6 = 0.05 * 10^3 = 50 MIPS$  

こっちの方法のほうが個人的にはやりやすい。  
一応、参考書に乗っている方法も乗せておく。  

解:  
・1命令を実行する平均が20ナノ秒  
・1秒 = 10^9ナノ秒なので、命令実行に要する時間は $20/10^9$ 秒  
∴MIPS = 1/ (20/10^9 * 10^6) = 50MIPS  

∴「ゆえに」「したがって」  
∵「なぜならば」  

例2 50MIPSのプロセッサの平均命令実行時間は幾らか。  

さっきの逆というよりも、MIPS自体10^6が掛けられている状態なので、  
1秒をそれで割れば答えが出る。  
$1 / 50 * 10^6 = 0.02 * 10^-6 = 20 * 10 ^9 = 20ナノ秒$  

解:  
1秒(=10^9ナノ秒)をMIPS値(0.5 * 10^6)で割って求める。  
$10^9 / 0.5 * 10^-6 = 20ナノ秒$  

---

## 2分探索木

「木」って種類がたくさんあるから、実はまだよくわかっていない。  
しかし、これに関してはなんて事はない。昇順に整列された状態を木にした奴の事だ。  
ルートより小さいデータは左に、大きいデータは右に集めた物。  

``` txt : ○
これが2分木
       4
   2       8
 1   3   6   9
        5 7

これではない。
       1
   2       3
 4   5   6   7
        8 9
```

---

## システムの実行アクセス時間

システムの実行アクセス時間 = (1-p)m + pc  
m:主記憶のアクセス時間  
c:キャッシュメモリのアクセス時間  
p:ヒット率(キャッシュメモリに必要なデータが存在する確立)  

公式だけ見れば、ややこしそうに見えるが、理屈がわかっていれば問題ない。  
キャッシュにある場合はキャッシュのアクセス時間。  
キャッシュに無ければメインメモリのアクセス時間。  
キャッシュのあるなしは1から引けばいいだけの話。  
ここら辺は確立の存在する確立としない確立の求め方になるな。  

例:
主記憶のアクセス時間70ナノ秒。
キャッシュメモリのアクセス時間10ナノ秒。
ヒット率を0.6としたとき、このシステムの実行アクセス時間は幾らか？

単位はナノ秒なので10^-9は省略する  
$0.6 * 10 + (1 - 0/6) * 70$  
$= 6 + 28$  
$= 34ナノ秒$  

---

## システムの信頼性(MTTF,MTTR)

稼働率 = MTBF / MTBF + MTTR

これは正直、当てずっぽうでも何とかなる。  
MTTR / MTBF + MTTRってやったとき、明らかに値が頼りなくなるので、すぐに間違いだと気が付く。  

---

## データ伝送時間

(1)データ伝送時間  
$伝送時間(秒) = 伝送データ量(ビット) / 回線の伝送速度(bps) * 伝送効率$  

まぁ、普通に考えてそうだよな。  
このくらいのデータを送りたいけど、これくらいの速度しか出ないからこれだけ時間かかるよって話だ。  

例1:
2秒で128kビットを送れる場合のデータ伝送速度を求めよ。  
→  
2秒で128kビット送れるので、単純に2で割ればいいだけ。  
$データ伝送速度 = 128(kビット) / 2(秒) = 64kビット/秒$  

(2)伝送効率  
$伝送効率 = 正しく受信されたデータのビット数 / 送信された総ビット数$  

比率でしか求められない。  
送ったビットはこれくらいだけどそれくらいしか届いてないなら、効率はこんな感じだねってところか？  

例2:  
1.5Mビット/秒の伝送路を用いて12Mバイトのデータを転送するのに必要な伝送時間は何秒か。  
ここで、伝送路の伝送効率を50%とする。  
→  
この手の問題で気を付けるべきは単位。  
ビットなのかバイトなのか底をよく見るって毎回いうんだけど、嵌るんだよね。  
それ以外は何の変哲もない問題。  

$12M * 8ビット / (1.5Mビット * 0.5)$  
$= 128ビット/秒$  

---

---

## エンタープライズアーキテクチャ

基本も応用もエンタープライズ大好きだからな。  
データアーキテクチャだけは覚えた。  
応用の時、これで間違えたから  
他3つを覚えられれば俺の勝ちだが、そもそもこいつって何なの？ってのはよくわかっていない。  
まぁ、試験なんてそんなもんだよね。  

企業の業務やシステム改善のためのフレームワーク。  
まぁ、ここまで要約すればそのままとしか言いようがないよな。  

企業向けのアーキテクチャ何だから、ビジネスがあり・・・。
というか、業務アプリケーション準拠で考えればいいだけの話では？
データはデータベース。アプリケーションはそのままソフト。
後はそれをどうやって実現するのかという技術全般がテクノロジーになるわけで、後は企業なんだからどういうビジネスしてるかで終わる話だと思うけどなぁ。

各業務と情報システムを，ビジネス，データ，アプリケーション，テクノロジの四つの体系で分析し，全体最適化の観点から見直すための技法である。

**ビジネスアーキテクチャ**  
業務の内容についてまとめたもの  

**アプリケーションアーキテクチャ**  
業務に沿った最適なシステムについてまとめたもの  

**データアーキテクチャ**  
業務上の最適なデータについて  

**テクノロジーアーキテクチャ**  
システムを構築する差異のもろもろの技術についてまとめた物。(ハードソフト含む)

うーん。アプリケーション作る時に考えることそのままじゃないか・・・。  
覚えてしまえばなんてことはないな。  

---

## バランススコアカード(Balanced Score Card、BSC)

これもよく出るよねー。  
だからここにまとめてるんだけど。  
正直なんで財務、顧客、プロセス、学習と成長の視点から業績を判断できるかわからない。

あー。ヒト、モノ、カネ＋キャク。  
これで十分だ。ヒトは育成するので、学習。金と客はわかる。
モノは消去法でプロセスだ。要は今あるものを最大限活用→プロセスの改善という意味でモノらしい。  

調べてみたけど、要はどうやったら儲かるかってのを整理するための視点見たいね。  
金をうまくやりくり出来ても、プロセスを改善してコストダウン出来ても、顧客を見方に付けて収益をアップしても、  
人を育成してイノベーションをもたらしても、儲かるわけなので、じゃあ今どんな状況なのってのを考えるために作り出されたものっぽい。  
そこまで調べてもなんでこの4つなのかはわからないけどねー。  
とりあえず、これに関してはこれくらいでいいかなー。  

企業のビジョンと戦略を実現するために、「財務」「顧客」「内部ビジネスプロセス」「学習と成長」という4つの視点から業績を評価・分析する手法です。
なぜか学習は覚えている。  

**財務の視点**  
株主や従業員などの利害関係者の期待に応えて良い業績を出すために、財務的にどのように行動すべきかの指標を設定する。  

**顧客の視点**  
企業のビジョンを達成するために、顧客に対してどのように行動すべきかの指標を設定する。  

**内部ビジネスプロセス(業務プロセス)の視点**  
財務的目標の達成や顧客満足度を向上させるために、優れた業務プロセスを構築するための指標を設定する。  

**学習と成長の視点**  
企業のビジョンを達成するために、組織や個人としてどのように変化（改善）し能力向上を図るかの指標を設定する。  

---

## 3C分析

3C分析は、マーケティング分析に必要不可欠な3要素「顧客(Customer)」「自社(Company)」「競合他社Competitor」について自社の置かれている状況を分析する手法です。
顧客(Customer)
自社(Company)
競合他社(Competitor)

大体この流れて頭にCがつく単語なんて顧客と会社くらいしかないじゃないですか。  
そこはいいとして、目的が自社の置かれている状況ってのがしっくり来ないので、ここを納得する必要がある。  

---

## バリューチェーン分析

業務を「購買物流」「製造」「出荷物流」「販売・マーケティング」「サービス」という5つの主活動と、「調達」「技術開発」「人事・労務管理」「全般管理」の4つの支援活動に分類し、製品の付加価値がどの部分（機能）で生み出されているかを分析する手法です。
価値の連鎖を分析することによって競合他社と比較した自社の強みと弱みを明らかにしたり、業務の最適化を図ろうとする目的があります。「購買した原材料等に対して、各プロセスにて価値（バリュー）を付加していくことが企業の主活動である。」というコンセプトに基づいた考え方です。

エンタープライズから、バランススコア、SWOT、3C、バリューチェーンあたりは全部頻出な気がするので全部覚える。  
読んで字のごとく、バリューチェーンなので価値の連鎖なわけですよ。  
価値の連鎖って事は、連鎖によって更に価値がどこかで生まれるわけですよ。  
つまりそういう事ですよ。  
後は、主活動と支援活動って単語がついてくる感じですかね。  

---

## アンゾフの成長マトリクス

縦軸に「市場」、横軸に「製品」をとり、それぞれに「既存」「新規」の2区分を設け、4象限(市場浸透，製品開発，市場開拓，多角化)のマトリクスとしたものです。  
事業が成長・発展できる経営戦略を検討するために適したフレームワークです。  

既存市場 * 既存製品 = 市場浸透  
既存市場 * 新規製品 = 製品開発  
新規市場 * 既存製品 = 市場開拓  
新規市場 * 新規製品 = 多角化  

---

## リスク(脅威と好機)

これもよく出る。
リスクよりもリスクとチャンスだよな。  
リスクを基準に対比して考えればいいのではないか？  

リスクは絶対に回避したいけど、チャンスは絶対に受け入れたい(回避と活用)
リスクは他人のせいにしたいけど、チャンスは他人に分け与えて置けば後々いいことになるかな(転嫁と共有)
リスクは出来れば軽減したいけど、チャンスはもっと儲かるようにしたい(軽減と強化)
リスク対策するより受け入れたほうが安上がり、まぁ、とりあえずいいことは受け入れておく？(受容)

PMBOKによればプロジェクトにマイナスの影響を与えるリスク(脅威)への対応戦略には「回避」「転嫁」「軽減」「受容」の4種類があります。

**回避**
リスクそのものの除去や、プロジェクトのスコープや目標を縮小・変更するなどしてリスクの影響をゼロにする戦略。

**転嫁**
リスクのある業務・作業のアウトソーシングや、損害保険の契約によってリスクによるマイナスの影響を第三者へ移転する戦略。

**軽減**
リスクの影響範囲を狭くしたり、発生確率を低減したりする戦略。

**受容**
リスクが現実化した時の影響が許容可能範囲内である場合やリスクの除去が困難であるときに、特に対策をせずにそのままにしておく戦略。対策費用が予想される損失金額を上回っているときなどに採られる。


逆にプロジェクトにプラスの影響を与えるリスク好機(好機)への対応戦略にも「活用」「共有」「強化」「受容」の4種類があります。

**活用**
好機が確実に到来するように、顕在化の不確実性を取り除くための戦略。

**共有**
好機を得られる能力の高い第三者にプロジェクトの実行権限の一部、または全部を与える戦略。

**強化**
好機のプラスの影響を増加させたり、その発生確率を高めたりする戦略。

**受容**
積極的な利用はしないが、好機が実現したときにはその利益を享受しようとする戦略。対策費用が予想される利得を上回っているときなどに採られる。

---

## リスク対応

内容は上でやったやつを大分類で囲ったような感じだな。  
正直これくらいなら分けないで欲しい。  

リスクを回避したり他人のせいにするのはリスクをコントロールすることになるよね。  
リスクの軽減のために投資をしたり、保険を掛けたり、とにかく金で何とかしようとするのがファイナンス(金に関する色々)  
ジタバタ動くより、受け入れたほうが安上がりじゃね？な受容  
正直、リスクで取り得る戦略なんてこれくらいしかないような？  
とにかく汚く暴力的に考えるんだ。  

リスク分析・リスク評価の結果明らかになったリスクに対応方法を講じることです。リスク対応では、リスクの大きさ、顕在化の可能性、情報資産の重要度、予算などを踏まえて最適な対応策をとることが重要となります。

**リスクコントロール**
潜在的なリスクに対して、リスクを回避したり低減したりする対策を講じること。リスク回避・リスク低減・リスク移転などがある。

**リスクファイナンス**
リスクが顕在化した場合に備えて、損失の補てんや対応のための資金確保策を講じること。

**リスク受容**
リスクの損失額や顕在化の可能性が低いため、予算などとの兼ね合いからあえて対処を行わないこと。

---

## システム管理基準

全体最適化計画とか開発計画とか、ここら辺の区切りがあいまい何だよな。  
選択肢に全体最適化計画ってあったらそれを選びたくなるし、毎回この答えは出てくるのでまとめる必要がある。  

とりあえず全体最適の意味から。  

**全体最適**  
全体最適とは、企業や組織、またはシステム全体が最適化された状態を示す経営用語のひとつです。  
経営課題となりやすい生産性向上やコスト削減などの問題解決や経営改革に導入されるケースが多く、経営層から現場まで幅広く取り入れられている解決策でもあります。  
"システム管理基準"によれば，組織全体の情報システムのあるべき姿を明確にする計画はどれか。
→全体最適化計画。

まぁ、読んで字のごとくか。  
「最適である事」なんだからあるべき姿だし、こうあるべきだし、こうありたいなぁってことだよね。  
ややこしいのはシステム管理基準によれば？って文言が入ってくることかな。後はタイミング？  
全体最適化計画を考えるのは開発計画が終わってからなのかどうかとか結構あいまいじゃないですかね。  


"システム管理基準"において，情報システムの費用，スケジュール，開発体制，投資効果などを明確にする計画はどれか。
→
あー。  
全体最適化計画があるべき姿ってわかってしまえば、事業継続計画と年間運用計画は字句的に全く当てはまらないから消去法で開発計画しかないようになってるんだ。  
それさえわかればこの問題十分だ。  

じゃあ次は開発計画って何なの？ってまとめることになるけど、これは明日やろう。  

**開発計画**  
システム管理基準において、情報システムの費用、スケジュール、開発体制、投資効果などを明確化するのは、開発計画  

順序的には全体最適化計画を立案して、あるべき姿はわかったとして、じゃあどうやって開発するってのを計画するのがこの段階な気がするなぁ。  
てか、順序的にそれ以外ないでしょ。  

---

## プレジデンス・ダイアグラム

[プレシデンス・ダイアグラム法とは何か？PMPにでてくるPMBOKの用語を解説](https://ssaits.jp/promapedia/method/pdm.html)  

なんか4つあるやつ。  
何故かまとめてなかったのでここでまとめる。  

プロジェクトの依存関係に注目して論理的順序関係を図式化していく手法。  

・終了-開始関係(FS)  
・終了-終了関係(FF)  
・開始-開始関係(SS)  
・開始-終了関係(SF)  

関係的には前のプロジェクトと後のプロジェクトの関係になる。  

前のプロジェクトが終わらないと後のプロジェクトが開始できない。
前のプロジェクトが終わらないと後のプロジェクトを終了できない。
前のプロジェクトが開始されないと後のプロジェクトを開始できない。
前のプロジェクトが開始されないと後のプロジェクトを終了できない。

転じて、

前のプロジェクトが終わったら後のプロジェクトが始まる。
前のプロジェクトが終わったら後のプロジェクトがも終わる。
前のプロジェクトが始まったら後のプロジェクトも始まる。
前のプロジェクトが始まったら後のプロジェクトが終わる。

って言い換えることができる。  
つまるところ、文字が全ての関係を表しているという訳。  
開始、終了の順番に応じた答えを選べば間違いはない。  
因みにほとんどはFS関係にある。
設計が終わらないとプログラミングができないみたいなそんな感じ。  
以下解説全文  

終了 – 開始関係（FS）
終了 – 開始関係（以下、FSと略記）とは、先行しているアクティビティが完了するまで、後続のアクティビティが開始できない関係を表しています。
例えば、「設計」と「開発」の関係であったり、「開発」と「テスト」の関係であったりと、スケジュール上のほとんどのアクティビティがこのFSの関係にあります。
これからプレシデンス・ダイアグラム法を使って、アクティビティの順序を整理し、ネットワーク図を書いたり、クリティカル・パスの確認などを行っていきますが、こうした分析をする上でもこのFSの関係さえ理解していたら十分でしょう。

終了 – 終了関係（FF）
終了 – 終了関係（以下、FFと略記）は先行するアクティビティが完了するまで、後続のアクティビティを終了させることができない関係を表しています。
例えば、「スケジュールの監視」というアクティビティは、スケジュールの作成が完了しても完了することはありません。多くのアクティビティと並行して活動し、多くの場合、プロダクトが完成した時点で「スケジュールの監視」も完了となります。
このように、何かのアクティビティが終わってようやく完了するアクティビティを、FFの関係であると言います。

開始 – 開始関係（SS）
開始 – 開始関係（以下、SSの関係）は先行するアクティビティを開始するまで、後続のアクティビティを開始することができない関係を表しています。
例えば、ITプロジェクトでいえば設計がはじまらなければ、テスト項目の検討をスタートすることができません。こうした関係をSSと呼びます。
ただし、このSSの関係のアクティビティがあったとしても、何かのアクティビティが完了したら同時にスタートさせるというFSの関係にしたほうが、アクティビティの順序を整理しやすいかもしれません。
先ほどの設計とテスト項目の検討の関係だと、さらに先行する要件定義のアクティビティが完了したら、同時に開始するという関係に置き換えたほうが良いかもしれません。

開始 – 終了関係（SF）
開始 – 終了関係（以下、SFの関係）は先行するアクティビティを開始するまで、後続のアクティビティを完了させることができない関係を表しています。
例えば、Webサイトをリニューアルする際、念のため、昔のサイトのバックアップをテストサイトとして残しておき、万が一公開作業に失敗したらすぐに切り替えられるようにすることがあります。この「テストサイトの維持」というのは、「リニューアルの公開作業」というアクティビティが開始した時に始められ、「リニューアルの公開作業」の終了とともに役割を終えます。こうした関係がSFの関係です。

---

## RAID(Redundant Arrays of Independent Disks)

複数台の磁気ディスクを組み合わせ、仮想的な1台の記憶装置として運用することで、全体として高い性能を得る技術です。
RAIDには0～5のレベルがありますが、その区別は本来のデータとエラー訂正用のデータ（ハミング符号・パリティビット）を、どのように書き込むかによって定義されています。

### RAID0(ストライピング)

「それぞれのハードディスクに別の内容を書き込むやり方」

・分散してデータを書き込む
・両手でペンを持って2つのノートに書き込むイメージ。
・処理速度は早い。
・エラー訂正はなし
・分散でエラー訂正なしなので、どれか死んだら整合性取れなくて終わるので信頼性は低い。

・ストライピングという言葉に意味はなく、単純にRAID0の別名をさす模様。
・RAID0がストライピングであり、ストライピングといったらRAID0の関係らしい。

### RAID1(ミラーリング)

「それぞれのハードディスクに同じ内容を書き込むやり方」

・同じデータを2台のディスクに書き込むことで、信頼性を向上させる。
・実質記憶容量は50%となるので記憶効率は悪い。
・エラー訂正はなし

### RAID2

「データをガッツリ守ろうとしたら負担が結構大変なことになっちゃったRAIDのやり方」

・データを複数のハードディスクに分割して保存する
・本体データと一緒に「データがおかしくなっても何とかするぜ」なデータを保存する
・ハードディスクが最低5台必要→2台はデータ用、3台は訂正用。
・金もかかるし、処理速度も微妙なので一番使われない。

・書き込みはビット単位
・エラー訂正はハミング符号

### RAID3

「RAID2を改良したよ！」

・「データがおかしくなっても何とかするぜ」なデータの作り方を少し手抜きした
・「データがおかしくなっても何とかするぜ」なデータを保存するハードディスクを3台から1台に減らした

・書き込みはバイト単位
・エラー訂正はパリティビット

### RAID4

「RAID3を改良したよ!」

・書き込みはブロック単位
・エラー訂正はパリティビット

### RAID5

「すべてのハードディスクが（ある程度）平等に忙しくなるようにした」
・RAID4までは訂正用データ格納HDDだけが忙しかったので、それを分散した方式
・一番バランスがいいのでよく使われる。

・書き込みはブロック単位
・エラー訂正はパリティビット

### まとめ

ストライピング単位
      読書単位  誤り訂正方式   誤り訂正符号格納場所
RAID2 ビット    ハミング符号   1台のディスク
RAID3 ﾋﾞｯﾄ/ﾊﾞｲﾄ パリティビット 1台のディスク
RAID4 ブロック  パリティビット 1台のディスク
RAID5 ブロック  パリティビット 複数台に分散

### 余談

・ブロック単位が細切れ、バイト単位がちょっと小間切れ、ビット単位が小間切れ
・パリティビットはエラーを検出できるが、エラーの訂正は出来ない。偶数パリティ、奇数パリティのあれね。
・ハミング符号はエラーの検出と訂正ができる。
→だけどRAID2では生かしきれない模様。
ハミング符号はXOR、パリティは1,0のビットで判断する。

### コメント

RAIDが増えるに連れて分散して書き込まれる。
だけど0,1に関してはそんなことはないのがたまに傷だ。
ストライピングとミラーリングはイメージし易い。
ストライプというくらいだから、縞々みたいに分散して書き込まれるんだろうなぁってイメージのままだ。
ミラーリングはその名の通り、同じ内容を書き込む。
2からは誤り訂正機能がつく。
2～4は分けわかめ。
最低限5を覚えておけばいいか。読み込める範囲は広いほうがいいだろう。
ビットやバイトよりもブロック単位がよい。
誤り訂正はハミングのほうがいいはずだが、RAIDだとパリティのほうが都合がいいらしい。
最後は誤り訂正符号の格納場所だが、5で複数に分散して書き込めるようになるみたいだ。

---

## CPU構成要素

令和元年秋期　問9  
CPUのプログラムレジスタ(プログラムカウンタ)の役割はどれか。  

この問題に端を発し、CPUの中の連中というか、CPUは何をするからどういうやつらが必要なのか、はっきりしてないのでまとめる事にします。  

基本的な流れはそれほど難しいわけではない。  
命令を取ってきて、その命令を解析し、実行して、結果を書き込むってだけ。  
命令を取るのはいいけれど、保管しておく場所が必要だし、そもそもどの命令を取ればいいのかって時に、命令レジスタやプログラムカウンタが登場するわけだ。  

### 基本的な流れ

1.命令の取り出し（命令フェッチ）  
2.命令の解読（デコード）  
3.対象データの読み出し（オペランドの読み出し）  
4.命令の実行  
5.結果の書き込み  

以上が基本的な流れになり、命令サイクルと呼ばれる。  

もっと詳しく言えば、2と3の間にもワンクッションあるみたい。  
命令レジスタに記憶される命令は命令部とオペランド部の2つで構成されていて、  
オペランド部にはオペランドのメモリ上の場所が入っているらしい。  
なので、そのオペランドがある場所を特定する作業が必要になってくるみたい。  
それをするのが実行アドレス計算見たい。  
それが終わったら3番目のオペランド読みだしをやって流れていく感じ。  

**実効(有効)アドレス計算**  
命令語のオペランド部の値を用いて、演算対象のデータを保持する主記憶のアドレスを計算する。  

### レジスタの種類

- 命令レジスタ  
主記憶から取り出した命令を一時的に記憶しておくためのレジスタ  
因みに命令レジスタに格納される命令は命令部とオペランド部にわかれる。  
オペランド部からアドレスを計算してオペランドを取ってくる処理にも色々あるので、それはそれでまとめる。  

- プログラムカウンタ  
次に実行すべき命令が格納されているメモリ上の番地（アドレス）を記憶しておくためのレジスタ。  
次に実行すべき命令がメモリ上のどの番地に格納されているかを示す。  
命令が実行されると、プログラムカウンタは読みこんだ命令長だけ自動的に加算され、次の命令のアドレスを差すようになる。  
分岐命令の際は、ジャンプ先のアドレスをプログラムカウンタにセットすることで命令実行順序を制御する。  
割り込み処理の場合は、処理の終了後に割込みによって中断された処理を割り込まれた場所から再開するために、割込み発生時に保持される  

- ベースレジスタ  
プログラムをメモリ上にロードした時の先頭の番地（アドレス）を記憶しておくためのレジスタ。  

- インデックスレジスタ  
連続したデータの取り出しに使うためのレジスタで、先頭からの相対位置を記憶している。配列など連続したデータに繰り返し同じ命令を適用する場合などに使用する  

- アキュムレータ  
演算途中の結果を一時的に保持しておくためのレジスタ  

- 汎用レジスタ  
特に役割を限定していないレジスタ。状況に応じて様々な用途に用いることができる  

- ALU 【Arithmetic and Logic Unit】 演算装置 / 算術論理演算装置  
・でかいVみたいな記号の奴  
・CPUの中で実際に計算を行う装置  
ALUとは、コンピュータを構成する基本的な装置の一つで、算術演算（四則演算）や論理演算などの計算を行う装置。
現代のコンピュータでは制御装置とともにマイクロプロセッサ（CPU/MPU）などの論理回路の一部として実装されている。

以下の2つは応用なら出てくるんじゃないかなって内容だ。
少なくとも、基本では出てこなかった。  

- スタックポインタ  
スタックの先頭アドレスを保持する。  

- レジスタファイル  
レジスタを複数集めたプロセッサ内のモジュール  

### ベースレジスタ

[ベースレジスタとは](https://medium-company.com/%e3%83%99%e3%83%bc%e3%82%b9%e3%83%ac%e3%82%b8%e3%82%b9%e3%82%bf/)  

ベースレジスタとは、プログラムをメモリ上にロードした時の先頭のアドレスを記憶しておくためのレジスタです。
ベースレジスタを使うことで、プログラムがメモリ上のどの位置にロードされても、命令を変えることなく実行できるというメリットがあります。
ベースレジスタは、ベースアドレス指定方式（基底アドレス指定方式）と呼ばれる方式で使用します。
ベースアドレス指定方式は、命令のオペランド部にベースレジスタの値を加算することで、対象データの位置を求める手法です。

例えば、プログラムをメモリ上にロードしたとき「1001」～「2000」のアドレスを使用したとします。
このときベースレジスタは、先頭のアドレスである「1001」を記憶します。
再び同じプログラムをメモリ上にロードした時、今度は「801」～「2000」のアドレスを使用したとします。
このときベースレジスタは、先頭のアドレスである「801」を記憶します。

命令のオペランド部に「1」が入っている場合は、前者は「1」+「1001」（ベースレジスタの値）=「1002」、後者は「1」+「801」（ベースレジスタの値）=「802」と、
どちらもプログラムがロードされた位置から2番目の値を参照しているのがわかります。

### インデックスレジスタ

連続したデータの取り出しに使うためのレジスタ。  

サラッと書きはしたが、命令レジスタに格納される命令には命令部とオペランド部にわかれて構成されている。  
命令部はそのままコンピューターへの命令でオペランド部は計算に使う値の場所が保存されている。  
対称データのありかとでも言おうか。  

まぁ、これが色々方式があるわけだ。  
そのうちの一つである、インデックスアドレス指定方式(指標アドレス指定方式)って奴でインデックスレジスタなるものを使う。  

この場合、オペランド部にはインデックスレジスタと値が入っており、インデックスレジスタにはアドレス0にはxx、アドレス1には22、みたいな感じでデータが入っている。
オペランド部の値に980と入っていた場合、この980とインデックスレジスタのアドレス1に格納されている22を足して1002番地という実行アドレスを求め、
メモリからデータを取り出すみたいな感じの流れになる。
これがインデックスアドレス指定方式であり、インデックスレジスタの役割である。  

[インデックスレジスタとは](https://medium-company.com/%e3%82%a4%e3%83%b3%e3%83%87%e3%83%83%e3%82%af%e3%82%b9%e3%83%ac%e3%82%b8%e3%82%b9%e3%82%bf/)  

まぁ、ここが全てだ。  
インデックスというからには、配列など連続したデータの処理に用いられる模様。

インデックスアドレス指定方式は、配列など連続したデータに繰り返し同じ命令を適用する場合などに使用します。インデックスレジスタの値を変更して繰り返し同じ命令を実行します。

---

## アドレス指定方式

ようやくまとめられる。
内容としてはCPU構成要素の延長なので、上にまとめるべきだが、肥大化しすぎたので別にする。

[アドレス指定方式](https://medium-company.com/%e5%9f%ba%e6%9c%ac%e6%83%85%e5%a0%b1-%e3%82%a2%e3%83%89%e3%83%ac%e3%82%b9%e6%8c%87%e5%ae%9a%e6%96%b9%e5%bc%8f/)  

直接アドレス指定方式 : オペランド部に**実効アドレスが格納**されている方式
間接アドレス指定方式 : オペランド部に**対象データの場所を示すメモリのアドレス**が格納されている方式
即値アドレス指定方式 : オペランド部に**対象となるデータそのものが格納**されている方式
指標アドレス指定方式 : オペランド部に**インデックスレジスタ**が入り、オペランド部の値にインデックスレジスタの値を加算することで、実効アドレスを求める方式
基底アドレス指定方式 : オペランド部に値が入り、その値に**ベースレジスタの値を加算**することで実効アドレスを求める方式
相対アドレス指定方式 : オペランド部に値が入り、その値に**プログラムカウンタの値を加算**することで実効アドレスを求める方式

まぁズバリである。  
インデックスレジスタとベースレジスタとプログラムカウンタが登場する。  
そのほかは直接アドレスを参照できるのと、ワンクッション挟んで参照できるのと、そもそも値が入っている場合の6種類だ。  
何というか、レジスタの種類を勉強しておけば自然とわかってくるのでは無かろうか。  

### 直接アドレス方式

一番オードソックスな奴。
オペランド部のアドレスを見に行ったらそこに値がありました。終わり。

### 間接アドレス方式

ワンクッション挟むやつ。
アドレス見に行ったら、アドレスが書いてあって、そのアドレス見に行ったらようやくあったみたいな。そんな感じ。
まぁ、必要だからこういう仕組みがあるんだろうけど、書いてるだけだと無駄でしかない。

### 即値アドレス方式

オペランド部そのものが値。以上。

### 指標アドレス方式

インデックスレジスタが絡むやつ。
オペランド部のアドレスとインデックスレジスタのアドレスを合わせた先のアドレスに目的のぶつが入ってる方式。
インデックスレジスタにもアドレスとデータの構造になっていて、これまたややこしい。
とにかくインデックスと名がつくので、1とか2とかそういうわかりやすいインデックスが割り振られているので、
そのインデックスの先のインデックスレジスタのデータとオペランドのアドレスを合わせれば、参照先がわかる。  

### 基底アドレス方式

ベースレジスタが絡むやつ。
オペランド部のアドレスにベースレジスタの値を合わせた先のアドレスに目的の物が入ってる方式。
ベースレジスタって、プログラムの先頭のアドレスが入るので、プログラムがどこに展開されても、何番目のアドレスを参照するってのが変わらないのが利点って話だった気がする。

### 相対アドレス方式

プログラムカウンタが絡むやつ。
正直、これは基底アドレスとほとんど変わらない。
ベースレジスタかプログラムカウンタかくらいの違いしか無くて、結局、プログラムカウンタの値を合わせた先のアドレスを見に行くのは変わらないからな。
メリットは知らん。  
ベースレジスタを持たないけど、基底アドレス方式と同じように扱いたい場合に利用するんだって。
ベースレジスタないことなんてあるのか。  

---

## 損益分岐点

損益分岐点ってそもそも何ってところから理論的に求められるようにならないと一生覚えれないと思ったのでまとめ。  
確か利益と損が相殺されて0になる点だった気がする。  

[SMBC](https://www.smbcnikko.co.jp/terms/japan/so/J0294.html)  
・売上高と費用が等しくなる点→損益が0になる時の売上高。  
・売上高が損益分岐点を上回れば利益、下回れば損失。  

そんな点のことを損益分岐点という。  

### 公式

1.損益分岐点 = 固定費 / ((売上高 - 変動費) / 売上高)

2.損益分岐点 = 固定費 / (1 - 変動比率)

3.損益分岐点 = 固定費 / 限界利益率
限界利益率 = 限界利益 ÷ 売上高 × 100%  
限界利益 = 売上高 - 変動費  

### 1or2の公式の求め方

損益分岐点の個々の要素を分解すると以下の3要素に分類できる。
・利益
・変動費
・固定費

利益は売り上げから費用を引いた値なので以下の式が成り立つ。  
→  
利益 = 売上高 - 変動費 - 固定費  

変動費は売上げに伴ってかかってくる費用なので売上高に比率を掛ければ、売上げに対する変動費を求めることができると考えられる。  
この関係から以下のような式に表すことができる。  
→  
変動費 = 売上高 * 変動比率  

なので変動比率は式を変形して以下のように求めることができる。  
→  
変動比率 = 変動費 / 売上高  

これらを「利益 = 売上高 - 変動費 - 固定費」に当てはめると以下のようになる。  
→  
利益 = 売上高 - 売上高 * 変動比率 - 固定費  
     = 売上高(1 - 変動比率) - 固定費  

損益分岐点は利益が0になる点なので、利益を0とする。  
→  
0 = 売上高(1 - 変動比率) - 固定費  

売上高を左辺に移動して、変形すると公式になる。  
→
売上高 = 固定費 / (1 - 変動比率)

この売上高が損益分岐点となる。  

式変形をしなければ1番目の公式になる。  
`損益分岐点 = 固定費 / ((売上高 - 変動費) / 売上高)`  

### コラム

まぁ基本情報においては1or2さえわかっていればいいけど、他にも色々有りそうなので、それもまとめておく。  

限界利益  
売上高から変動費を引いたものを限界利益という。  
1個商品を売ったときにどれだけ固定費を回収できるかを表している。  
まぁ小難しく言ってるけど、例えば、商品を1000円で売りました。800円が売上原価になります。200円儲けが出るけど、それ以上の利益はないよ。  
それが限界の利益だよって言ってるだけだ。  
で、話は続くけど、これに固定費30万円がかかりますっていう場合、それを上回るためには儲けが200円なので1500個売らないといけないです。  
で、1000円と1500個の150万の売上が損益分岐点になるし、1500個という数字は損益分岐点販売量と言われるものになる。  

`限界利益 = 売上高 - 変動費`  

限界利益率  
売上に対してどの程度が限界利益として出ているのかを割合で示したもの  
`限界利益率 = 限界利益 ÷ 売上高 × 100%`  

確かあの問題は売上700,変動費140,固定費500だった気がする。  
限界利益 : 700 - 140 = 560  
限界利益率 : 560 / 700 = 0.8  
500 / 0.8 = 625  
あー、普通に求まりますね。  

因みにこの時、利益が500万になるためには？って応用の問題に当てはめると、
利益といいつつ、達成しないといけないノルマって考えたら固定費が500万増えたような物と同じなので、
固定費の部分に500万ぶち込んで計算すればどのくらいの売上高が必要なのか求まります。

### 具体例

[損益分岐点とは？具体例でわかる計算方法](https://biz.moneyforward.com/accounting/basic/34/)  

1個80円で仕入れた商品を120円で販売しています。1カ月の固定費が50万円だとすると、利益を生み出すには何個売らなければならないでしょうか？  
→  
120円で販売しており、仕入原価は80円なので、限界利益は120円−80円＝40円となります。
固定費50万円を回収するためには、50万円÷40円＝12,500個売る必要があることがわかります。そうすると、利益が0になる売上高は、販売額にこの12,500個を掛ければ求められます。
120円×12,500個＝150万円ということです。これは、先ほどの損益分岐点の計算式でも同じ結果になります。
50万円÷｛（120円−80円）÷120円｝＝150万円

---

## 線形計画法

**令和元年秋期　問76**
製品X及びYを生産するために2種類の原料A，Bが必要である。製品1個の生産に必要となる原料の量と調達可能量は表に示すとおりである。製品XとYの1個当たりの販売利益が，それぞれ100円，150円であるとき，最大利益は何円か。

A 2 1 100
B 1 2 80
→
線形計画法は明日やろう。

とりあえず、前解いた時の解き方をそのままやる。
確か、Xを全部の場合とYを全部の場合とその中間の場合を考えることができるはず。
全部の場合よりも中間の場合のほうが効率はよかったので、連立方程式使って解いた気がする。

製品Xをフルで作ると50個調達可能。→5000円
製品Yをフルで作ると40個調達可能。→6000円
でも、これだと部品のあまりが生じてしまう。

求めることは、今ある部品を無駄なく使うと、一体いくつのX,Yをそれぞれ生産可能か？ということだ。
とりあえず、2x + y = 100, x + 2y = 80 の式を組めれば正解したようなものだ。
でも、なんでこれがX,Yの生産可能数になってくるのかわからない。
どちらかというと、a,bの部品数な気がするのだが？

うーん。とりあえず、数直線上のイメージは正しいのと、最適な生産数を求めるなら、表示されている図の通りに式を組み上げて計算すればオッケーってのはわかった。
yを0とみなせるのは、数直線上におけるXを求めるためって思えば普通の事だ。

→

線形計画法
x,yはいくつかの1次方程式を満たす時、1次方程式 ax + by = k がその多角形の頂点を通る場合を調べることで、最大値。最小値が求められる。

製品Xの生産量をx,製品Yの生産量をyとする。
原料Aと原料Bについて、設問の表で式を立てると次のようになる。

原料A : 2x + y <= 100 ①
原料B : x + 2y <= 80  ②

一方利益金額(zとする)
z = (100円 * x個) + (150円 * y個) ③

が、①、②の領域を交わるzの最大値が最大利益金額となる。

①より y <= -2x + 100
②より y <= -1/2x + 40
③より y <= -2/3x + x/150

①、②の交点の座標をPとすると、
① - ②より X <= 40
② × 4 - ① より Y <= 20
よって最大利益になるのは、製品Xを40個、製品Yを20個生産した場合。

→

線型計画法に則って考えると最大利益となる可能性のある生産方針は、
・製品Xを優先的に限界量まで生産
・製品Yを優先的に限界量まで生産
・調達可能量を全て使いきる製品XとYの組合せで生産
の3つのどれかになります。それぞれのケースごとに得られる利益を計算し、最大利益を求めます。
原料の調達可能量の制約からXの最大生産量は50個になります。Xの1個当たりの販売利益は100円なので、得られる利益は5,000円です。
原料の調達可能量の制約からYの最大生産量は40個になります。Yの1個当たりの販売利益は150円なので、得られる利益は6,000円です。
原料A、Bの両方を調達可能量まで使いきるときの、XとYの生産量の組合せを連立方程式で求めます。

2X + Y = 100
X + 2Y = 80

(1)の式を変形

Y = 100 - 2X

(3)の式を(2)の式に代入してXを求める

X + 2(100 - 2X) = 80
X + 200 - 4X = 80
-3X = -120
X = 40

(4)の式を(2)の式に代入してYを求める。

40 + 2Y = 80
2Y = 40
Y = 20

調達可能量まで原料A・Bを使った場合「X＝40個、Y＝20個」を生産できます。このときに得られる利益は、

　100円×40個＋150円×20個＝7,000円
最大利益は3つのケースのうち最大となる「7,000円」となります。

---

## アーンド・バリュー・マネジメント(EVM : Earned Value Management)

応用じゃないと出てこないので今はいいや。
しかし、やはりわかりそうが一番わかりやすいな。

[わかりそう](https://wa3.i-3-i.info/word16508.html)  

プロジェクト管理手法の一つ。
成果物とかも全部コスト換算して「どれくらい進んだ？」と「いくら、かかった？」を分析することで、状況を判断したりするやり方。

・全てをコスト換算
・どれくらい進んだか
・幾らかかったか

1.PV (Planned Value) : 「いくら、かかりそう？」な計画(予算)  
2.EV (Earned Value) : 「いくら分、出来た？」な実績(進捗をコスト換算したもの)  
3.AC (Actual Cost) : 「いくら、使った？」な実際に消費したコスト  

---

## 稼働率

直列はいいんだけど、並列ってなんであの公式なのか、理屈を知りたくてまとめた。  

[稼働率の計算方法がわかる｜かんたん計算問題](https://www.seplus.jp/dokushuzemi/fe/fenavi/easy_calc/availability/)  

### とりあえず定義  

稼働率とは、「システムが動作している確率」のこと  

### 並列の場合の稼働率の求め方

システム全体の稼働率 = 1 - ( 両方の装置が同時に停止する確率 )  ①
両方の装置が同時に停止する確立 = (一方の装置が停止する確率) × (もう一方の装置が停止する確立)  ②
装置が停止する確立 = 1 - 装置の稼働率  ③

例 :
サーバーA稼働率0.9 , サーバーB稼働率0.8

③装置が停止する確立  
サーバーAが停止する確立 = 1 - 0.9 = 0.1  
サーバーBが停止する確立 = 1 - 0.8 = 0.2  

②両方の装置が同時に停止する確立  
サーバーAとサーバーBの両方が同時に停止する確立
0.1 * 0.2 = 0.02  

①システム全体の稼働率  
サーバーAとサーバーBのいずれかが動作する確立  
1 - 0.02 = 0.98

同時に停止する確立だけを考慮しているので、どちらかが動いているかどちらも動いているかでシステムは十分継続可能ということになるのか。  
因みに直列の場合は1つでも死んだら全体がアウトなので、動いている確立と動いている確立を掛け合わせる事で全体の稼働率となる。  
もちろんそこから1を引けば、システムが死ぬ確立を表しており、どっちかが死んだが、どちらも死んだかを表している。  

オーケー。納得できた。  

---

## オブジェクトプログラム

ソースプログラムをコンパイラで機械語に翻訳したプログラムのことである。  
ソースプログラムはコンピューターで実行することができないが、これを実行できる形式に直したものがオブジェクトプログラムとなる。  
オブジェクトプログラム = オブジェクトコード  

---

## LRU

なんか親戚が3つ位あるのは知ってるんですが、それぞれが何っていうのは割とあいまいなんですよね。  
2021/10/18 Monにようやくまとめる余裕を取ったので、一気にまとめます。  

[基本情報でわかる FIFO LFU LRU 「略語の意味がわかればわかる」](https://www.seplus.jp/dokushuzemi/fe/fenavi/mastering_tech/fifo_lfu_lru/)  

まず、これらアルゴリズムは仮想メモリのページングの追い出しの方式です。  
応用も調べて見ましたが、基本的に3つだけ見たいです。  
LRUもあいまいですが、Frequencyなるものもあいまいです。こいつは一番存在感がない気がしますね。  
まぁ、直近でよく使うものほど残しておくといい感じになる法則があるので、主流はLRUみたいよ。

FIFO (First In First Out)  
「最初にページインしたページ」  
→もといページインしてからの時間が最も長いページを置換え対象とするアルゴリズム  

LFU (Least Frequency Used)  
「利用された回数が最も少ないページ」  
→わかってしまうとこれが一番わかりやすかった。  
直訳すると「最もそうでない（ Least は、 Little の最上級です）、頻繁に、使われる」です。これは、「最も頻繁でない」が「最も回数が少ない」と同じなので、「利用された回数が最も少ないページ」に該当します。

LRU (Least Recentry Used)  
「最後に利用してから最も時間が経過しているページ」  
→これは表現がダメ。最も直近で使っていないものにすべき。最も時間が経過したということは最も古くからあるということなので、これはどちらかというとFIFOになる。  
直訳すると「最もそうでない、最近、使われる」です。これは、「最も、最近ではない」が、

例:  
A B B C A  

ページングアルゴリズムに FIFO を採用した場合  
A → B → B → C → A で最初にページインしたページ×「最も長く存在するページ」は A なので、 A を仮想メモリに退避させます。  

ページングアルゴリズムに LFU を採用した場合  
A → B → B → C → A において、 A は 2 回、 B は 2 回、 C は 1 回使われていて、利用された回数が最も少ないページは C なので、 C を仮想メモリに退避させます。  

ページングアルゴリズムに LRU を採用した場合  
A → B → B → C → A で最後に利用してから最も時間が経過しているページは B なので、 B を仮想メモリに退避させます。  
直近でAを使用したので、更新された。そうすると直近で最も使われていないのはBになるのでBが追い出されるというわけ。  

**平成29年春期　問19**
仮想記憶方式のコンピュータにおいて，実記憶に割り当てられるページ数は3とし，追い出すページを選ぶアルゴリズムは，FIFOとLRUの二つ考える。あるタスクのページアクセス順序が
1, 3, 2, 1, 4, 5, 2, 3, 4, 5

FIFO
1  1  1  1+ 4F 4  4  4  4+ 4
   3  3  3  3  5F 5  5  5  5+
      2  2  2  2  2+ 3F 3  3

LRU
1  1  1  1+ 1  1  2F 2  2  5F
   3  3  3  4F 4  4  3F 3  3
      2  2  2  5F 5  5  4F 4

額面通りに受け止めてもしっくり来なかったが、追い出しに置けるFIFOはページインしてからの時間が最も長いページが対象だとは・・。  
FIFOと言えば、上から入って下から抜けるアレだ。そのイメージでいくと、1が来た地点で1が抜けるのだが、そうではない。  
同じものがあった場合は変化しない。違う数字が来た場合に、抜けるイメージか。そのルールさえ覚えれば、FIFOも大丈夫だ。  
というか、これ当たり前だよな。  
同じ数字が来たらというよりも、既にある数字だから置き換えの必要がないだけで、一番最初にIn下のが1だから次に違う数字が来た時に置き換え対象になったというだけだ。  

LRUは+のポジションで存在の更新がかかるので直近で使われたことになる。  
すると、最も最近使われていないものは自動的に最も古くからあるものになる。  
まぁ、言葉でいうより見たほうが早いだろう。  
あーあれだ、「最後に利用してから最も時間が経過」しているが正解だな。

取り合えず、最も古くから、最も回数が少ない、最も直近で使っていない→最後に利用してから最も時間が経過の3つを覚えたのでおｋ。  

---

## パイプライン処理

[【基本情報技術者試験】パイプライン処理](https://medium-company.com/%e5%9f%ba%e6%9c%ac%e6%83%85%e5%a0%b1-%e3%83%91%e3%82%a4%e3%83%97%e3%83%a9%e3%82%a4%e3%83%b3%e5%87%a6%e7%90%86/)  

ようやくタブを一つ消化できるな。

**基本情報技術者平成28年春期 午前問10**
RISCプロセッサの5段パイプラインの命令実行制御の順序はどれか。ここで，このパイプラインのステージは次の五つとする。
① 書込み
② 実行とアドレス生成
③ 命令デコードとレジスタファイル読出し
④ 命令フェッチ
⑤ メモリアクセス
ア：③，④，②，⑤，①
イ：③，⑤，②，④，①
ウ：④，③，②，⑤，①
エ：④，⑤，③，②，①

2週目でもやったこの問題。

**基本情報技術者平成20年春期 午前問17**
スーパスカラの説明はどれか。

ア：処理すべきベクトルの長さがベクトルレジスタより長い場合，ベクトルレジスタの長さの組に分割して処理を繰り返す方式である。
イ：パイプラインを更に細分化することによって，高速化を図る方式である。
ウ：複数のパイプラインを用いて，同時に複数の命令を実行可能にすることによって，高速化を図る方式である。
エ：命令語を長く取り，一つの命令で複数の機能ユニットを同時に制御することによって，高速化を図る方式である。

→
最近の基本情報では全く見なかったが、超基本なのでこの際に覚えておきたい。
なんかパイプライン何だけど、更に2段になってる奴。
イメージではわかるけど、言葉では説明できない奴。
とりあえず、答えを選別すると、イはスーパーパイプライン。
同時に複数の命令を実行可能ってあるから正解はウですね。
因みにエは命令を長くするって文言からVLなんちゃらの奴ですね。

### 本題

とりあえず、最近覚えて喜んでいる。フェッチ、デコード、実行、書き込みのあの流れ。
あれって逐一やっていたら遅いわけですよ。
命令を一つずつ順番に処理していく方式だと、一つの命令が終わるまで次の命令を処理することが出来ないから。

じゃあ、フェッチしてデコードしてる間、次のフェッチ出来ない？みたいな感じで、一段ずらして処理を実行したら高速かできるんじゃね？って事でパイプライン処理ってのが出来ました。
これが超基本。
単純にずらしただけだけどね。

スーパーパイプラインはパイプラインのフェッチをフェッチ1，2，3とかに更に細分化したもの。
フェッチ1，2，3、デコード1，2，3ってわけて、後はパイプラインと同じく段々に配置した感じの奴。  
フェッチ1の地点でデコード１が始まる。フェッチ1，2，3が終わってからデコード1が始まるわけではない。
キーワード的には**パイプライン処理の階段を更に細分化**することによって高速化を図る手法。

因みに、この段々になっているのは命令って単位らしい。
当たり前か。1つの命令をフェッチしてデコードしてってわけだからな。
命令1を処理している間、命令2を実行して、命令3を実行して。

で、スーパースカラは命令1と2のフェッチを同じタイミングで並べて実行する。
命令1と2が同じ段にある。命令3と4が次の段にある。
よくイメージで見るやつ。
キーワード的には**パイプライン処理を行う回路を複数持つ**って事らしい。  

パイプライン処理を行う回路が一つしかないが、スーパースカラではパイプライン処理wお行う回路を複数持つことが出来ます。
つまり1命令を実行するためには1回路が必要って事か。
スーパースカラは、回路を複数持つことで複数の命令を同時に実行できるようにしたのね。
とりあえず、これだけの認識で十分かなー。

最後にVLIW(Very Long Instruction Word)。
Very Longまでは覚えられたのだが。
こいつはパイプラインはあまり関係ないっぽい。
命令を段々にするのも限界があるから、じゃあ全部の命令合わせて1つの命令にしちゃえばよくねって発想みたい。
キーワード的には**依存関係のない複数の命令を一つの複合命令として同時に実行させる**手法。

まとめてしまえばこのくらいでしかないか。

---

## リエントラント(Reentrant，再入可能)、リユーザブル(Reusable，再使用可能)、リロケータブル(Relocation，再配置可能)

リカーシブは飛ばすぞ。

[再入可能・再帰的・再使用可能・再配置可能について調べる](https://snofra.hatenablog.com/entry/2018/09/06/004527)  

### 最後に問題

**応用情報技術者平成28年春期 午前問7**
リアルタイムシステムにおいて，複数のタスクから並行して呼び出された場合に，同時に実行する必要がある共用ライブラリのプログラムに要求される性質はどれか。

→
並行して呼び出される。それぞれの呼び出し元で値が変わることはない。
ならば、リエントラントしかない。

→
リエントラント(Reentrant，再入可能)
各プロセスごとに変数部分を割り当てることで、複数のプロセスで同時に実行できる性質。

リユーザブル(Reusable，再使用可能)
プログラムの主記憶への展開を初回実行時のみ行い、以後は何度でも正しく使用できる性質。

リカーシブ(Recursive，再帰可能)
プログラム中において自分自身を呼び出すことが可能な性質。

リロケータブル(Relocation，再配置可能)
プログラムを主記憶上のどの位置においても処理が可能な性質。

共用ライブラリは、1つのプログラムを複数のプロセスが共用する前提で作られます。特にリアルタイムシステムにおいては、他のプロセスがライブラリを解放するのを待つようでは処理が遅延し、システムとして致命的となるため「リエントラント(再入可能)」なプログラム構造である必要があります。


**応用情報技術者平成29年春期 午前問7**
プログラムの特性に関する記述のうち，適切なものはどれか。

再帰的プログラムは，手続の中でそれ自体を呼び出すプログラムであり，再入可能である。
再使用可能プログラムは，一度実行したプログラムを主記憶装置上にロードし直さずに再度実行できるプログラムであり，再入可能である。
再入可能プログラムは，複数のタスクから同時に呼び出されたときに，並列に実行できるプログラムであるが，再配置可能ではない。
再配置可能プログラムは，主記憶装置上のどの領域にロードされても実行可能なプログラムであるが，再使用可能ではない。

→
歳入可能であるということは再帰も許可される。
また、再帰毎に値が変わる事はあり得ないので、歳入可能ということは再帰可能であり、再帰可能ということは歳入可能と言える。
なので、自然とアが正解になる。

→
リエントラント(Reentrant，再入可能)
プログラム内で使用する変数部分を各プロセスごとに割り当てることで、複数のプロセスで同時に使用できる特性

リユーザブル(Reusable，再使用可能)
主記憶へのプログラムの展開を初回実行時のみ行い、それ以降はロードせずとも何度でも正しく使用できる特性

リカーシブ(Recursive，再帰可能)
プログラム中において自分自身を呼び出すことができる特性

リロケータブル(Relocation，再配置可能)
プログラムを主記憶上のどの位置においても正しく実行できる特性

再帰的プログラムは，手続の中でそれ自体を呼び出すプログラムであり，再入可能である。
正しい。再帰的プログラムは、呼び出し元のプログラムの実行中に自分自身を呼び出します。このとき2つ以上のプロセスが同時に存在することになるため再入可能であることが求められます。

再使用可能プログラムは，一度実行したプログラムを主記憶装置上にロードし直さずに再度実行できるプログラムであり，再入可能である。
再使用可能なプログラムが、再入可能であるとは限りません。

再入可能プログラムは，複数のタスクから同時に呼び出されたときに，並列に実行できるプログラムであるが，再配置可能ではない。
再入可能かつ再配置可能なプログラムもあります。

再配置可能プログラムは，主記憶装置上のどの領域にロードされても実行可能なプログラムであるが，再使用可能ではない。
再配置可能かつ再使用可能なプログラムもあります。

---

ACID特性
