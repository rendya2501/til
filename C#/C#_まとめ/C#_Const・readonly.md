# const,readonly

---

## 読み取り専用のローカル変数

C#に読み取り専用のローカル変数は存在しない。  
`readonly`キーワードはローカル変数に対応していない。  

初期代入可能で変更不可なローカル変数はC#では定義できない。  
Javaはできる。(final修飾子)  

読み取り専用のローカル変数は定義できないが、ローカル定数は定義できる。  
しかし、この変数は初期代入ができない。  

``` cs
void method1() 
{
    // ローカル定数を定義
    const int ID = 1;
    ID = 2; // エラー
}

void method2(int id) 
{
    // ローカル定数は初期代入ができない
    const int ID = id; // エラー
}
```

Javaは`final`修飾子で初期代入+変更不可のローカル変数を定義可能。  

>``` java
>void method() {
>    final int a; // 初期化されていないが、コンパイルエラーにはならない
>    System.out.println(a); // コンパイルエラー!! finalだが値が設定されていないため使用できない
>    a = 10;
>    System.out.println(a); // 変数に値が設定されたため参照できる
>    a = 123; // コンパイルエラー!! finalなので再代入はできない。
>}
>```
>
>[Javaのfinalを大解剖 finalの全てがここにある!!](https://www.bold.ne.jp/engineer-club/java-final)  

こちらの記事のコメントで言及がある。  

>C#のローカル変数にreadonlyがない理由は、おそらく明示しなくてもコンパイラにはわかることだからです。  
>ローカル変数は基本的にそのメソッド内でしかインスタンスを差し替えることができないので、  
>
>- メソッド内で再代入していない  
>- refつきパラメータとして他のメソッドに渡していない  
>
>この2つを満たしていれば明示しなくてもコンパイラはreadonly的な変数として扱います。  
>[【Unity】ローカル変数のreadonly（読み取り専用）を実現する方法【C#】 - Qiita](https://qiita.com/su10/items/602e89acfa0439c707ae)  

[C#のreadonlyの使い方と注意点を解説します！ | .NETコラム](https://www.fenet.jp/dotnet/column/language/3516/)  

---

## const,readonly,static readonly

### const

コンパイル時に定義する。  
なので、メソッドの結果など、実行しなければ確定しないものは定数として定義できない。  
これによって、バージョニング問題が発生するとか。  

``` C#
class Hoge
{
    public const double PI = 3.14;     // OK
    public const double piyo = PI \* PI;     // OK
    public const double payo = Math.Sqrt(10);   // NG

    void Piyo(){
        //コンパイルで生成される中間言語では下の条件式はmyData == 3.14となる
        if(Moge == PI)
            //処理
    }
}
```

### readonly

コンストラクタでのみ書き込み可能。  
それ以降は変更不可。  

### static readonly

コンパイル時ではなく、実行時に値が定まり、以後不変となる。  
コンパイルした後の話なので、メソッドを実行した結果をプログラム実行中の定数として扱うことができる。  
バージョニング問題的な観点から、constよりstatic readonlyが推奨される。  
ちなみにconstは暗黙的にstaticに変換されるので、staticを嫌悪する必要はない。  

[constとreadonlyとstatic readonly、それぞれの特徴と使い分け方](https://qiita.com/4_mio_11/items/203c88eb5299e4a45f31)  

---

## constのバージョニング問題

C#のconstキーワードは、コンパイル時に定数値を提供します。  
これは、変更できない値を定義するために使用されます。  
ただし、constを使用することにより、バージョニング問題が発生することがあります。  

バージョニング問題の原因は、constがコンパイル時に解決され、その値がコンパイル済みのアセンブリに直接埋め込まれるためです。  
これにより、次のような問題が発生します。  

1. 互換性の問題:  
   あるアセンブリが定数を使用して別のアセンブリと連携している場合、定数の値を変更して新しいバージョンのアセンブリをリリースした場合、その変更が適用されません。  
   これは、古いアセンブリがまだコンパイル時に埋め込まれた以前の定数値を使用しているためです。  
   この問題を解決するには、アセンブリを再コンパイルして新しい定数値を取り込む必要があります。  

2. 保守性の問題:  
   定数が複数のプロジェクトで共有されている場合、定数の値を変更すると、すべてのプロジェクトを再コンパイルする必要があります。  
   これは、一部のプロジェクトが更新されず、結果として古い定数値を使用し続けることがあります。  
   また、他のプロジェクトが新しい定数値を使用しているため、予期しない動作やエラーが発生する可能性があります。  

バージョニング問題を回避する方法として、readonly修飾子を使用することが推奨されます。  
readonlyは、ランタイム時に値が設定され、その後変更されないことを保証します。  
readonlyフィールドは、アセンブリ間で動的にリンクされるため、アセンブリを再コンパイルせずに値を更新できます。  
