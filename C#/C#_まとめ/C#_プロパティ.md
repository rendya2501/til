# プロパティ

---

## 概要

クラス外部から見るとメンバー変数のように振る舞い、 クラス内部から見るとメソッドのように振舞うものです。  
JavaやC++にはない(Visual Basicにはある)機能。  

乱暴な言い方すると、JavaのGetter,Setterに相当するモノ。  
Javaはプロパティがないので、自分でGetter,Setterを実装する必要があるが、C#なら自動実装プロパティなら1行で済む。  

※プロパティ（property：所有物、特性）  
[未確認飛行C](https://ufcpp.net/study/csharp/oo_property.html)  

---

## 自動実装プロパティ

サードパーティー製のライブラリを使わない場合のINotifyPropertyChanged実装はどうやるのか研究してたら、プロパティの自動実装で色々発見というか、知らないことが多々あったのでまとめることにした。  

[未確認飛行C](https://ufcpp.net/study/csharp/oo_property.html)  

### 自動プロパティの基本

C# 3.0 では、プロパティの get/set の中身の省略もできるようになりました。  
この機能を自動プロパティ（auto-property, auto-implemented property）といいます。  

``` C# : 自動プロパティの基本
// get; set; とだけ書いておくと、以下のというようなコードに相当するものが自動的に生成されます。  
public string Name { get; set; }

// ↓こう書いたのと同じ

private string __name;
public string Name
{
  get { return this.__name; }
  set { this.__name = value; }
}
```

[__name] はコンパイラーによって生成されるフィールドで、バック フィールド(baking field: 後援フィールド)と呼ばれます。  
バック フィールド([__name])はプログラマが参照できるものではありません。  

### 自動実装プロパティの初期化

``` C# : 自動実装プロパティの初期化
    // C# 6 以降では、フィールドと同様に自動実装プロパティを初期化することができます。
    public string FirstName { get; set; } = "Jane";
```

### get onlyプロパティ

C# 6 では、get アクセサーだけのプロパティを定義できるようになりました。

``` C# : get only
    // 1. これは MyCommand { get; } と同じ意味であり、3.と同じことを意味する
    public ICommand MyCommand => new RelayCommand(() => Count++);

    // 2. こう書くこともできる
    public ICommand MyCommand { get => new RelayCommand(() => Count++); }

    // 3. 1.2.を愚直に書くとこうなる
    public RelayCommand MyCommand
    {
        // ちなみに ??= はnull合体代入演算子であり、_myCommandがnullであればnew RelayCommandを代入するという代物。
        // 8.0から使用可能
        get => _myCommand ??= new RelayCommand(() => Count++);
    }
    private RelayCommand _myCommand;
```

### aa

[WisdomSofg_自動実装プロパティ](http://www.wisdomsoft.jp/182.html)  

自動実装プロパティは get アクセッサと set アクセッサの両方でセミコロンを本体にしなければなりません。  
一方をブロックの本体にしたり、片方のアクセッサのみを指定するということはできません。  
必ず両方のアクセッサを記述し、セミコロンの本体を指定します。  

``` C#
    // 毎回こうやって書くのはだるい
    public int Count
    {
       get { return _Count; }
       set
       {
           _Count = value;
           PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Count)));
       }
    }
    private int _Count;

    // 理想はこうだが、これはだめらしい。
    // abstract、extern、または partial に指定されていないため、本体を宣言する必要があります。というエラーが発生する
    public int Count { 
        get;
        set => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Count))); 
    }
```

---

## プロパティーを参照渡ししてメソッド先で値を変更したい場合

<https://takap-tech.com/entry/2014/08/13/143232>  

SearchSimple○○系の処理はどれも似ている。  
FromToで使いまわしたいが、プロパティは固定で指定しないといけないので、本来ならFrom用、To用と作らないといけない。  
そんなことしたくないので、プロパティを渡そうとしたらエラーになった。  
`プロパティ、インデクサー、または動的メンバー アクセスを out または ref のパラメーターとして渡すことはできません。`  
参考URLでは「この挙動は自動実装プロパティが実際はsetter/getterメソッドを隠ぺいした存在という事に起因する。」ということらしい。  

仕方がないので、Actionを渡すことで対応出来た。  
参考にしたURLでは拡張メソッドで対応しているっぽいが、影響範囲がでかすぎるのでActionで済ませた。  
いいかは知らない。多分よくないはず。  
リフレクション使ってプロパティ名を渡して動的に対応してもらうってのもいいかも。  

<https://atmarkit.itmedia.co.jp/fdotnet/csharp30/csharp30_04/csharp30_04_01.html>  
まとめ終わった後に見つけた。  
似たようなことしてる。やっぱり苦肉の策っぽいですね。  

``` C#
// 自動実装プロパティ
public int No { get; set; }

// 呼び出し元
private Hoge() {
    Fuga(No);
}

// 参照渡し
// プロパティ、インデクサー、または動的メンバー アクセスを out または ref のパラメーターとして渡すことはできません。
private Fuga(ref int no){
    no = 1;
}
```

``` C#
// 自動実装プロパティ
public int No { get; set; }

// 呼び出し元
private Hoge() {
    Fuga((no) => No = no);
}

// Actionで実現
// プロパティ、インデクサー、または動的メンバー アクセスを out または ref のパラメーターとして渡すことはできません。
private Fuga(Action<int> action){
    action(1);
}
```

---

## 内部で使用する場合、メンバ変数に直接アクセスしていいのか、プロパティからアクセスすればいいのか？

[クラス内でプロパティを通してフィールドにアクセスすることの是非](https://teratail.com/questions/304645)  

「クラス内からであっても、private のメンバー変数には直接アクセスせず、 プロパティを通してアクセスする方が後々の保守がしやすかったりします」  
→  
クラスの内側でも「プロパティ」による抽象化の恩恵に与りたいのか否か，程度の話なんじゃないかな，と。  
→  
日次帳票でやった、内部クラス(印刷データ生成クラス)なら、直接フィールドでやり取りしていいのではないだろうか。  
外部に公開するわけでもないし、内部で使うだけだし、抽象化する必要性もないし、そういう場合はフィールドでよさそうな気はする。  
それ以外はプロパティ自体をprivateで宣言して使えば、フィールドを使っているのと同じ様なものでは無かろうか。  
しかし、プロパティのほうが参照元を表示してくれるので、プロパティを使ったほうが便利といえば便利。  

``` txt
(1) オブジェクト指向の概念の一つ「カプセル化」を実現するため、通常クラス内の各フィールドへの直接アクセスは禁止するようにしておき、外部からはパブリックプロパティで各フィールドの値を取得したり設定したりするということがもともとのプロパティの目的です。 

(2) プロパティを使う目的には、開発者が意図した規則に基づいてフィールドを正しく使用できるよう保証するということもあります。

(3) プロパティでなければダメというケースもあります。
例えば、Entity Framework Code First でのモデルを定義を行う場合はフィールドではダメで、プロパティの定義が必要です。
他には、ASP.NET Web Forms アプリのデータバインド式でもプロパティでないとダメです。
```

<https://qiita.com/toshi0607/items/801a0d37fb48313cbdbd>  

1.フィールド  
・オブジェクト指向について「クラスは、データと振る舞いをカプセル化したものである」と説明されるときの「データ」の部分です。  
・オブジェクトが持つデータをフィールドとして定義します。  
・フィールドはクラスのメンバ（クラスなど、型を構成する内部要素の総称）として宣言された変数で、インスタンスと直接結び付けられます。  
・メンバ変数とも呼ばれます。  
・フィールドはインスタンスからアクセスします。  
・**非公開にし、プロパティで操作するのが原則です。**  
・フィールドと3.プロパティの混乱を避けるためにアンダースコア（_）をつけて定義することがあります。  
→  
答えがあったぞ。特に理由が無ければプロパティ経由でアクセスしておけって話か。  

3.プロパティ  
・オブジェクト内にあるフィールドの値を取得、または設定するための手段です。  
・クラス外部から見るとメンバー変数のように振る舞い、 クラス内部から見るとメソッドのように振舞います。  
・メンバー変数の値の取得・変更を行うためのメソッドのことをアクセサー(accessor)といいます。  
・setterに渡す値にはsetter内からvalueという変数でアクセスできます。  
