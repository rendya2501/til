# VisualStudioで簡易データベース構築

---

## LocalDB

Visual Studioと一緒にインストールされる必要最低限の機能を備えたSQL Server。

---

## LocalDB 作成から接続までの最小サンプル

[MicroSoft公式](https://docs.microsoft.com/ja-jp/visualstudio/data-tools/create-a-sql-database-by-using-a-designer?view=vs-2022)  
[C#からDB接続でSQLServerに接続してSELECT文を実行する方法](https://rainbow-engine.com/csharp-dbconnection-sqlserver/)
[SQL Server LocalDB へ接続してSQLを実行する](https://www.ipentec.com/document/csharp-sql-server-localdb-connect-exec-sql)  
[SQL Serverに接続してSQLを実行する (C#プログラミング)](https://www.ipentec.com/document/csharp-sql-server-connect-exec-sql)  

1. コンソールアプリプロジェクトを作成する  
2. プロジェクト右クリック→新しい項目の追加→サービスベースのデータベース  
3. [System.Data.SqlClient]はnugetから取得  
4. 以下のプログラムを貼り付け  
5. 作成したLocalDBを右クリックしてプロパティから接続文字列を取得して接続文字列部分に貼り付け  

``` C#
using System.Data.SqlClient;

    try
    {
        // 接続文字列
        string constr = @"LocalDBを右クリックしてプロパティから接続文字列を取得して貼り付け";
        // 接続オブジェクト生成
        using SqlConnection connection = new SqlConnection(constr);
        // データベース接続
        connection.Open();
        // クエリ生成
        StringBuilder query = new StringBuilder()
            .AppendLine("DROP TABLE IF EXISTS [Products];")
            .AppendLine("CREATE TABLE [Products] ( ")
            .AppendLine("    [Id]    INT        NOT NULL,")
            .AppendLine("    [name]  NCHAR (32) NULL, ")
            .AppendLine("    [price] INT        NULL ")
            .AppendLine("    PRIMARY KEY CLUSTERED ([Id] ASC)")
            .AppendLine("); ")
            .AppendLine("INSERT INTO [Products]")
            .AppendLine("VALUES ")
            .AppendLine("    (1,N'ペンギンクッキー',150), ")
            .AppendLine("    (2,N'シロクマアイス',200), ")
            .AppendLine("    (3,N'らくだケーキ',320), ")
            .AppendLine("    (4,N'くじらキャンディー',60), ")
            .AppendLine("    (5,N'ふくろうサブレ',120); ")
            .AppendLine("SELECT * FROM [Products];");
        // SQLコマンド生成
        using SqlCommand command = new SqlCommand(query.ToString(), connection);
        // SQL実行
        using SqlDataReader reader = command.ExecuteReader();
        // 結果表示
        while (reader.Read()){
            Console.WriteLine($"{reader["name"]}:{reader["price"]}");
            // 律儀にやるならこう
            // Console.WriteLine($"{(string)reader["name"]:s}:{(int)reader["price"]:d}");
            // DataReaderには型で取得するメソッドがあるのでそれでも良い
            // Console.WriteLine($"{reader.GetString(1)},{reader.GetInt32(2)}");
        }
    }
    catch (SqlException Ex)
    {
        Console.WriteLine(Ex.ToString());
    }
```

### 微妙に嵌った事

[System.Data.SqlClient] は単純にusingしただけでは使えない。  
nugetからパッケージをインストールする必要があった。  

[SqlConnectionを.NET Core アプリケーションで利用する](https://www.ipentec.com/document/csharp-using-sqlconnection-in-dot-net-core-application)  
>対処法1: NuGetを利用して、System.Data.SqlClient パッケージを参照する  

---

## SqlConnectionをUsingした場合、Disposeと同時にCloseされるのでFinallyで明示的にCloseする必要はない

SqlConnection using close  

[Microsoft公式_SqlConnection.Close メソッド](https://docs.microsoft.com/ja-jp/dotnet/api/system.data.sqlclient.sqlconnection.close?redirectedfrom=MSDN&view=netframework-4.7.2#System_Data_SqlClient_SqlConnection_Close)  

>次の例では、作成、 SqlConnection開き、そのプロパティの一部を表示します。  
>**接続はブロックの最後で自動的に using 閉じられます**。  

``` C#
private static void OpenSqlConnection(string connectionString)
{
    using (SqlConnection connection = new SqlConnection(connectionString))
    {
        connection.Open();
        Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
        Console.WriteLine("State: {0}", connection.State);
    }
}
```

[SqlConnectionとSqlDataReaderをusingで囲った場合Closeは必要？](https://social.msdn.microsoft.com/Forums/ja-JP/c2a0c8b2-7743-4cfa-869c-f26293b0250f/sqlconnection12392sqldatareader12434using123912225812387123832258021512close?forum=csharpgeneralja)  

>SqlConnection.Close()にはClose と Dispose は、機能的に同じです。  
>「DbDataReader.Dispose()にこのメソッドは Close を呼び出します。」と書かれています。  

[using文で初期化したDbConnection、Closeを書くべき？書かなくていい？](https://qiita.com/momotaro98/items/c4fe0fff0c173e879f2d)  
>using文は、try {} finally {XXX.Dispose();}をわざわざ書かなくてすむようにする糖衣構文ということです。  
→へぇ～そうだったんだ。  
>functionally equivalentとあるように、 DbConnectionクラスにとっては、機能的にはCloseもDisposeもどちらも変わらない ということです。  
>なので、using文ではDisposeメソッドを必ず呼ぶので、結果、Closeメソッドは基本的に不要ということです。  
>しかし、1つ異なる点があります。  
>Closeメソッドは再度そのインスタンスを再Openできるのに、対し、Disposeメソッドは一度実行されたら、そのインスタンスにはアクセスできない。  

### ではなぜCloseを書くのか

[Should I call Close() or Dispose() for stream objects?](https://stackoverflow.com/questions/7524903/should-i-call-close-or-dispose-for-stream-objects/7525134#7525134)  
>It doesn't affect the behaviour of the code, but it does aid readability.  
>つまり、 可読性のため。(既存のコードに影響を与えないし) とのこと。  
>複数のスコープがあるとどこでインスタンスがCloseされているのかがわかりにくくなるので、Closeを書くとよいということです。  

---

## 一連のCRUDデモ

[Windows上でSQL Serverを使用してC#アプリを作成する](https://qiita.com/ymasaoka/items/944e8a5f1987cc9e0d37#c-%E3%82%A2%E3%83%97%E3%83%AA%E3%82%92-100-%E5%80%8D%E9%80%9F%E3%81%AB%E3%81%99%E3%82%8B)  

``` C#
private void Execute()
{
    try
    {
        Console.WriteLine("LocalDB に接続し、Create、Read、Update、Delete 操作のデモを行います。");
        Console.WriteLine("---");

        // 接続文字列の構築
        string constr = @"LocalDBを右クリックしてプロパティから接続文字列を取得して貼り付け";
        // 接続オブジェクト生成
        using SqlConnection connection = new SqlConnection(constr);

        // サーバー接続
        Console.WriteLine("SQL Server に接続しています... ");
        connection.Open();
        Console.WriteLine("接続成功");
        Console.WriteLine("---");

        // CreateDataBase();
        CreateTable();
        CreateDefaultData();
        Insert();
        Update();
        Delete();
        //DropTbale();

        Task.WaitAll(
            Task.Run(Read),
            Task.Run(() =>
            {
                string sqlstr = "select * from products";
                using SqlCommand com = new SqlCommand(sqlstr, connection);
                // SQL実行
                using SqlDataReader reader = com.ExecuteReader();
                // 結果表示
                while (reader.Read())
                {
                    Console.WriteLine($"{reader.GetString(1)},{reader.GetInt32(2)}");
                }
            }
            )
        );
    

        // データベースの作成
        void CreateDataBase()
        {
            Console.WriteLine("既に作成されている SampleDB データベースを削除し、再作成します... ");
            string sql = "DROP DATABASE IF EXISTS [SampleDB]; CREATE DATABASE [SampleDB]";
            // コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒
            using SqlCommand command = new SqlCommand(sql, connection) { CommandTimeout = 60000 };
            command.ExecuteNonQuery();
            Console.WriteLine("SampleDB データベースを作成しました。");
            Console.WriteLine("---");
        }

        // テーブルの作成
        void CreateTable()
        {
            Console.WriteLine("テーブルを作成");
            StringBuilder query = new StringBuilder()
                    //.AppendLine("USE SampleDB; ")
                .AppendLine("DROP TABLE IF EXISTS [Employees];")
                .AppendLine("CREATE TABLE [Employees] ( ")
                .AppendLine("    Id INT IDENTITY(1,1) NOT NULL PRIMARY KEY, ")
                .AppendLine("    Name NVARCHAR(50), ")
                .AppendLine("    Location NVARCHAR(50) ")
                .AppendLine("); ");
            using (SqlCommand command = new SqlCommand(query.ToString(), connection) { CommandTimeout = 60000 })
            {
                command.ExecuteNonQuery();
                Console.WriteLine("テーブル作成完了");
                Console.WriteLine();
            }
            Read();
        }

        // サンプルデータの登録
        void CreateDefaultData()
        {
            Console.WriteLine("デフォルトデータを作成します。");
            StringBuilder query = new StringBuilder()
                .AppendLine("INSERT INTO Employees (Name, Location)")
                .AppendLine("VALUES ")
                .AppendLine("    (N'Jared', N'Australia'), ")
                .AppendLine("    (N'Nikita', N'India'), ")
                .AppendLine("    (N'Tom', N'Germany'); ");
            using (SqlCommand command = new SqlCommand(query.ToString(), connection) { CommandTimeout = 60000 })
            {
                command.ExecuteNonQuery();
                Console.WriteLine("作成完了");
                Console.WriteLine();
            }
            Read();
        }

        // INSERT デモ
        void Insert()
        {
            Console.WriteLine("テーブルに新しい行を挿入するには、任意のキーを押して続行します...");
            StringBuilder query = new StringBuilder()
                .AppendLine("INSERT Employees (Name, Location) ")
                .AppendLine("VALUES (@name, @location);");
            using (SqlCommand command = new SqlCommand(query.ToString(), connection) { CommandTimeout = 60000 })
            {
                command.Parameters.AddWithValue("@name", "Jake");
                command.Parameters.AddWithValue("@location", "United States");
                int rowsAffected = command.ExecuteNonQuery();
                Console.WriteLine(rowsAffected + " 行 挿入されました。");
                Console.WriteLine();
            }
            Read();
        }

        // UPDATE デモ
        void Update()
        {
            string userToUpdate = "Nikita";
            Console.WriteLine("ユーザー名 '" + userToUpdate + "' の 'Location' を更新中です。任意のキーを押して処理を続行します...");
            StringBuilder query = new StringBuilder()
                .AppendLine("UPDATE Employees")
                .AppendLine("SET Location = N'United States'")
                .AppendLine("WHERE Name = @name");
            using (SqlCommand command = new SqlCommand(query.ToString(), connection) { CommandTimeout = 60000 })
            {
                command.Parameters.AddWithValue("@name", userToUpdate);
                int rowsAffected = command.ExecuteNonQuery();
                Console.WriteLine(rowsAffected + " 行 更新されました。");
                Console.WriteLine();
            }
            Read();
        }

        // DELETE デモ
        void Delete()
        {
            string userToDelete = "Jared";
            Console.WriteLine("ユーザー名 '" + userToDelete + "' を削除中です。任意のキーを押して処理を続行します...");
            StringBuilder query = new StringBuilder()
                .AppendLine("DELETE FROM Employees WHERE Name = @name;");
            using (SqlCommand command = new SqlCommand(query.ToString(), connection) { CommandTimeout = 60000 })
            {
                command.Parameters.AddWithValue("@name", userToDelete);
                int rowsAffected = command.ExecuteNonQuery();
                Console.WriteLine(rowsAffected + " 行 削除されました。");
                Console.WriteLine();
            }
            Read();
        }

        // Select
        void Read()
        {
            StringBuilder query = new StringBuilder()
                .AppendLine("SELECT Id, Name, Location FROM Employees;");
            using SqlCommand command = new SqlCommand(query.ToString(), connection);
            using SqlDataReader reader = command.ExecuteReader();
            while (reader.Read())
            {
                Console.WriteLine($"{reader.GetInt32(0)} {reader.GetString(1)} {reader.GetString(2)}");
                //_TextBox1.Text += $"{reader.GetInt32(0)} {reader.GetString(1)} {reader.GetString(2)}";
            }
            Console.WriteLine("---");
        }

        // テーブル削除
        void DropTbale()
        {
            Console.WriteLine("SampleDB データベースを削除します。");
            string sql = "DROP TABLE [Employees];";
            //string sql = "DROP DATABASE [SampleDB];";
            using SqlCommand command = new SqlCommand(sql, connection) { CommandTimeout = 60000 };
            command.ExecuteNonQuery();
            Console.WriteLine("削除完了");
            Console.WriteLine("---");
        }
    }
    catch (SqlException e)
    {
        Console.WriteLine(e.ToString());
    }

    Console.WriteLine("全て完了しました");
}
```

---

## 接続文字列構築パターン

``` C# : SQL Serverへの接続文字列の構築
    SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder
    {
        // 接続先の SQL Server インスタンス
        DataSource = "localhost",
        // 接続ユーザー名
        UserID = "sa",
        // 接続パスワード
        Password = "your_password",
        // 接続するデータベース
        InitialCatalog = "master",
        // 接続タイムアウトの秒数(ms) デフォルトは 15 秒
        ConnectTimeout = 60000
    };
    SqlConnection connection = new SqlConnection(builder.ConnectionString);
```

``` C# : ローカルDBへの接続文字列の構築 SqlConnectionStringBuilderパターン
    SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder
    {
        DataSource = @"(LocalDB)\MSSQLLocalDB",
        AttachDBFilename = System.IO.Path.GetFullPath(@"..\..\..\SampleDatabase.mdf"),
        IntegratedSecurity = true,
    };
    SqlConnection connection = new SqlConnection(builder.ConnectionString);
```

``` C# : ローカルDBへの接続文字列の構築 直接指定パターン
    //Data Source=(SQL Server のホスト名またはIPアドレス);Initial Catalog=(接続先データベース名);Connect Timeout=60;Persist Security Info=True;User ID=(SQL Serverに接続するユーザーID);Password=(ユーザーのパスワード)
    string constr = @"Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=C:\Users\~~~~~\LocalDB\SampleDatabase.mdf;Integrated Security=True";
    // string constr = $@"Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename={System.IO.Path.GetFullPath(@"..\..\..\Database1.mdf")};Integrated Security=True";
    SqlConnection con = new SqlConnection(constr);
```

---

## 1つのコネクションの中で並列して処理を実行することはできるか？

A.できない。  

デッドロックではなさそうだけど、処理が明らかに止まり、しばらくしたらタイムアウトエラーになる。  
それぞれコネクションをopenして並列して実行する分には問題ないことが分かった。  

``` txt : エラー内容
内部例外 1:
Win32Exception: 待ち操作がタイムアウトになりました。
```

``` C# : ①
    using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
    {
        // データベース接続
        connection.Open();
        // テーブルの生成と初期データを準備
        CreateTable(connection);
        Insert(connection);
        // 1つのコネクションで並列実行→エラー
        Task.WaitAll(
           Task.Run(() => Read1(connection)),
           Task.Run(() => Read2(connection))
        );
    }
```

``` C# : ②
    using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
    {
        // データベース接続
        connection.Open();
        // テーブルの生成と初期データを準備
        CreateTable(connection);
        Insert(connection);
    }
    // ②コネクションを張りなおすが、相変わらず1つのコネクションを使って並列実行 → エラー
    using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
    {
       connection.Open();
       Task.WaitAll(
           Task.Run(() => Read1(connection)),
           Task.Run(() => Read2(connection))
       );
    }
```

``` C# : OKパターン
    // テーブルの生成と初期データを準備済みの体

    // それぞれでコネクションを張って並列実行 → OK
    Task.WaitAll(
        Task.Run(() =>
        {
            using (SqlConnection connection = new SqlConnection(builder.ConnectionString)){
                connection.Open();
                Read1(connection);
            }
        }),
        Task.Run(() =>
        {
            using (SqlConnection connection = new SqlConnection(builder.ConnectionString)){
                connection.Open();
                Read2(connection);
            }
        })
    );

```
