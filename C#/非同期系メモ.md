# 非同期系メモ

[【C#】Task初心者のTask初心者によるTask初心者の為のTask入門](https://qiita.com/OXamarin/items/eddc9f7f01b691631887)  

---

## Task

TaskクラスはStaticなので宣言する必要はなく、Runさせたい時はTask.Run()でよろしい。  
New Task().Run()はできない。  

Newの意味合いは実行したいTaskを作ることになる。  
Task型は仕事を意味する型なので、オブジェクト作ってもその仕事をRunできない。  
できてWaitさせることくらい。  

とっさのことだったがこれに対応できなかった。  
Task使用例を作って簡単にまとめたい。  
→  
2020/12/19 Satようやくまとめた。  
パターンとしては3つだろうか。  

1. Taskを並列実行する
2. Taskの中で非同期処理を実行して、その非同期が終わってから次の処理を実行する
3. メソッド単位でTaskを定義する

```C# : 並列実行
private void Test() {
    var task1 = New Task();
    var task2 = New Task();
    Task.Run(task1,task2).WaitAll()
}
```

```C# : Taskの中で非同期処理を実行して、その非同期が終わってから次の処理を実行する
private void Test() {
    // この地点で非同期になる
    Task.Run(
        async () =>
        {
            var key = new TMa_ProductKey
            {
                OfficeCD = Data.Product.OfficeCD,
                DepartmentCD = Data.Product.DepartmentCD.Value,
                ProductCD = setProduct.ProductCD
            };
            TMa_Product data = null;
            // 非同期検索処理
            await ServiceErrorHandlingAsync(
                async () => data = await ServiceAdapter.GetProductAsync(key),
                nameof(IsBusy)
            );
            // 非同期検索処理が終わってから次へ行く
            HogeHoge(data);
        }
    );
}
```

```C# : メソッド単位でTaskを定義する
class Program
{
    /// <summary>
    /// https://tech-lab.sios.jp/archives/15711
    /// </summary>
    /// <param name="args"></param>
    static void Main(string[] args)
    {
        var task = HeavyMethod1(); // ①処理の実行
        // ④処理が戻るのでHeavyMethod2が実行される
        HeavyMethod2();
        Console.WriteLine(task.Result);
        Console.ReadLine();
    }
    static async Task<string> HeavyMethod1()
    {
        Console.WriteLine("すごく重い処理その1(´・ω・`)始まり");
        // ②重い処理の実行
        // ③一度実行もとに戻る。その間HeavyMethod1の処理は続行される(バックグラウンド)。
        await Task.Delay(3000); 
        Console.WriteLine("すごく重い処理その1(´・ω・`)終わり");
        // ⑤バックグラウンド(別スレッド)で動いているHeavyMethod1の重い処理が終了すると、
        // HeavyMethod2が実行中でもHeavyMethod1に戻り、hogeを返す。
        return "hoge";
    }
    static void HeavyMethod2()
    {
        Console.WriteLine("すごく重い処理その2(´・ω・`)始まり");
        Thread.Sleep(3000);
        Console.WriteLine("すごく重い処理その2(´・ω・`)終わり");
    }
}
```

Taskを単体で実行させる場合は、単純にTask.Runさせるだけで、その部分だけ非同期で実行される。  
.Resultなどで結果を取得しない限り、いつ終わったのかを観測できないが、処理自体は勝手に実行される。  

``` C#
    // Taskの実行
    Task.Run(() => {
        Console.WriteLine("task1開始");
        Task.Delay(5000);
        Console.WriteLine("task1終了");
    });

    // Taskの実行
    Task.Run(() => {
        Console.WriteLine("task2開始");
        Task.Delay(3000);
        Console.WriteLine("task2終了");
    });

    Console.WriteLine("tas111111終了");

    // 結果が毎回違うので、Task.Runだけで非同期実行されていることが分かる。

    //task2開始
    //tas111111終了
    //task1開始
    //task2終了
    //task1終了

    //task1開始
    //task2開始
    //tas111111終了
    //task1終了
    //task2終了
```

---

## Taskのラムダ式の定義の仕方 / asyncのデリゲート定義

async/await を使った非同期ラムダ式を変数に代入する方法とも言うか。  
いつもの癖でAction型に入れようとして少し苦戦したので備忘録として残すことにした。  

<https://qiita.com/go_astrayer/items/352c34b8db72cf2f6ca5>  
[async/await を使った非同期ラムダ式を変数に代入する方法](https://qiita.com/go_astrayer/items/352c34b8db72cf2f6ca5)  

TaskはTask型を絶対に返すので、Actionは使うことができない。  
最低でも`Func<Task>`が必要。  
戻り値もあるなら`Func<戻り値、Task>`が必要。  

``` C# : 単純なTaskのデリゲート定義
    Func<Task> AsyncFunc = async () =>
    {
        await Task.Delay(1);
    };
```

```C# : 単純なTaskのローカル関数定義
    async Task AsyncFunc = async () => 
    {
        await Task.Delay(1);
    }
```

``` C# : 戻り値があるTask型のデリゲート定義
    Func<ListReplyContext, Task> callback = async res =>
    {
        return new ListReplyContext();
    }
```

---

## async voidのラムダ式

<https://stackoverflow.com/questions/61827597/async-void-lambda-expressions>  

async void ○○ await △△ みたいな非同期処理を1行で書けないか探したが、全然そんなこと書いてるところがない。  
「async void lambda c#」で調べてようやくそれっぽいところにたどり着いたが、本当にあってるのかはわからない。  

2022/05/19 追記  
async voidはTask.Run()を投げっぱなしにすることで実現できる。  

async voidは仕事の完了を観測できない。  
つまり処理の投げっぱなしを意味する。  
でもって、Taskは絶対にTask型を返すので、ラムダ式として定義するなら最低でも`Func<Task>`と定義する必要がある。  
なので、厳密にasync voidはラムダ式で定義できず、Task.Run()で特にawaitも.Resultもしなければasync voidと同じ状況を再現できる。  

だからいくら探しても思うような記事にめぐり合わなかった。  
そもそもTaskに対する理解が足りていなかった証拠だろう。  

``` C#
    private async void Hoge()
    {
        await Task.Delay(1000);
    }
    private void Main()
    {
        // async void HogeはTask.Runのように書いても動くけど、厳密には少し違うみたい。
        Hoge();
        // これは正確にはWait1000みたいな意味合いらしい。
        Task.Run(async () => await Task.Delay(1000));
    }
    private async Task Wait1000() {
        await Task.Delay(1000);
    }
    Task.Run(Wait1000);
```

---

## Dispatcher

<https://hilapon.hatenadiary.org/entry/20130225/1361779314>  
<https://araramistudio.jimdo.com/2017/05/02/c-%E3%81%A7%E5%88%A5%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8B%E3%82%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%82%92%E6%93%8D%E4%BD%9C%E3%81%99%E3%82%8B/>  
<https://www.it-swarm-ja.com/ja/c%23/dispatcherinvoke%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E9%9D%9E%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8B%E3%82%89wpf%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B/968851135/>  

`Application.Current.Dispatcher.Invoke(() =>`謎の呪文。後で調べたい。  
→  
どうやら、並列処理における概念らしい。  
async,awaitなどでスレッドを分けた場合、他のスレッドで動作しているコントロールをいじれなくなってしまう。  
でも、場合によってはそのコントロールを操作したい時があるわけで、  
そういう場合に、そのコントロールを操作する仕組みがDispatcherっぽい。  
Dispatcherはキューを管理するクラス。  
操作したいコントロールを所有しているスレッドのキュー管理に対して、指定したデリゲートの実行をお願いするイメージ。  
とりあえず、並列処理とかasync,awaitとかの時に使えばいいみたいね。  

[Dispatcher.InvokeとDispatcher.BeginInvoke、Dispatcher.InvokeAsyncの違い](https://redwarrior.hateblo.jp/entry/2021/03/29/090000)  
この記事も面白い。  

[await/async等の別スレッドからコントロールのプロパティを変更する](https://todosoft.net/blog/?p=363)  
改めて見てみたけど、非同期中に他のコントロールのプロパティ変更したりするときに使う命令みたいね。  

``` C#
/*
await/async等の別スレッドからコントロールのプロパティを変更しようとすると、
コントロールの描画を行っているスレッドと異なる為、エラーとなる。
InvokeRequired で異なるスレッドからの呼び出しかを判定し、異なる場合は Invoke で再呼び出しをすることで解決する。
*/
private async void button1_Click(object sender, EventArgs e)
{
    await Task.Run(() =>
    {
        Invoke((MethodInvoker)(() =>
        {
            // 非同期中に他のコントロールのプロパティを変更する
            button1.Text = "OK";
        }));
    });
}
// WPFのVMでは上記Invokeが使用できない為、下記のようになる
System.Windows.Application.Current.Dispatcher.Invoke((Action)(() => {
    // 同期処理
}));
```

---

## 

``` C#

private void FUGA()
{
    async InnerMethod() {
        await Task.Run(() => !_IsInitializing)
            .ContinueWith(res => Messenger.Raise(new InteractionMessage("AccountNoFocusAction")));
    }

    Initialize();
}

private async void Initialize()
{
    _IsInitializing = true;
    await HOGE();
    _IsInitializing = false;
}
```

---

## 非同期メソッドの並列実行

<https://docs.microsoft.com/ja-jp/dotnet/csharp/programming-guide/concepts/async/>  

RN3で非同期メソッドを並列処理できそうな箇所があったので、ECOでやったような,Task.WaitAllみたいな並列処理をAsyncAwaitでも実現できないか調べてみた。  
天下のマイクロソフトに完璧なサンプルがあったのでそれを拝借する。  
因みに実現できたのだが、そうしたら非同期中のクルクルがなくなってしまったのでやめた。  

``` C#
static async Task Sample1()
{
    var eggsTask = Task.Run(async () =>
    {
        Console.WriteLine("すごく重い処理その1(´・ω・`)始まり");
        await Task.Delay(3000);
        Console.WriteLine("すごく重い処理その1(´・ω・`)終わり");
    });
    var baconTask = Task.Run(async () =>
    {
        Console.WriteLine("すごく重い処理その2(´・ω・`)始まり");
        await Task.Delay(5000);
        Console.WriteLine("すごく重い処理その2(´・ω・`)終わり");
    });
    // 普通にTask.WhenAllに各非同期メソッドを登録すればいいみたい。
    await Task.WhenAll(eggsTask, baconTask);
    Console.WriteLine("終わり");

    // Listに入れて引き回す事もできる。
    // 処理を並列に実行しつつ、各処理固有の終了処理を記述したい時はこっちかもね。
    var breakfastTasks = new List<Task> { eggsTask, baconTask };
    while (breakfastTasks.Count > 0)
    {
        Task finishedTask = await Task.WhenAny(breakfastTasks);
        if (finishedTask == eggsTask)
        {
            Console.WriteLine("eggs are ready");
        }
        else if (finishedTask == baconTask)
        {
            Console.WriteLine("bacon is ready");
        }
        breakfastTasks.Remove(finishedTask);
    }
    Console.WriteLine("終わり");
}
```

---

## Task.Run と Task.Factory.StartNew

[Task.Run と Task.Factory.StartNew](http://outside6.wp.xdomain.jp/2016/08/04/post-205/)  

いつもと同じ感覚でTask.Run()で処理を定義しようとしたらできなくて、何かないかと探したらTask.Factroy.StartNewなる構文だといけることが分かった。  
それはいいのだが、そもそもこれは何なのか分からなかったのでまとめることにした。  

``` C#
Task thread1 = Task.Factory.StartNew(() => fun1());
Task thread2 = Task.Factory.StartNew(() => fun2());
```

``` txt
項目                 Task.Run      Task.Factory.StartNew  戻り値           備考

CancellationToken    ○             ○                      -                キャンセルに使うTokenを指定
TaskCreationOptions  ×             ○                      -                どのように作成するかを指定するオプション
TaskScheduler        ×             ○                      -                同期コンテキストを指定

Action               ○             ○                      Task
Func<TResult>        ○             ○                      Task<TReuslt>
Action<object>       ×             ○                      Task             第2引数にOjbectが必須
Func<Object,TResult> ×             ○                      Task<TReuslt>
Func<Task>           ○             ×                      Task             入れ子のTaskの内側が戻る
Func<Task<TResult>>  ○             ×                      Task<TReuslt>
```

Task.Facotry.StartNewを一般的な用途でもっと手早く使うためにTask.Runが作られたようだ。  
確かに、タイプ数が少ないし使い勝手が良い。自分も多用している。  
ただ、Task.RunのTaskCreationOptionが「DenyChildAttach」なので、Task.Runの中でTask.Factory.StartNewを「AttachedToParent」で使っても無効になってしまうことには注意が必要。  
また、Task.Runは手軽だけど細かい設定はできない。  
Task.Factory.StartNewが不要になったわけではない。  

---

## 戻り値があるTaskの並列実行と結果の扱い方

``` C#
    Task<int> t1 = Task.Run(() => 1);
    Task<int> t2 = Task.Run(() => 2);
    Task<(int, int)> t3 = Task.Run(() => (3, 3));

    Task.WaitAll(t1, t2, t3);

    int result1 = t1.Result;
    int result2 = t2.Result;
    (int, int) result3 = t3.Result;

    // Actionを返すTaskの定義方法
    Task<Action> t1 = new Task<Action>(() =>
    {
        return () => { _ = 1; };
    });
```

---

## AsyncをAwaitするのと同期は同じか？

居林さんは毎回いい質問を持ってきてくれる。  
厳密には違うだろう。  

async await 同期 同じ　c#  
[[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく](https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1)  
[【C#】ASYNC/AWAITで同期メソッドから非同期メソッドを呼ぶ方法](https://nryblog.work/call-sync-to-async-method/)  
