# 非同期系メモ

[【C#】Task初心者のTask初心者によるTask初心者の為のTask入門](https://qiita.com/OXamarin/items/eddc9f7f01b691631887)  
[Taskを極めろ！async/await完全攻略](https://qiita.com/acple@github/items/8f63aacb13de9954c5da)  

TaskはUIスレッドを止めないための仕組み。  
メインスレッド一本で処理するのが同期処理。  
メインスレッド以外で処理するのが非同期処理。  
メインスレッドには、必然的にUIスレッドが来るので、同期処理で重い処理を走らせたら画面が固まるのはこのため。  

---

## Task

[C#_Task とは](https://koshinran.hateblo.jp/entry/2018/05/12/132407)  
[async/await を完全に理解する](https://zenn.dev/vatscy/articles/ba2263bdfadfeb805379)  
[async/await を完全に理解してからもう少し理解する](https://zenn.dev/vatscy/articles/d4782637dd4257ef9822)  

Task は非同期処理のことではない。  
名の通り「仕事、課題、作業の最小単位」。  

タスクAがタスクBの完了を待ちたい場合、これらの状態を知りたいはずです。  

- 正常終了したかどうか  
- 例外が発生して異常終了したかどうか  
- 処理が途中でキャンセルされたかどうか  

また、タスクBに戻り値がある場合、タスクBが完了したらその値ももらいたいはずです。  

このときに登場するのがTask型です。  
Taskオブジェクトはこれらの状態と戻り値を教えてくれます。  

``` C#
public int RunTaskA()
{
    Task taskB = RunTaskBAsync(); // Task型のオブジェクトを返す
    
    bool status1 = taskB.IsCompletedSuccessfully; // 正常終了したかどうか
    bool status2 = taskB.IsFaulted; // 例外が発生して異常終了したかどうか
    bool status3 = taskB.IsCanceled; // 処理が途中でキャンセルされたかどうか
    var returnValue = taskB.Result; // 戻り値(ある場合)
}
```

---

## Task.Run

「タスクを生成し開始する」という意味。  
実際の処理は別のだれかが裏で行う。  

``` C#
// 変数 task は「HogeA を実行後 HogeB を実行する、という『タスク』を作成してそれを開始したもの」を表わす。  
var task = Task.Run(() =>
{
    HogeA();
    HogeB();
});
```

### Task.Run の使い方

同期的な一連の処理を、一つのタスクとみなす。

非同期タスクを組み合わせ、合成して、一つのタスクを組み上げるのが非同期メソッドだとしたら、その中に同期処理もタスクの一つとして組み込みたい時に使う。  

もう一つ別の使い方はTask.Runの中に非同期ラムダ式を書くパターン。  
これは、単純にその非同期メソッドを呼び出しているというもの。  

これ以外の使い方をしているなら、それはTask.Runの濫用。  
・同期処理を Task.Run でラップした場合「スレッドプール上で動作する一連の処理」となる。  

---

スレッド：
プログラムの処理の実行単位（ のひとつ ）。
タスクやプロセスより細かい処理の実行単位が「スレッド」。
プロセスのサブスレッドとして動作し、
実行に必要なメモリ空間を複数のスレッドで共有。

マルチスレッド：
A という処理と B という処理を同時に行える。( 並行処理 )

スレッドプール：
スレッドの増加は ( スレッドを生成したり消したりして ) パフォーマンスへの影響が非常に大きい。
故に、1 度作ったスレッドを可能な限り使いまわす仕組み。
つまり、あらかじめスレッドを生成しておき、消さずに再利用する。
1 ) 一定数のスレッドを常に立てておく。
2 ) タスクを持たせておくためのキューを持つ。
3 ) 処理中のタスクが終わり次第、次のタスクをキューから取り出して実行する。

プロセス：
プログラム実行の為の固有のメモリ空間を持っていおり、独立性の高い実行単位。
単体で実行可能なプログラムの単位。
複数のプロセスが存在する時は、それぞれ独立したアドレス空間を持つ。

ファイバ
スレッドをさらに軽量化したもの。

タスク：
曖昧。
1 ) プロセスと同じ意味。
2 ) スレッドのことを指す。
3 ) プロセスよりも大きな集合を指す。

---

## await

非同期処理しているタスクの完了を待つ場合はawaitを使います。  
指定した Task の完了を待ち、その結果を取りだす。  

※awaitはTask型に対して使用する。  

``` C# : 基本
await RunTaskBAsync(); // タスクBに戻り値がない(void)場合

var returnValue = await RunTaskBAsync(); // タスクBに戻り値がある場合
```

``` C# : タスクBが正常終了した後、その戻り値を使って続きの処理をする場合
var result = await RunTaskBAsync();
Console.WriteLine(result); // 続きの処理
```

``` C# : タスクBが異常終了、またはキャンセルされた場合のエラーハンドリング(try/catch)
try
{
  await RunTaskBAsync();
}
catch (TaskCanceledException ex)
{
  // キャンセルされた場合の例外処理
}
catch (Exception ex)
{
  // 異常終了した場合の例外処理
}
```

``` C# : 必ずしもメソッドの実行時にawaitを使う必要はなく、待機のタイミングを遅らせることもできます。
Task<int> taskB = RunTaskBAsync(); // awaitをつけていないのでTask<int>型を受け取る

// 何か別の処理 (この間もタスクBは非同期で実行されている)

int result = await taskB; // ここでタスクBの完了を待つ
```

---

## async

awaitを使う場合、下記ルールに則って実装します。  

1. メソッドにasyncキーワードを付与 (文法)  
   - `非同期メソッド` となる  
2. 戻り型としてTask型を利用 (文法)  
   - returnする場合: Task<戻り値の型>  
   - returnしない場合: Task  
3. メソッド名の語尾にAsyncをつける (推奨)  
   - 呼び出す側が非同期処理であることを把握しやすくするため  

``` C#
public async Task<int> RunTaskAAsync()
{
  int result = await RunTaskBAsync();
  return result + 1; // taskBの戻り値を使った計算例
}
```

上記サンプルコードでのポイントは「戻り型はTask\<int>型なのに、実際にreturnしているのはint型である」という点です。  
実は asyncキーワードをつけると、戻り値をTask型で自動的にラップして返してくれるようになります。  
これで呼び出し元はTask型のオブジェクトを使って非同期処理のハンドリングができますし、自分でTask型を生成しなくてよい。  

以上のポイントを踏まえ、 タスクA -> タスクB -> タスクC の非同期呼び出しを実装すると下記になります。  

``` C#
public async Task<int> RunTaskAAsync()
{
    var result = await RunTaskBAsync(); // taskBの完了を待つ
    return result + 1;
}
private async Task<int> RunTaskBAsync()
{
    await RunTaskCAsync(); // taskCの完了を待つ
    return 1 + 2 + 3;
}
private async Task RunTaskCAsync()
{
    await Task.Delay(500); // 0.5秒待機
}
```

---

## 同時に複数の非同期処理を扱う

例えば、タスクBとタスクCを同時に処理して、両方が完了した後にタスクAの続きを処理したい場合があります。  
そういった場合はTask.WhenAllを使用します。  
Task.WhenAllは、「複数のタスクが全て完了したかどうかを確認できるTask」を返します。  
Task型なのでawaitできます。  

``` C#
public async Task<int> RunTaskAAsync()
{
  Task<int> taskB = RunTaskBAsync();
  Task<int> taskC = RunTaskCAsync();
  
  int[] results = await Task.WhenAll(taskB, taskC); // 両方完了後、戻り値が配列として返る
  
  return results[0] + results[1]; // タスクBとタスクCの結果を加算
}

private async Task<int> RunTaskBAsync()
{
  await Task.Delay(100); // 0.1秒待機
  return 1 + 2 + 3;
}

private async Task<int> RunTaskCAsync()
{
  await Task.Delay(200); // 0.2秒待機
  return 4 + 5 + 6;
}
```

---

## 既存の同期処理を非同期化する

既存の同期メソッドを、呼び出し側から非同期扱いすることができます。  
Task.Runを使うと処理をTaskでラップすることができます。  

``` C#
public async Task<int> RunTaskAAsync()
{
  var result = await Task.Run(RunTaskB); // Task<int>化されるのでawaitできる
  return result + 1;
}

private int RunTaskB() // 同期メソッド
{
  return 1 + 2 + 3;
}
```

---

## 非同期処理の完了を待たない

非同期処理は必ずしも待つ必要はありません。投げっぱなしにしたいケースがあります。  

そういった場合は単純に待たなければ良い、つまりawaitを使わなければ良いです。  

``` C#
public int RunTaskA()
{
    RunTaskBAsync(); // awaitを使わない

    var result = 1 + 2 + 3; // タスクBの完了を待たずに処理を続ける
    return result; // タスクBの完了を待たずにreturnする
}
```

この場合のポイントは下記になります。  

- タスクBの完了を待たずに処理を続けることができる  
- タスクBが失敗したとしてもタスクAには影響はない  

ちなみにこのように実装するとVisual Studio審判長から以下のようなイエローカードが提示されます。  

>この呼び出しを待たないため、現在のメソッドの実行は、呼び出しが完了するまで続行します。呼び出しの結果に 'await' 演算子を適用することを検討してください。  

わかっていて敢えてawaitをつけていないことを審判に示すためには下記のように実装します。  

``` C#
var _ = RunTaskBAsync(); // taskを利用しないことを明示
```

---

## 非同期メソッドを同期メソッドから呼び出す

非同期処理をする場合、基本的にはasync/awaitパターンが推奨されるのですが、既存実装の改修などでは戻り値をTask型に変更できないケースも多いです。  

そういった場合はこれらを利用します。  

- Task型: task.Waitメソッド  
- Task\<T>型: task.Resultプロパティ  

``` C#
public int RunTaskA()
{
    int result = RunTaskBAsync().Result; // 完了の待機と戻り値の取得
    return result + 1;
}
```

!. task.Wait task.Resultを使うとデッドロックが発生する可能性があります。どうしてもという場合のみ気をつけて使いましょう。  
参考: [async/awaitについての備忘録 - async/await, Taskのタブー②](https://qiita.com/mounntainn/items/3f39e0c57412c48508bf#asyncawait-task%E3%81%AE%E3%82%BF%E3%83%96%E3%83%BC-1)  

---

## asyncを使う必要がないケース

非同期メソッドを実装するときには必ずしもasyncを使う必要はありません。  
asyncキーワードは自動的にTaskを生成してくれますが、逆に言えば自力でTaskオブジェクトをreturnすることができればasyncに頼る必要はありません。  

そのようなケースは主に2つあります。  

- 他の非同期メソッドの戻り値をそのままreturnできる場合  
- タスクAがタスクBを呼び出し、その結果をそのままreturnする場合  

``` C#
public async Task<int> RunTaskAAsync()
{
    return await RunTaskBAsync(); // int型をreturnしてasyncにラップしてもらう
}

private async Task<int> RunTaskBAsync()
{
    await Task.Delay(1000); // 1秒待機
    return 1 + 2 + 3;
}
```

この場合、async/awaitを使わずにこのように記載することもできます。  

``` C#
public Task<int> RunTaskAAsync()
{
    return RunTaskBAsync(); // Task<int>型をreturnする
}

private async Task<int> RunTaskBAsync()
{
    await Task.Delay(1000); // 1秒待機
    return 1 + 2 + 3;
}
```

後者のように書くメリットは、前者だとawaitでTaskを剥がした後にasyncでまたTaskにラップされるので、その余計なステップを排除できることでしょうか(そこまで気にしなくていい気もするけど)。  

---

## 自力でTaskを生成する場合

Taskを自力で生成する場合の代表例は、既存同期メソッドの非同期化です。  

``` C#
public Task<int> RunTaskAAsync()
{
  Task<int> taskB = Task.Run(RunTaskB);
  return taskB;
}

private int RunTaskB() // 同期メソッド
{
  return 1 + 2 + 3;
}
```

他には、「戻り型はTask型だが処理は非同期である必要がない」という場合があります。  
具体的には下記のような場合です。  

- 元々は非同期メソッドだったものが改修により非同期である必要がなくなった  
- interfaceの戻り型の定義がTaskになっているが、それを実装した際に非同期処理がなかった  

こういった場合にはTask.CompletedTaskでTask型のオブジェクト、Task.FromResultでTask\<T>型のオブジェクトを生成できます。  

``` C#
public Task RunTask1Async()
{
    // 同期処理
        
    return Task.CompletedTask; // "正常終了"を表すTaskオブジェクト
}

public Task<int> RunTask2Async()
{
    // 同期的な計算処理
    var result = 1 + 2 + 3;
    return Task.FromResult(result); // 値をTaskでラップして返す
}
```

---

## 非同期処理のキャンセル

あるタスクを非同期実行した後、そのタスクをキャンセルしたい場合があります。  
例えば「サーバーに通信したはいいものの応答が遅すぎるので通信を切りたい」など。  

そういった場合は**CancellationToken**を使います。  
CancellationTokenは呼び出し元から非同期メソッドにキャンセル依頼をするためのものです。  
これは事前に呼び出し元で生成して非同期メソッドに渡しておく必要があります。  

``` C#
var cts = new CancellationTokenSource();
var taskB = RunTaskBAsync(cts.Token); // CancellationTokenを渡す

// なんらかの処理

cts.Cancel(); // タスクBにキャンセルを依頼
```

ただし、このキャンセルの仕組みを利用するためには当然ですが非同期メソッド側が下記のようにキャンセルに対応していないといけません。  
自作する場合には気をつけましょう。  

- 引数でCancellationTokenを受け取れるようになっている  
- CancellationTokenを監視して、キャンセル依頼が来たときに反応できるようになっている  
- キャンセル処理をしてTaskCanceledExceptionをthrowできるようになっている  

---

## async void

async void ってなんだ？  
→  
イベントのためにしょうがなくある構文。  
基本的に非同期処理は投げっぱなしになる模様。  

[asyncの落とし穴Part3, async voidを避けるべき100億の理由](https://neue.cc/2013/10/10_429.html)  

>自分で書く場合は、必ずasync Taskで書くべき、というのは非同期のベストプラクティスで散々言われていることなのですけれど、理由としては、まず、**voidだと、終了を待てないから**。  
>voidだと、その中の処理が軽かろうと重かろうと、終了を感知できない。  
>例外が発生しても分からない。投げっぱなし。  
>これがTaskになっていれば、awaitで終了待ちできる。例外を受け取ることができる。  
>await Task.WhenAllで複数同時に走らせたのを待つことができる。  
>はい、async Taskで書かない理由のほうがない。  
>んじゃあ何でasync voidが存在するかというと、イベントがvoidだから。  
>はい。button_clickとか非同期対応させるにはvoidしかない。それだけです。  
>なので、自分で書く時は必ずasync Task。async voidにするのはイベントだけ。これ絶対。  

[C#_戻り値が void と Task の違い](https://koshinran.hateblo.jp/entry/2018/05/14/101108)  

>戻り値が void だと await がついた処理がいつ完了するかわからない。  

■await  
Task 完了まで待つ、という意味なので同期的。  

await しない場合、「誰かこの仕事実行して」と命令を投げるだけなのでタスク実行中に自分は本来の仕事の続きをこなせる。  
戻り値 Task とすることで、その仕事の進捗状況を把握できる。  

■戻り値 Task  
「手順書に書かれた仕事が全て完了したことを報告する」ことになる。  
非同期メソッドで戻り値を Task にした場合、自動的にメソッドが return した時に完了する Task となる。  

■戻り値 void  
「この Task を開始して」という命令をした後は、その命令したことを忘れる。  
実害は、 void で実行した非同期メソッドの中で例外が発生した場合など、その例外はコード上で見つけることが出来なくなり、アプリケーションを殺す。  

■非同期メソッドで戻り値 Task  

``` C#
    private async Task Hoge()    // 順次動作
    {
        await Task.Run(() => 処理A);
        //処理 A を実行する、というタスクを開始して完了するまで待機。
    }
```

↑ return は？  
非同期メソッドで戻り値が Task の時、そのメソッドが return した時に完了する Task となる。  
戻り値 Task と指定しても、返す必要がない ( 返せないもよう )。  
Task\<T> とすると、 return で T 型が返る。  

■非同期メソッドで戻り値 void (基本 NG )  

``` C#
    private async void Hoge()    // 順次動作
    {
        await Task.Run(() => 処理A);
        //処理 A がいつ完了するか不明。完了するまで待機。
    }
```

■同期メソッドで戻り値 void  

``` C#
    private void Hoge()    // 並列動作
    {
        Task.Run(() => 処理A);
        // Task.Run が投げっぱ。処理 A の状態が分からない。
        // 命令を投げるだけなので、 処理 A 実行中に自分自身は本来の仕事の続きができる。
        // 戻り値が Task だと進捗状況を把握できる。
    }
```

■同期メソッドで戻り値 Task  

``` C#
    private Task Hoge()    // 並列動作
    {
        var cs = new List<Fuga>;
        for()
        {
            var c = Task.Run(() => 処理A);
            cs.Add(c);    //処理 A を開始するというタスクを List にまとめる。
        }
        return Task.WhenAll(c);
        //全ての Task が完了した時、完了扱いになる Task を生成。
    }
```

**async void は禁止**  
UI イベントハンドラ―に非同期メソッドを登録するのは void の必要があった。  
UI から直接実行されるイベントの受け皿メソッドのみ、async void を使える。  
それ以外は NG。  

※  
特定のスレッドに依存する処理 ( UI 操作など ) は、  
本来非同期メソッド上で取り扱ってはいけない。( Task の思想ではそうなるはずだった )  

同期メソッドの戻り値 void は、非同期メソッドでは戻り値 Task のこと。  
同期メソッドの戻り値 T は、非同期メソッドでは戻り値 Task\<T> の T のこと。  

## 投げっぱなしの非同期メソッドを使いたい場合、どうすればいいんでしょう？

async Task メソッドをそのまま実行する。  

``` C#
public async Task<ActionResult> Index()
{
    // 警告抑制のため破棄で受ける
    _ = ToaruAsyncMethod();
    return View();
}

public async Task ToaruAsyncMethod()
{
    await Task.Delay(TimeSpan.FromSeconds(1));
    Debug.WriteLine("hoge");
}
```

---

## async void と _ = Task.Run は同じか？

[c# async voidでawait Task.Run()失敗の巻](https://qiita.com/twentyfourhours/items/3451f39567239f951a1a)  
多分同じ。  

``` C#
        // Start 0
        // Start 1
        // Start 2
        // End 1
        // End 0
        // End 2
        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            for (int i = 0; i < 3; i++)
            {
                await Task.Run(() => DelayMethodByAsyncVoid(i));
            }
        }
        async void DelayMethodByAsyncVoid(int id)
        {
            Console.WriteLine("Start " + id);
            await Task.Delay(2000);
            Console.WriteLine("End " + id);
        }

        // Start 0
        // Start 1
        // Start 2
        // End 2
        // End 1
        // End 0
        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            for (int i = 0; i < 3; i++)
            {
                _ = DelayMethodByAsyncTask(i);
            }
        }

        // こいつだけは明らかに動作が違うのでやるな
        // Start 3
        // Start 3
        // Start 3
        // End 3
        // End 3
        // End 3
        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            for (int i = 0; i < 3; i++)
            {
                _ = Task.Run(() => DelayMethodByAsyncTask(i));
            }
        }

        async Task DelayMethodByAsyncTask(int id)
        {
            Console.WriteLine("Start " + id);
            await Task.Delay(2000);
            Console.WriteLine("End " + id);
        }
```

---

## 非同期プログラミングのベストプラクティス

[非同期プログラミングのベストプラクティス](https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming)  

- async void を避ける  
- すべて非同期にする  
- コンテキストを構成する  

---

## Task実行集

TaskクラスはStaticなので宣言する必要はなく、Runさせたい時はTask.Run()でよろしい。  
New Task().Run()はできない。  

Newの意味合いは実行したいTaskを作ることになる。  
Task型は仕事を意味する型なので、オブジェクト作ってもその仕事をRunできない。  
できてWaitさせることくらい。  

1. Taskを並列実行する
2. Taskの中で非同期処理を実行して、その非同期が終わってから次の処理を実行する
3. メソッド単位でTaskを定義する

```C# : 並列実行
private void Test() {
    var task1 = New Task();
    var task2 = New Task();
    Task.Run(task1,task2).WaitAll()
}
```

```C# : Taskの中で非同期処理を実行して、その非同期が終わってから次の処理を実行する
private void Test() {
    // この地点で非同期になる
    Task.Run(
        async () =>
        {
            var key = new TMa_ProductKey
            {
                OfficeCD = Data.Product.OfficeCD,
                DepartmentCD = Data.Product.DepartmentCD.Value,
                ProductCD = setProduct.ProductCD
            };
            TMa_Product data = null;
            // 非同期検索処理
            await ServiceErrorHandlingAsync(
                async () => data = await ServiceAdapter.GetProductAsync(key),
                nameof(IsBusy)
            );
            // 非同期検索処理が終わってから次へ行く
            HogeHoge(data);
        }
    );
}
```

```C# : メソッド単位でTaskを定義する
class Program
{
    /// <summary>
    /// https://tech-lab.sios.jp/archives/15711
    /// </summary>
    /// <param name="args"></param>
    static void Main(string[] args)
    {
        var task = HeavyMethod1(); // ①処理の実行
        // ④処理が戻るのでHeavyMethod2が実行される
        HeavyMethod2();
        Console.WriteLine(task.Result);
        Console.ReadLine();
    }
    static async Task<string> HeavyMethod1()
    {
        Console.WriteLine("すごく重い処理その1(´・ω・`)始まり");
        // ②重い処理の実行
        // ③一度実行もとに戻る。その間HeavyMethod1の処理は続行される(バックグラウンド)。
        await Task.Delay(3000); 
        Console.WriteLine("すごく重い処理その1(´・ω・`)終わり");
        // ⑤バックグラウンド(別スレッド)で動いているHeavyMethod1の重い処理が終了すると、
        // HeavyMethod2が実行中でもHeavyMethod1に戻り、hogeを返す。
        return "hoge";
    }
    static void HeavyMethod2()
    {
        Console.WriteLine("すごく重い処理その2(´・ω・`)始まり");
        Thread.Sleep(3000);
        Console.WriteLine("すごく重い処理その2(´・ω・`)終わり");
    }
}
```

Taskを単体で実行させる場合は、単純にTask.Runさせるだけで、その部分だけ非同期で実行される。  
.Resultなどで結果を取得しない限り、いつ終わったのかを観測できないが、処理自体は勝手に実行される。  

``` C#
    // Taskの実行
    Task.Run(() => {
        Console.WriteLine("task1開始");
        Task.Delay(5000);
        Console.WriteLine("task1終了");
    });

    // Taskの実行
    Task.Run(() => {
        Console.WriteLine("task2開始");
        Task.Delay(3000);
        Console.WriteLine("task2終了");
    });

    Console.WriteLine("tas111111終了");

    // 結果が毎回違うので、Task.Runだけで非同期実行されていることが分かる。

    //task2開始
    //tas111111終了
    //task1開始
    //task2終了
    //task1終了

    //task1開始
    //task2開始
    //tas111111終了
    //task1終了
    //task2終了
```

---

## Taskのラムダ式の定義の仕方 / asyncのデリゲート定義

async/await を使った非同期ラムダ式を変数に代入する方法とも言うか。  
いつもの癖でAction型に入れようとして少し苦戦したので備忘録として残すことにした。  

<https://qiita.com/go_astrayer/items/352c34b8db72cf2f6ca5>  
[async/await を使った非同期ラムダ式を変数に代入する方法](https://qiita.com/go_astrayer/items/352c34b8db72cf2f6ca5)  

TaskはTask型を絶対に返すので、Actionは使うことができない。  
最低でも`Func<Task>`が必要。  
戻り値もあるなら`Func<戻り値、Task>`が必要。  

``` C# : 単純なTaskのデリゲート定義
    Func<Task> AsyncFunc = async () =>
    {
        await Task.Delay(1);
    };
```

```C# : 単純なTaskのローカル関数定義
    async Task AsyncFunc = async () => 
    {
        await Task.Delay(1);
    }
```

``` C# : 戻り値があるTask型のデリゲート定義
    Func<ListReplyContext, Task> callback = async res =>
    {
        return new ListReplyContext();
    }
```

``` C# : 戻り値があるTask型のローカル関数定義
    async Task<ListReplyContext> callback ()
    {
        return new ListReplyContext();
    }
```

---

## async voidのラムダ式

<https://stackoverflow.com/questions/61827597/async-void-lambda-expressions>  

async void ○○ await △△ みたいな非同期処理を1行で書けないか探したが、全然そんなこと書いてるところがない。  
「async void lambda c#」で調べてようやくそれっぽいところにたどり着いたが、本当にあってるのかはわからない。  

2022/05/19 追記  
async voidはTask.Run()を投げっぱなしにすることで実現できる。  

async voidは仕事の完了を観測できない。  
つまり処理の投げっぱなしを意味する。  
でもって、Taskは絶対にTask型を返すので、ラムダ式として定義するなら最低でも`Func<Task>`と定義する必要がある。  
なので、厳密にasync voidはラムダ式で定義できず、Task.Run()で特にawaitも.Resultもしなければasync voidと同じ状況を再現できる。  

だからいくら探しても思うような記事にめぐり合わなかった。  
そもそもTaskに対する理解が足りていなかった証拠だろう。  

``` C#
    private async void Hoge()
    {
        await Task.Delay(1000);
    }
    private void Main()
    {
        // async void HogeはTask.Runのように書いても動くけど、厳密には少し違うみたい。
        Hoge();
        // これは正確にはWait1000みたいな意味合いらしい。
        Task.Run(async () => await Task.Delay(1000));
    }
    private async Task Wait1000() {
        await Task.Delay(1000);
    }
    Task.Run(Wait1000);
```

---

## Dispatcher

<https://hilapon.hatenadiary.org/entry/20130225/1361779314>  
<https://araramistudio.jimdo.com/2017/05/02/c-%E3%81%A7%E5%88%A5%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8B%E3%82%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%82%92%E6%93%8D%E4%BD%9C%E3%81%99%E3%82%8B/>  
<https://www.it-swarm-ja.com/ja/c%23/dispatcherinvoke%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E9%9D%9E%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8B%E3%82%89wpf%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B/968851135/>  

`Application.Current.Dispatcher.Invoke(() =>`謎の呪文。後で調べたい。  
→  
どうやら、並列処理における概念らしい。  
async,awaitなどでスレッドを分けた場合、他のスレッドで動作しているコントロールをいじれなくなってしまう。  
でも、場合によってはそのコントロールを操作したい時があるわけで、  
そういう場合に、そのコントロールを操作する仕組みがDispatcherっぽい。  
Dispatcherはキューを管理するクラス。  
操作したいコントロールを所有しているスレッドのキュー管理に対して、指定したデリゲートの実行をお願いするイメージ。  
とりあえず、並列処理とかasync,awaitとかの時に使えばいいみたいね。  

[Dispatcher.InvokeとDispatcher.BeginInvoke、Dispatcher.InvokeAsyncの違い](https://redwarrior.hateblo.jp/entry/2021/03/29/090000)  
この記事も面白い。  

[await/async等の別スレッドからコントロールのプロパティを変更する](https://todosoft.net/blog/?p=363)  
改めて見てみたけど、非同期中に他のコントロールのプロパティ変更したりするときに使う命令みたいね。  

``` C#
/*
await/async等の別スレッドからコントロールのプロパティを変更しようとすると、
コントロールの描画を行っているスレッドと異なる為、エラーとなる。
InvokeRequired で異なるスレッドからの呼び出しかを判定し、異なる場合は Invoke で再呼び出しをすることで解決する。
*/
private async void button1_Click(object sender, EventArgs e)
{
    await Task.Run(() =>
    {
        Invoke((MethodInvoker)(() =>
        {
            // 非同期中に他のコントロールのプロパティを変更する
            button1.Text = "OK";
        }));
    });
}
// WPFのVMでは上記Invokeが使用できない為、下記のようになる
System.Windows.Application.Current.Dispatcher.Invoke((Action)(() => {
    // 同期処理
}));
```

---

## ContinueWith

``` C#

private void FUGA()
{
    async InnerMethod() {
        await Task.Run(() => !_IsInitializing)
            .ContinueWith(res => Messenger.Raise(new InteractionMessage("AccountNoFocusAction")));
    }

    Initialize();
}

private async void Initialize()
{
    _IsInitializing = true;
    await HOGE();
    _IsInitializing = false;
}
```

---

## 非同期メソッドの並列実行

<https://docs.microsoft.com/ja-jp/dotnet/csharp/programming-guide/concepts/async/>  

非同期メソッドを並列処理できそうな箇所があったので、Task.WaitAllみたいな並列処理をAsyncAwaitでも実現できないか調べてみた。  
天下のマイクロソフトに完璧なサンプルがあったのでそれを拝借する。  
因みに実現できたのだが、そうしたら非同期中のクルクルがなくなってしまったのでやめた。  

``` C#
static async Task Sample1()
{
    var eggsTask = Task.Run(async () =>
    {
        Console.WriteLine("すごく重い処理その1(´・ω・`)始まり");
        await Task.Delay(3000);
        Console.WriteLine("すごく重い処理その1(´・ω・`)終わり");
    });
    var baconTask = Task.Run(async () =>
    {
        Console.WriteLine("すごく重い処理その2(´・ω・`)始まり");
        await Task.Delay(5000);
        Console.WriteLine("すごく重い処理その2(´・ω・`)終わり");
    });
    // 普通にTask.WhenAllに各非同期メソッドを登録すればいいみたい。
    await Task.WhenAll(eggsTask, baconTask);
    Console.WriteLine("終わり");

    // Listに入れて引き回す事もできる。
    // 処理を並列に実行しつつ、各処理固有の終了処理を記述したい時はこっちかもね。
    var breakfastTasks = new List<Task> { eggsTask, baconTask };
    while (breakfastTasks.Count > 0)
    {
        Task finishedTask = await Task.WhenAny(breakfastTasks);
        if (finishedTask == eggsTask)
        {
            Console.WriteLine("eggs are ready");
        }
        else if (finishedTask == baconTask)
        {
            Console.WriteLine("bacon is ready");
        }
        breakfastTasks.Remove(finishedTask);
    }
    Console.WriteLine("終わり");
}
```

---

## Task.Run と Task.Factory.StartNew

[Task.Run と Task.Factory.StartNew](http://outside6.wp.xdomain.jp/2016/08/04/post-205/)  

いつもと同じ感覚でTask.Run()で処理を定義しようとしたらできなくて、何かないかと探したらTask.Factroy.StartNewなる構文だといけることが分かった。  
それはいいのだが、そもそもこれは何なのか分からなかったのでまとめることにした。  

``` C#
Task thread1 = Task.Factory.StartNew(() => fun1());
Task thread2 = Task.Factory.StartNew(() => fun2());
```

``` txt
項目                 Task.Run      Task.Factory.StartNew  戻り値           備考

CancellationToken    ○             ○                      -                キャンセルに使うTokenを指定
TaskCreationOptions  ×             ○                      -                どのように作成するかを指定するオプション
TaskScheduler        ×             ○                      -                同期コンテキストを指定

Action               ○             ○                      Task
Func<TResult>        ○             ○                      Task<TReuslt>
Action<object>       ×             ○                      Task             第2引数にOjbectが必須
Func<Object,TResult> ×             ○                      Task<TReuslt>
Func<Task>           ○             ×                      Task             入れ子のTaskの内側が戻る
Func<Task<TResult>>  ○             ×                      Task<TReuslt>
```

Task.Facotry.StartNewを一般的な用途でもっと手早く使うためにTask.Runが作られたようだ。  
確かに、タイプ数が少ないし使い勝手が良い。自分も多用している。  
ただ、Task.RunのTaskCreationOptionが「DenyChildAttach」なので、Task.Runの中でTask.Factory.StartNewを「AttachedToParent」で使っても無効になってしまうことには注意が必要。  
また、Task.Runは手軽だけど細かい設定はできない。  
Task.Factory.StartNewが不要になったわけではない。  

---

## 戻り値があるTaskの並列実行と結果の扱い方

``` C#
    Task<int> t1 = Task.Run(() => 1);
    Task<int> t2 = Task.Run(() => 2);
    Task<(int, int)> t3 = Task.Run(() => (3, 3));

    Task.WaitAll(t1, t2, t3);

    int result1 = t1.Result;
    int result2 = t2.Result;
    (int, int) result3 = t3.Result;

    // Actionを返すTaskの定義方法
    Task<Action> t1 = new Task<Action>(() =>
    {
        return () => { _ = 1; };
    });
```

---

## AsyncをAwaitするのと同期は同じか？

ibさんからAsyncをAwaitするのと、普通の同期処理は同じか？という質問を受けた。  
ibさんは毎回いい質問を持ってきてくれる。  
厳密には違うだろうが、どう違うのか、考えてみればわからないのでまとめることにした。  

同期処理における時間のかかる処理は白くなって動かせなくなる。  
しかし、AsyncAwaitは普通に動かせる。  
おそらくだが、実行するスレッドが違うからこのような違いになると思われる。  
同期処理における待機は、UIスレッドそのものを止めるので、画面が固まってしまうが、AsyncAwaitはUIスレッド以外で新しくスレッド作ってそちらで実行するので、画面は固まらない。  
でも、処理を実行しているスレッドでは、実質同期的な停止と同じなのだろう。  

``` C#
    // 画面固まる。2秒経過したら画面動かせるようになって、メッセージボックスが表示される。
    private void Button_Click(object sender, RoutedEventArgs e)
    {
        Task.Delay(2000).GetAwaiter().GetResult();
        MessageBox.Show("owata1");
    }

    // 画面固まらない。2秒中も操作可能で2秒経過したらメッセージボックスが表示される。
    private async void Button_Click_1(object sender, RoutedEventArgs e)
    {
        await Task.Delay(2000);
        MessageBox.Show("owata2");
    }
```

async await 同期 同じ c#  
[[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく](https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1)  
[【C#】ASYNC/AWAITで同期メソッドから非同期メソッドを呼ぶ方法](https://nryblog.work/call-sync-to-async-method/)  

何回もボタンを押した後で、〇〇のスレッドが終了しましたってのはそういう意味なのかもしれない？
そのスレッドの処理が終わったことを通知するアナウンスなんだろうな。

---

## なぜThread.Sleepはだめなのか

[C# で Thread.Sleep はあきまへん](https://qiita.com/TsuyoshiUshio@github/items/e9404651c9e48f1b8443)  

理由は簡単で、Thread.Sleep Method は、スレッドを止めるメソッドだから。  
スレッドがブロックされ、事実上のフリーズ状態となる。  
だから、この非同期処理が、メインと同じスレッドを使っているとしたら、メイン側のスレッドも停止します。  

``` C#
// Thread.Sleepの場合 | Task.Delayの場合
// step 1             | step 1
// getMessage!        | getMessage!
// finished!          | step 3
// message:hello      | finished!
// step 2             | message:hello
// step 3             | step 2
{
    executeAsync();
    Console.WriteLine("step 3");
    Console.ReadLine();
}
static async Task<string> getMessageAsync(string message)
{
    Console.WriteLine("getMessage!");
    //System.Threading.Thread.Sleep(3000);
    await Task.Delay(3000);
    Console.WriteLine("finished!");
    return "message:" + message;
}
static async void executeAsync()
{
    Console.WriteLine("step 1");
    var result = await getMessageAsync("hello");
    Console.WriteLine(result);
    Console.WriteLine("step 2");
}
```

---

## UIスレッド以外からUIのコントロールを操作する

[【C#】UIスレッド以外からUIのコントロールを操作する](https://hikotech.net/post-388/)  
