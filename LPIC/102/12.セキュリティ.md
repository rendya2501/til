# 12.セキュリティ

``` txt : セキュリティ関係早見表
## ホストレベルのセキュリティ
・スーパーサーバー
・xinetd
・/etc/xinetd.conf
・/etc/xinted.d
・TCP Wrapper ::
・lsof  :: 
・nmap  :: 
・fuser :: 

## ユーザーに対するセキュリティ管理
・/etc/nologin :: rootユーザ以外のユーザのログインを禁止するファイル
・/etc/sudoers :: sudoコマンドの設定を行うファイル
・/etc/shadow  :: シャドウパスワードやパスワードの有効期限に関する情報が記載されるファイル
・change :: ユーザーのパスワードの有効期限を表示・変更するコマンド
・su     :: 一時的に別のユーザーになるコマンド
・sudo   :: 別のユーザーの権限でプログラムを実行するためのコマンド
・visudo :: /etc/sudoersを編集するコマンド。sudoコマンドの利用設定をするコマンド
・ulimit :: ユーザーが利用できるリソースを制御するコマンド 

## OpenSSH
・SSH
・/etc/ssh/sshd_config
・/etc/ssh/ssh_known_hosts
・ssh
・ssh-keygen
・scp
・ssh-agent
・ポート転送

## GnuPGによる暗号化
・gpg

## その必要なコマンド
・last :: 
・w    :: 
・who  ::
```

## ホストレベルのセキュリティ

・スーパーサーバー  
・/etc/xinetd.confファイル  
・/etc/xinetd.dディレクトリ  

### スーパーサーバー

サーバープログラムを管理するプログラム。  
必要な時だけ個々のサーバープログラムを起動する。  
→メモリなどのシステムリソースを効率的に使うことが出来る。  

即応性が求められるサービスはそのサービス自体で監視すべき(スタンドアロン)  
Webサーバー,メールサーバ,etc...  

FTP,Telnetなど、頻度が高くないものはスーパーサーバー経由での接続に適している。  

代表的なスーパーサーバー  
inted,xinted  

### xinetd

ネットワークからのリクエストを受け付けるデーモン。  
`/etc/xinted.confファイル` : xintedの全体的な設定を行うファイル  
`/etc/xinted.dディレクトリ` : サービスごとの設定ファイルを格納するディレクトリ  

<https://www.express.nec.co.jp/linux/distributions/knowledge/network/xinetd.html>  
xinetd は、単体で inetd + TCP wrapper(tcpd) の機能を持っているだけでなく、よりきめ細かで自由度の高い設定を行なうことができる。  

``` txt
/etc/services
ポート番号→サービス名
23 telnet

/etc/xinetd.conf
サービス名→デーモン名
telnet in.telnetd
```

### /etc/xinetd.confファイル

### /etc/xinted.dディレクトリ

/etc/xinted.d以下の設定ファイルの主なパラメーター  

``` txt
disable : サービスの有効/無効
socket_type : 通信のタイプ(TCP:stream , UDP:dgram)
wait : ウェイトタイム
user : サービスを実行するユーザー
server : サーバープログラム(デーモン)へのフルパス
server_args : サーバープログラム(デーモン)に渡す引数
log_on_failure : 接続を拒否した時にログに記録する内容
nice : 実行優先度
only_from : 接続を許可する接続元
no_acccess : 接続を拒否する接続元
access_time : アクセスを許可する時間帯
```

/etc/xinetd.d/time-streamの例  

``` txt
service time
{
    disable = no
    id = time-stream
    type = INTERNAL
    wait = no
    socket_type = stream
    only_from = 172.16.0.1
```

### TCP Wrapper

システムに常駐する、外部からのTCP/IP接続のアクセス制御を行うプログラム。  
標準の常駐プログラム名(デーモン名)は**tcpd**  
サービス要求を受け取った後、設定に基づいてチェックを行い、接続が許可された場合はそれぞれのサーバープログラムに処理を引き渡す。  

設定ファイル  
/etc/hosts.allow  
/etc/hosts.deny  

### lsofコマンド

プロセスによってオープンされているファイルの一覧を表示するコマンド  
引数にファイル名をした場合、そのファイルをオープンしているプロセスを表示する。  

``` txt
lsof [オプション] [ファイル名]

オプション
-i : オープンしているポートとプロセスを表示する。
-i:ポート番号 : 指定のポートをオープンしているプロセスを表示する。
-i:サービス名 : 指定のサービスをオープンしているプロセスを表示する。
-p プロセスID : 指定したプロセスがオープンしているファイルを表示する。
-P : ポート番号をサービス名に変換せず、数値のままで表示する。
```

### nmapコマンド

ポートスキャンをするコマンド  

``` txt
nmap 対象ホスト
```

使用例  
`nmap www.emxample.com`  

### fuserコマンド

ポートを開いているプロセスを調べるコマンド  

``` txt
fuser -n tcp 8080
```

### SUIDの確認

SUIDが設定されているファイルを把握しておく必要がある。  
定期的にチェックすべき。  

SUIDが設定されているファイルを検索するコマンド  
`find / -perm -u+s -ls`  

セキュリティ上、ルートユーザの所有権を持ち、かつSUIDが設定されたファイルをすべて把握しておきたい。適切なコマンドはどれか（2つ選択）  
`find / -perm -u+s -uid 0`  
`find / -perm -4000 -uid 0`  

SUIDやSGIDが設定されていると、一般ユーザーでもroot権限でファイルを実行できる場合があります。root権限を不正に操作されるとセキュリティ上問題があります。そこで、システムの管理者は、ファイルを検索する「find」コマンドに「-perm」オプションを付けて、SUID/SGIDが設定されたファイルを検索し、普段から把握するように努めます。

■findコマンドの書式
find [検索場所] -perm -[モード]
　[モード]で指定されている許可属性ビットのすべてが、ファイルでも立っていたら真
find [検索場所] -perm +[モード]
　[モード]で指定されている許可属性ビットのどれか一つが、ファイルでも立っていたら真

SUIDが設定されたモードを数字表現で表すと「4000」、記号表現では「u+s」となります。
また、「-uid」で所有権を持つユーザIDを、「-gid」で所有権を持つグループIDを指定して検索できます。rootユーザはユーザID、グループIDともに「0」です。

よって正解は
・find / -perm -u+s -uid 0
・find / -perm -4000 -uid 0
です。

その他のコマンドでは「ルートユーザの所有権を持ち、かつSUIDが設定されたファイル」を検索することはできません。

以下は表示例です。

---

## ユーザーに対するセキュリティ管理

### changeコマンド

ユーザーのパスワードの有効期限を表示・変更するコマンド。  
引数を設定しないで実行した場合、対話モードになる。  
9.管理タスクのパスワードに置ける問題でも頻出。  

``` txt
chage [オプション] [ユーザー名]

-l :: アカウントとパスワードの失効日の情報を表示。一般ユーザーでも使用可能。
-d :: パスワードの最終更新日を設定。YYYY-MM-DDの形式もしくは1970年1月1日からの日数で指定する。
-m :: パスワード変更間隔の最短日数を設定。
-M :: パスワードを変更なしで使用できる最長日数を設定。
-W :: パスワードの変更期限の何日前から警告を出すかを指定。
-I :: パスワードの変更期限を過ぎてからアカウントが使用できなくなるまでの失効日数。
-E :: アカウントの失効日を設定。
```

ユーザーryoのパスワードの有効期限を60日に設定する。  
`change -M 60 ryo`  

期限を過ぎてから無効になるまでにパスワードを変更できる期間を30日に設定する。  
`change -I 30 ryo`  

### /etc/nologinファイル

ユーザーのログインを禁止するファイル  
これが存在するだけでルートユーザー以外のログインは出来なくなる。  
中身は空でもよい。
記述した場合は、その内容が一般ユーザーがログインしようとしたときに表示される。  

### suコマンド

su（Switch User）コマンドを使うと、ログイン中に別のユーザーに切り替わる事ができます。  

suコマンドには以下の特徴があります。  
・引数に「-」をつけると、切り替わる先のユーザの環境変数を使用する  
・ユーザー名を指定しない場合、rootユーザへ切り替わる  
・ユーザを切り替える時に求められるパスワードは、切り替わる先のユーザのパスワード  
・但し、rootユーザから別のユーザに切り替わる時はパスワードは要求されない  

一時的に別のユーザーになるコマンド  
別の実行ユーザーIDと実行グループIDを持つ新たなシェルを起動するコマンド  

``` txt
su [オプション] [-] ユーザー名

-あり :: 直接ログインしたときと同様の動作を行う。
カレントディレクトリは新しいユーザーのホームディレクトリとなる。
環境変数が全て初期化される。

-なし :: 現在の環境をそのままにしてユーザーだけを切り替える。  
```

### sudoコマンド

別のユーザーの権限でプログラムを実行するためのコマンド  
大抵はrootユーザーとして実行する場合に使われる。  

「sudo」コマンドで、一般ユーザでも、管理者から実行権限を委譲されたコマンドであれば実行できます。  

自身に委譲されているコマンドは「sudo -l」で確認できます。  
sudoコマンドを実行するとパスワードの入力を求められますが、rootのパスワードではなく、ユーザー自身のパスワードを入力します。  
権限委譲の設定は「visudo」コマンドで「/etc/sudoers」ファイルを編集することで行います。  

``` txt
sudo [オプション] [-u ユーザー名] コマンド

オプション
-l :: 許可されているコマンドで表示する
-i :: 変更先ユーザーでシェルを起動する(ログイン時の処理を行う)
-s :: 変更先ユーザーでシェルを起動する

-u ユーザー :: rootではなく指定したユーザーでコマンドを実行する
ユーザー名を省略するとrootユーザーで実行する。
```

### visudoコマンド

sudoコマンドの利用設定をするコマンド。  
/etc/sudoersファイルを開く。  
rootユーザーのみ実行可能。  

### /etc/sudoersファイル

sudoコマンドを実行できるユーザーの設定を行うファイル。  
sudoコマンド実行時、sudoコマンドはこのファイルを参照してユーザーが実行権限を持っているかどうか判定を行う。  
visudoコマンドで編集する。  
エディターで直接、このファイルを開いてはいけないらしい。  

``` txt
書式
権限を委譲するユーザ名 ホスト名=(実行ユーザー名) [NOPASSWD:]委譲するコマンド

ユーザー名     :: コマンドの実行を許可するユーザー名かグループ名、もしくはALL
ホスト名       :: 実行を許可するホスト名か、IPアドレス、もしくはALL
実行ユーザー名 :: コマンド実行時のユーザー名(省略時はroot)、もしくはALL
コマンド       :: 実行を許可するコマンドのパス、もしくはALL
NOPASSWD:      :: 指定すると、コマンド実行時にパスワードを問われない
```

studentユーザーのみshutdownコマンドが実行できるように設定する  
`student ALL=(ALL) /sbin/shutdown`  

studentユーザーに対し、全てのroot権限が必要なコマンドの実行を許可する。  
`student ALL=(ALL) ALL`  

wheelグループに対し、全てのroot権限が必要なコマンドをパスワードなしで実行できるようにする。  
`%wheel ALL=(ALL) NOPASSWD:ALL`

### ulimitコマンド

ユーザーが利用できるリソースを制御するコマンド  
アプリケーションのエラー発生時に生成されるcoreファイルの最大サイズやシェルが使用できる最大メモリ量など、使用するリソースを制限できる。  

``` txt
ulimit [オプション[リミット]]

-a : 現在の全ての設定を表示
-c サイズ : コアダンプで生成されるcoreファイルの最大サイズ(単位はブロック)を制限
-f サイズ : シェルが生成できるファイルの最大サイズをブロック単位で指定する
-n 数 : オープンできるファイル(ファイル記述子)の最大個数を制限
-u プロセス数 : 1人のユーザーが利用できる最大プロセス数を指定する
-v サイズ :プロセスの仮想メモリの最大サイズ(単位はキロバイト)を制限
```

---

## OpenSSH

オープンソースのSSH実装のソフトウェア。  
SSHプロトコルを利用するためのソフトウェア。  
SSHサーバーおよびSSHクライアントを含む。  
SSHを利用するために、現在世界で最も使われているSSH実装。  

[インフラエンジニアじゃなくても押さえておきたいSSHの基礎知識](https://qiita.com/tag1216/items/5d06bad7468f731f590e)  

### SSH(Secure Shell)

暗号や認証の技術を利用して、安全にリモートコンピュータと通信するためのプロトコル。  
ポート番号 : 22  

sshd : SSHサーバーの機能を提供するデーモン  

/etc/sshディレクトリは、sshサーバーとsshクライアントがともに使用するディレクトリ。  

### /etc/ssh/sshd_config  

sshdの設定ファイル  

sshtの主なディレクティブ  

- Port : 待機ポート番号  
- Protocol : プロトコルバージョン
- PermitRootLogin : rootログインを許可するかどうか
- PubkeyAuthentication : 公開鍵認証(プロトコルバージョン2)  
- AuthorizedKeysFile : ユーザー認証の公開鍵格納ファイル名  
- PasswordAuthentication : パスワード認証  

``` txt : sshd_configの抜粋
Port 22
Protocol 2
PermitRootLogin yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PasswordAuthentication yes
```

### /etc/ssh/ssh_known_hostsファイル

ローカルシステムの全ユーザーが利用するsshサーバーの公開鍵を格納するファイル。  
そのsshサーバーはローカルシステムの全ユーザーにとって正当と認めるサーバーになる。  

### sshコマンド

SSHを使ってリモートホストにログインするためのコマンド  

``` txt
ssh [オプション] [[ログインユーザー@] ホスト]

-p ポート番号 → ポート番号を指定する
※ 「-o Port = ポート番号」 or 「-o "Port ポート番号"」 でも指定可能な模様。
-l ユーザー名 → 接続するユーザーを指定する
-i ファイル名 → 秘密鍵ファイルを指定する
-f → コマンドを実行する際にsshをバックグラウンドにする(Xアプリケーションを実行する際に使用)
-N → リモートコマンドを無効にする。転送のみを指示する。
-2 → SSHのバージョン2を使用する。

ssh ユーザー名@ホスト名 -i 秘密鍵ファイルのパス -p ポート番号
```

sv1.lpic.jpにSSHで接続する。  
`ssh sv1.lpic.jp`  

studentユーザーとしてsv1.lpic.jpにSSHで接続する。  
`ssh student@sv1.lpic.jp`  

ポート番号22番、アイデンティティファイル~/.ssh/id_dsa、プロトコルバージョン2、ログインユーザーyukoでsshサーバーにログインする。  
`ssh -p 22 -i ~/.ssh/id_dsa -2 -l yuko examserver`  

### ホスト認証

クライアントがサーバーの正当性を確認するための認証。  
①クライアントがサーバーにSSH接続する。  
②サーバーがクライアントに公開鍵を送信する。  
③クライアントは送られてきた公開鍵の正当性をチェックする。  

ホスト認証の後、ユーザー認証を行う。  
接続先がなりすましだった場合、警告が出る。  
ユーザーが接続先の正当性を確認するための認証がホスト認証というわけ。  

### 公開鍵認証

- 公開鍵暗号方式は非対称暗号方式とも呼ばれる。  
- 暗号化と復号の鍵が異なる方式。  
- 秘密鍵を乱数で生成し、秘密鍵から大きな2つの素数の積や離散対数により公開鍵を生成する。  
- 秘密鍵と公開鍵は1対1対応。  
- 秘密鍵から公開鍵が計算されるが、その逆の演算は実質不可能(宇宙が出来上がるまでの時間を書ければ出来なくはないが、計算時間に対して割に合わな過ぎる。)  
- データ送信側は受信側から事前に取得してある公開鍵でデータを暗号化して受信側に送り、受信側は自分の秘密鍵でデータを復号する。  
- 公開鍵認証では、被認証側が自分の秘密鍵で認証データを作成して認証側に送り、認証側では被認証側の公開鍵で認証データを検証する。  

### ssh-keygenコマンド

公開鍵と秘密鍵の鍵ペアを作成するコマンド  

``` txt
ssh-keygen [オプション]

-t キータイプ : 
-p : 
-f ファイル名 :
-R ホスト名 : 
-b ビット長 :

キータイプ
rsa1 : 
rsa : デフォ
dsa :
ecdsa : 
ed25519 : 
```

DSAで鍵ペアを作成
`ssh-keygen -t dsa`

パスフレーズ  
秘密鍵を利用する際の認証用文字列。  
秘密鍵を暗号化してファイルに格納するために秘密鍵の作成時に設定する文字列。  
秘密鍵をファイルから取り出すときに同じパスフレーズを入力して復号する。  

### ~/.ssh/内のファイル

#### authorized_keys  

接続を許可する公開鍵を登録しておくサーバー側のファイル。  
①接続先リモートホストのホームディレクトリ内に「.ssh」ディレクトリを作成。  
②その中にauthorized_keysファイルを作成して、そこに公開鍵をコピーして登録する。  

#### config

SSH接続情報を格納したファイル。  
sshコマンドを使うとき、ここに記述した設定が反映されるので、毎回面倒な接続情報書かなくて済むようになったりする。  
接続時に使うので、クライアント側に配置するファイルだと思われる。  

<https://blog-and-destroy.com/20409>  
<https://qiita.com/0084ken/items/2e4e9ae44ec5e01328f1>  
SSH系の記事が豊富過ぎてまとめるのが大変だ。  

主な設定項目

- Host  
  sshコマンド等で指定するホスト名  
  使い方はしたでまとめている。  
- HostName  
  実際の接続ホストのアドレス。IPアドレスや/etc/hostsに指定したホスト名等を指定する。  
  これがあることでホスト名を省略できる。  
- User  
  ユーザー名  
  これがあることでユーザー名を省略できる。  
- Port  
  ポート番号  
  これがあることで `-p ポート番号` って書かなくてよくなる。  
- IdentityFile  
  秘密鍵ファイル  
  これがあることで `-i 秘密鍵ファイルのパス` って書かなくてよくなる。  

``` txt
Host 接続コマンド名（任意の名前）
    HostName ホスト名
    User ユーザー名
    IdentityFile ~/.ssh/秘密鍵のファイル名
    Port ポート番号

ssh 接続コマンド名
を利用した接続が可能になる。  
```

#### id_rsa

ssh-keygenで生成した秘密鍵。  

#### id_rsa.pub

ssh-keygenで生成した公開鍵。  

#### known_hosts

過去に接続したことがあるサーバーの情報。  
クライアント側に保存される。  
内容は**ホスト名、IPアドレス、公開鍵**  

### scpコマンド

SSHの仕組みを使い、ホスト間で安全にファイルをコピーするコマンド  

``` txt
ローカルホストにあるファイルをリモートホストにコピーする場合の書式
scp コピー元ファイル名 [ユーザー名@]コピー先ホスト:[コピー先ファイル名]

リモートホストにあるファイルをローカルホストにコピーする場合
scp [ユーザー名@]コピー元ホスト:コピー元ファイル コピー先ファイル名

オプション
-p → パーミッションなどを保持したままコピーする
-r → ディレクトリ内を再帰的にコピーする
-P ポート番号 → ポート番号を指定する
```

ローカルホストの/etc/hostsをリモートホストsv3.example.jpの/tmp以下にコピーする。  
`scp /etc/hosts sv3.example.jp:/tmp`  

リモートホストsv3.example.jpの/etc/hostsをカレントディレクトリにコピーする。  
`scp sv3.example.jp:/etc/hosts .`

リモートホストsv3.example.jpのfredユーザーのホームディレクトリに、ローカルホストのdata.txtファイルをコピーする。  
`scp data.txt fred@sv3.example.jp:`  

### ssh-agent

参考書のほうがわかりにくいので全面的にこちらを使う。  
[ssh-agentを使って公開鍵認証方式のsshパスワード入力を省略する方法](https://www.server-memo.net/server-setting/ssh/ssh-agent.html)  

公開鍵認証方式による認証を行っているSSHサーバーへ接続する際、秘密鍵に設定されているパスフレーズの入力を代わりにやってくれるプログラム。  
秘密鍵とパスフレーズはメモリ上にキャッシュされる。  
クライアント側で稼働するデーモン。  

パスフレーズの入力回数を減らしてくれるという便利なプログラムだが、ちょっと使いづらい仕様もあったりする。  

- ssh-agentを起動したシェル内のみ有効  
  ログアウトしたりシェルを変更すると使えなくなりssh-agentの再実行が必要  
- ssh-addで秘密鍵とパスフレーズの登録が必要  
  ssh-agentを起動するたびに登録が必要  
- ssh-agentが自動終了しない  
  ログアウトしたりシェルを変更してもssh-agentは自動終了しないため、新しいシェルでssh-agentを起動すると多重起動が発生してしまう  

ssh-agent利用のためには、子プロセスとしてbashシェルを起動する必要がある。  
`ssh-agent bash`  

秘密鍵を登録する。  
`ssh-add`  

秘密鍵の登録確認。  
`ssh-add -l`  

### ポート転送

SSHポート転送(ポートフォワーディング)とは、あるポートに送られてきたTCPパケットをSSHを使った安全な通信路を経由して、リモートホストの任意のポートに転送すること。  
POP3やFTPなど、暗号化されていないプロトコルを使った通信の安全性を高めることが出来る。  

書式  
`ssh -L [ローカルポート]:[リモートホスト]:[リモートポート] [リモートホストのユーザー名]@[リモートホスト]`  

ローカルホストの10110版ポートに接続すると、リモートホストpop.example.netの110番ポートに接続する。  
`ssh -f -N -L 10110:pop.example.net:110 student@pop.example.net`  

### X11ポート転送

ポート転送の仕組みを使って、リモートホストのXクライアントをローカルホストで動作させる事。  
X11ポート転送を有効にするためには`/etc/ssh/sshd_configファイル`に以下の設定を行う。
`X11Forwarding yes`  

---

## GnuPGによる暗号化

### GnuPG(GNU Privacy Guard)

公開鍵暗号方式を使って、ファイルの暗号化や復号をしたり、電子署名をしたりすることができるオープンソースソフトウェア。  
公開鍵暗号PGP(Pretty Good Privacy)の標準仕様であるOpenPGPのGNUによる実装であり、暗号化と署名を行うツール。  

### gpgコマンド

公開鍵と秘密鍵の鍵ペアを生成するコマンド  
`gpg --full-generate-key` or `gpg --gen-key`  
鍵は`~/.gnupg`ディレクトリに作成される。  

失効証明書の作成  
`gpg -o 執行証明書ファイル名 --gen-revoke メールアドレス`  
失効証明書はパスフレーズが漏れてしまったり、忘れてしまった際に鍵を無効化するために必要。  

失効証明書を使い鍵を無効化するコマンド  
`gpg --import revoke.asc`  

共通鍵を使ったファイルの暗号化  
`gpg -c ファイル名`  
例 : secret.txtファイルを暗号化  
`gpg -c secret.txt`  

公開鍵を使ったファイルの暗号化  
`gpg -c ファイル名`  

公開鍵のエクスポート  
`gpg -o 出力ファイル名 -a --export 自分のメールアドレス`  

公開鍵のインポート  
`gpg --import pubkey`  

鍵に署名を行うコマンド  
`gpg --sign-key メールアドレス`
公開鍵が信頼できる場合に行う。署名を行わないと毎回警告が表示される。  

ファイルの暗号化  
`gpg -e -a -r 送り先のメールアドレス 暗号化するファイル名`  
例 : 受信者ID yuko@mylpic.com,送信データファイルsecret-document.txt  
`gpg --encrypt --recipient yuko@mylpic.com secret-document.txt`  
受信は○○です。暗号化するファイルはこれです。この組み合わせで暗号化します。  

ファイルの復号  
`gpg important.txt.asc`  

ファイルの署名  
`gpg -o sample.sig --sign gpg.log`  

鍵の管理に関するタスクを対話モードで実行する場合のコマンド  
`gpg --edit-key`  

---

## その必要なコマンド

### lastコマンド  

システムのログイン履歴を一覧表示するコマンド  
ログイン記録`/var/log/wtmp`を参照して、ログイン履歴を表示する。  

last : 過去、最後  
lust : 強い欲望、切望、渇望、色欲、肉欲  

``` txt
last [オプション][ユーザー名][端末番号]

オプションたくさんあるけど、今はいいです。
必要になったらまとめます。
```

### wコマンド

現在、システムに誰がログインしていて、何を実行しているのかを表示するコマンド。
`/var/log/wtmp`および`/proc`の情報を参照して表示する。  

``` txt
w [オプション][ユーザー名]

-h : ヘッダーを表示しない
-u : 現在のプロセス時間とCPU時間を計算する際に、ログイン名と現在のユーザー名の違いを無視する
-s : 短く表示する
-f : リモートホスト名を表示しない
```

### whoコマンド

システムに誰がログインしているかを表示するコマンド。  
`/var/run/utmp`ファイルを参照して表示する。

``` txt
who [オプション]

たくさんある。
```

---

## 小豆本問題

### 1 ○

TCP Wrapperを使ってアクセス制御している。  
/etc/hosts.allow「sshd : 192.168.2.」  
/etc/hosts.deny「ALL:ALL」  
このことの説明。  

→  
B : 192.168.2.5のホストからSSH接続ができる。  

ホワイトリスト→ブラックリスト  
ホワイトリストに当てはまったら即OK。  
ホワイトリストに無かったらブラックリストを見る。  
ブラックリストにあったら即OUT。  

---

### 2 ×

/etc/nologinファイルを作成するとどうなるか？  

→  
C : /etc/nologinファイルに記述されたユーザーはログインできなくなる。  

A : 全てのユーザーはログイン出来なくなる。  
まじか。覚え間違えだったかな。  
ファイルを作って、その中でユーザーを指定するものだと思っていたのだが、勘違いだったようだ。  

空のファイルで良いが、メッセージを記述すると、ログインしたときのそのメッセージが表示されるらしい。  
なるほどね。  

---

### 3 ○

パスワードの有効期限を表示、設定するコマンドは？

→  
change  

---

### 4 ○

SSHを使って、ホストa.example.netに、ユーザーstudentとしてログインしたい。  
実行するコマンドは？  

→  
`ssh student@a.example.net`  
Eかな。  

正解。  
`ssh ログインユーザー名@ホスト名`  
ユーザー名を省略した場合、ローカルホストでSSHを実行したユーザーのユーザー名が指定されたことになる。  

---

### 5 ×

SSHを使ってリモートホストへ公開鍵認証でログインできるよう設定中。  
①接続先リモートホストのホームディレクトリ内に「.ssh」ディレクトリを作成。  
②その中に___ファイルを作成。そこに公開鍵をコピーして登録した。  
ファイル名は？  

→  
`~/.ssh/authorized_keys`  
なのでファイル名は`authorized_keys`  
登録元は？  

---

### 6 ○

GPGを使って暗号化されたファイルsecret.ascが送られてきた。  
送付元の公開鍵はすでに登録済み。  
復号のコマンドは？  

→  
`gpg secret.asc`  
ということでA  

当たった。  
