# 7.シェルとシェルスクリプト

## シェル環境のカスタマイズ

### aliasコマンド

エイリアスを設定するコマンド。  
コマンドの別名を定義したり、コマンドとそのオプションをまとめて1つの新しいコマンドとして実行できる。  

``` txt
alias
登録されている全てのエイリアスが表示される。

alias [エイリアス名='コマンド']
エイリアスを登録する。
既に登録されている別名と同じ別名で再定義した場合、上書きされる。  
通常の場合はシングルクオート、コマンドが2語以上になる場合は、シングルクォート（'）もしくはダブルクォート（"）で括ることに注意。  
```

単一引用符で括っているのは、コマンドとオプションの間のスペースがシェルによって解釈されないようにするため。  
本来のコマンド名と同じエイリアスを定義した場合、エイリアス側が実行される。  
本来のコマンドを実行したい場合は頭に`\` or `バックスラッシュ`を付けて実行するか、パス付きで実行する。  
→`\ls` or `/bin/ls`  

`ls`と入力した時に`ls -l`コマンドが実行されるようにする。  
`alias ls = 'ls -l'`  

`ls -l`コマンドの実行結果を`less`コマンドで表示するエイリアス`lsless`を定義する。  
`alias lsless = 'ls -l | less'`

### unaliasコマンド

設定したエイリアスを削除するコマンド  

``` txt
unalias [オプション] 別名

オプション
-a → 現在の登録内容を全て削除する。
```

上で定義した`lsless`コマンドを解除する。  
`unalias lsless`  

### functionコマンド

bashシェル上で利用できる独自の関数を定義するためのコマンド。  
複雑なコマンドの組み合わせや条件分岐を行う場合等に使用する。  
単純なコマンドの組み合わせはエイリアスだが、それでは対応出来ない場合にfunctionを定義する。  

※定義された関数はシェル内部で実行されるため、子プロセスは生成しない。  

``` txt
※1
function シェル関数名() { コマンド; }

※2
function
関数名()
{
    コマンド
}
```

- ※1の書式では`{`と`}`の間にはスペースが必要。  
- ※2の書式ではコマンドの後ろの`;`は不要。  
- 関数が利用できるのは、その関数を定義したシェル内のみ。  
- bashでは変数名と関数名を区別しないので競合しないようにする必要がある。  

例:  
指定したディレクトリの中にあるリンクファイルのみをリスト表示するlslink関数を定義する。  

`function lslink() { ls -l $1 | grep '^1' }`  
1番目の引数は$1と表す。  
シンボリックリンクは行頭のファイル種別記号が「l」になるので、行頭のlを検索する。  

### unsetコマンド

定義したシェル関数を削除するコマンド。  

``` txt
unset シェル関数名
```

- シェル関数[lsmo]の削除  
  `unset lsmo`  

### declareコマンド

変数を宣言するコマンド。  
定義済み変数や関数の定義内容も表示する。  
declare : 宣言する。  

``` txt
declare [オプション] [名前]
declare [オプション] [名前=値]

オプション
-f → 現在定義されているシェル関数を全て表示する。
-F → 現在定義されている関数名を全て表示する。
-p → 現在定義されている変数を全て表示する。
-P → 現在定義されている変数名を全て表示する。
```

### setコマンド

シェルの設定を確認、変更するコマンド。  
101の時は環境変数を確認するためのコマンドとして認識していた物。  

引数なしで実行した場合、表示できるもの :: 環境変数、シェル変数、シェル関数  
オプションの有効は「-」、オプションの無効は「+」。直観的な認識と逆なので注意。  
シェルのオプションの設定状態を確認する時は`set -o`コマンドを実行する。  

``` txt
set [-o][+o] [オプション]

-oでオプション有効
+oでオプション無効

オプション
allexport :: 作成・変更した変数を自動的にエクスポートする。
emacs :: emacs風のキーバインドにする。
ignoreeof :: Ctrl + Dによってログアウトしないようにする。
noclobber :: 出力リダイレクトによる上書きを禁止する。
noglob :: メタキャラクタを使ったファイル名展開を無効にする。
          (ワイルドカードによる展開(*や?)が無効になる。)
vi :: vi風のキーバインドにする。
```

noclobberとnoglobが毎回わからなくなるので注意。  

### envコマンド

環境変数を表示するコマンド。  
そのほか、環境変数を一時的に変更したり、削除したりしてコマンドを実行できる。  
設定されている環境変数の値を一時的に指定された値に変更してコマンド実行するのもこいつ。  

``` txt
env [オプション] [環境変数名=値] [コマンド]

オプション
-i :: 何も環境変数が設定されていない状態にする。
-u 環境変数名 :: 環境変数を一時的に削除する。
環境変数名=値 :: 環境変数の値を一時的に指定された値に変更する。
(オプションなし) :: 全ての環境変数を表示する。
```

何も環境変数が設定されていない状態で、「sample.sh」というコマンド（スクリプト）を実行する。  
`env -i ./sample.sh`  
こうすることで、シェルを実行するときに、余計な環境変数に影響されることがなくなるのだろう。  

「TEST_A」という環境変数を一時的に「999」に変更して、「sample.sh」というコマンド（スクリプト）を実行  
`env TEST_A=999 ./sample.sh`  

### printenvコマンド

指定した環境変数のみを表示するコマンド。  
未指定の場合、全ての環境変数を表示する。  

### 早見表

set :: 全てのシェル変数、シェル関数、環境変数  
env :: 環境変数  
printenv :: 環境変数  
declare -f :: シェル関数

### bashの設定ファイル

シェルを起動するたびに環境変数やエイリアス、関数などを定義するのは非効率なので、それらの定義を自動的に行うための設定ファイルが用意されている。  

``` txt
/etc/profile :: ログイン時に実行され、全ユーザーから参照される。  
/etc/bash.bashrc :: bash起動時に実行され、全ユーザーから参照される。  
/etc/bashrc :: ~/.bashrcから参照される。  
~/.bash_profile :: ログイン時に実行される。  
~/.bash_login :: ~/.bash_profileがない場合、ログイン時に実行される。  
~/.profile :: ~/.bash_profileも~/.bash_loginもない場合、ログイン時に実行される。  
~/.bashrc :: bash起動時に実行される。  
~/.bash_logout :: ログアウト時に実行される。  
```

### /etc/profileファイル

bashのログイン時に実行される。  
システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な**環境変数**を設定していくファイル。  

### /etc/bash.bashrcファイル

Debian系のシステムで全ユーザーのbash起動時に共通の処理を記述するファイル。  
bash.bashrcとかbashを2回も使うふざけた名前であることに注意。  

### /etc/bashrcファイル

システムを利用する全ユーザーに対する設定を記述するファイル。
あるコマンドのエイリアスを全ユーザーで使用できるようにするためには、このファイルを編集する。  

### ~/.bash_profileファイル

ユーザー独自の設定が格納されたファイル。  
ログインした場合、2番目に読みこまれる。  

### ~/.bashrcファイル

対話型シェルが起動されるたびに実行される。  
システムを利用する全ユーザーに対する設定は/etc/bashrcに記述し、~/.bashrcから呼び出すようになっている。  
ログインシェルとしてbashが起動した際に、読みこむ設定がない場合は読みこまれない。  
その設定は`~/.bash_profile`に記述されているらしい。  

### ~/.profileファイル

Bashあるいはshが読み取って実行するファイル。  
記述内容はシェル構文に従う。  
ファイルに読み取り権は必要。実行権は不必要。  
ホームディレクトリにあるので、rootユーザーは関係ない。  
ユーザーにのみファイルの読み取り件を付ける必要がある。→ない。  

### ~/.bash_logoutファイル

bashがログアウトの直前に実行するスクリプトであり、ログアウト前に行いたい処理を記述する。  
画面をクリアする clear コマンドなどを記述する。  

### 読み込み順

bashは起動のされ方によって扱いが変わります。  
・ログインシェル ：: /etc/passwdに設定され、ユーザーのログイン時に最初に起動されるシェル。このシェルが終了するとログアウトされる。  
・対話型シェル :： ログインシェルから別のプロセスとして起動するシェル（例：直接/bin/bashを実行する）  

ログインシェルとしてbashが起動すると、環境変数の設定などユーザー環境にかかわるものが記述されている全ユーザー共通、また、各ユーザー個別の環境設定ファイルを読み込みます。  
これらのファイルはシェル上で実行できるコマンドが記述されたシェルスクリプトです。  

これらの設定ファイルはsourceコマンド（指定したシェルスクリプトを読み込み、現在のシェルで実行する）によって実行されており、  
ファイルに読み取り権とファイルが存在するディレクトリに検索権（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼ぶ）があれば実行可能です。  

#### bashをログインシェルとして起動した場合  

1. /etc/profile  
2. /etc/bash.bashrc ← 設定によって読みこんだり読みこまなかったりする(Debian系のみ読み込みらしい)  
3. ~/.bash_profile  
4. ~/.bash_login  
5. ~/.profile  
6. ~/.bashrc ← 読みこむ設定がない場合は読みこまれない。  
7. /etc/bashrc  

基本的に、先にprofile。後にrc。  
最初はetc。次に.~/。最後にまたetc。  
profile読んだ後にlogin読みこんでprofileを読みこむクソ仕様なので注意。  

#### 対話型シェルを起動した際に読みこまれるファイル、bashコマンドを実行してbashを起動した場合  

1. ~/.bashrc  
2. /etc/bashrc  

対話型として起動した場合は、profileは読みこまれない事に注意。  

### 非ログインシェル

ユーザーがログインした後に、ターミナルエミュレーターを開くことで起動するシェルを実行したり、コマンドラインから別のシェルを起動したりしたシェルの事  

### おまけ : 代表的な環境変数まとめ

``` txt
HISTFILE :: コマンド履歴保存ファイルのパス
HISTSIZE :: 現在のシェルでコマンド履歴の保存数
HISTFILESIZE :: コマンド履歴保存ファイルへの履歴保存数
HOSTNAME :: ホスト名
HOME :: ログインしているユーザーのホームディレクトリ
LANG :: ロケール(言語設定)
PATH :: コマンドやプログラムを検索するディレクトリのリスト
PWD :: カレントディレクトリパス
USER :: ログインしているユーザー
```

---

## シェルスクリプト

スクリプト(特定の処理を行うために作成したプログラム)をシェルプログラムで記述したもの。  
bashシェルを始め、シェルにはスクリプト言語によるプログラミング機能が備わっている。  
これがシェルスクリプト。  

一連のコマンドライン作業を自動化する事ができる。  

Web連携のログを抜き出すアレと言えば話は早いだろう。  

バイナリ形式のコマンドは実行権のみで実行できるが、シェルスクリプトの場合は読み込み権限もないと実行できない。  
なお、シェルスクリプトの場合は`bash sample.sh`のようにしてシェルの引数として指定すれば、実行権がなくても読み込み権さえあれば実行できる。  

### シェルスクリプトの実行方法

1. bashコマンドを使う。  
   `bash testing.sh`  
2. soueceコマンドを使う。  
   `source testing.sh`  
3. スクリプトファイルの前に省略記号「.」を入力して実行する。  
   `. testing.sh`  
4. ファイルに実行権を付与してファイル名を指定して実行する。  
   `chmod a+x test.sh`  
   `./testing.sh`  

4番目に関して  
カレントディレクトリにあるスクリプトを実行するために「./」を付ける必要があるのは、  
そのディレクトリにパスが通っていない(変数PATHにそのディレクトリが含まれていない)場合。  
パスの通っているディレクトリ内にあるスクリプトファイルは「./」を付けなくても実行できる。  
変数PATHに「.」を追加する事はセキュリティ上のリスクをはらむらしい。  

`実行権`がないシェルスクリプトを実行するには、`source`コマンドを使用する。  
但し`source`コマンドを実行するには、シェルスクリプトに`読み取り権`と、シェルスクリプトが存在するディレクトリに`検索権`が必要。  
`source`コマンドは「.(ドット)」で代用できる。  

設定を即座に反映させるには、現在のシェルでスクリプトを実行できるsourceコマンドを使用します。  

### コマンドの実行結果をシェル変数に代入する方法  

- コマンドを`$()`で囲んで、その結果をシェル変数に代入する。  
- コマンドをバッククオート「`」で囲んでその結果をシェル変数に代入する。  

bashにはコマンドの実行結果を文字列として扱う「コマンド置換」機能があります。コマンド置換は次の書式で実行します。  

・`実行コマンド`（バッククォート、日本語キーボードではSHIFT+@）  
・$(実行コマンド)  

`$echo $HOSTNAME`  
→`testserver.localdomain`  
`$ echo $(echo $HOSTNAME)`  
→`testserver.localdomain`  

### sourceコマンド

ファイルに書かれたコマンドを現在のシェルで実行する事を指示するコマンド。  
主にシェルの設定を反映させる際に使用する。  

sourceコマンドはシェルに組み込まれたビルトインコマンドで、bashやtcsh,zshに共通して使用できる。  
ビルトインコマンド「.」の処理内容はsourceと全く同じ。  

``` txt
source ファイル [ファイル実行時の引数]
. ファイル [ファイル実行時の引数]

オプションはない。
```

bash ファイル名  
ファイル名  

で実行した場合はbashの子プロセスが立ちあがり、  

### execコマンド

子プロセスを生成するのではなく、現行プロセスを引数で指定したコマンドに入れ替えて実行するコマンド。  
bashの組み込みコマンド。  
指定したコマンドを既存のジョブ(シェルとプロセス)と置き換えて実行するコマンドとも言えるらしい。  

### シェルスクリプトの特殊変数

シェル変数とも言うらしい。  

``` txt
$0 → シェルスクリプトファイル名  
$1 → 1番目の引数。※ 2番目の引数の場合は $2 と指定する。  
\$$ → 現在のシェルのプロセス番号  
$# → コマンドラインに与えられた引数の数  
$? → シェルが最後に実行したコマンドの終了ステータス ( 0 = 正常終了、1 = 異常終了、それ以外はエラー ）  
$@ → 全ての引数 ( 区切りはスペース )  
$* → 全ての引数 ( 区切りは環境変数IFSで指定したもの )  
```

シェルスクリプトの実行後 `echo $?` と実行して 0 が帰ってくるならスクリプトが正常終了したことが分かる。  
bashのプロンプトで`echo $$`を実行した場合のプロセスIDはシェル自身のプロセスIDが格納される。  

10番目以降の引数を参照する時は${10}のように「{}」で囲う必要があります。  
「{}」を使用しないとシェルは「$1 + "0"」のように誤った解釈をします。  
そのため、$10および$11はそれぞれ「a0」と「a1」のように表示されます（aは1番目の引数）。  

### if文

``` sh
if 条件式
then
    実行文1
else
    実行文2
fi
```

### case文

``` sh
case 式 in
    値1)
        実行文1 ;;
    値2)
        実行文2 ;;
    ~~~
esac
```

case式はforeachでないくせに[in]であることに注意。  
実行文の最後は[;]ではなく[;;]であることに注意。  
最後はcaseの反対文字(esac)になるタイプであることに注意。  

### for文

``` sh
for 変数名 in 変数に代入する値のリスト
do
    実行文
done
```

### while文

``` sh
while 条件文
do
    実行文
done
```

``` sh
while read USERNAME
do
    useradd $USERNAME
    echo $USERNAME | passwd --stdin $USERNAME
done < $1
```

### readコマンド

ユーザーからの入力値を受け取り、変数に格納してそれを次の処理で使用したい場合に使用するコマンド。  
キーボードからの入力を受け付けて、それを後の処理でも使いまわすという性質上、シェルスクリプトで使われるコマンド。  

``` txt
read [オプション] 変数名
```

``` sh
echo -n " あなたのお名前は? "
read yourname
echo " こんにちは、$yourname さん "
```

``` sh
read a b c <<END
1 2 3 4 5 6
END
```

格納変数は複数定義可能。  
上記例の場合、a=1,b=2,C=3 4 5 6 となる。  
そういう仕様らしい。  

### testコマンド

条件分岐が行われる条件式の真偽を判断して、その結果を返すコマンド。  
条件が満たされた場合は真(0)、満たされない場合は偽(1)を返す。  
エラーの場合、0や1ではない何かが返される模様。  
主にシェルスクリプト内部で使用する。  

``` txt
test [条件文]

[ファイルの形式に関する条件式]
-d ディレクトリ名 → 指定したディレクトリがあれば真
-f ファイル名 → 指定したファイルが通常ファイルであり、存在すれば真
-s ファイル → 指定したファイルのサイズが0より大きいファイルであれば真
-L ファイル → 指定したファイルがシンボリックリンクであるファイルであれば真

[ファイルの権限に関する条件式]
-r ファイル → 指定したファイルが存在して、かつ読み込み可能であれば真
-w ファイル → 指定したファイルが存在して、かつ書き込み可能であれば真
-x ファイル → 指定したファイルが存在して、かつ実行可能であれば真

[ファイルの特性に関する条件式]
-e ファイル → 指定したファイルが存在すれば真
ファイル1 -nt ファイル2 → 指定したファイル1が指定したファイル2よりも修正時刻が正しければ真(newer than)
ファイル1 -ot ファイル2 → 指定したファイル1が指定したファイル2よりも修正時刻が古ければ真(older then)

[文字列に関する条件式]
-n 文字列 → 文字列の長さが0より大きければ真
-z 文字列 → 文字列の長さが0であれば真
文字列1 = 文字列2 → 文字列1と文字列2が等しければ真
文字列1 != 文字列2 → 文字列1と文字列2が等しくなければ真

[数値に関する条件式]
数値1 -eq 数値2 → 数値1と数値2が等しければ真
数値1 -ne 数値2 → 数値1と数値2が等しくなければ真
数値1 -ge 数値2 → 数値1が数値2よりも大きい、または等しければ真
数値1 -gt 数値2 → 数値1が数値2よりも大きければ真
数値1 -le 数値2 → 数値1が数値2よりも小さい、または等しければ真
数値1 -lt 数値2 → 数値1が数値2よりも小さければ真

[論理結合に関する条件式]
!条件 → 条件式が偽であれば真
条件1 -a 条件2 → 条件1と条件2の両方の条件式が真であれば真
条件1 -o 条件2 → 条件1と条件2のどちらかの条件式が真であれば真
```

test構文 :: `text 条件式`  
「[」構文 :: `[ 条件式 ]`  

### seqコマンド

連続した数値を自動的に生成するコマンド。  
主にシェルスクリプトで使用する。  

``` txt
seq 開始する数値 終了する数値
seq 終了する数値(1から開始)
seq 開始する数値 増加する値 終了する数値
```

1,2,3,4,5をforで出力する。  
→  
`seq 1 5` or `seq 5` or `seq 1 1 5`  

`seq 1-5` or `seq 1 to 5`は間違いだから注意ね。  

### 制御演算子

`&&` :: command1が成功した場合のみcommand2を実行する。  
`||` :: command1が失敗した場合のみcommand2を実行する。  
`;` :: コマンドを続けて実行する。  

制御演算子との間にスペースは無くて良い模様。  

command1を実行し、続けてcommand2を実行させたい。ただし、command1が失敗した場合はcommand2を実行しないこととする。下線部にあてはまる語句は次のうちどれか。  
→  
&&  

---

## 小豆本問題

---

### 1 ○

エイリアスを解除することなく、一時的にエイリアスを無効にして、オプションなしのlsコマンドを実行したい場合どうすればいいか。  

→  
E.コマンドの直前に「\」をつけて実行する。  

→  
まぁ、やったばっかしだからね。  

---

### 2 ○

一連のコマンドを実行するlslink()関数を作成したい場合、関数作成には何というコマンドを使うか？

→  
function  

（　＾ω＾）・・・  
`function lslink() { ls -l | grep '^l'; }`  

---

### 3 ○

システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な環境変数を設定しておきたい場合、どの設定ファイルに設定を記述するのが適切か？  

→
A. /etc/profile  

よく、問題文を読んでみれば、これしかない。  
基本的な環境変数の設定ファイルはprofileか。  

---

### 4 ×

次のスクリプトを実行した際、変数「$#」に入る値を選択してください。  
`$ ./testscript args1 args2`

→
・変数「$#」に入る値→引数の数。
・$0 には ./testscript
・$1 には args1
・$2 には args2

---

### 5 ×

bashシェルスクリプトで、`test -x file_a`と同じ動作をするものを選択してください。  

→  
B. [-x file_a]  

souece , .はスクリプトの実行  
functionは関数を作成するコマンド。  
scriptコマンドは存在するか知らない。  
消去法でB.

当たった。

→
testコマンドは[~]の形式でも使われる。  
というか大半は[~]形式で使われる模様。  

---

### 6 ×

以下は、端末から名前を入力すると、その名前を使って挨拶を返すシェルスクリプトです。  

``` sh
echo -n "Enter your name:"
______ name
echo "Hello,$name!"
```

→  
read  

全体を一周する前にやった問題だから間違った。  
答えはシェルスクリプト内部でキーボード入力を受け付けるコマンドであるreadです。  
C#に置けるConsole.Readですね。  
