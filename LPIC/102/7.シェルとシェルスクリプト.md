# 7.シェルとシェルスクリプト

``` txt : シェル環境のカスタマイズ
・alias    :: エイリアスを設定するコマンド。
              本来のコマンドを実行したい場合は頭に「\(バックスラッシュ)」を付けて実行するか、パス付きで実行する。
              既に登録されている別名と同じ別名で再定義した場合、上書きされる。
・unalias  :: 設定したエイリアスを削除するコマンド。
・function :: bashシェル上で利用できる独自の関数を定義するためのコマンド。
・unset    :: 設定済みの環境変数やシェル変数を削除するコマンド。
・declare  :: 変数を宣言するコマンド。シェル関数の確認は「-f」。
・set      :: シェルの設定を確認、変更するコマンド。全てのシェル変数、シェル関数、環境変数を表示できる。
              パス名のワイルドカードによる展開（*や?）を無効に設定したい。[set -o noglob]
              リダイレクト「>」によるファイルの上書きを禁止にしたい。[set -o noclobber]
              シェルのオプションの設定状態を確認。[set -o]
・env      :: 設定されている環境変数の値を一時的に変更したり、削除したりしてコマンドを実行するコマンド。全ての環境変数も表示できる。
              一時的に削除するコマンドは「-u」
・printenv :: 指定した環境変数のみを表示するコマンド。未指定で全ての環境変数を表示する。
・/etc/bash.bashrc :: Debian系。bash起動時に実行させたい処理(エイリアス)を記述するファイル。
・/etc/bashrc      :: RedHat系。bash起動時に実行させたい処理(エイリアス)を記述するファイル。
・/etc/profile     :: Linuxの標準シェルであるbashの環境設定ファイル。ログイン後すぐに必要となる基本的な環境変数を設定する。
・~/.bash_profile  :: 各ユーザー個別の環境変数等を記述するファイル。ログイン時に実行される。  
・~/.bash_login    :: ~/.bash_profileがない場合、ログイン時に実行される。内容は~/.bash_profileと同じ。  
・~/.profile       :: ~/.bash_profileも~/.bash_loginもない場合、ログイン時に実行される。内容は~/.bash_profileと同じ。  
・~/.bashrc        :: 各ユーザー個別のbash起動時に実行させたい処理(エイリアス)等を記述するファイル。読み込む設定がない場合は読み込まれない。
・~/.bash_logout   :: bashログアウト時に実行させたい処理を記述するファイル。
・ログインシェル   :: /etc/passwdに設定され、ユーザーのログイン時に最初に起動されるシェル。このシェルが終了するとログアウトされる。  
・非ログインシェル :: ログインシェルから別のプロセスとして起動するシェル。コマンドラインから直接起動したシェル。  
・export           :: シェル変数を環境変数に変更するコマンド。
・bash :: Linuxの標準シェル
・sh :: 1977年にAT&Tベル研究所のスティーブン・ボーンにより開発された（Bourne Shell）
・ksh :: 1980年代初期にベル研究所のデビッド・コーンにより開発された（KornShell）
・csh :: BSD UNIXシステム上でビル・ジョイによってC言語をモデルとして開発された
・tcsh :: cshのバグを修正し、機能を拡張したもの

■ bashをログインシェルとして起動した場合の読み込み順  
1. /etc/profile     ← 絶対
2. /etc/bash.bashrc ← Debian系の場合、読み込む
3. ~/.bash_profile  ← 存在したら読み込む
4. ~/.bash_login    ← ~/.bash_profileが存在しないで、~/.bash_loginが存在したら読み込む
5. ~/.profile       ← ~/.bash_proflieも~/.bash_loginも存在しないで、~/.profileが存在したら読み込む
6. ~/.bashrc        ← ~/.bash_proflieと~/.bash_loginと~/.profileのどれかが存在して、かつ読み込む設定があれば読み込む
7. /etc/bashrc      ← ~/.bashrcを読み込んで、更に/etc/bashrcを読み込む設定があれば読み込む

■ bashを非ログインシェル(対話型シェル)として起動した場合の読み込み順  
1. /etc/bash.bashrc ← Debian系の場合、読み込む
2. ~/.bashrc        ← 絶対
3. /etc/bashrc      ← 読み込む設定があれば読み込む 

■bashにおける環境設定ファイル
・bashで実行できるシェルスクリプトである
・ログインシェル起動時に「/etc/profile」を最初に読み込む
・実行権は必要ない。(soueceコマンド、ファイルの読み取り権、ディレクトリの検索権[-x]があればよい。)
```

``` txt : シェルスクリプト
・コマンド置換 :: コマンドの実行結果をシェル変数に代入する機能。  
                  ・コマンドを「$()」で囲んで、その結果をシェル変数に代入する。  
                  ・コマンドをバッククオート「`」で囲んでその結果をシェル変数に代入する。  
・source  :: ファイルに書かれたコマンドを現在のシェルで実行する事を指示するコマンド。「.（ドット）」でも代用されます。
・exec    :: 指定したコマンドを既存のジョブ(シェルのプロセス)に置き換えて実行するコマンド。
             子プロセスを生成するのではなく、現行プロセスを引数で指定したコマンドに入れ替えて実行するコマンド。
・シバン(シェバング) :: スクリプトファイルの1行目「#!」の事。そのシェルスクリプトがどのインタープリタ（シェル）で実行されるかを記述します。
・$0      :: シェルスクリプトファイル名。  
・$1      :: 1番目の引数。※ 2番目の引数の場合は $2 と指定する。10番目以降は${10}のように「{}」で囲う。  
・「$$」  :: 現在のシェルのプロセス番号。文体がおかしくなるので、これだけかっこで囲ってます。
・$#      :: コマンドラインに与えられた引数の数  
・$?      :: シェルが最後に実行したコマンドの終了ステータス ( 0 = 正常終了、1 = 異常終了、それ以外はエラー ）  
・$@      :: 全ての引数 ( 区切りはスペース )  
・$*      :: 全ての引数 ( 区切りは環境変数IFSで指定したもの )  
・if文    :: if 条件式 then 実行文1 else 実行文2 fi
・case文  :: case 式 in 値1) 実行文1 ;; 値2) 実行文2 ;; ~~~ esac
・for文   :: for 変数名 in 変数に代入する値のリスト do 実行文 done
・while文 :: while 条件文 do 実行文 done
・read    :: ユーザーからの入力値を受け取り、変数に格納してそれを次の処理で使用したい場合に使用するコマンド。
・test    :: 条件分岐が行われる条件式の真偽を判断して、その結果を返すコマンド。
・seq     :: 連続した数値を自動的に生成するコマンド。
             [開始する数値 終了する数値],[終了する数値(1から開始)],[開始する数値 増加する値 終了する数値]
・&&      :: command1が成功した場合のみcommand2を実行する。  
・||      :: command1が失敗した場合のみcommand2を実行する。  
・;       :: コマンドを続けて実行する。  
```

## シェル環境のカスタマイズ

### aliasコマンド

エイリアスを設定するコマンド。  
コマンドの別名を定義したり、コマンドとそのオプションをまとめて1つの新しいコマンドとして実行できる。  

単一引用符で括っているのは、コマンドとオプションの間のスペースがシェルによって解釈されないようにするため。  
本来のコマンド名と同じエイリアスを定義した場合、エイリアス側が実行される。  
本来のコマンドを実行したい場合は頭に`\` or `バックスラッシュ`を付けて実行するか、パス付きで実行する。  
→`\ls` or `/bin/ls`  

``` txt
alias
登録されている全てのエイリアスが表示される。

alias [エイリアス名='コマンド']
エイリアスを登録する。
既に登録されている別名と同じ別名で再定義した場合、上書きされる。  
通常の場合はシングルクオート。
コマンドが2語以上になる場合は、シングルクォート（'）もしくはダブルクォート（"）で括る。  
```

`ls`と入力した時に`ls -l`コマンドが実行されるようにする。  
`alias ls = 'ls -l'`  

`ls -l`コマンドの実行結果を`less`コマンドで表示するエイリアス`lsless`を定義する。  
`alias lsless = 'ls -l | less'`

### unaliasコマンド

設定したエイリアスを削除するコマンド  

``` txt
unalias [オプション] 別名

オプション
-a :: 現在の登録内容を全て削除する。
```

上で定義した`lsless`コマンドを解除する。  
`unalias lsless`  

### functionコマンド

bashシェル上で利用できる独自のシェル関数を定義するためのコマンド。  
複雑なコマンドの組み合わせや条件分岐を行う場合等に使用する。  
単純なコマンドの組み合わせはエイリアスだが、それでは対応出来ない場合にfunctionを定義する。  

シェル関数はシェルスクリプトとは異なり、現在のシェルで動作します。  
例えば、シェル関数内でexitした場合、現在のシェルが終了します。  
シェルスクリプトを実行した場合は新たなシェル（サブシェル）を生成し、そのサブシェル上でシェルスクリプトは動作しますので、  
シェルスクリプト内でexitした場合はサブシェルが終了し、現在のシェルに戻ります。  

※関数が利用できるのは、その関数を定義したシェル内のみ。  
※bashはシェル変数とシェル関数を区別しないため、シェル関数はsetコマンドでも確認できる＆競合しないようにする必要がある。  
※定義済みの関数は「declare -f」コマンドで確認できる。  

``` txt
※1
function シェル関数名() { コマンド; }

※2
function
関数名()
{
    コマンド
}

※1の書式では「{」と「}」の間にはスペースが必要。  
※2の書式ではコマンドの後ろの「;」は不要。  

コマンド中には、関数の実行時に指定した引数を設定することもできます。実行時に指定した順に$1、$2 ... とすることで、引数の値を参照します。
```

例)指定したディレクトリの中にあるリンクファイルのみをリスト表示するlslink関数を定義する。  
`function lslink() { ls -l $1 | grep '^1' }`  
→  
1番目の引数は$1と表す。  
シンボリックリンクは行頭のファイル種別記号が「l」になるので、行頭のlを検索する。  

例）2つの引数を逆に表示するシェル関数reverseを作成する場合  
function reverse() { echo $2 $1; }

``` bash : 実行例
reverse a b
b a
```

### unsetコマンド

定義したシェル関数を削除するコマンド。  

``` txt
unset シェル関数名
```

シェル関数[lsmo]の削除  
`unset lsmo`  

### declareコマンド

変数を宣言するコマンド。  
定義済み変数や関数の定義内容も表示する。  
declare : 宣言する。  

``` txt
declare [オプション] [名前]
declare [オプション] [名前=値]

オプション
-f :: 現在定義されているシェル関数を全て表示する。
-F :: 現在定義されている関数名を全て表示する。
-p :: 現在定義されている変数を全て表示する。
-P :: 現在定義されている変数名を全て表示する。
```

### setコマンド

シェルの設定を確認、変更するコマンド。  
101の時は環境変数を確認するためのコマンドとして認識していた物。  

引数なしで実行した場合、表示できるもの :: 環境変数、シェル変数、シェル関数  
オプションの有効は「-」、オプションの無効は「+」。直観的な認識と逆なので注意。  

``` txt
set [-o][+o] [オプション]

-o :: オプション有効
+o :: オプション無効
シェルのオプションの設定状態を確認する :: 「set -o」

オプション
allexport :: 作成・変更した変数を自動的にエクスポートする。
emacs     :: emacs風のキーバインドにする。
ignoreeof :: Ctrl + Dによってログアウトしないようにする。
noclobber :: 出力リダイレクトによる上書きを禁止する。
noglob    :: メタキャラクタを使ったファイル名展開を無効にする。
             ワイルドカードによる展開(*や?)が無効になる。
noexec    :: シェルスクリプトを読み込むが、実行はせずに構文エラーのみを確認(検査)する。
             構文エラーはディスプレイに標準出力され、構文エラーがない場合もシェルスクリプトは実行されません。
             このオプションは対話的シェルでは無視されます。
vi        :: vi風のキーバインドにする。

※noclobberとnoglobが毎回わからない。
```

### envコマンド

設定されている環境変数の値を一時的に指定された値に変更してコマンド実行するコマンド。  
環境変数も表示できる。  

``` txt
env [オプション] [環境変数名=値] [コマンド]

オプション
-i               :: 何も環境変数が設定されていない状態にする。
-u 環境変数名    :: 環境変数を一時的に削除する。
環境変数名=値    :: 環境変数の値を一時的に指定された値に変更する。
(オプションなし) :: 全ての環境変数を表示する。
```

何も環境変数が設定されていない状態で、「sample.sh」というコマンド（スクリプト）を実行する。  
`env -i ./sample.sh`  
こうすることで、シェルを実行するときに、余計な環境変数に影響されることがなくなるのだろう。  

「TEST_A」という環境変数を一時的に「999」に変更して、「sample.sh」というコマンド（スクリプト）を実行  
`env TEST_A=999 ./sample.sh`  

### printenvコマンド

指定した環境変数のみを表示するコマンド。  
未指定の場合、全ての環境変数を表示する。  

### 環境変数早見表

``` txt
set        :: 全てのシェル変数、シェル関数、環境変数  
env        :: 環境変数  
printenv   :: 環境変数  
declare -f :: シェル関数
```

### bashの設定ファイル

シェルを起動するたびに環境変数やエイリアス、関数などを定義するのは非効率なので、それらの定義を自動的に行うための設定ファイルが用意されている。  

``` txt
適用範囲   | ファイル         | 読込ﾀｲﾐﾝｸﾞ   | 主な設定内容
全ユーザー | /etc/bash.bashrc | bash起動時   | Debian系。bash起動時に実行させたい処理(エイリアスなど)
           | /etc/bashrc      |     〃       | RedHat系。bash起動時に実行させたい処理(エイリアスなど)
           | /etc/profile     | ログイン時   | 環境変数、利用環境にかかわるもの
各ユーザー | ~/.bash_profile  |     〃       | 環境変数などユーザー環境に関わるもの
           | ~/.bash_login    |     〃       | ~/.bash_profileがない場合の読み込み次候補。内容は~/.bash_profileと同じ。
           | ~/.profile       |     〃       |  ~/.bash_profileも~/.bash_loginもない場合の読み込み次候補。内容は~./bash_profileと同じ。
           | ~/.bashrc        | bash起動時   | bash起動時に実行させたい処理(エイリアスなど)
           | ~/.bash_logout   | ログアウト時 | ログアウト時に実行させたい処理を記述する。


■ /etc/bash.bashrcファイル
Debian系。全ユーザー。  
bash起動時に実行させたい処理(エイリアス等)を記述するファイル。  

■ /etc/bashrcファイル
RedHat系。全ユーザー。  
bash起動時に実行させたい処理(エイリアス等)を記述するファイル。  

■ /etc/profileファイル
システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な環境変数を設定するファイル。  

■ ~/.bash_profileファイル
ユーザー独自の設定が格納されたファイル。ログインした場合、2番目に読みこまれる。  

■ ~/.bashrcファイル
対話型シェルが起動されるたびに実行される。  
システムを利用する全ユーザーに対する設定は/etc/bashrcに記述し、~/.bashrcから呼び出すようになっている。  
ログインシェルとしてbashが起動した際に、読みこむ設定がない場合は読みこまれない。  
その設定は`~/.bash_profile`に記述されているらしい。  

■ ~/.profileファイル
Bashあるいはshが読み取って実行するファイル。  
記述内容はシェル構文に従う。  
ファイルに読み取り権は必要。実行権は不必要。  
ホームディレクトリにあるので、rootユーザーは関係ない。  
ユーザーにのみファイルの読み取り件を付ける必要がある。→ない。  

■~/.bash_logoutファイル
bashログアウト時に実行させたい処理を記述するファイル。画面をクリアする clear コマンドなどを記述する。  
```

### ログインシェルと非ログインシェル(対話型シェル)

bashは起動のされ方によって扱いが変わります。  

・ログインシェル  
`/etc/passwd`に設定され、ユーザーのログイン時に最初に起動されるシェル。  
このシェルが終了するとログアウトされる。  

・非ログインシェル(対話型シェル)  
ログインシェルから別のプロセスとして起動するシェル。  
ユーザーがログインした後に、ターミナルエミュレーターを開くことで起動するシェルを実行したり、コマンドラインから直接起動したシェル。  
（例：直接/bin/bashを実行する）  

### 読み込み順

ログインシェルとしてbashが起動すると、環境変数の設定などユーザー環境にかかわるものが記述されている全ユーザー共通、また、各ユーザー個別の環境設定ファイルを読み込みます。  
これらのファイルはシェル上で実行できるコマンドが記述されたシェルスクリプトです。  

これらの設定ファイルはsourceコマンド（指定したシェルスクリプトを読み込み、現在のシェルで実行する）によって実行されており、  
ファイルに読み取り権とファイルが存在するディレクトリに検索権（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼ぶ）があれば実行可能です。  

``` txt : 読み込み順
■ bashをログインシェルとして起動した場合の読み込み順  
1. /etc/profile     ← 絶対
2. /etc/bash.bashrc ← Debian系の場合、読み込む
3. ~/.bash_profile  ← 存在したら読み込む
4. ~/.bash_login    ← ~/.bash_profileが存在しないで、~/.bash_loginが存在したら読み込む
5. ~/.profile       ← ~/.bash_proflieも~/.bash_loginも存在しないで、~/.profileが存在したら読み込む
6. ~/.bashrc        ← ~/.bash_proflieと~/.bash_loginと~/.profileのどれかが存在して、かつ読み込む設定があれば読み込む
7. /etc/bashrc      ← ~/.bashrcを読み込んで、更に/etc/bashrcを読み込む設定があれば読み込む

■ bashを非ログインシェル(対話型シェル)として起動した場合の読み込み順  
1. /etc/bash.bashrc ← Debian系の場合、読み込む
2. ~/.bashrc        ← 絶対
3. /etc/bashrc      ← 読み込む設定があれば読み込む
```

### おまけ : .bashrc とか .npmrc とかの「RC」って何？

[.bashrc とか .npmrc とかの「RC」って何？](https://neos21.net/blog/2017/02/15-02.html)  
>.bashrc とか .npmrc とかの「RC」とは、Run Commands の略。  
>どうも Run Control とか Resource Control の略、というのは誤りらしく、  
>Wikipedia やジャーゴンファイルでは、Run Commands が RunCom と略され、最終的に rc となったとされている。  

### おまけ : 代表的な環境変数

``` txt
HISTFILE     :: コマンド履歴保存ファイルのパス
HISTSIZE     :: 現在のシェルでコマンド履歴の保存数
HISTFILESIZE :: コマンド履歴保存ファイルへの履歴保存数
HOSTNAME     :: ホスト名
HOME         :: ログインしているユーザーのホームディレクトリ
LANG         :: ロケール(言語設定)
PATH         :: コマンドやプログラムを検索するディレクトリのリスト
PWD          :: カレントディレクトリパス
USER         :: ログインしているユーザー
```

echoコマンドを使用して環境変数の値を確認するには、変数の先頭に「$」をつけたものを引数に指定します。  

---

## シェルスクリプト

スクリプト(特定の処理を行うために作成したプログラム)をシェルプログラムで記述したもの。  
bashシェルを始め、シェルにはスクリプト言語によるプログラミング機能が備わっている。  
一連のコマンドライン作業を自動化する事ができる。  

バイナリ形式のコマンドは実行権のみで実行できるが、シェルスクリプトの場合は読み込み権限もないと実行できない。  
なお、シェルスクリプトの場合は`bash sample.sh`のようにしてシェルの引数として指定すれば、実行権がなくても読み込み権さえあれば実行できる。  

原則、スクリプトファイルの1行目にはそのシェルスクリプトがどのインタープリタ（シェル）で実行されるかを記述します。  
この「#!」は「シバン」または「シェバング」（shebang）と呼ばれるもので、「#!」が記述された行のことを「シバン（シェバング）行」ということもあります。  
ここに記述されたインタープリタは、次の行からのスクリプトを解釈して実行します。  

``` txt
書式：#!インタープリタ
```

以下はスクリプトをbashシェルで実行する場合の例です。  

``` txt
$ cat hoge.sh
#!/bin/bash
echo "Hello Ping-t Users."
```

シェルスクリプトを実行するには主に以下の方法があります。  

・sourceコマンドを使用  
指定したシェルスクリプトを読み込み、現在のシェルで実行するコマンドです。  
シェルスクリプトに実行権が無い場合でも実行できます。  
ただし、実行するシェルスクリプトに読み取り権と、シェルスクリプトが存在するディレクトリに検索権が必要です。  
（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼びます）  
なお、sourceコマンドは「.(ドット)」で代用できます。  

``` txt
$ source hoge.sh
または
$ . hoge.sh
```

・sh、bashコマンドを使用  
シェルを起動してシェルスクリプトを実行するコマンドです。  
sourceコマンドと同様に、シェルスクリプトに実行権が無い場合でも実行できます。  
ただし、実行するシェルスクリプトに読み取り権と、シェルスクリプトが存在するディレクトリに検索権が必要です。  
（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼びます）  

``` txt
$ sh hoge.sh
または
$ bash hoge.sh
```

・コマンドとして実行  
シェルスクリプトに実行権がある場合、シェルスクリプトはコマンドのように実行できます。  
ただし、パスが通っていない場合は、絶対パスまたは相対パスでシェルスクリプトを指定する必要があります。  
またこの場合、シェルスクリプトはサブシェル内で実行されます。  
サブシェルとは現在のシェルから新たに生成されたシェルのことです。  

``` txt
$ /home/test/hoge.sh （絶対パスで指定）
または
$ ./hoge.sh （「/home/test」ディレクトリから相対パスで指定）
または
$ hoge.sh （パスが通っている場合）

$ ./hoge.sh （相対パスで指定した場合）
Hello Ping-t Users.
```

### シェルスクリプトの実行方法

1. bashコマンドを使う。  
   `bash testing.sh`  
2. soueceコマンドを使う。  
   `source testing.sh`  
3. スクリプトファイルの前に省略記号「.」を入力して実行する。  
   `. testing.sh`  
4. ファイルに実行権を付与してファイル名を指定して実行する。  
   `chmod a+x test.sh`  
   `./testing.sh`  

4番目に関して  
カレントディレクトリにあるスクリプトを実行するために「./」を付ける必要があるのは、  
そのディレクトリにパスが通っていない(変数PATHにそのディレクトリが含まれていない)場合。  
パスの通っているディレクトリ内にあるスクリプトファイルは「./」を付けなくても実行できる。  
変数PATHに「.」を追加する事はセキュリティ上のリスクをはらむらしい。  

`実行権`がないシェルスクリプトを実行するには、`source`コマンドを使用する。  
但し`source`コマンドを実行するには、シェルスクリプトに`読み取り権`と、シェルスクリプトが存在するディレクトリに`検索権`が必要。  
`source`コマンドは「.(ドット)」で代用できる。  

設定を即座に反映させるには、現在のシェルでスクリプトを実行できるsourceコマンドを使用します。  

### コマンド置換

bashにはコマンドの実行結果を文字列として扱う「コマンド置換」機能があります。  
コマンド置換は次の書式で実行します。  

・`実行コマンド`（バッククォート、日本語キーボードではSHIFT+@）  
・$(実行コマンド)  

`$echo $HOSTNAME`  
→`testserver.localdomain`  
`$ echo $(echo $HOSTNAME)`  
→`testserver.localdomain`  

### sourceコマンド

sourceコマンドからシェルスクリプトを実行すると、現在のシェルで直接シェルスクリプトを実行します。  
シェルの環境設定をシェルスクリプトで行う場合に使われます。  
sourceコマンドは「.（ドット）」でも代用されます。  

ファイルに書かれたコマンドを現在のシェルで実行する事を指示するコマンド。  
主にシェルの設定を反映させる際に使用する。  

sourceコマンドはシェルに組み込まれたビルトインコマンドで、bashやtcsh,zshに共通して使用できる。  
sourceコマンド（または「.（ドット）」）はスクリプトの実行権限がなくても実行できます。  

``` txt
source ファイル [ファイル実行時の引数]
or
. ファイル [ファイル実行時の引数]

オプションはない。
```

bash ファイル名  
ファイル名  

で実行した場合はbashの子プロセスが立ちあがり、  

### execコマンド

子プロセスを生成するのではなく、現行プロセスを引数で指定したコマンドに入れ替えて実行するコマンド。  
bashの組み込みコマンド。  
指定したコマンドを既存のジョブ(シェルとプロセス)と置き換えて実行するコマンドとも言えるらしい。  

### シェルスクリプトの特殊変数

シェル変数とも言うらしい。  

``` txt
$0    :: シェルスクリプトファイル名  
$1    :: 1番目の引数。※ 2番目の引数の場合は $2 と指定する。  
「$$」:: 現在のシェルのプロセス番号。文体がおかしくなるので、これだけかっこで囲ってます。
$#    :: コマンドラインに与えられた引数の数  
$?    :: シェルが最後に実行したコマンドの終了ステータス ( 0 = 正常終了、1 = 異常終了、それ以外はエラー ）  
$@    :: 全ての引数 ( 区切りはスペース )  
$*    :: 全ての引数 ( 区切りは環境変数IFSで指定したもの )  
```

シェルスクリプトの実行後 `echo $?` と実行して 0 が帰ってくるならスクリプトが正常終了したことが分かる。  
bashのプロンプトで`echo $$`を実行した場合のプロセスIDはシェル自身のプロセスIDが格納される。  

10番目以降の引数を参照する時は${10}のように「{}」で囲う必要があります。  
「{}」を使用しないとシェルは「$1 + "0"」のように誤った解釈をします。  
そのため、$10および$11はそれぞれ「a0」と「a1」のように表示されます（aは1番目の引数）。  

### if文

``` sh
if 条件式
then
    実行文1
else
    実行文2
fi
```

### case文

``` sh
case 式 in
    値1)
        実行文1 ;;
    値2)
        実行文2 ;;
    ~~~
esac
```

case式はforeachでないくせに[in]であることに注意。  
実行文の最後は[;]ではなく[;;]であることに注意。  
最後はcaseの反対文字(esac)になるタイプであることに注意。  

### for文

``` sh
for 変数名 in 変数に代入する値のリスト
do
    実行文
done
```

### while文

``` sh
while 条件文
do
    実行文
done
```

``` sh
while read USERNAME
do
    useradd $USERNAME
    echo $USERNAME | passwd --stdin $USERNAME
done < $1
```

### readコマンド

ユーザーからの入力値を受け取り、変数に格納してそれを次の処理で使用したい場合に使用するコマンド。  
キーボードからの入力を受け付けて、それを後の処理でも使いまわすという性質上、シェルスクリプトで使われるコマンド。  

``` txt
read [オプション] 変数名
```

``` sh
echo -n " あなたのお名前は? "
read yourname
echo " こんにちは、$yourname さん "
```

``` sh
read a b c <<END
1 2 3 4 5 6
END
```

格納変数は複数定義可能。  
上記例の場合、a=1,b=2,C=3 4 5 6 となる。  
そういう仕様らしい。  

### testコマンド

条件分岐が行われる条件式の真偽を判断して、その結果を返すコマンド。  
条件が満たされた場合は真(0)、満たされない場合は偽(1)を返す。  
エラーの場合、0や1ではない何かが返される模様。  
主にシェルスクリプト内部で使用する。  

``` txt
test 条件式
or
[ 条件式 ]
※「[]」はtestコマンドと同じコマンド。「[」の後ろと「]」の前にはスペースが必要

[ファイルの形式に関する条件式]
-d ディレクトリ名  :: 指定したディレクトリがあれば真
-f ファイル名      :: 指定したファイルが通常ファイルであり、存在すれば真
-s ファイル        :: 指定したファイルのサイズが0より大きいファイルであれば真
-L ファイル        :: 指定したファイルがシンボリックリンクであるファイルであれば真

[ファイルの権限に関する条件式]
-r ファイル :: 指定したファイルが存在して、かつ読み込み可能であれば真
-w ファイル :: 指定したファイルが存在して、かつ書き込み可能であれば真
-x ファイル :: 指定したファイルが存在して、かつ実行可能であれば真

[ファイルの特性に関する条件式]
-e ファイル             :: 指定したファイルが存在すれば真。ファイルでもディレクトリでも真となる。
ファイル1 -nt ファイル2 :: 指定したファイル1が指定したファイル2よりも修正時刻が正しければ真(newer than)
ファイル1 -ot ファイル2 :: 指定したファイル1が指定したファイル2よりも修正時刻が古ければ真(older then)

[文字列に関する条件式]
-n 文字列          :: 文字列の長さが0より大きければ真
-z 文字列          :: 文字列の長さが0であれば真
文字列1 = 文字列2  :: 文字列1と文字列2が等しければ真
文字列1 != 文字列2 :: 文字列1と文字列2が等しくなければ真

[数値に関する条件式]
数値1 -eq 数値2 :: 数値1と数値2が等しければ真
数値1 -ne 数値2 :: 数値1と数値2が等しくなければ真
数値1 -ge 数値2 :: 数値1が数値2よりも大きい、または等しければ真
数値1 -gt 数値2 :: 数値1が数値2よりも大きければ真
数値1 -le 数値2 :: 数値1が数値2よりも小さい、または等しければ真
数値1 -lt 数値2 :: 数値1が数値2よりも小さければ真

[論理結合に関する条件式]
!条件          :: 条件式が偽であれば真
条件1 -a 条件2 :: 条件1と条件2の両方の条件式が真であれば真
条件1 -o 条件2 :: 条件1と条件2のどちらかの条件式が真であれば真
```

### seqコマンド

連続した数値を自動的に生成するコマンド。  
主にシェルスクリプトで使用する。  

``` txt
seq 開始する数値 終了する数値
seq 終了する数値(1から開始)
seq 開始する数値 増加する値 終了する数値

※スペースで区切る。「-」などの記号は不要。
※seqコマンドの代わりに「{1..5}」のように範囲を指定してもOK
```

1,2,3,4,5をforで出力する。  
→  
`seq 1 5` or `seq 5` or `seq 1 1 5`  

`seq 1-5` or `seq 1 to 5`は間違いだから注意ね。  

### 制御演算子

`&&` :: command1が成功した場合のみcommand2を実行する。  
`||` :: command1が失敗した場合のみcommand2を実行する。  
`;` :: コマンドを続けて実行する。  

制御演算子との間にスペースは無くて良い模様。  

command1を実行し、続けてcommand2を実行させたい。ただし、command1が失敗した場合はcommand2を実行しないこととする。下線部にあてはまる語句は次のうちどれか。  
→  
&&  

---

## 小豆本問題

---

### 1 ○

エイリアスを解除することなく、一時的にエイリアスを無効にして、オプションなしのlsコマンドを実行したい場合どうすればいいか。  

→  
E.コマンドの直前に「\」をつけて実行する。  

→  
まぁ、やったばっかしだからね。  

---

### 2 ○

一連のコマンドを実行するlslink()関数を作成したい場合、関数作成には何というコマンドを使うか？

→  
function  

（　＾ω＾）・・・  
`function lslink() { ls -l | grep '^l'; }`  

---

### 3 ○

システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な環境変数を設定しておきたい場合、どの設定ファイルに設定を記述するのが適切か？  

→
A. /etc/profile  

よく、問題文を読んでみれば、これしかない。  
基本的な環境変数の設定ファイルはprofileか。  

---

### 4 ×

次のスクリプトを実行した際、変数「$#」に入る値を選択してください。  
`$ ./testscript args1 args2`

→
・変数「$#」に入る値→引数の数。
・$0 には ./testscript
・$1 には args1
・$2 には args2

---

### 5 ×

bashシェルスクリプトで、`test -x file_a`と同じ動作をするものを選択してください。  

→  
B. [-x file_a]  

souece , .はスクリプトの実行  
functionは関数を作成するコマンド。  
scriptコマンドは存在するか知らない。  
消去法でB.

当たった。

→
testコマンドは[~]の形式でも使われる。  
というか大半は[~]形式で使われる模様。  

---

### 6 ×

以下は、端末から名前を入力すると、その名前を使って挨拶を返すシェルスクリプトです。  

``` sh
echo -n "Enter your name:"
______ name
echo "Hello,$name!"
```

→  
read  

全体を一周する前にやった問題だから間違った。  
答えはシェルスクリプト内部でキーボード入力を受け付けるコマンドであるreadです。  
C#に置けるConsole.Readですね。  
