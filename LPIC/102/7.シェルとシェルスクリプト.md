# 7.シェルとシェルスクリプト

## シェル環境のカスタマイズ

### aliasコマンド

エイリアスを設定するコマンド。  
コマンドの別名を定義したり、コマンドとそのオプションをまとめて1つの新しいコマンドとして実行できる。  

``` txt
alias 別名 = `コマンド`
```

- 単一引用符で括っているのは、コマンドとオプションの間のスペースがシェルによって解釈されないようにするため。  
- 本来のコマンド名と同じエイリアスを定義した場合、エイリアス側が実行される。  
- 本来のコマンドを実行したい場合は頭に`\`を付けて実行するか、パス付きで実行する。  
  →`\ls` or `/bin/ls`  

`ls`と入力した時に`ls -l`コマンドが実行されるようにする。  
`alias ls = 'ls -l'`  

`ls -l`コマンドの実行結果を`less`コマンドで表示するエイリアス`lsless`を定義する。  
`alias lsless = 'ls -l | less'`

### unaliasコマンド

設定したエイリアスを削除するコマンド  

``` txt
unalias [オプション] 別名

オプション
-a → 現在の登録内容を全て削除する。
```

上で定義した`lsless`コマンドを解除する。  
`unalias lsless`  

### functionコマンド

bashシェル上で利用できる独自の関数を定義するためのコマンド。  
複雑なコマンドの組み合わせや条件分岐を行う場合等に使用する。  
単純なコマンドの組み合わせはエイリアスだが、それでは対応出来ない場合にfunctionを定義する。  

※定義された関数はシェル内部で実行されるため、子プロセスは生成しない。  

``` txt
※1
function シェル関数名() { コマンド; }

※2
function
関数名()
{
    コマンド
}
```

- ※1の書式では`{`と`}`の間にはスペースが必要。  
- ※2の書式ではコマンドの後ろの`;`は不要。  
- 関数が利用できるのは、その関数を定義したシェル内のみ。  
- bashでは変数名と関数名を区別しないので競合しないようにする必要がある。  

例:  
指定したディレクトリの中にあるリンクファイルのみをリスト表示するlslink関数を定義する。  

`function lslink() { ls -l $1 | grep '^1' }`  
1番目の引数は$1と表す。  
シンボリックリンクは行頭のファイル種別記号が「l」になるので、行頭のlを検索する。  

### unsetコマンド

定義したシェル関数を削除するコマンド。  

``` txt
unset シェル関数名
```

- シェル関数[lsmo]の削除  
  `unset lsmo`  

### declareコマンド

変数を宣言するコマンド。  
定義済み変数や関数の定義内容を表示する。  
declare : 宣言する。  

``` txt
declare [オプション] [名前]
declare [オプション] [名前=値]

オプション
-f → 現在定義されている関数を全て表示する。
-F → 現在定義されている関数名を全て表示する。
-p → 現在定義されている変数を全て表示する。
-P → 現在定義されている変数名を全て表示する。
```

### setコマンド

### bashの設定ファイル

シェルを起動するたびに環境変数やエイリアス、関数などを定義するのは非効率なので、それらの定義を自動的に行うための設定ファイルが用意されている。  

/etc/profile → ログイン時に実行され、全ユーザーから参照される。  
/etc/bash.bashrc → bash起動時に実行され、全ユーザーから参照される。  
/etc/bashrc → ~/.bashecから参照される。  
~/.bash_profile → ログイン時に実行される。  
~/.bash_login → ~/.bash_profileがない場合、ログイン時に実行される。  
~/.profile → ~/.bash_profileも~/.bash_loginもない場合、ログイン時に実行される。  
~/.bashrc → bash起動時に実行される。  
~/.bash_logout → ログアウト時に実行される。  

### /etc/profileファイル

bashのログイン時に実行される。  
システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な環境変数を設定していくファイル。  

### ~/.bash_profileファイル

### ~/.bashrcファイル

### 読み込み順

---

## シェルスクリプト

スクリプト(特定の処理を行うために作成したプログラム)をシェルプログラムで記述したもの。  
bashシェルを始め、シェルにはスクリプト言語によるプログラミング機能が備わっている。  
これがシェルスクリプト。  

一連のコマンドライン作業を自動化する事ができる。  

Web連携のログを抜き出すアレと言えば話は早いだろう。  

### シェルスクリプトの実行方法

1. bashコマンドを使う。  
   `bash testing.sh`  
2. soueceコマンドを使う。  
   `source testing.sh`  
3. スクリプトファイルの前に省略記号「.」を入力して実行する。  
   `. testing.sh`  
4. ファイルに実行権を付与してファイル名を指定して実行する。  
   `chmod a+x test.sh`  
   `./testing.sh`  

4番目に関して  
カレントディレクトリにあるスクリプトを実行するために「./」を付ける必要があるのは、  
そのディレクトリにパスが通っていない(変数PATHにそのディレクトリが含まれていない)場合。  
パスの通っているディレクトリ内にあるスクリプトファイルは「./」を付けなくても実行できる。  
変数PATHに「.」を追加する事はセキュリティ上のリスクをはらむらしい。  

### コマンドの実行結果をシェル変数に代入する方法  

- コマンドを`$()`で囲んで、その結果をシェル変数に代入する。  
- コマンドをバッククオート「`」で囲んでその結果をシェル変数に代入する。  

### sourceコマンド

### execコマンド

子プロセスを生成するのではなく、現行プロセスを引数で指定したコマンドに入れ替えて実行するコマンド。  
bashの組み込みコマンド。  

### シェルスクリプトの特殊変数

``` txt
$0 → シェルスクリプトファイル名  
$1 → 1番目の引数。※ 2番目の引数の場合は $2 と指定する。  
\$$ → 現在のシェルのプロセス番号  
$# → コマンドラインに与えられた引数の数  
$? → シェルが最後に実行したコマンドの終了ステータス ( 0 = 正常終了、1 = 異常終了、それ以外はエラー ）  
$@ → 全ての引数 ( 区切りはスペース )  
$* → 全ての引数 ( 区切りは環境変数IFSで指定したもの )  
```

シェルスクリプトの実行後 `echo $?` と実行して 0 が帰ってくるならスクリプトが正常終了したことが分かる。  

### if文

``` txt
if 条件式
then
    実行文1
else
    実行文2
fi
```

### case文

``` txt
case 式 in
    値1)
        実行文1 ;;
    値2)
        実行文2 ;;
    ~~~
esac
```

### for文

``` txt
for 変数名 in 変数に代入する値のリスト
do
    実行文
done
```

### while文

``` txt
while 条件文
do
    実行文
done
```

``` sh
while read USERNAME
do
    useradd $USERNAME
    echo $USERNAME | passwd --stdin $USERNAME
done < $1
```

### readコマンド

ユーザーからの入力値を受け取り、変数に格納してそれを次の処理で使用したい場合に使用するコマンド。  
キーボードからの入力を受け付けて、それを後の処理でも使いまわすという性質上、シェルスクリプトで使われるコマンド。  

``` txt
read [オプション] 変数名
```

``` sh
echo -n " あなたのお名前は? "
read yourname
echo " こんにちは、$yourname さん "
```

### testコマンド

条件分岐が行われる条件式の真偽を判断して、その結果を返すコマンド。  
条件が満たされた場合は真(0)、満たされない場合は偽(1)を返す。  
エラーの場合、0や1ではない何かが返される模様。  
主にシェルスクリプト内部で使用する。  

``` txt
test [条件文]

[ファイルの形式に関する条件式]
-d ディレクトリ名 → 指定したディレクトリがあれば真
-f ファイル名 → 指定したファイルが通常ファイルであり、存在すれば真
-s ファイル → 指定したファイルのサイズが0より大きいファイルであれば真
-L ファイル → 指定したファイルがシンボリックリンクであるファイルであれば真

[ファイルの権限に関する条件式]
-r ファイル → 指定したファイルが存在して、かつ読み込み可能であれば真
-w ファイル → 指定したファイルが存在して、かつ書き込み可能であれば真
-x ファイル → 指定したファイルが存在して、かつ実行可能であれば真

[ファイルの特性に関する条件式]
-e ファイル → 指定したファイルが存在すれば真
ファイル1 -nt ファイル2 → 指定したファイル1が指定したファイル2よりも修正時刻が正しければ真
ファイル1 -or ファイル2 → 指定したファイル1が指定したファイル2よりも修正時刻が古ければ真

[文字列に関する条件式]
-n 文字列 → 文字列の長さが0より大きければ真
-z 文字列 → 文字列の長さが0であれば真
文字列1 = 文字列2 → 文字列1と文字列2が等しければ真
文字列1 != 文字列2 → 文字列1と文字列2が等しくなければ真

[数値に関する条件式]
数値1 -eq 数値2 → 数値1と数値2が等しければ真
数値1 -ne 数値2 → 数値1と数値2が等しくなければ真
数値1 -ge 数値2 → 数値1が数値2よりも大きい、または等しければ真
数値1 -gt 数値2 → 数値1が数値2よりも大きければ真
数値1 -le 数値2 → 数値1が数値2よりも小さい、または等しければ真
数値1 -lt 数値2 → 数値1が数値2よりも小さければ真

[論理結合に関する条件式]
!条件 → 条件式が偽であれば真
条件1 -a 条件2 → 条件1と条件2の両方の条件式が真であれば真
条件1 -o 条件2 → 条件1と条件2のどちらかの条件式が真であれば真
```

### seqコマンド

連続した数値を自動的に生成するコマンド。  
主にシェルスクリプトで使用する。  

``` txt
seq 開始数値 終了数値
seq 終了数値
```

---

## 小豆本問題

---

### 1 ○

エイリアスを解除することなく、一時的にエイリアスを無効にして、オプションなしのlsコマンドを実行したい場合どうすればいいか。  

→  
E.コマンドの直前に「\」をつけて実行する。  

→  
まぁ、やったばっかしだからね。  

---

### 2 ○

一連のコマンドを実行するlslink()関数を作成したい場合、関数作成には何というコマンドを使うか？

→  
function  

（　＾ω＾）・・・  
`function lslink() { ls -l | grep '^l'; }`  

---

### 3 ○

システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な環境変数を設定しておきたい場合、どの設定ファイルに設定を記述するのが適切か？  

→
A. /etc/profile  

よく、問題文を読んでみれば、これしかない。  
基本的な環境変数の設定ファイルはprofileか。  

---

### 4 ×

次のスクリプトを実行した際、変数「$#」に入る値を選択してください。  
`$ ./testscript args1 args2`

→
・変数「$#」に入る値→引数の数。
・$0 には ./testscript
・$1 には args1
・$2 には args2

---

### 5 ×

bashシェルスクリプトで、`test -x file_a`と同じ動作をするものを選択してください。  

→  
B. [-x file_a]  

souece , .はスクリプトの実行  
functionは関数を作成するコマンド。  
scriptコマンドは存在するか知らない。  
消去法でB.

当たった。

→
testコマンドは[~]の形式でも使われる。  
というか大半は[~]形式で使われる模様。  

---

### 6 ×

以下は、端末から名前を入力すると、その名前を使って挨拶を返すシェルスクリプトです。  

``` sh
echo -n "Enter your name:"
______ name
echo "Hello,$name!"
```

→  
read  

全体を一周する前にやった問題だから間違った。  
答えはシェルスクリプト内部でキーボード入力を受け付けるコマンドであるreadです。  
C#に置けるConsole.Readですね。  
