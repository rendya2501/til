# 10.必須システムサービス

---

## システムクロックの設定

### ハードウェアクロック

PCにハードウェアとして内臓された時計。  
電源がオフの状態でも動作する。(PC内に取り付けられた電池で動作する)  

### システムクロック

Linuxカーネル内に存在する時計。  
Linux起動時にハードウェアクロックを参照して設定されるが、その後は別々に動く。  
そのため、起動してから時間が経過するにつれ、ハードウェアクロックと差が生じる。  

### dateコマンド

システムクロックを表示するコマンド。  
rootユーザーはdateコマンドを使ってシステムクロックを変更できる。  

``` txt
現在の日付を表示する。
date

引数を「+」で始めると、指定した書式で表示する。
%Y :: 年
%m :: 月(01~12)
%d :: 日(01~31)
%H :: 時(00~23)
%M :: 分(00~59)
%a :: 曜日
%b :: 月名

-u,--universal,--utc :: 協定標準時を表示する。  

システムクロックを変更する。
date [MMDDhhmm[[CC]YY][.ss]]

MM :: 月
DD :: 日
hh :: 時
mm :: 分
CC :: 西暦の上2桁
YY :: 西暦の下2桁
ss :: 秒
```

システムクロックを2018年12月10日20時に設定する。  
`sudo date 121020002018`  

「年/月/日(曜日)」の書式で表示する。  
`date "+%Y/%m/%d (%a)"`  
2018/12/10 (月)  

※バックアップをする時に``tar czf `date +"+%Y%m%d"`.tar.gz/data``というコマンドが自動的に実行されるようにしておけば、  
「20181210.tar.gz」のように、バックアップを実行した日付入りのアーカイブファイルを作成する事ができる。  

cfz → create file zip  

### hwclockコマンド

ハードウェアクロックの参照や設定を行うコマンド  

``` txt
hwclock オプション

-r :: ハードウェアクロックを表示する。
-w(--systohc) :: システムクロックの時刻をハードウェアクロックに設定する。
-s(--hctosys) :: ハードウェアクロックの時刻をシステムクロックに設定する。
-u :: utcを指定する。
```

### timedatectlコマンド

日付と時刻、タイムゾーンを管理するコマンド。  
systemdを採用したディストリビューションで使用可能。  
コマンドのみを実行した場合、現在の日時、タイムゾーン、NTPを利用しているかどうかを表示する。  

``` txt
timedatectl [サブコマンド]

status :: 現在の状態を表示する(デフォルト)
set-time 時刻 :: 時刻を設定する(HH:MM:SS)
set-time 日付 :: 日付を設定する(YYYY-MM-DD)
set-time 日付 時刻 :: 日付と時刻を設定する(YYYY-MM-DD HH:MM:SS)
set-timezone タイムゾーン :: タイムゾーンを設定する
list-timezones :: タイムゾーン一覧を表示する
set-ntp yes|no :: NTPを使うかどうか
```

日時を2019年3月12日12時24分に設定する。  
`timedatectl set-time 2019-03-12 12:24:00`  

タイムゾーンを「Asia/Tokyo」に設定する。  
`timedatectl set-timezone Asia/Tokyo`  

### NTP(Network Time Protocol)

ハードウェアクロックもシステムクロックも残念ながらあまり正確ではない。  
正確な時刻を設定するためには、ネットワーク経由でクロックを同期するプロトコルであるNTPを使い、インターネット上にあるNTPサーバー(タイムサーバー)から正確な時刻を取得する。  

NTPネットワークは階層構造になっている。  
最上位は原子時計やGPSなど、きわめて正確な時刻情報の提供元がある。  
その直下にあるNTPサーバーをStratum1。
その次をStratum2。
数字は階層を下るに従って増えていく。  
NTPサーバーは上位の複数のNTPサーバーから正確な時刻を取得する。  

NTPクライアントによるNTPサーバーとの時刻同期にはroot権限が必要。  

### ntpdateコマンド

指定したNTPサーバーから現在時刻を取得するコマンド。  

``` txt
ntpdate [オプション] NTPサーバー名

-q :: NTPサーバーとシステムクロックの差分(offset)を確認する。
```

NTPサーバーtime.sercer.lpic.jpから現在時刻を取得する。  
`ntpdate time.server.lpic.jp`  

NTPサーバー(ntp.nict.jp)を使ってシステム時計との差分を確認する。
`ntpdate -q ntp.nict.jp`  

### NTPサーバー

NTPサーバーは自前で運用することができる。  
組織内にNTPクライアントが多い場合は用意したほうが都合がよい。  

ntpdはNTPバージョン3互換のデーモン。  
stratum上位の外部NTPサーバーの時刻を参照してシステムクロックの時刻同期を行い、  
このシステムクロックにより外部ホストに対して時刻同期のサービスを提供するNTPサーバーとなる。  

SysVinitを採用したシステムでのNTPサーバーの起動方法  
`/etc/init.d/ntpd start`  

systemdを採用したシステムでのNTPサーバーの起動方法  
`systemctl start ntpd.service`  

NTPサーバーの設定は`/etc/ntp.conf`で行う。(NTPデーモンが参照する設定ファイル)  
補正情報(クロックの誤差を予測した数値)は、`/etc/ntp.drift`に保存される。  
ディストリビューションによっては`/var/lib/ntp/drift`や`/var/lib/ntp/ntp.drift`になっていることもある。  

``` txt : /etc/ntp.confファイルの例
server 0.jp.pool.ntp.org ← 1番目のNTPサーバー
server 1.jp.pool.ntp.org ← 2番目のNTPサーバー
server 2.jp.pool.ntp.org ← 3番目のNTPサーバー
server 3.jp.pool.ntp.org ← 4番目のNTPサーバー
driftfile /etc/ntp.drift ← 補正情報ファイルの指定
logfile /var/log/ntp.log ← ログファイルの設定
```

この設定例では、複数のNTPサーバーをまとめて仮想的なNTPサーバーとして運用している。  
0.jo.pool.ntp.orgにDNSで問い合わせすると、いくつかのNTPサーバーの中から1つのIPアドレスがランダムに帰ってくる。  
このようにして特定のNTPサーバーに負荷が集中しないようにしている。  

左の項目はコンフィグレーションコマンドと言うらしい。  
serverはNTPデーモンを外部NTPサーバーの刷れーにするための項目ともいえるらしい。  

### ntpqコマンド

NTPサーバーの状態を紹介するコマンド。  

localhostで稼働しているNTPサーバーから問い合わせされているNTPサーバーのリストを表示する。
`ntpq -p localhost`  

### Chrony

ntpd/ntpdate の代替となるNTPサーバー/クライアントソフトウェア。  
デーモンプロセス:`chronyd` と クライアントコマンド:`chronyc` から構成される。  
設定ファイル : `/etc/chrony.conf`  

``` conf : /etc/chrony.confの設定例
# NTPサーバーを指定
server 0.centos.pool.ntp.org iburst
server 1.centos.pool.ntp.org iburst
server 2.centos.pool.ntp.org iburst
server 3.centos.pool.ntp.org iburst

# 補正情報ファイルを指定
driftfile /var/lib/chrony/drift

# ハードウェアクロックと同期させる
rtcsync

# ログファイルを指定
logdir /var/log/chrony
```

### chronycコマンド

chronydの管理を行うコマンド  
chronycコマンド単体で実行した場合、対話モードでの操作となる。  

``` txt
chronyc [サブコマンド]

activity :: NTPサーバーのオンライン/オフライン数を表示する。
sources :: 時刻ソースの情報を表示する。
sourcestats :: 時刻ソースの統計情報を表示する。
tracking :: トラッキングを確認する。
quit :: 対話状態を終了する。
```

時刻ソースとなるNTPサーバー毎の情報を表示する。  
`chronyc sources`  

---

## システムログの設定

Linuxでは、**syslog**と呼ばれるプログラムを使用することによってLinuxで発生する各種イベントをログファイルに出力したりコンソールに出力することが可能となります。  
syslogのプログラムは、**syslogd**というデーモンにより実行される。  
syslogは他のプログラムからのメッセージを受信して、出力元や優先度に従って分類を行って、syslogで定義した出力先に送信する。  

### syslog,rsyslog

CentOS6以降のディストリビューションではrsyslogが採用されている場合がある。  
rsyslogは各種機能をプラグインモジュールで拡張できるようになっている。  
ログの出力方式などは/etc/syslog.confファイルの書式とほぼ同じ。  
linucイージスではsyslog,小豆本ではrsyslogを解説しているのでどちらもまとめる。  

syslogの設定  
`/etc/syslog.conf`設定ファイルで行う。  

rsyslogの設定  
`/etc/rsyslog.conf`設定ファイル or `etc/rsyslog.d`設定ディレクトリで行う。  

### /etc/rsyslog.conf

rsyslog.confファイルは「モジュール設定部分」「グルーバル設定部分」「ルール設定部分」が主たる設定項目になる。  
`#`で始まる行はコメント行。  

モジュールプラグインのデフォルトは[imuxsock] [imklog]のみ有効になっている。  

``` txt : rsyslogの主なプラグインモジュール
imuxsock :: UNIXソケットによるローカルロギングサポート(loggerコマンドなど)
imjournal :: systemdのジャーナルサポート
imklog :: カーネルログのサポート
immark :: マークを出力(--MARK--)
imudp :: UDPでメッセージを受信
imtcp :: TCPでメッセージを受信
```

どのようなメッセージをどこに出力するか？といった設定はルール設定部分および、/etc/rsyslog.dディレクトリ以下の～.confファイルで設定する。  

rsyslog.confファイルの書式 :: `ファシリティ.プライオリティ 出力先`  

### ファシリティ

メッセージの生成元を表す。  
具体的にはカーネルや実行中のプロセス。  
[*]を使うとすべてのファシリティを選択できる。  

``` txt : ファシリティ
auth,authpriv :: 認証システム(loginなど)による出力
cron :: cronによる出力
deamon :: 各種デーモンによる出力
kern :: カーネルによる出力
lpr :: 印刷システムによる出力
mail :: メールサービス関連による出力
user :: ユーザーアプリケーションによる出力
syslog :: syslog機能
local0~local7 :: ローカルシステムの設定
```

### プライオリティ

メッセージの重要度を表す。  
低く設定すればするほど、ログとして出力される情報量も多くなる。
[*]を使うとすべてのプライオリティを選択できる。  
noneだけは例外で、指定されたファシリティのログを除外する役割を持つ。  

emergが最も高く、debugが最も低い。  
指定したプライオリティよりもレベルが高いものがすべて記録される。  
critならalertとemergも含まれる。  
特定のプライオリティを指定したい場合、プライオリティの前に[=]を付ける。  

``` txt : プライオリティ
emerg :: 緊急事態
alert :: 早急に対処が必要な事態
crit :: システムの処理は継続できるものの深刻な事態
err :: 一般的なエラー
warning :: 一般的な警告
notice :: 一般的な通知
info :: 一般的な情報
debug :: デバッグ情報
none :: ログを記録しない
```

### 出力先

出力先として、ログファイルやユーザーの端末、他のホスト等を選択できる。  
この部分を「アクションフィールド」と言う。  

``` txt : アクションフィールド
ファイル名 :: ファイルへの出力
ユーザー名 :: ユーザーの端末への出力
@ホスト名 :: リモートホストのsyslogへUDPで出力
@@ホスト名 :: リモートホストのsyslogへTCPで出力
/dev/tty1 :: コンソール(rrt1)に出力
/dev/console :: コンソールへの出力
* :: ログイン中のすべてのユーザーの端末に出力

/var/log/messages :: ログファイルに出力
@sv.example.com :: ホストsv.sxample.comにUDPで出力
@@sv.example.com :: ホストsv.example.comにTCPで出力
violet :: ユーザーvioletの端末に出力
```

※因みにファシリティとプライオリティを合わせて「セレクタフィールド」という。  
セレクタフィールドは「;」区切り文字で複数を列挙できる。  

### 記述例のオンパレード

crit,alert,emergレベルのメール関連のログを/var/log/mailファイルに記録  
`mail.crit /var/log/mail`  

critレベルのメール関連のログを/var/log/mailファイルに記録  
`mail.=crit /var/log/mail`  

errレベル、noticeレベルのメール関連のログを/var/log/mailファイルに記録  
`mail.=err;mail.=notice /var/log/mail`  

crit,alert,emergレベルのメール関連のログを192.168.0.1の端末に転送  
`mail.crit @192.168.0.1`  

メールのログを出力しない  
`mail.none`  

カーネルに関するすべてのメッセージを/var/log/kernelに出力  
`keln.* /var/log/kernel`  

緊急メッセージは全ユーザーが受け取る  
`*.emerg *`  

### loggerコマンド

システムログに記録を追加するコマンド。  
ログメッセージを生成する事ができるので、syslog.confの設定ファイルが正しく設定されたのかを確認する事ができる。  
任意のファシリティ、任意のプライオリティのメッセージをsyslogに送るコマンドとも言える。  

``` txt
logger [-p ファシリティ.プライオリティ] [-t タグ] メッセージ

-f :: 指定したファイルの内容を送信する。
-p :: ファシリティ.プライオリティを指定する。デフォルトはuser.notice
```

ファシリティをsyslog,プライオリティをinfoとして「test message」というメッセージを出力  
`logger -p syslog.info -t TEST "test message"`  

### syslogの一元管理

各Linuxマシンでsyslogによりログを管理できるが、複数のLinuxマシンを運用する場合、syslogは1つのLinuxマシンに集中管理させることが一般的。  
その場合は、各Linuxマシンのsyslog.confファイルにて、syslogを管理するサーバーをログの出力先として設定する。  

Webサーバー、Mailサーバー、DNSサーバーがあったとして、それらのsyslog.confを`*.* @192.168.0.100`と設定する。  
syslogサーバーとして192.168.0.100を設定する。外部からのsyslogを受信できるようにUDPポート514番を解放する。  

### systemd-catコマンド

systemdを採用したシステムで使用可能。  
コマンドの実行結果をジャーナルに書き込む事ができるコマンド。  
メッセージをsystemd-journalに送ることでログに記録するコマンド。  
引数の指定がない場合、標準入力から取りこんだメッセージをsystemd-journalに送ることでログに記録する。  

``` txt
systemd-cat コマンド
```

uptimeコマンドの実行結果をジャーナルに書き込む。  
`systemd-cat uptime`  
`journalctl -xe`を実行する事で結果を確認できる。  

標準入力からメッセージを取りこんでログに記録する。  
`echo Test! | systemd-cat`  

### logの調査方法色々

### journalctlコマンド

systemd-journaldが収集し、格納したsystemdのログを表示するコマンド。  
syslog,rsyslogなど、他のデーモンが収集したログは閲覧出来ない。  

ログの保存場所 :: `/var/log/journal` or `/var/run/log/journal`等のディレクトリ内にあるバイナリファイル。  
ログは一定量を超えると古いものから削除される。  
設定ファイル`/etc/systemd/journald.conf`で「Storage=persistent」となっていれば、ジャーナルは/var/log/jornalディレクトリ以下に永続的に保存される。  
/runはメモリ上にある仮想的なファイルシステムなので、システムの再起動で失われる。  
/etc/systemd/journald.confファイルの設定を変更した場合は、systemd-journaldを再起動する。  
`sudo systemctl restart systemd-journald`  

``` txt
journalctl [オプション] [フィールド=値]

-f :: ログの末尾を表示し続ける。リアルタイムに表示する。
-r :: ログを新しい順に表示する(デフォルトは古いものから)
-e :: ジャーナルの末尾(最新)を表示する。
-x :: 説明文付きで表示する。
-k :: カーネルメッセージのみ示する。
-b :: ブート時のメッセージを表示する。
-n :: 表示行数を指定する。
-p プライオリティ :: 指定したプライオリティより高いメッセージを表示する。
-u Unit名 :: 指定したUnitのログを出力する。
--full :: エスケープ文字を除いてプレーンテキストで出力する。
--no-pager :: 1ページ毎に表示せず、全てのログを出力する。
--since :: 指定日時以降を表示する。
--until :: 指定日時以前を表示する。
SYSLOG_FACILITY= :: Syslogプロトコルのファシリティコードを指定して表示する。
```

[--since=] [--until=]で指定した日時のログを表示する。  

2019年7月8日9時から7月9日17時までのログを表示する。  
`journalctl --since="2019-07-08 09:00:00" --until="2019-07-09 17:00:00"`  

プライオリティがwarning以上のログの表示。
`journalctl -p warning`  

ファシリティがメール(ファシリティコード=2)のログを表示。  
`journalctl SYSLOG_FACILITY=2`  

sshd.service関連のログのみ表示  
`journalctl -u sshd.service`

### ログファイルのローテーション

ログファイルのローテーション機能は、`logrotateユーティリティ`が提供している。  
logrotateユーティリティはcronを利用して、定期的に実行される。  
設定は`/etc/loglotate.conf`ファイルで行う。  

``` conf : /etc/logrotate.confファイルの内容(一部)
# ローテーション周期を1週間とする。
weekly
# バックアップログを4習慣保存する。
rotate 4
# ローテーションさせたら、空のログファイルを作成する。
create
# ログファイルを圧縮する。
compress
# /var/log/wtmpファイルの設定
/var/log/wtmp{
    monthly #←ローテーション周期を1か月とする。
    create 0664 root utmp #←パーミッション664,所有者root、グループutmpで新しいファイルを作成
    rotate 1    #←バックアップログを1つ保存する。
}
```

### logrotateコマンド

ログ名、間隔、回数を設定ファイルで指定してローテーションできる。  
logrotateコマンドは/etc/cron.daily/logrotateスクリプトにより、1日1回実行される。  
設定ファイル名は任意だが、一般的には/etc/logrotate.confとして用意する。  

``` txt
logrotate [オプション] 設定ファイル
```

/etc/logrotate.confを設定ファイルとして用意し、このファイルを指定してlogrotateコマンドを実行している例。  
`logrotate /etc/logrotate.conf`  

---

## メール管理(メールシステム)

### MTA(Mail Transfer Agent)

メールの配送を行うプログラム。  
メールシステムの中心的役割を担う。  
DNSサーバーを使用してメールの送信先となるMTAのホスト名を調べる。  
SMTPプロトコルでメッセージをやり取りするため、SMTPサーバーとも呼ばれる。  

代表的なMTAプログラム  
Exim,Postfix,Sendmailなど  

### MDA (Mail Delivery Agent)

MTAが受け取ったメールをローカルドメインのユーザーに配信する(メールスプールに格納する)プログラム。  

MTAに対するMDAプログラム  

- Sendmail : procmail(デフォルト)  
- PostFix : localデーモン  
- Exim : Exim自身が行う  

### MUA (Mail User Agenet)

ユーザーがメールの送受信に使用するプログラム。  

CUIベース : malix,mutt  
GUIベース : Thunderbird,Evolution  

### メール配送の仕組み

``` txt
クライアント  メールサーバー  ネットワーク  メールサーバー  クライアント
    MUA    →     MTA①          →             MTA②
                                                 ↓
                                                 MDA
                                                 ↓
                                            メールボックス
                                                 ↓
                                              POPサーバー  →    MUA
```

①メールクライアントソフトウェア(MUA)で作成されたメールは、送信用MTA①へ送られる。  
②MTA①は、メールアドレスから配送先メールサーバーを調べ、メールをMTA②に配送する。  
③MTA②がメールを受け取ると、ローカル配送プログラムであるMDAが、メールのさて先となっているユーザーのメールボックスにメールを格納する。  
④受取人側はPOPサーバーやIMAPサーバーを経由して自分のメールボックスからメールを取り出す。  

### Sendmail,Exim,Postfix

Sendmail : 1981  
Exim : 1995  
Postfix : 1998  

Sendmailは標準的なMTAとして長く使われてきたが、最近は使われていない。(さすがに古いし、後継もある)  
主流はEximとPostfix。  
SMTPサーバーとして使われる。  
EximとPostfixはSendmailに互換性がある。  

以下のコマンドとファイルでの設定が有効であるため  
・sendmailコマンド  
・newaliasesコマンド  
・mailqコマンド  
・~/.forwardファイル  

### ローカルユーザー宛のメールが格納されるディレクトリ

Sendmail : /var/spool/mail  
Exim : /var/mail  
Postfix : /var/mail  

### 転送することが出来なかったメールを置くデフォルトのキューディレクトリ

Sendmail : /var/spool/mqueue  
Exim : /var/spool/exim/input  
Postfix : /car/spool/postfix/deferred  

### /etc/aliasesファイル

メールアドレスの別名を設定するファイル。  
例えば、root宛に届いたメールをユーザーadminとlpicでも受け取れるようにするには以下のように設定する。  
adminとlpicはどちらもrootあてのメールを受け取れるようになるが、rootにはメールが届かなくなる。  
設定の反映は`newaliases`コマンドで行う。  

``` txt : /etc/aliasesの記述例
root: admin,lpic
```

### MTAの起動

### mailコマンド

コマンドラインでメールを受信したり、受信メールを確認したりするコマンド。  
mailコマンドでユーザー名のみを指定するとローカルシステムのユーザー宛に送信される。  
-sはタイトル(Subject)を指定するオプション。  
引数なしでコマンドを実行すると、メールボックスに届いているメールを確認できる。  
`番号`でその番号のメールを選択。`q`で終了。

``` txt
mail [-s 題名] [宛先メールアドレス or ユーザー名]
```

ローカルシステム内のユーザーである「admin」にメールを送信する。  

``` txt
mail -s TESTMAIL admin
this is a test e-mail
.
```

### sendmailコマンド

メールを送信するコマンド。  
CUIのMUAであるmalix,muttで利用する。  

``` txt : 実行例
sendmail yuki@mylpic.com < 送信する本文を格納したファイル
```

### newaliasesコマンド

メールアドレスの別名を設定するファイルとして、エイリアスファイル(/etc/aliases)とエイリアスデータベースファイル(/etc/aliases.db)がある。  
このうちの、**エイリアスデータベースファイルを更新するコマンド**。  
エイリアスデータベースファイルは更新してもすぐには反映されないので、newaliasesコマンドを叩いて変更を反映させる必要がある。  
因みにエイリアスファイルはSendmail,Postfixの起動時にのみ、読みこまれる。  

エイリアスデータベースファイルがあれば、そちらを参照し、無ければエイリアスファイルが参照される。  
Eximはエイリアスデータベースファイルを参照しない。  
newaliasesコマンドは使えるが、それはSendmailとの互換性のためだけ。  

Sendmail,Postfix : エイリアスファイル、エイリアスデータベースファイル  
Exim : エイリアスファイル  

``` txt
別名 : 転送アドレス1,転送アドレス2,転送アドレス3
```

### mailqコマンド

MTAが転送できなかったメールのキューを見るためのコマンド。  
送信待ちのメールはメールキュー(/var/spool/mqueue)に蓄えられる。  
全MDA(Sendmail,Postfix,Exim)で使用可能。  

### ~/.forwardファイル

ユーザー受信メールのリダイレクトを行いたい時に設定するファイル。  
自分のホームディレクトリの下に`.forward`ファイルを作成して、転送先メールアドレスを記述する。  
一時的にメールを転送したい場合等に便利。  
ユーザーが各自で設定できるため、管理者が設定する必要はない。  

``` txt : 記述例
mana@example.com
mana@mylpic.com
```

自分宛のメールをmana@example.comとmana@mylpic.comに転送する。  

因みにファイル名やディレクトリが「.(ドット)」から始まるのは隠しファイルや隠しフォルダ。  
`~/`はホームディレクトリを表す。  

### /var/spool/queue

送信待ちメールの格納先  

### /var/spool/mail

受信待ちメールの格納先  

### オープンリレー

外部からのメールを制限することなく他のドメインに中継する事。  
そのままではスパムの踏み台にされるので、以下の制限を設定する。  
①外部からのメールはローカルドメイン宛のメールだけを受け取り、他のドメインへ中継しない。  
②内部ネットワークからのメールだけを他のドメインに中継する。  

因みに「外部からの名前解決リクエストに対して制限することなく答えを返すこと」をオーブンリゾルバという。  

---

## プリンタ管理

### CPUS(Common Unix Printing System)

印刷サブシステムらしい。  

・IPP(Internet Printer Protocol)の採用  
ネットワーク上のプリンタをサポートする印刷プロトコルIPPを採用。  

・PPD(PostScript Printer Description)ファイルのサポート  
AdobeのPPD形式のファイル(テキストファイル)でデバイスドライバの設定ができる。  

・Webベースで設定可能  
Webブラウザから設定できるツールが組み込まれている。  

・プリンタクラスのサポート  
複数のプリンタを1台のプリンタに見せかける機能をサポートしている。  

・PPDファイルの格納場所 :: `/etc/cups/ppdディレクトリ以下`  

・CUPSの設定ファイル :: `/etc/cups/cupsd.conf`  
→印刷要求をネットワーク経由で受け付ける場合のポート番号や、接続するクライアントのアクセス許可の設定等。  

・プリンタに関する情報などの設定 :: `/etc/cups/printers.conf`  

・設定ポート :: 631  
→localhost:631でアクセス。  

設定の仕方  
①設定ファイルを直接編集。  
②WebブラウザでCUPSの設定ページにアクセスして編集する。  

### CUPSの印刷処理の流れ

1. アプリケーションや印刷コマンドから印刷データを受け取る。  
   プリンタの設定オプションはPPDファイルから提供される。  
2. スプーラーが印刷データを受付、スケジューリングを行う。  
3. プリンタが直接受け付けられないデータを一旦中間形式としてPDFまたはPostScriptにフィルタで変換する。  
4. PPDに定義されたフィルタにより、最終の印刷データに変換する。  
5. 処理した印刷データをCUPSのバックエンドに送る。  
6. バックエンドは印刷データをローカル接続(USBなど)またはネットワークを経由(IPPやLPRなど)してプリンタに渡す。  

### CUPSサービスの起動

SysVinitの場合  
`/etc/init.d/cups start`  

systemdの場合  
`systemctl start cups.service`  

IPPサービス(ポート631/tcp)が開いていれば、CUPSは動作している。  
`netstat -at | grep ipp`  

### PPD(Postscript Printer Description)

フォント、用紙サイズ、解像度など、PostScriptプリンタの機能を記述し制御するためのファイル。  
アドビシステムズによって策定された。  

### lprコマンド

印刷コマンド。  
指定されたファイルや標準入力をプリントキューに送る。  

``` txt
lpr [オプション] [ファイル名]

-# 部数 :: 印刷部数を指定する。
-P プリンタ名 :: 印刷を行うプリンタを指定する。
```

テキストファイル testdata.txtを6部印刷する。  
`lpr -# 6 testdata.txt`  

/etc/passwdファイルを5部印刷する。  
`lpr -# 5 /etc/passwd`  

dmesgコマンドの出力を印刷する。  
`dmesg | lpr`  

### lpqコマンド

BSD系におけるプリントキューの内容を表示するコマンド。  
オプションを指定せずにコマンドを実行した場合、デフォルトに設定されているプリンタのキューを表示する。  

``` txt
lpq [オプション] [ユーザー名] [ジョブ番号]

-a :: すべてのプリンタの情報を表示。
-P プリンタ名 :: 指定したプリンタの情報を表示。
```

### lpcコマンド

BSD系に属するプリンタのキューの状態を表示するコマンドの内の1つ。  
CUPSのlpcは実質的にプリントキューの状態を表示するstatusコマンドしかなく、`lpc status キュー名`以外の機能はない。  
コマンドの指定なしで実行すると対話的にコマンドを実行できる。  

``` txt
lpc [コマンド]
```

キューが受付可能かどうか、プリンタへ出力可能かどうか調べる。  
`lpc status all`

### lprmコマンド

プリンタキューにある印刷ジョブを削除するコマンド。  
一般ユーザーは自分の発行した印刷要求のみ、スーパーユーザーはすべての印刷要求を削除できる。  

``` txt
lprm [オプション] [ジョブ番号]

-P プリンタ名 :: 指定したプリンタの印刷ジョブを削除
- :: 自分の印刷ジョブをすべて削除
```

自分の印刷ジョブを全て削除(一般)  
`$ lprm -`  

自分の印刷ジョブを全て削除(root)  
`# lprm -`  

### lpadminコマンド

プリンタの登録や削除等を行うCUPSの設定コマンド。

``` txt
lpadmin -p プリンタ名 [オプション] 

-p :: 作成するプリンタ名を指定する。
-E :: プリンタジョブを受付、プリンタへの出力を開始状態にする。
-v :: デバイスURIを指定する。
-m :: modelディレクトリ/usr/share/cups/modelの下のPPDファイル名を指定する。
-p :: PPDファイル名を指定する。
```

新規にプリンタを登録する構文  
`lpadmin -p プリンタ名 オプション`  

デフォルトプリンタを設定する構文  
`lpadmin -d プリンタ名`  

デフォルトプリンタを削除する構文  
`lpadmin -x プリンタ名`  

### lpコマンド

SystemV系のlprコマンド。  
lprはBSD系らしい。  
オプションの機能は同じなのに引数が違うというクソ仕様。  

``` txt
lp [オプション] ファイル名

-d :: 指定したプリンタに出力する。指定しない場合はデフォルトプリンタが使われる。 lprにおける-P。
-n 部数 :: numで指定した部数を出力する。lprにおける-#。
-o raw :: フィルタを通さずにプリンタに出力する。これはlprと同じ。
-l :: フィルタを通さずに直接印刷する。-oと動作的に同じらしい。
```

sampleファイルを2部印刷する。  
パイプラインでファイル名を渡しても大丈夫らしい。  
`cat sample | lp -n2`  
`cat sample | lpr -#2`

### lpstatコマンド

SystemV系におけるプリンターのキューを表示するコマンド。  
BSD系はlpqとlpc。  

``` txt
lpstat [オプション]

-a :: プリントキューが受付可能(accept)になっているか否かを表示。
-p :: プリントキューが出力可能(enable)になっているか否かを表示。
-t :: プリンタの状態をキューの状態を含めてすべて表示。  
```

### cupsdisableコマンド

指定したプリンターを停止状態にするコマンド。  
引数に-r(reason)を付けて実行すると、現在のプリンタの状態のコメントを設定することができる。  
コメントはキューの状態を調べるコマンドを実行したときに表示される。  

``` txt
cupsdisable [オプション] プリンタ名

-c :: プリントキューの全てのジョブをキャンセル
-r :: 停止の理由を示すメッセージを指定。キューの状態の中にメッセージが表示される。
```

### cupsableコマンド

停止したプリンタを開始するコマンド。  

### cupsrejectコマンド

指定したプリンタへのプリントジョブを受け付けないようにするコマンド。  

``` txt

-c :: プリントキューの全てのジョブをキャンセル
-r :: 停止の理由を示すメッセージを指定(cupsrejectのみ)。キューの状態の中にメッセージが表示される。
```

### cupsacceptコマンド

プリントジョブを受け付けるようにするコマンド。  

### プリントキュー管理のまとめ  

``` txt
lp,lprコマンド → プリントキュー入口 → プリントジョブ → プリントキュー出口 → プリンタ
                         ↑                    ↑                  ↑
    受付/拒否を制御するコマンド  キューの状態を表示するコマンド   開始/停止を制御するコマンド
                    cupsaccept             lpstat -a              cupseanble
                    cupsreject             lpstat -p              cupsdisable
                                           lpstat -t
                                           lpq
                                           lpc status

```

---

## 小豆本問題

---

### 1 ○

cronを使って自動的にバックアップを取るようにしている。  
バックアップファイル名にバックアップ日時が使われるにように死体場合、書式として適切なコマンドは？  

→  
D. ``tar czf /backup/date`date "+%Y%m%d"`.tar.gz /home``  

すげー。当たった。  
書式の設定はじめは「+」からだったような？ってのは合ってたみたいだ。  
tarのコマンドは知らん。xは回答だから違うとしとvとfの違いがわからない。  

cfz → create file zip  

---

### 2 ○

認証関連のメッセージで、プライオリティがnotice以上のものは/var/log/secureに保存されるようにしたい場合、/etc/rsyslog.confの書式として適切なものを選択せよ。  

→  
C.`authpriv.notice /var/log/secure`  

ファシリティ.プライオリティ 出力先  

---

### 3 ○

システムログファイル/var/log/messagesを常に監視して起き、新しいメッセージが書き込まれる様子を画面上でモニタリングし続けたい場合、  
どのコマンドを実行すればよいか？  

→  
B. `tail -f /var/log/messages`  

普通に考えて後に追加されたものを表示するからtailかなって思うけどね。  
tailコマンドの-fオプションはファイルの末尾を表示し続け、新たに書き込みがあればリアルタイムに画面に表示する。  

---

### 4 ○

Postfixを利用している。  
root宛のメールをユーザーuser01で受け取れるように設定するため、/etc/aliasesファイルを編集しましたが、メールが届きません。  
実行すべき操作は？  

→  
C.newaliasesコマンドを実行する。  

意外と覚えているものである。  

---

### 5 ○

jupitor.example.net上でstudentユーザーとして作業をしている。  
student@jupitor.example.netに届いたメールを、student@lpic.jpに転送するには~/___に「student@lpic.jp」と記述します。  
下線部のファイル名は？  

→  
.forward  

覚えているものである。  

---

### 6 ○

メールがメールキューに残っていないかを確認するためにあるコマンドを実行した。  
`$____`
mail queue is empty  

コマンドは？  

→  
mailq  

すげー。まじで覚えてるもんだな。  

---

### 7 ○

lprコマンドを使い、プリンタlaser01で、/etc/hpstsファイルを5部印刷したい場合、どのコマンドを実行すればよいか？  

→  
`lpr -# 5 -P laser01 /etc/hosts`  
なのでCですね。  
親切なことに#が入ってるのが1つしかないので、実質正解みたいなものだ。  

---

### 8 ○

プリントキューにある自分の印刷ジョブを全て削除したい場合、実行すべきコマンドは？  

→  
lprm -  

[-]は自分のジョブを消すオプションだったっけか。  
昨日の今日とは言え、全問正解はすごくないか？  
