# 10.必須システムサービス

``` txt : システムクロックの設定
・date :: システムクロックの参照や設定を行うコマンド。
           date [MMDDhhmm[CC[YY]][.ss]](MMは月、DDは日、hhは時、mmは分、CCは西暦の上2桁、YYは西暦の下2桁、ssは秒)
・hwclock :: ハードウェアクロックの参照や設定を行うコマンド。
・timedatectl :: systemdの動作するシステムにおいてシステム時刻の表示や設定を行うコマンド。
・ntpd :: NTPデーモン。NTPサーバー機能を提供する。
          自身をNTPサーバとすることで、指定したNTPサーバに定期的に時刻情報を問い合わせて自身の時刻を修正し、正確なシステムクロックを維持できます。
・/etc/ntp.conf :: ntpd（NTPサーバのデーモン）の設定ファイル。
                   restrict  :: ntpdへのアクセス制限を行う。
                   server    :: 時刻を取得するサーバを指定。
                   driftfile :: 自身の時刻のズレ具合を記録するファイルを指定。
・ntpdate          :: 手動でNTPサーバから正確な時刻を取得し、システムクロックに反映させるコマンド。NTPクライアントとしてのツール。
・ntpq             :: ntpdの時刻同期状況を確認するコマンド。[*]時刻同期先、[+]同期可能、[-]参照しない事が決定。[-p :: 時刻同期状況]
・Chrony(ｸﾛｰﾆｰ)    :: ntpdに代わるNTPサーバ/クライアント。
・chronyd          :: ntpdに代わるNTPサーバ/クライアントであるChronyのデーモン。
・/etc/chrony.conf :: Chronyの設定ファイル。
・iburstオプション :: 起動直後にNTPサーバに対して短い間隔で4回問い合わせることで時刻同期を速めるオプション。
・chronyc :: chronyd（chronyデーモン）の管理を行うコマンド。
・systemdのタイマーユニット :: 
・pool.ntp.org :: 複数のNTPサーバで構成させる仮想的なNTPサーバを、DNSラウンドロビン方式で提供するプロジェクト。
```

``` txt : システムログの設定
・syslog    :: ログメッセージを送受信する規格。
・rsyslog   :: syslogの問題点を克服した次世代のsyslog。主要なディストリビューションで採用されている。
・syslog-ng :: 次世代のsyslog2。
※次世代のsyslog :: rsyslog,syslog-ng
・/etc/syslog.conf  :: syslogに関する設定ファイル。
・/etc/rsyslog.conf :: rsyslogの設定ファイル。
・/etc/systemd/journald.conf
sytemd-journaldの設定ファイル。
「/run/log/journal」配下にシステム固有のディレクトリを作成し、その中の「system.journal」ジャーナルファイルに記録する。
※「/run」ディレクトリはメモリ上に作成されたファイルシステム上のディレクトリのため、再起動するとデータが消えてしまいます。
・/run/log/journal/system.journal :: バイナリ形式のログが保存されるジャーナルファイル。

・systemd-journald :: systemdの動作するシステムで、ユニットが出力するログを扱うデーモンプログラム。
・journalctl
systemdの動作するシステムでsystemd-journaldのログを表示するコマンド。ログはバイナリ形式。
※syslogdがsystemd-journaldからsyslogを読み出すように設定する必要がある。
※rsyslogやsyslog-ngは、設定せずにsystemd-journaldから読み出せます。
※デフォルトではページャによる表示を行う
※ページャを無効にするには --no-pager オプションを指定する
[-xd :: エマージェンシー]
[-k  :: dmesgと同じ情報を得られるオプション]
※前回の起動からシャットダウンまでのログを出力
/var/log/journal ディレクトリが存在する
journalctl -b -1
※各Unitが出力する表示可能なログをすべて表示させたい。
-l, --full
※journalctlコマンドでのログ出力をjson形式に変更したい。
journalctl -o json
※・アーカイブジャーナルの総容量が指定したサイズを下回るまで古いエントリを削除したい。
--vacuum-size
※・指定した期間より古いアーカイブジャーナルを削除したい。
--vacuum-time
※journalctlコマンドでのログ出力において、新規に追加されたログをリアルタイムに表示させたい。
-f , --follow (tail -fと同様)
※sshd.service ユニットからのログのみを出力させたい
journalctl -u sshd.service
journalctl _SYSTEMD_UNIT=sshd.service

・systemd-cat :: 指定したコマンドの実行結果をジャーナルファイルに書き込むコマンド。ログメッセージを生成できるloggerコマンドと同様です。
・logger      :: システムログに記録を追加するコマンド。
・logrotate   :: ログのローテーションを実行するコマンド。通常はcronによって定期的に実行される。
・/etc/logrotate.conf :: ログローテーションの設定ファイル。

・ファシリティ
auth,authpriv :: 認証システム(loginなど)による出力
cron          :: cronによる出力
deamon        :: 各種デーモンによる出力
kern          :: カーネルによる出力
lpr           :: 印刷システムによる出力
mail          :: メールサービス関連による出力
user          :: ユーザーアプリケーションによる出力
syslog        :: syslog機能
local0~local7 :: ローカルシステムの設定

・プライオリティ
emerg   :: 緊急事態
alert   :: 早急に対処が必要な事態
crit    :: システムの処理は継続できるものの深刻な事態
err     :: 一般的なエラー
warning :: 一般的な警告
notice  :: 一般的な通知
info    :: 一般的な情報
debug   :: デバッグ情報
none    :: ログを記録しない

・出力先
ファイル名        :: ファイルへの出力
ユーザー名        :: ユーザーの端末への出力
@ホスト名         :: リモートホストのsyslogへUDPで出力
@@ホスト名        :: リモートホストのsyslogへTCPで出力
/dev/tty1         :: コンソール(rrt1)に出力
/dev/console      :: コンソールへの出力
/var/log/messages :: ログファイルに出力
*                 :: ログイン中のすべてのユーザーの端末に出力
```

``` txt : メール管理(メールシステム)
・MTA(Message Transfer Agent)
メールの転送を行うプログラム。ネットワーク経由、またはサーバ内部（ローカル）のメール転送依頼に基づき、指定された宛先へメールを転送する。
メールサーバとして使用される。
・MDA(Mail Delivery Agent)
ローカルのメールスプールへ配送するプログラム。
MTAによってローカルの宛先へのメールであると判断されたメールを受け取り、宛先ユーザのメールボックス（メールスプール）へメールを配送する。
・MUA(Mail User Agent)
ユーザーがメールを扱うプログラム。自身のメールボックスへアクセスして受信したメールを閲覧したり、メールを送信したりする。
MUAの例としては、LinuxのmailコマンドやThunderbird、WindowsやMac OS X付属のメールソフトがある。

・sendmail :: 古くから使われるMTAで、様々なメール転送方式に対応している。
              1つのプログラムで全ての処理を実行できる反面、設定は難解で専用のツールを使う必要がある。  
              セキュリティ面での問題がたびたび発生したり、処理速度が遅いなどの問題もある。
・/var/spool/mail/   :: Sendmailのローカルユーザー宛のメールが格納されるディレクトリ
・/var/spool/mqueue/ :: Sendmailの転送することが出来なかったメールを置くデフォルトのキューディレクトリ

・Postfix :: sendmailとの高い互換性を保ちながら、処理速度を上げ、セキュリティも向上させている。
             設定が平易。最近の一部のLinuxディストリビューションの標準MTAにもなっている。
・/var/mail/                   :: Postfixのローカルユーザー宛のメールが格納されるディレクトリ
・/var/spool/postfix/deferred/ :: Postfixの転送することが出来なかったメールを置くデフォルトのキューディレクトリ

・exim :: Debian系の標準MTA。設定は平易だが、日本語の情報は比較的少ない。設定ファイルの内容はバージョンによって異なる。
・/var/mail/                   :: Eximのローカルユーザー宛のメールが格納されるディレクトリ
・/var/spool/exim/input/       :: Eximの転送することが出来なかったメールを置くデフォルトのキューディレクト

・/etc/aliases :: sendmailでメールアドレスの別名を設定するファイル。
・newaliases   ::「/etc/aliases」を編集後、設定を反映させるためのコマンド。
・~/.forward   :: ユーザー個別でメールの転送先を記載するファイル。即時反映。
・sendmail :: 古くからあるMTAのsendmailでは、メール送信やMTAの制御のためにsendmailコマンドが用意されていました。
              引数無しで単独で実行すると、標準入力からメールのデータを受け取り、.(ピリオド)のみの行を受け取った時点でメールの送信を行います。
・mail  :: メールの送信や受信メールの確認を行うコマンド。オプションを付けずにコマンドを実行すると、[/var/spool/mail/]に格納されている受信メールを表示する。
・mailq :: 一般的なMTAにおいて、送信待ちのメールキューを一覧表示できるコマンド。
・オープンリレー :: 
```

``` txt : プリンタ管理
・CUPS(Common Unix Printing System)
これまで使われてきた「lpd」に代わる新しいWebブラウザベースの印刷システム。
・ネットワーク上のプリンタをサポートするプロトコル「IPP（Internet Printing Protocol)」を採用している。
・プリンタの機種依存情報を記述する「PPD（PostScript Printer Description）」ファイルをサポートしている。
・Webブラウザベースで設定できる。
・従来の印刷システム「lpd」との互換性を持っている。

・cupsd      :: UNIXの印刷サービスCUPSのデーモン。
・lpd        :: Linuxでこれまで長年利用されてきた印刷用のデーモン。
・/etc/cups/ :: UNIXの印刷サービスCUPSに関する設定ファイルが置かれるディレクトリ。
・/etc/cups/cupsd.conf    :: cupsdの設定ファイル。接続要求を受けるポート番号(デフォルトは631)や、接続するクライアントのアクセス制御などの設定を行う。
・/etc/cups/printers.conf :: プリンタに関する設定ファイル。
・/etc/printcap           :: レガシー印刷システムとの互換性を確保するため自動的に作られる設定ファイル。
・/var/spool/cups/        :: プリントスプールの場所。
・IPP(Internet Printing Protocol) :: CUPSのネットワーク上のプリンタをサポートするプロトコル。
・PPD(Postscript Printer Description) :: プリンタの機種依存情報を記述するファイル。

・lp     :: CUPSの標準的な印刷コマンド。印刷ジョブを生成し、プリントキューに登録するコマンド。
・cancel :: CUPSの標準的な印刷コマンド。プリントキューにある印刷ジョブを削除するコマンド。
・lpstat :: CUPSの標準的な印刷コマンド。プリントキューにある印刷ジョブを表示するコマンド。
・lpr    :: LPDと互換性のある印刷コマンド。レガシーな印刷システムであるLPDと互換性のある印刷コマンド。
・lprm   :: LPDと互換性のある印刷コマンド。プリントキューにある印刷ジョブを削除するコマンド。
・lpq    :: LPDと互換性のある印刷コマンド。プリントキューに登録されたジョブを一覧表示させるコマンド。
```

---

## システムクロックの設定

### ハードウェアクロック

PCにハードウェアとして内臓された時計。  
電源がオフの状態でも動作する。(PC内に取り付けられた電池で動作する)  

### システムクロック

Linuxカーネル内に存在する時計。  
Linux起動時にハードウェアクロックを参照して設定されるが、その後は別々に動く。  
そのため、起動してから時間が経過するにつれ、ハードウェアクロックと差が生じる。  

### dateコマンド

システムクロックを表示するコマンド。  
rootユーザーはdateコマンドを使ってシステムクロックを設定できる。  

``` txt
現在の日付を表示する。
date [オプション] [+書式]

オプション
-u,--universal,--utc :: 協定標準時を表示する。  

引数を「+」で始めると、指定した書式で表示する。
%Y :: 年
%m :: 月(01~12)
%d :: 日(01~31)
%H :: 時(00~23)
%M :: 分(00~59)
%a :: 曜日
%b :: 月名

システムクロックを変更する。
date [MMDDhhmm[[CC]YY][.ss]]

MM :: 月
DD :: 日
hh :: 時
mm :: 分
CC :: 西暦の上2桁
YY :: 西暦の下2桁
ss :: 秒
```

システムクロックを2018年12月10日20時に設定する。  
`sudo date 121020002018`  

「年/月/日(曜日)」の書式で表示する。  
`date "+%Y/%m/%d (%a)"`  
2018/12/10 (月)  

※バックアップをする時に``tar czf `date +"+%Y%m%d"`.tar.gz/data``というコマンドが自動的に実行されるようにしておけば、  
「20181210.tar.gz」のように、バックアップを実行した日付入りのアーカイブファイルを作成する事ができる。  

cfz → create file zip  

### hwclockコマンド

ハードウェアクロックの参照や設定を行うコマンド  

``` txt
hwclock オプション

-r(read)      :: ハードウェアクロックを表示する。デフォルト動作なので省略可能。
-w(--systohc) :: システムクロックの時刻をハードウェアクロックに設定する。
-s(--hctosys) :: ハードウェアクロックの時刻をシステムクロックに設定する。
-u            :: utcを指定する。
```

### NTP(Network Time Protocol)

ハードウェアクロックもシステムクロックも残念ながらあまり正確ではない。  
正確な時刻を設定するためには、ネットワーク経由でクロックを同期するプロトコルであるNTPを使い、インターネット上にあるNTPサーバー(タイムサーバー)から正確な時刻を取得する。  

NTPネットワークは階層構造になっている。  
最上位は原子時計やGPSなど、きわめて正確な時刻情報の提供元がある。  
原子時計やGPSなどの正確な時計をstratum（ストレイタム：階層）0とし、その直下にあるNTPサーバーをStratum1。その次をStratum2。  
最下層は stratum 16となる。  
stratum 16のサーバからは時刻を取得することは出来ません。  

NTPサーバーは上位の複数のNTPサーバーから正確な時刻を取得する。  
NTPクライアントによるNTPサーバーとの時刻同期にはroot権限が必要。  

ntpdの各種設定は`/etc/ntp.conf`で行う。  

### /etc/ntp.conf

ntpdの設定ファイル。  

正確な時刻を有するNTPサーバから時刻を取得し、システムクロックと自動で同期させるには「ntpd」デーモンを起動しておきます。  
「ntpd」デーモンは、その設定ファイルである「/etc/ntp.conf」を読み込んで起動します。  

公開NTPサーバを利用する場合は、複数のNTPサーバ群で構成される「pool.ntp.org」プロジェクトに登録されている外部サーバ等を指定します。  
「pool.ntp.org」を利用すると、複数のNTPサーバから、負荷分散の技術の一つである「DNSラウンドロビン」を利用して時刻を取得します。  
例えば日本であれば「0.jp.pool.ntp.org」から「3.jp.pool.ntp.org」といったserverを指定することで、遅延の少ない、正確な時刻を入手できるようになります。  

NTPサーバは「/etc/ntp.conf」の設定項目「server」で指定します。  
内外部にある信頼できるNTPサーバを設定項目「server」で指定して正確な時刻を得ながら、  
自身のマシンも管理下のネットワークに対してNTPサーバ（他のNTPサーバが時刻を取得するサーバ）として動作させる、といった運用も可能です。  

``` txt : 主な設定項目
restrict  :: ntpdへのアクセス制御を行う。
server    :: 時刻を取得するサーバーを指定する項目。
             ネットワーク内部に設置したNTPサーバや、世界中にある公開NTPサーバ、プロバイダが提供するNTPサーバを指定します。 
driftfile :: 自身の時刻のズレ具合を記録するファイルを指定。
```

### ntpdateコマンド

指定したNTPサーバーから現在時刻を取得するコマンド。  
手動でNTPサーバから正確な時刻を取得し、即座にシステムクロックに反映させる。  
ntpdate コマンドはNTPクライアントとしてのツール。  

``` txt
ntpdate [オプション] NTPサーバー名

-q :: NTPサーバーとシステムクロックの差分(offset)を確認する。
```

NTPサーバーtime.sercer.lpic.jpから現在時刻を取得する。  
`ntpdate time.server.lpic.jp`  

NTPサーバー(ntp.nict.jp)を使ってシステム時計との差分を確認する。  
`ntpdate -q ntp.nict.jp`  

### NTPサーバー

NTPサーバーは自前で運用することができる。  
組織内にNTPクライアントが多い場合は用意したほうが都合がよい。  

ntpdはNTPバージョン3互換のデーモン。  
stratum上位の外部NTPサーバーの時刻を参照してシステムクロックの時刻同期を行い、  
このシステムクロックにより外部ホストに対して時刻同期のサービスを提供するNTPサーバーとなる。  

自身をNTPサーバとすることで、指定したNTPサーバに定期的に時刻情報を問い合わせて自身の時刻を修正し、正確なシステムクロックを維持できます。  
よく使用されるNTPサーバ（デーモン）はntpdです。  

SysVinitを採用したシステムでのNTPサーバーの起動方法  
`/etc/init.d/ntpd start`  

systemdを採用したシステムでのNTPサーバーの起動方法  
`systemctl start ntpd.service`  

NTPサーバーの設定は`/etc/ntp.conf`で行う。(NTPデーモンが参照する設定ファイル)  
補正情報(クロックの誤差を予測した数値)は、`/etc/ntp.drift`に保存される。  
ディストリビューションによっては`/var/lib/ntp/drift`や`/var/lib/ntp/ntp.drift`になっていることもある。  

``` txt : /etc/ntp.confファイルの例
server 0.jp.pool.ntp.org ← 1番目のNTPサーバー
server 1.jp.pool.ntp.org ← 2番目のNTPサーバー
server 2.jp.pool.ntp.org ← 3番目のNTPサーバー
server 3.jp.pool.ntp.org ← 4番目のNTPサーバー
driftfile /etc/ntp.drift ← 補正情報ファイルの指定
logfile /var/log/ntp.log ← ログファイルの設定
```

この設定例では、複数のNTPサーバーをまとめて仮想的なNTPサーバーとして運用している。  
0.jp.pool.ntp.orgにDNSで問い合わせすると、いくつかのNTPサーバーの中から1つのIPアドレスがランダムに帰ってくる。  
このようにして特定のNTPサーバーに負荷が集中しないようにしている。  

左の項目はコンフィグレーションコマンドと言うらしい。  
serverはNTPデーモンを外部NTPサーバーのスレーブにするための項目ともいえるらしい。  

iburstオプション  
NTPサーバーとの初期の同期にかかる時間を短縮するオプション。
serverコマンドのオプションとして指定可能。  

### ntpqコマンド

NTPサーバーの状態を照会するコマンド。  

``` txt
ntpq [オプション] 接続先サーバー

-p :: /etc/nptd.confのserverに指定したサーバーとの同期状態を一覧表示する。対話モードのpeersコマンドと同様。
-i :: 対話モードで起動する(デフォルト)
```

localhostで稼働しているNTPサーバーから問い合わせされているNTPサーバーのリストを表示する。  
`ntpq -p localhost`  

``` txt : 表示項目の説明
remote :: serverに指定したNTPサーバーのホスト。
          先頭に「*」がついているものが時刻同期先。
          「+」は時刻同期可能なサーバー。
          「-」は参照しないことが決定したサーバーを意味する。
refid  :: remoteのサーバーの時刻参照先アドレス。
          同期開始時は「.INIT.」を表示し、stratum1のサーバーでは「.GPS.」などを表示する。
st     :: remoteのサーバーのstratum。
t      :: ntpパケットの交換方法。uはユニキャストを表す。
when   :: 前回ntpパケットを交換してからの経過時間(秒)
poll   :: 時刻問い合わせの間隔(秒)。同期が安定すると間隔が自動で長くなっていく。
reach  :: 過去8回の時刻問い合わせ結果を8進数で表示。
          8回全て成功で377(2進数で11 111 111)。
          過去7回成功して直前が失敗すると376(11 111 110)。
          過去7回失敗で直前が成功すると1(00 00 001)。
delay  :: ntpパケットの往復に要した遅延時間(ミリ秒)
offset :: remoteのサーバーとの時刻のズレ(ミリ秒)
jitter :: 同期した時刻とのずれ具合(ミリ秒)
```

時刻同期が安定してくると、poll間隔が自動で長くなっていく。  
最大1024秒(約17分)ごとに時刻問い合わせを行うようになり、システムへの負荷が少なくなるようになって行く。  
refidが`.INIT.`の時は初期化中なので、同期できない。その場合はremoteが空白になる。(+でも-でも*でもない)  

上表から設問の出力結果を確認すると
・60.56.214.78と時刻同期している
・60.56.214.78とは直近8回連続で時刻同期に成功している
・106.185.48.114とは時刻同期が可能
・157.7.236.66を時刻同期先としない
・49.212.186.27とは開始処理中のため、時刻同期処理は行われていない
事がわかります。

よって正解は
・60.56.214.78と時刻同期している
・49.212.186.27とは時刻同期できない
・60.56.214.78とは安定して時刻同期している
です。

その他の選択肢については以下のとおりです。
・106.185.48.114と時刻同期している
・157.7.236.66と時刻同期している
先頭に「*」がついていないので時刻同期先になっていないことがわかります。

・103.1.106.69とは時刻同期できない
「103.1.106.69」は「157.7.236.66」のNTPサーバが参照している時刻同期先サーバのアドレスです。この表示から時刻同期できないとは言えません。

・106.185.48.114とは安定して時刻同期している
reach項目を8進数→2進数に変換すると、直近８回の時刻問い合わせ結果が以下のとおり成功（1）が連続していないことがわかります。
12: 00 001 010
問い合わせが連続して成功していないので、安定して時刻同期しているとは言えません。

・145.174.168.164とは安定して時刻同期している
「145.174.168.164」は「106.185.48.114」のNTPサーバが参照している時刻同期先サーバのアドレスです。この表示から安定して時刻同期しているとは言えません。

### Chrony(クローニー)

ntpd/ntpdate の代替となるNTPサーバー/クライアントソフトウェア。  
デーモンプロセス:`chronyd` と クライアントコマンド:`chronyc` から構成される。  
設定ファイル : `/etc/chrony.conf`  

### /etc/chrony.conf

Chrony（クローニー: ntpdに代わるNTPサーバ/クライアント）の設定ファイル。  

``` txt : 主な設定項目
server    :: 時刻を取得するNTPサーバーを指定。サーバー/クライアントの関係。
peer      :: 時刻を取得するNTPサーバーを指定。同じstratum(階層)同士。
pool      :: 時刻を取得するNTPサーバーのプール(複数アドレスを集約した名前)を指定。
driftfile :: 自身の時刻のズレ具合を記録するファイルを指定。
rtcsync   :: システムクロックをハードウェアクロック(RTC)にコピーする。
             デフォルトで11分おきに反映される。
```

``` conf : /etc/chrony.confの設定例
# NTPサーバーを指定
server 0.centos.pool.ntp.org iburst
server 1.centos.pool.ntp.org iburst
server 2.centos.pool.ntp.org iburst
server 3.centos.pool.ntp.org iburst

# 補正情報ファイルを指定
driftfile /var/lib/chrony/drift

# ハードウェアクロックと同期させる
rtcsync

# ログファイルを指定
logdir /var/log/chrony
```

### chronydデーモン

NTPにより時刻の同期を取るクライアントかつサーバーデーモン。  
ntpdと同様に上位のNTPサーバーから時刻の同期を受けるクライアント機能と、NTPクライアントに時刻を配信するサーバー機能を持っている。  

設定ファイル  
・`/etc/chrony.conf`(RedHad系)  
・`/etc/chrony/chrony.conf`(Debian系)  

#### 主なディレクティブ

- `server ホスト名`  
  時刻元として使用するNTPサーバーを指定する。  
  オプション「iburst」を指定した場合は起動後の最初の4回の問い合わせは2秒間隔で行う。  
  起動後の同期を早くするために有効。  
  例1: server 0.centos.pool.ntp.org iburst  
  例2: server ntp.nict.jp iburst  
- `pool プール名`  
  時刻元として使用する複数のNTPサーバーのプールを指定する。  
  オプション「maxsources」を指定した場合は、使用するサーバーの最大台数は指定した値となる。  
  例1: pool ntp.ubuntu.com iburst maxsources 4  
  例2: pool ntp.nict.jp burst  
- `makestep 閾値 回数`  
  時刻のずれが閾値(単位:秒)より大きかった場合は指定した問い合わせ回数まではステップで同期する。  
  例: makestep 1.0 3  
- `rtcsync`  
  定期的にハードウェアクロックの同期を取る。
- `rtcfile`  
  ドリフトファイルにより時刻を補正する。  
- `driftfile ファイル`  
  システムクロックとハードウェアクロックのズレを記録するドリフトファイルを指定する。  
  例: driftfile /var/lib/chrony/drift  

### chronycコマンド

chronydの管理を行うコマンド  
chronycコマンド単体で実行した場合、対話モードでの操作となる。  

``` txt
chronyc

対話モード
quit :: 対話状態を終了する。


chronyc [オプション] [サブコマンド]

主なサブコマンド
activity           :: NTPサーバーのオンライン/オフライン数を表示する。
sources            :: 時刻ソースの情報を表示する。
sourcestats        :: 時刻ソースの統計情報を表示する。
tracking           :: トラッキングを確認する。システムクロックのパフォーマンス情報を表示する。
makestep 閾値 回数 :: 時刻のずれが閾値(単位:秒)より大きかった場合は指定した問い合わせ回数まではステップで同期する。
                      引数を指定せずに実行した場合は時刻を合わせる。
```

時刻ソースとなるNTPサーバー毎の情報を表示する。  
`chronyc sources`  

``` txt : chronyc sources コマンド実行結果の各項目の説明
M               :: ソースのモード（「^」はserver、「=」はpeer ）
S               :: ソースの状態（「*」は同期している、「+」は同期可能、「?」は全てのテストをパスしていないか切断されたソース）
Name/IP address :: ソースの名前/IPアドレス
Stratum         :: ソースのストレイタム（階層）。
                   原子時計やGPSなどの正確な時計をstratum 0とし、そこから直接時刻を取得するサーバがstratum 1、stratum 1のサーバから時刻を取得するサーバはstratum 2、
                   最下層は stratum 16（stratum 16のサーバからは時刻を取得することはできない）
Poll            :: ソースに問い合わせるポーリング間隔。デフォルト値は6（26=64秒）
Reach           :: 過去8回分の問い合わせ結果を8進数で表示。全て成功で377（2進数で11 111 111）
LastRx          :: ソースから最後のサンプルを受信した時期（デフォルトは秒数）
Last sample     :: 同期した時刻とのズレ具合
                   例）「-843us[-1329us] +/- 103ms」表示の場合、843usは前回測定時のズレ、1329usは前回測定後にslewで調整した値、103msは誤差の範囲
```

### systemdのタイマー

cronのsystemd版。  
systemdにもタイマーを設定して実行してくれる機能があるらしい。  

atコマンド、crontabコマンドは一般ユーザーでも利用できるが、systemdのタイマーはroot権限を持つユーザーしか設定出来ない。  
cronと同じく、一定間隔あるいは指定した時刻でサービスを実行することが出来る。  
タイマーの設定はサフィックスを.timeとしてunit設定ファイルを作成する。  
2種類のタイマーがある。  

●monotinic timer  
指定した間隔で1回、あるいは複数回、サービスを実行する。  
●realtime timer  
指定した時刻にサービスを実行する。  

monotonic timerの設定
タイマーユニット設定ファイルの[timer]セクションにスターティングポイントから時間間隔を指定して実行する。  
スターティングポイント  
OnActiveSec=(タイマーをアクティベートしてからの時間を指定)  
OnBootSec=(マシンが立ち上がった後の時間間隔を指定)  
等  
OnUnitActiveSec(繰り返して実行する場合の時間間隔)  

``` txt : monotonic timerの設定例
[Timer]
OnActiveSec=1hour
OnUnitActiveSec=1hour
Unit=tiemr-test.service
```

タイマーユニット設定ファイルの[Timer]セクションに実行時刻を「OnCalendar=」で指定する。  
時刻の書式は「曜日 年-月-日 時刻」。(曜日、年-月-日、時刻は省略可能。全て省略したら00:00:00となる。)  

``` txt : realtime timerの設定例
[Timer]
OnCalendar=*-*-* 4:00:00
Unit=timer-test.service
```

まぁ、つまり、systemdでタイマー使いたかったら[.time]ってファイル作って[Timer]ってセクションに何か書けばいいって事だろう。  

### timedatectlコマンド

systemdの動作するシステムにおいてシステム時刻の表示や設定を行うコマンド。  
dateコマンドのようにシステムクロック（Linuxカーネルが持つ時刻）を操作するだけではなく、  
システムクロックとハードウェアクロック（コンピュータに内蔵された時刻）を同時に設定できます。  
コマンドのみを実行した場合、現在の日時、タイムゾーン、NTPを利用しているかどうかを表示する。  

``` txt
timedatectl [サブコマンド]

status                    :: 現在の状態を表示する(デフォルト)
set-time 時刻             :: 時刻を設定する(HH:MM:SS)
set-time 日付             :: 日付を設定する(YYYY-MM-DD)
set-time 日付 時刻        :: 日付と時刻を設定する(YYYY-MM-DD HH:MM:SS)
set-timezone タイムゾーン :: タイムゾーンを設定する
list-timezones            :: タイムゾーン一覧を表示する。zone's'であることに注意。
set-ntp yes|no            :: NTPを使うかどうか
```

日時を2019年3月12日12時24分に設定する。  
`timedatectl set-time 2019-03-12 12:24:00`  

タイムゾーンを「Asia/Tokyo」に設定する。  
`timedatectl set-timezone Asia/Tokyo`  

### pool.ntp.org

複数のNTPサーバで構成させる仮想的なNTPサーバを、DNSラウンドロビン方式で提供するプロジェクト。  
複数のNTPサーバをまとめて仮想的なNTPサーバとして運用し負荷分散の技術の一つである「DNSラウンドロビン」方式で時刻を提供します。  

---

## システムログの設定

Linuxでは、**syslog**と呼ばれるプログラムを使用することによってLinuxで発生する各種イベントをログファイルに出力したりコンソールに出力することが可能となります。  
syslogのプログラムは、**syslogd**というデーモンにより実行される。  
syslogは他のプログラムからのメッセージを受信して、出力元や優先度に従って分類を行って、syslogで定義した出力先に送信する。  

### syslog,rsyslog

CentOS6以降のディストリビューションではrsyslogが採用されている場合がある。  
rsyslogは各種機能をプラグインモジュールで拡張できるようになっている。  
ログの出力方式などは/etc/syslog.confファイルの書式とほぼ同じ。  
linucイージスではsyslog,小豆本ではrsyslogを解説しているのでどちらもまとめる。  

syslogの設定  
`/etc/syslog.conf`設定ファイルで行う。  

rsyslogの設定  
`/etc/rsyslog.conf`設定ファイル or `etc/rsyslog.d`設定ディレクトリで行う。  

### 各種ログ収集ソフトウェアについて

システムログを収集するLinuxのソフトウェア  
syslog , rsyslog , syslog-ng , systemd journal  

次世代のsyslog  
・rsyslog  
・syslog-ng  

■syslog  
4種類の中で最も古い。  
1980年代にEric Allman氏(Sendmailの開発者)が開発。  
Syslogプロトコルとして標準化。  
ファシリティ、プライオリティの始まり。  
問題点  
・ネットワーク経由でのメッセージ送受信にUDP(Port512)を使用しているため、サーバーにログメッセージが届いている事が保障出来ない(TCPのように確認応答がない)  
・syslogは暗号化機能を持っておらずすべてのログメッセージが平文で送受信されるため、ログが覗かれる可能性がある。  

■rsyslog(reliable-syslog)  
Rainer Gerhards氏が主開発者であるrsyslogプロジェクトによって2004年から開発が始まる。  
Syslogプロトコルをベースとして、TCPの利用、マルチスレッド対応、セキュリティの強化、各種データベース(MySQL,PostgreSQL,Oracle等)への対応。  
**rsyslog.confはsyslogの設定ファイルsyslog.confと後方互換性がある。**  

■syslog-ng(syslog next-generation)  
Balazs Scheidler氏が主開発者であるsyslog-ngプロジェクトによって1998年から開発が始まった。  
Syslogプロトコルに対応し、TCPの利用やメッセージのフィルタリング機能等の特徴がある。  
**syslog-ng.confはsyslog.confとは書式が異なるため互換性がない。**  

■systemd journal  
systemdが提供するログ機能。  
システムログの収集はsystemd-journaldデーモンが行う。  
カーネル、サービス、アプリケーションから収集したログを不揮発性ストレージ(/var/log/journal/machine-id/*.journal)  
揮発性ストレージ(/run/log/journal/madhine-id/*.journal)に構造化したバイナリデータとして格納される。  
※揮発性ストレージは再起動すると消える。runフォルダはメモリ上の仮想ファイルを扱う領域のため。  
揮発性、不揮発性の設定はjournald.confの中でパラメータStorageにより指定する。  
Syslogプロトコル互換のインターフェース(/dev/log,/run/systemd/journal/syslog)も備えている。  
収集したシステムログをrsyslogd等の他のSyslogデーモンに転送して格納する構成にすることもできる。  

### /etc/rsyslog.conf

rsyslog.confファイルは「モジュール設定部分」「グルーバル設定部分」「ルール設定部分」が主たる設定項目になる。  
どのようなメッセージをどこに出力するか？といった設定はルール設定部分および、/etc/rsyslog.dディレクトリ以下の～.confファイルで設定する。  

rsyslog.confファイルの書式 :: `ファシリティ.プライオリティ 出力先`  

`#`で始まる行はコメント行。  
モジュールプラグインのデフォルトは[imuxsock] [imklog]のみ有効になっている。  

``` txt : rsyslogの主なプラグインモジュール
imuxsock  :: UNIXソケットによるローカルロギングサポート(loggerコマンドなど)
imjournal :: systemdのジャーナルサポート
imklog    :: カーネルログのサポート
immark    :: マークを出力(--MARK--)
imudp     :: UDPでメッセージを受信
imtcp     :: TCPでメッセージを受信
```

### ファシリティ

メッセージの生成元を表す。  
具体的にはカーネルや実行中のプロセス。  
[*]を使うとすべてのファシリティを選択できる。  

``` txt : ファシリティ
auth,authpriv :: 認証システム(loginなど)による出力
cron          :: cronによる出力
deamon        :: 各種デーモンによる出力
kern          :: カーネルによる出力
lpr           :: 印刷システムによる出力
mail          :: メールサービス関連による出力
user          :: ユーザーアプリケーションによる出力
syslog        :: syslog機能
local0~local7 :: ローカルシステムの設定
```

※serverなる項目はないので注意。  

### プライオリティ

メッセージの重要度を表す。  
低く設定すればするほど、ログとして出力される情報量も多くなる。
[*]を使うとすべてのプライオリティを選択できる。  
noneだけは例外で、指定されたファシリティのログを除外する役割を持つ。  

・emergが最も高く、debugが最も低い。  
・指定したプライオリティよりもレベルが高いものがすべて記録される。  
・critならalertとemergも含まれる。  
・特定のプライオリティを指定したい場合、プライオリティの前に[=]を付ける。  
・因みにファシリティとプライオリティを合わせて「セレクタフィールド」という。  
・「;（セミコロン）」でつなぐことで、1つのアクションに対して複数のセレクタが指定できる。  

``` txt : プライオリティ
emerg   :: 緊急事態
alert   :: 早急に対処が必要な事態
crit    :: システムの処理は継続できるものの深刻な事態
err     :: 一般的なエラー
warning :: 一般的な警告
notice  :: 一般的な通知
info    :: 一般的な情報
debug   :: デバッグ情報
none    :: ログを記録しない
```

### 出力先

出力先として、ログファイルやユーザーの端末、他のホスト等を選択できる。  
この部分を「アクションフィールド」と言う。  

``` txt : アクションフィールド
ファイル名   :: ファイルへの出力
ユーザー名   :: ユーザーの端末への出力
@ホスト名    :: リモートホストのsyslogへUDPで出力
@@ホスト名   :: リモートホストのsyslogへTCPで出力
/dev/tty1    :: コンソール(rrt1)に出力
/dev/console :: コンソールへの出力
*            :: ログイン中のすべてのユーザーの端末に出力

/var/log/messages :: ログファイルに出力
@sv.example.com   :: ホストsv.sxample.comにUDPで出力
@@sv.example.com  :: ホストsv.example.comにTCPで出力
violet            :: ユーザーvioletの端末に出力
```

### 記述例のオンパレード

crit,alert,emergレベルのメール関連のログを/var/log/mailファイルに記録  
`mail.crit /var/log/mail`  

critレベルのメール関連のログを/var/log/mailファイルに記録  
`mail.=crit /var/log/mail`  

errレベル、noticeレベルのメール関連のログを/var/log/mailファイルに記録  
`mail.=err;mail.=notice /var/log/mail`  

crit,alert,emergレベルのメール関連のログを192.168.0.1の端末に転送  
`mail.crit @192.168.0.1`  

メールのログを出力しない  
`mail.none`  

カーネルに関するすべてのメッセージを/var/log/kernelに出力  
`keln.* /var/log/kernel`  

緊急メッセージは全ユーザーが受け取る  
`*.emerg *`  

「;（セミコロン）」でつなぐことで、1つのアクションに対して複数のセレクタが指定できる。  
`*.info;mail.none;syslog.none /var/log/messages`

・ファシリティとプライオリティは「.（ドット）」でつなぎます
・ファシリティとプライオリティをあわせて「セレクタ」と呼び、セレクタによって扱うログメッセージを特定します
・全てのファシリティや全てのプライオリティを指定するには「*（アスタリスク）」を使います
・プライオリティは、指定したレベル以上のログを出力します（errを指定すると、emerg, alert, crit, errが出力される）。特定のレベルのログだけを指定するには、「=（イコール）プライオリティ」とします。
・アクションには、出力先を指定します。出力先は、ファイルであれば絶対パス、外部のsyslogサーバであれば「@サーバアドレス」とします。出力先に「/dev/console」を指定すると、ログメッセージはコンソールに表示されます。また、緊急メッセージなど全ユーザーのコンソールに送信したい場合は「*（アスタリスク）」を指定します。

### loggerコマンド

システムログに記録を追加するコマンド。  
手動でログメッセージを生成するコマンド。  
ログメッセージを生成する事ができるので、syslog.confの設定ファイルが正しく設定されたのかを確認する事ができる。  
任意のファシリティ、任意のプライオリティのメッセージをsyslogに送るコマンドとも言える。  

``` txt
logger [-p ファシリティ.プライオリティ] [-t タグ] メッセージ

-f :: 指定したファイルの内容を送信する。
-p :: ファシリティ.プライオリティを指定する。デフォルトはuser.notice
```

ファシリティをsyslog,プライオリティをinfoとして「test message」というメッセージを出力  
`logger -p syslog.info -t TEST "test message"`  

### syslogの一元管理

各Linuxマシンでsyslogによりログを管理できるが、複数のLinuxマシンを運用する場合、syslogは1つのLinuxマシンに集中管理させることが一般的。  
その場合は、各Linuxマシンのsyslog.confファイルにて、syslogを管理するサーバーをログの出力先として設定する。  

Webサーバー、Mailサーバー、DNSサーバーがあったとして、それらのsyslog.confを`*.* @192.168.0.100`と設定する。  
syslogサーバーとして192.168.0.100を設定する。外部からのsyslogを受信できるようにUDPポート514番を解放する。  

### systemd-catコマンド

systemdを採用したシステムで使用可能。  
コマンドの実行結果をジャーナルに書き込む事ができるコマンド。  
メッセージをsystemd-journaldに送ることでログに記録するコマンド。  
引数の指定がない場合、標準入力から取りこんだメッセージをsystemd-journalに送ることでログに記録する。  

``` txt
systemd-cat コマンド
```

uptimeコマンドの実行結果をジャーナルに書き込む。  
`systemd-cat uptime`  
`journalctl -xe`を実行する事で結果を確認できる。  

標準入力からメッセージを取りこんでログに記録する。  
`echo Test! | systemd-cat`  

### logの調査方法色々

### journalctlコマンド

systemd-journaldが収集し、格納したsystemdのログを表示するコマンド。  
syslog,rsyslogなど、他のデーモンが収集したログは閲覧出来ない。  

ログの保存場所 :: `/var/log/journal` or `/var/run/log/journal`等のディレクトリ内にあるバイナリファイル。  
ログは一定量を超えると古いものから削除される。  
設定ファイル`/etc/systemd/journald.conf`で「Storage=persistent」となっていれば、ジャーナルは/var/log/jornalディレクトリ以下に永続的に保存される。  
/runはメモリ上にある仮想的なファイルシステムなので、システムの再起動で失われる。  
/etc/systemd/journald.confファイルの設定を変更した場合は、systemd-journaldを再起動する。  
`sudo systemctl restart systemd-journald`  

journalctlコマンドは、デフォルトでlessをページャとしてログ表示を行います。  
そのため、ページ単位での表示や文字列の検索が可能です。  
ページャを使用せず、catのように一括でログを表示させたい場合は --no-pager オプションを指定します。  

``` txt
journalctl [オプション] [フィールド=値]

主なオプション
-a(--all)       :: 画面表示出来ない文字も含めてすべて表示
-b(--boot)      :: 特定のシステム起動時のログを表示する。
                   0 :: 今回の起動
                   1 :: 最古のログ
                   2…と指定するか、直近の起動から-1(前回起動時),-2(2回前の起動時)…と指定する。
-e              :: ジャーナルの末尾(最新)を表示する。
-D(--directory) :: 指定したディレクトリのログを表示
-f(--follow)    :: ログの末尾を表示し続ける。リアルタイムに表示する。(tail -fと同様)
-k(--dmesg)     :: カーネルメッセージのみ示する。
-l(--full)      :: 画面表示可能な全てのログを表示する。エスケープ文字を除いてプレーンテキストで出力する。
-n(--lines)     :: 直近のログから指定行数分を表示(行数未指定時のデフォルトは10行)
--no-pager      :: 1ページ毎に表示せず、全てのログを出力する。
-o(--output)    :: ログの出力形式を指定。通常より詳細(verbose)な形式やJSON形式が指定できる。
-r(--reverse)   :: 最古のログからの表示(デフォルト)を逆にし、最新のログから表示。
-p ﾌﾟﾗｲｵﾘﾃｨ     :: 指定したプライオリティより高いメッセージを表示する。
-u Unit名       :: 指定したUnitのログを出力する。
--since         :: 指定日時以降を表示する。
--until         :: 指定日時までを表示する。
-x              :: 説明文付きで表示する。
                   ※エマージェンシーモードで起動時に"journalctl -xb"でログを確認するように表示される。
--vacuum-size=  :: アーカイブジャーナルの総容量が指定したサイズを下回るまで古いジャーナルを削除。
--vacuum-time=  :: 指定した期間より古いアーカイブジャーナルを削除。

主なフィールド
_PID=             :: プロセス番号の指定
_UID=             :: ユーザーIDの指定
SYSTEMD_UNIT=     :: Unit名の指定(-uオプションと同じ)
SYSLOG_FACILITY=  :: Syslogプロトコルのファシリティコードを指定して表示する。
```

[--since=] [--until=]で指定した日時のログを表示する。  

2019年7月8日9時から7月9日17時までのログを表示する。  
`journalctl --since="2019-07-08 09:00:00" --until="2019-07-09 17:00:00"`  

プライオリティがwarning以上のログの表示。  
`journalctl -p warning`  

ファシリティがメール(ファシリティコード=2)のログを表示。  
`journalctl SYSLOG_FACILITY=2`  

sshd.service関連のログのみ表示  
`journalctl -u sshd.service`

journalctlコマンドでのログ出力をjson形式に変更したい。  
`journalctl -o json`  

全てのファシリティ、全ておプライオリティのログをコンソールへ出力する。  
`*.* /dev/console`  

### systemd-journald

systemdの動作するシステムではsystemd-journaldデーモンを動作させ、ログの一元管理を行います。  
systemd-journaldはsystemdから起動したプロセスの標準出力やsyslogへのログメッセージをバイナリ形式で記録します。  
また、syslogの規格にも対応しており、同じファシリティ（ログの送信元）やプライオリティ（監視レベル）が指定できます。  

sytemd-journaldのデフォルトの設定では、バイナリ形式のログは「/run/log/journal」配下にシステム固有のディレクトリを作成し、  
その中の「system.journal」というジャーナルファイルに記録します。  
しかし「/run」ディレクトリはメモリ上に作成されたファイルシステム上のディレクトリのため、再起動するとデータが消えてしまいます。  
ログが再起動によってクリアされないようにするには、「/etc/systemd/journald.conf」でジャーナルファイルの保存先を制御する設定項目「Storage=persistent」を設定します。  
この設定により、systemd-journaldは「/var/log/journal」ディレクトリを作成し、その配下にログファイルを記録するようになります。  

・設定ファイルは`/etc/systemd/journald.conf`  
・syslogのファシリティとプライオリティに対応している  
・syslogへのログメッセージも記録する。  
・「/run/log/journal」配下に保存されたログは、システム再起動後はクリアされる  
・バイナリ形式のファイル名は「system.journal」である  

・rsyslogやsyslog-ngでは、systemd-journaldからメッセージを読み出す設定が必要である  
→  
systemd-journaldと旧来のsyslogd（syslogデーモン）が同時に稼働しているシステムでは、syslogdがsystemd-journaldからsyslogを読み出すように設定する必要があります。  
syslogに代わるrsyslog（reliable-syslog）やsyslog-ng（syslog next-generation）では、設定せずにsystemd-journaldから読み出せます。  

### ログファイルのローテーション

ログファイルのローテーション機能は、`logrotateユーティリティ`が提供している。  
logrotateユーティリティはcronを利用して、定期的に実行される。  
設定は`/etc/loglotate.conf`ファイルで行う。  

``` conf : /etc/logrotate.confファイルの内容(一部)
# ローテーション周期を1週間とする。
weekly
# バックアップログを4習慣保存する。
rotate 4
# ローテーションさせたら、空のログファイルを作成する。
create
# ログファイルを圧縮する。
compress
# /var/log/wtmpファイルの設定
/var/log/wtmp{
    monthly #←ローテーション周期を1か月とする。
    create 0664 root utmp #←パーミッション664,所有者root、グループutmpで新しいファイルを作成
    rotate 1    #←バックアップログを1つ保存する。
}
```

### logrotateコマンド

ログ名、間隔、回数を設定ファイルで指定してローテーションできる。  
logrotateコマンドは/etc/cron.daily/logrotateスクリプトにより、1日1回実行される。  
設定ファイル名は任意だが、一般的には/etc/logrotate.confとして用意する。  

``` txt
logrotate [オプション] 設定ファイル
```

/etc/logrotate.confを設定ファイルとして用意し、このファイルを指定してlogrotateコマンドを実行している例。  
`logrotate /etc/logrotate.conf`  

---

## メール管理(メールシステム)

### MTA(Mail Transfer Agent)

メールの転送を行うプログラム。  
ネットワーク経由、またはサーバ内部（ローカル）のメール転送依頼に基づき、指定された宛先へメールを転送する。  
メールシステムの中心的役割を担う。  
DNSサーバーを使用してメールの送信先となるMTAのホスト名を調べる。  
SMTPプロトコルでメッセージをやり取りするため、SMTPサーバーとも呼ばれる。  

代表的なMTAプログラム  
Exim,Postfix,Sendmailなど  

Sendmailは標準的なMTAとして長く使われてきたが、最近は使われていない。(さすがに古いし、後継もある)  
主流はEximとPostfix。  
SMTPサーバーとして使われる。  
EximとPostfixは以下のコマンドとファイルでの設定が有効であるためSendmailに互換性がある。  
・sendmailコマンド  
・newaliasesコマンド  
・mailqコマンド  
・~/.forwardファイル  

### MDA (Mail Delivery Agent)

ローカルのメールスプールへ配送するプログラム。  
MTAによってローカルの宛先へのメールであると判断されたメールを受け取り、宛先ユーザのメールボックス（メールスプール）へメールを配送する。  
MTAが受け取ったメールをローカルドメインのユーザーに配信する(メールスプールに格納する)プログラム。  

MTAに対するMDAプログラム  

- Sendmail : procmail(デフォルト)  
- PostFix : localデーモン  
- Exim : Exim自身が行う  

### MUA (Mail User Agenet)

ユーザーがメールの送受信に使用するプログラム。  
ユーザーがメールを扱うプログラム。  
自身のメールボックスへアクセスして受信したメールを閲覧したり、メールを送信したりする。  
MUAの例としては、LinuxのmailコマンドやThunderbird、WindowsやMac OS X付属のメールソフトがある。

CUIベース : malix,mutt  
GUIベース : Thunderbird,Evolution  

### メール配送の仕組み

``` txt
クライアント  メールサーバー  ネットワーク  メールサーバー  クライアント
    MUA    →     MTA①          →             MTA②
                                                 ↓
                                                 MDA
                                                 ↓
                                            メールボックス
                                                 ↓
                                              POPサーバー  →    MUA
```

①メールクライアントソフトウェア(MUA)で作成されたメールは、送信用MTA①へ送られる。  
②MTA①は、メールアドレスから配送先メールサーバーを調べ、メールをMTA②に配送する。  
③MTA②がメールを受け取ると、ローカル配送プログラムであるMDAが、メールのさて先となっているユーザーのメールボックスにメールを格納する。  
④受取人側はPOPサーバーやIMAPサーバーを経由して自分のメールボックスからメールを取り出す。  

### Sendmail

Sendmail : 1981  
古くから使われるMTAで、様々なメール転送方式に対応している。  
1つのプログラムで全ての処理を実行できる反面、設定は難解で専用のツールを使う必要がある。  
また、セキュリティ面での問題がたびたび発生したり、処理速度が遅いなどの問題もある。

``` txt : sendmailのメールスプールとキュー
スプール :: /var/spool/mail/   :: mail
キュー   :: /var/spool/mqueue/ :: mailq
```

### Exim

Exim : 1995  
Debian系の標準MTA。  
設定は平易だが、日本語の情報は比較的少ない。  
設定ファイルの内容はバージョンによって異なる。  

``` txt : Eximのメールスプールとキュー
スプール :: /var/mail/             :: mail
キュー   :: /var/spool/exim/input/ :: mailq
```

### Postfix

Postfix : 1998  
sendmailとの高い互換性を保ちながら、処理を高速化している。  
設定が平易でsendmailよりもセキュリティが向上しているため、最近の一部のLinuxディストリビューションで標準のMTAになっている。  

``` txt : Postfixのメールスプールとキュー
スプール :: /var/mail/                   :: mail
キュー   :: /var/spool/postfix/deferred/ :: mailq
```

### /etc/aliasesファイル

メールアドレスの別名を設定するファイル。  
例えば、root宛に届いたメールをユーザーadminとlpicでも受け取れるようにするには以下のように設定する。  
adminとlpicはどちらもrootあてのメールを受け取れるようになるが、rootにはメールが届かなくなる。  
設定の反映は`newaliases`コマンドで行う。  

・書式は「別名:転送先（メールアドレスやアカウント）」  
・転送先が複数ある場合はカンマで区切って指定  

``` txt : /etc/aliasesの記述例1
root: admin,lpic
```

``` bash: 記述例2
#vi /etc/aliases
support: root,postmaster, xxxx@yahoo.co.jp
# newaliases ←設定を反映させるために必要
```

### mailコマンド

コマンドラインでメールを受信したり、受信メールを確認したりするコマンド。  
mailコマンドでユーザー名のみを指定するとローカルシステムのユーザー宛に送信される。  

``` txt : ※sendmailのメールスプールとキュー
スプール :: /var/spool/mail/   :: 受信メール     :: mail
キュー   :: /var/spool/mqueue/ :: 返信待ちメール :: mailq
```

``` txt
■mail
引数なしでコマンドを実行すると、メールスプール「/var/spool/mail」に格納されている受信メールを表示する。
番号でその番号のメールを選択。qで終了。

■mail [-s 題名] [宛先メールアドレス or ユーザー名]
-sはタイトル(Subject)を指定するオプション。  
```

ローカルシステム内のユーザーである「admin」にメールを送信する。  

``` txt
mail -s TESTMAIL admin
this is a test e-mail
.
```

### sendmailコマンド

メールを送信するコマンド。  
CUIのMUAであるmalix,muttで利用する。  

古くからあるMTAのsendmailでは、メール送信やMTAの制御のためにsendmailコマンドが用意されていました。  
sendmailコマンドは引数無しで単独で実行すると、標準入力からメールのデータを受け取り、.（ピリオド）のみの行を受け取った時点でメールの送信を行います。  

MUAの中にはsendmailコマンドを使ってメールの送信を行うものもあることから、sendmail以外のMTAでも互換性のためにsendmailコマンドが用意されています。  
Postfixやeximでも、sendmailコマンドが用意されています。  

``` txt : 実行例
sendmail yuki@mylpic.com < 送信する本文を格納したファイル
```

### newaliasesコマンド

メールアドレスの別名を設定するファイルとして、エイリアスファイル(/etc/aliases)とエイリアスデータベースファイル(/etc/aliases.db)がある。  
このうちの、**エイリアスデータベースファイルを更新するコマンド**。  
エイリアスデータベースファイルは更新してもすぐには反映されないので、newaliasesコマンドを叩いて変更を反映させる必要がある。  
因みにエイリアスファイルはSendmail,Postfixの起動時にのみ、読みこまれる。  

エイリアスデータベースファイルがあれば、そちらを参照し、無ければエイリアスファイルが参照される。  
Eximはエイリアスデータベースファイルを参照しない。  
newaliasesコマンドは使えるが、それはSendmailとの互換性のためだけ。  

Sendmail,Postfix : エイリアスファイル、エイリアスデータベースファイル  
Exim : エイリアスファイル  

``` txt
別名 : 転送アドレス1,転送アドレス2,転送アドレス3
```

### mailqコマンド

MTAが転送できなかったメールのキューを見るためのコマンド。  
送信待ちのメールはメールキュー(/var/spool/mqueue)に蓄えられる。  
全MDA(Sendmail,Postfix,Exim)で使用可能。  

### ~/.forwardファイル

ユーザー受信メールのリダイレクトを行いたい時に設定するファイル。  
自分のホームディレクトリの下に`.forward`ファイルを作成して、転送先メールアドレスを記述する。  
一時的にメールを転送したい場合等に便利。  
ユーザーが各自で設定できるため、管理者が設定する必要はない。  

``` txt : 記述例
mana@example.com
mana@mylpic.com
```

自分宛のメールをmana@example.comとmana@mylpic.comに転送する。  

因みにファイル名やディレクトリが「.(ドット)」から始まるのは隠しファイルや隠しフォルダ。  
`~/`はホームディレクトリを表す。  

### オープンリレー

外部からのメールを制限することなく他のドメインに中継する事。  
そのままではスパムの踏み台にされるので、以下の制限を設定する。  
①外部からのメールはローカルドメイン宛のメールだけを受け取り、他のドメインへ中継しない。  
②内部ネットワークからのメールだけを他のドメインに中継する。  

因みに「外部からの名前解決リクエストに対して制限することなく答えを返すこと」をオーブンリゾルバという。  

MTA(Mail Transfer Agent)は、通常SMTP（電子メール送信用のプロトコル）を利用して電子メールを送信します。  
MTA間でメールの転送を行うことをリレー（中継）といい、リレー対象を制限せず、誰からのメール送信、  
転送依頼でも受け付ける設定になっているMTA（SMTPサーバ）の事を「オープンリレー」といいます。  
オープンリレーは誰でも利用できるため、悪質な迷惑メール（スパム）送信に使用されてしまいます。  
そのためインターネットに公開された**SMTPサーバ**にはオープンリレー設定をするべきではありません。  

### メール転送早見表

``` txt
設定ファイル    影響範囲        内容                  設定の反映方法
/etc/aliases :: システム全体 :: 別名と転送先を記載 :: [newaliases]コマンドを実行
~/.forward   :: ユーザー個別 :: 転送先を記載       :: 即時反映
```

---

## プリンタ管理

### CPUS(Common Unix Printing System)

UNIXの印刷サービス。印刷サブシステムらしい。  
以前はLPD（Line Printer Daemon）が使われていましたが、現在ではCUPS（Common Unix Printing System）が使われます。  
CUPSはレガシーな印刷システムであるLPDとの互換性があります。  

``` txt : LPDと互換性のある印刷コマンド
lpr  :: 印刷ジョブを生成し、プリントキューに登録
lprm :: プリントキューにある印刷ジョブを削除
lpq  :: プリントキューにある印刷ジョブを表示
```

``` txt : CUPSで標準的な印刷コマンド
lp     :: 印刷ジョブを生成し、プリントキューに登録
cancel :: プリントキューにある印刷ジョブを削除
lpstat :: プリントキューにある印刷ジョブを表示
```

- IPP(Internet Printer Protocol)の採用  
  ネットワーク上のプリンタをサポートする印刷プロトコルIPPを採用。  
- PPD(PostScript Printer Description)ファイルのサポート  
  AdobeのPPD形式のファイル(テキストファイル)でデバイスドライバの設定ができる。  
- Webベースで設定可能  
  Webブラウザから設定できるツールが組み込まれている。  
- プリンタクラスのサポート  
  複数のプリンタを1台のプリンタに見せかける機能をサポートしている。  
- `/etc/cups/ppd`  
  PPDファイルを格納するためのディレクトリ  
- `/var/spool/cups`  
  印刷ジョブを溜めておくためのスプールディレクトリ。  
- CUPSのデーモンはcupsd。  
  cupsdは`/etc/cups/cupsd.conf`設定ファイルを参照して動作します。  
- `/etc/cups/cupsd.conf`
  CUPSの設定ファイル  
  印刷要求をネットワーク経由で受け付ける場合のポート番号(631)や、接続するクライアントのアクセス許可の設定等。  
- `/etc/cups/printers.conf`
  プリンタに関する情報などの設定(プリンタの場所や共有設定など)  
- 設定ポート :: 631  
  localhost:631でアクセス。  

CUPSの設定ファイルが置かれるディレクトリは「/etc/cups/」です。  
ここに、CUPSのデーモン「cupsd」の設定ファイル「/etc/cups/cupsd.conf」や、プリンタに関する設定を記述する「/etc/cups/printers.conf」があります。  

設定の仕方  
①設定ファイルを直接編集。  
②WebブラウザでCUPSの設定ページにアクセスして編集する。  

### CUPSの印刷処理の流れ

1. アプリケーションや印刷コマンドから印刷データを受け取る。  
   プリンタの設定オプションはPPDファイルから提供される。  
2. スプーラーが印刷データを受付、スケジューリングを行う。  
3. プリンタが直接受け付けられないデータを一旦中間形式としてPDFまたはPostScriptにフィルタで変換する。  
4. PPDに定義されたフィルタにより、最終の印刷データに変換する。  
5. 処理した印刷データをCUPSのバックエンドに送る。  
6. バックエンドは印刷データをローカル接続(USBなど)またはネットワークを経由(IPPやLPRなど)してプリンタに渡す。  

ping-t解説  

1. データを印刷プログラムによって印刷ジョブとしてスプーラ（スケジューラ）に登録する  
2. スプーラは、スプールに溜まった印刷データを順に取り出してフィルタシステムに送る  
3. フィルタはデータをPostScript形式に変換し、PostScript形式のデータをPPDファイルの定義に従って、印刷するプリンタ専用のラスタデータ形式に変換する。  
   ラスタデータはバックエンドに送られる  
4. バックエンドは、渡されたラスタデータを指定されたプリンタに送信する  

### CUPSサービスの起動

SysVinitの場合  
`/etc/init.d/cups start`  

systemdの場合  
`systemctl start cups.service`  

IPPサービス(ポート631/tcp)が開いていれば、CUPSは動作している。  
`netstat -at | grep ipp`  

### PostScript , PPD(Postscript Printer Description)

アドビシステムズが開発したページ記述言語で、どういったデータをどのように描画するかという命令が記述されます。  

PPDファイルとは、アドビシステムズが策定したファイル形式で、プリンタがPostScriptで記述されたデータをどのように扱うかを定義するファイルです。  
(フォント、用紙サイズ、解像度など、PostScriptプリンタの機能を記述し制御するためのファイル)  

ラスタデータとは、点の集合で作成された画像形式です（例：JPEG、BMPファイル）。  
対称的な形式としてベクタデータ（数値や座標計算によって描画される画像形式）があります。  

現在のプリンタの多くは各メーカー独自の形式で印刷データを扱います。  
各プリンタ用のPPDファイルを用意することで、いったんPostScript形式に印刷データを変換することで、各メーカー独自の形式に変換することが容易になります。  
そのため、CUPSではLPDよりも多くのプリンタに対応できるようになりました。  

### lprコマンド

印刷コマンド。  
指定されたファイルや標準入力をプリントキューに送る。  
オプションでプリンタを指定しなければ、デフォルトのプリンタで印刷します。  

``` txt
lpr [オプション] [ファイル名]

-#部数      :: 印刷部数を指定する。
-Pプリンタ名 :: 印刷を行うプリンタを指定する。-Pとプリンタ名の間に空白はないことに注意。
```

テキストファイル testdata.txtを6部印刷する。  
`lpr -# 6 testdata.txt`  

/etc/passwdファイルを5部印刷する。  
`lpr -# 5 /etc/passwd`  

dmesgコマンドの出力を印刷する。  
`dmesg | lpr`  

「/etc/group」ファイルを「PrinterA」で印刷。  
`lpr -PPrinterA /etc/group`  

### lpqコマンド

BSD系におけるプリントキューの内容を表示するコマンド。  
オプションを指定せずにコマンドを実行した場合、デフォルトに設定されているプリンタのキューを表示する。  

``` txt
lpq [オプション] [ユーザー名] [ジョブ番号]

-a           :: すべてのプリンタの情報を表示。
-Pプリンタ名 :: 指定したプリンタの情報を表示。
```

### lpcコマンド

BSD系に属するプリンタのキューの状態を表示するコマンドの内の1つ。  
CUPSのlpcは実質的にプリントキューの状態を表示するstatusコマンドしかなく、`lpc status キュー名`以外の機能はない。  
コマンドの指定なしで実行すると対話的にコマンドを実行できる。  

``` txt
lpc [コマンド]
```

キューが受付可能かどうか、プリンタへ出力可能かどうか調べる。  
`lpc status all`

### lprmコマンド

プリンタキューにある印刷ジョブを削除するコマンド。  
一般ユーザーは自分の発行した印刷要求のみ、スーパーユーザーはすべての印刷要求を削除できる。  

``` txt
lprm [オプション] [ジョブ番号]

-Pプリンタ名 :: 指定したプリンタの印刷ジョブを削除。
-            :: 自分の印刷ジョブをすべて削除。
                rootユーザーで実行した場合は、全ユーザーの印刷ジョブを削除する。
```

自分の印刷ジョブを全て削除(一般)  
`$ lprm -`  

PrinterBで問題を起こしている印刷ジョブ番号500の印刷ジョブをいったん取り消したい。  
`lprm -PPrinterB 500`  

### lpadminコマンド

プリンタの登録や削除等を行うCUPSの設定コマンド。

``` txt
lpadmin -p プリンタ名 [オプション] 

-p :: 作成するプリンタ名を指定する。
-E :: プリンタジョブを受付、プリンタへの出力を開始状態にする。
-v :: デバイスURIを指定する。
-m :: modelディレクトリ/usr/share/cups/modelの下のPPDファイル名を指定する。
-p :: PPDファイル名を指定する。
```

新規にプリンタを登録する構文  
`lpadmin -p プリンタ名 オプション`  

デフォルトプリンタを設定する構文  
`lpadmin -d プリンタ名`  

デフォルトプリンタを削除する構文  
`lpadmin -x プリンタ名`  

### lpコマンド

CUPSの標準的な印刷コマンド。  
印刷ジョブを生成し、プリントキューに登録する。  

SystemV系のlprコマンド。  
lprはBSD系らしい。  
オプションの機能は同じなのに引数が違うというクソ仕様。  

``` txt
lp [オプション] ファイル名

-d      :: 指定したプリンタに出力する。指定しない場合はデフォルトプリンタが使われる。 lprにおける-P。
-n 部数 :: numで指定した部数を出力する。lprにおける-#。
-o raw  :: フィルタを通さずにプリンタに出力する。これはlprと同じ。
-l      :: フィルタを通さずに直接印刷する。-oと動作的に同じらしい。
```

sampleファイルを2部印刷する。  
パイプラインでファイル名を渡しても大丈夫らしい。  
`cat sample | lp -n2`  
`cat sample | lpr -#2`

### lpstatコマンド

CUPS標準の印刷ジョブを表示するコマンド。  
SystemV系におけるプリンターのキューを表示するコマンド。  
BSD系はlpqとlpc。  

``` txt
lpstat [オプション]

-a :: プリントキューが受付可能(accept)になっているか否かを表示。
-p :: プリントキューが出力可能(enable)になっているか否かを表示。
-t :: プリンタの状態をキューの状態を含めてすべて表示。  
```

### cancelコマンド

CUPS標準の印刷ジョブを削除するコマンド。  

PrinterBの全ての印刷ジョブを削除する。  
`cancel -a PrinterB`  

### cupsdisableコマンド

指定したプリンターを停止状態にするコマンド。  
引数に-r(reason)を付けて実行すると、現在のプリンタの状態のコメントを設定することができる。  
コメントはキューの状態を調べるコマンドを実行したときに表示される。  

``` txt
cupsdisable [オプション] プリンタ名

-c :: プリントキューの全てのジョブをキャンセル
-r :: 停止の理由を示すメッセージを指定。キューの状態の中にメッセージが表示される。
```

### cupsableコマンド

停止したプリンタを開始するコマンド。  

### cupsrejectコマンド

指定したプリンタへのプリントジョブを受け付けないようにするコマンド。  

``` txt

-c :: プリントキューの全てのジョブをキャンセル
-r :: 停止の理由を示すメッセージを指定(cupsrejectのみ)。キューの状態の中にメッセージが表示される。
```

### cupsacceptコマンド

プリントジョブを受け付けるようにするコマンド。  

### プリントキュー管理のまとめ  

``` txt
lp,lprコマンド → プリントキュー入口 → プリントジョブ → プリントキュー出口 → プリンタ
                         ↑                    ↑                  ↑
    受付/拒否を制御するコマンド  キューの状態を表示するコマンド   開始/停止を制御するコマンド
                    cupsaccept             lpstat -a              cupseanble
                    cupsreject             lpstat -p              cupsdisable
                                           lpstat -t
                                           lpq
                                           lpc status

```

---

## 小豆本問題

---

### 1 ○

cronを使って自動的にバックアップを取るようにしている。  
バックアップファイル名にバックアップ日時が使われるにように死体場合、書式として適切なコマンドは？  

→  
D. ``tar czf /backup/date`date "+%Y%m%d"`.tar.gz /home``  

すげー。当たった。  
書式の設定はじめは「+」からだったような？ってのは合ってたみたいだ。  
tarのコマンドは知らん。xは回答だから違うとしとvとfの違いがわからない。  

cfz → create file zip  

---

### 2 ○

認証関連のメッセージで、プライオリティがnotice以上のものは/var/log/secureに保存されるようにしたい場合、/etc/rsyslog.confの書式として適切なものを選択せよ。  

→  
C.`authpriv.notice /var/log/secure`  

ファシリティ.プライオリティ 出力先  

---

### 3 ○

システムログファイル/var/log/messagesを常に監視して起き、新しいメッセージが書き込まれる様子を画面上でモニタリングし続けたい場合、  
どのコマンドを実行すればよいか？  

→  
B. `tail -f /var/log/messages`  

普通に考えて後に追加されたものを表示するからtailかなって思うけどね。  
tailコマンドの-fオプションはファイルの末尾を表示し続け、新たに書き込みがあればリアルタイムに画面に表示する。  

---

### 4 ○

Postfixを利用している。  
root宛のメールをユーザーuser01で受け取れるように設定するため、/etc/aliasesファイルを編集しましたが、メールが届きません。  
実行すべき操作は？  

→  
C.newaliasesコマンドを実行する。  

意外と覚えているものである。  

---

### 5 ○

jupitor.example.net上でstudentユーザーとして作業をしている。  
student@jupitor.example.netに届いたメールを、student@lpic.jpに転送するには~/___に「student@lpic.jp」と記述します。  
下線部のファイル名は？  

→  
.forward  

覚えているものである。  

---

### 6 ○

メールがメールキューに残っていないかを確認するためにあるコマンドを実行した。  
`$____`
mail queue is empty  

コマンドは？  

→  
mailq  

すげー。まじで覚えてるもんだな。  

---

### 7 ○

lprコマンドを使い、プリンタlaser01で、/etc/hpstsファイルを5部印刷したい場合、どのコマンドを実行すればよいか？  

→  
`lpr -# 5 -P laser01 /etc/hosts`  
なのでCですね。  
親切なことに#が入ってるのが1つしかないので、実質正解みたいなものだ。  

---

### 8 ○

プリントキューにある自分の印刷ジョブを全て削除したい場合、実行すべきコマンドは？  

→  
lprm -  

[-]は自分のジョブを消すオプションだったっけか。  
昨日の今日とは言え、全問正解はすごくないか？  
