# データベース

## 多対多の概念

[やさしい図解で学ぶ 中間テーブル 多対多 概念編](https://qiita.com/ramuneru/items/db43589551dd0c00fef9)  

多対多のテーブルを結合する場合には、間に中間テーブルを嚙ませるといい感じになるよって話。  
因みに、多対多に中間テーブルを適応することによって「1対多、多対1」の関係にすることができる。  

A 多対多 B  
→  
A 1対多 中間 多対1 B  

---

## 正規化

[うさぎでもわかる](https://www.momoyama-usagi.com/entry/info-database-seikika)  
[[DataBase]で行う正規化の手順についてわかりやすく解説します](https://rikulogger.com/db/nomalization/)

**正規化**  
データとかを使いやすいように整理したり変形したりすること  
正規化の目的は冗長性の排除することで更新時異状を回避し、データベースの一貫性を確保すること。  
DB上で扱うデータの重複を排除し、「矛盾」の発生を「設計レベル」で防ぐこと。  
正規化はパフォーマンス向上のために行うわけではない。  

**第1正規形**  
→同一行内に置ける重複の排除  
ポイント：レコードの繰り返し項目を別のレコードへと分割する  

パッと見DBに格納できる状態ではあるが、重複しまくっているので使い物にはならない状態。  

**第2正規形**  
→部分関数従属の排除。  
複合主キーの部分キーによって一意に定まる属性を別表に移したもの。  
主キーに部分従属している属性を分離したもの。  
ポイント：テーブルの主キーに着目し、その項目に関数従属する非キー項目を見つける。  

この項目はこの主キーとこの主キーの組み合わせで特定できるよね？  
逆にこの項目はこの主キーだけで特定できるよね？  
ってのを上げて、それぞれのテーブルに分離した状態。  

**第3正規形**  
→推移的関数従属の排除。  
主キー又は主キーの一部に推移的に関数従属する属性を別表に移します。  
どのテーブルであってもすべての属性が主キーに対して完全従属であるテーブルにします。  
`a→b→{f，g，h}、受注番号→顧客コード→顧客名`  
ポイント：非キー項目に着目して、関数従属する項目を見つける  

それぞれのテーブルに分けたのはいいけれど、分けた後のテーブルの中に主キーじゃないキーで特定できる項目(非キー項目)が残ってるよね。  
このキーとなりえる項目とそれに紐づく名称とかの情報は別のテーブルとして独立させることができるよね？  
ってのを探して、それを分離させた状態。  
つまり、マスターとして独立した状態。  

### 結局のところ、第1正規系と第2正規系と第3正規系って何が違うの？

第1正規系はわかる。  
正規化される前の状態はレコードが重複しまくって、データベースに格納できない状態だから、その重複を解消するのが第1正規系で行うこと。  
正直、この状態は試験ではまず出ない。対策するなら第2正規系と第3正規系の一番微妙な間をやるべし。  

第3正規系はマスターとしてまとまってる状態ではなかろうか。  
主キーで一意に決まるテーブルとしてそれぞれ分離された状態。  
少なくとも、業務でデータベースを設計するならここまでやらないと不十分だろう。  
データを参照する際はテーブルを結合しまくってようやくデータが出来上がるって状態にまで分離された状態。  

第1と第3がわかれば、第2もなんとなくわかってくるのでは？  
正直、第2正規系が一番微妙なのだが、「これ別のテーブルに分離できるよな？」ってのがあれば第2正規系状態といえるのではないだろうか。  
次にデータベースの問題をやるなら、そういう点に着目してやってみようかね。  

まぁ、上に行く程重複もなくなって、テーブルとして独立していくってイメージでいいんじゃないでしょうかね。  

第1正規形：レコードの繰り返し項目を別レコードへと分割する。  
第2正規形：テーブルの主キーに着目して、関数従属する非キー項目を見つける。  
第3正規形：テーブルの非キーに着目して、関数従属する項目を見つける。  

---

## 主キーはアップデート可能か？

<https://urashita.com/archives/33098>

**可能**  
萬君に質問されたので、知識を確かなものにするためにまとめ。  
Teelaか何かでやったことがあるような気がしたが、まとめていなかったので自信を持って答えられなかったのでまとめ。  

<https://atmarkit.itmedia.co.jp/bbs/phpBB/viewtopic.php?topic=45369&forum=26>  
更新は可能だが、1レコードを特定するための情報が変更されてしまうし、更新した値が他の値と被った場合エラーになるので、運用が難しくなる。  
後、そうしなきゃいけない地点で設計が悪い。  
マスターの主キーが更新された場合には関連するテーブルの全てを更新しなければいけなくなる可能性も存在する。  

---

## レプリケーション

レプリケーション : 複製

[わかりそうレプリケーション (replication)](https://wa3.i-3-i.info/word12869.html)  

平成30年春午後のネットワークでレプリケーションサーバーってのが出てきて、単語だけ調べるつもりだったけど、DBにまで範囲が及んだのでまとめることにした。  
レプリケーションは複製という意味になる。  
オリジナルDBに書き込みつつ、同じ内容をレプリカDBにも書き込む事をレプリケーションというらしい。  
つまり、リアルタイムに複製を生成する技術ということになるか。  

話だけ聞くとバックアップと同じように感じるが、バックアップはある時点のデータをメディアに記録して別の場所に保管することを指すので、全然違う。  
後、障害が発生した場合、環境から用意しないといけないが、レプリケーションは同じ環境で動作しているものを切り替えるだけで済むので対応力も違う。  
一応その記事も置いておきますね。  
[レプリケーションとは？バックアップと何が違う？](https://bcblog.sios.jp/what-is-replication/)  

---

## サロゲートキー

<https://amg-solution.jp/blog/8980>  

surrogate : 代理
代理キー。ウチで言う一番左のid列のこと。ソートの為にあるようなやつ。  
それ単体では意味を持たないが、一意であるキー。  
主キーを設定すること。  

---

## PRIMARY KEY (主キー) と UNIQUE の違い

[PostgreSQL - PRIMARY KEY (主キー) と UNIQUE の違い](https://esthersoftware.hatenablog.com/entry/deference-between-primarykey-and-unique-postgresql)  

### PRIMARY KEY と UNIQUE の違いとは？

Primary Key（主キー）とUniqueはどちらも「データが一意である」制約を設定するものです。それならこの2つに違いはあるの？と気になったので調べてみました。

### PRYMARY KEY(主キー)

・「テーブル内の行データを識別するために設定でき、重複した値を許さないカラム」のこと
・複数のカラムに対して設定可能
・NULLは許可されない
・UNIQUE制約と非NULL制約を組み合わせたもの
・この制約は一つのテーブルに対して一つしか設定できない

[主キー（primary key）を複数のカラムに、その名は複合主キー（composite primary key ）](https://ts0818.hatenablog.com/entry/2017/02/04/162513)  

主キーが1つだけしか許可されないなら、複数のカラムに主キーを設定してるあれはなんなの？  
→  
複数のカラムをまとめて複合キーとして、その複合キーに対して主キーを設定している。  
なので主キーを実質1つしか設定していないことになるので、問題がないということ。  

### UNIQUE制約

・「カラムまたはカラムのグループに含まれるデータが、テーブル内の全ての行で一意であることを確実にする」ということ  
・つまり行データを識別する必要は無いけれど、あるカラムに対して重複した値が入るのを禁止したいときに使う  

・重複した値の入力が不可能になる。  
・NULLは許可されている。  
・この制約は一つのテーブルに対して複数設定することができる。  

### まとめ

・PRIMARY KEYもUNIQUEもデータに一意性を持たせる点は同じ  
・目的によって使い分けができる  

PRIMARY KEY : テーブル内の行データを特定するために一意性を持たせる。  
UNIQUE制約 :  重複した値を格納したくないカラム（またはカラムのグループ）に一意性を持たせる。  

というわけなので、このカラムとこのカラムを主キーにするってことは出来なくて、  
このカラムとこのカラムを合わせて複合キーとして、その複合キーに対して主キーを設定するのはOK。  
UNIQUEキーなら、このカラムとこのカラムにユニーク制約を課すってのはOK。  
この違いが主キーとユニークキーの違いってところじゃないですかね。  

---

## DDLについて

A5M2からDDL作成ってやってテーブル生成クエリ作ってもらうじゃないですか。  
DDLって何よ？ってなったのが発端。  
調べたらそこそこあったので全部まとめることにした。  

[わかりそうデータ定義言語 (DDL)](https://wa3.i-3-i.info/word15639.html)  
SQLを使った命令は、大きく分けて3つに分類できる。  
1．データをあれこれするときに使う命令  
2．データを入れておく箱をあれこれするときに使う命令  
3．データベースに対する権限周りをあれこれするときに使う命令  

**1.データ操作言語(DML Data Manipulation Language)**  
「データをあれこれするときに使う命令」はデータそのものに関する命令です。  
「この条件に一致するデータを探して」「このデータを入れておけ」「このデータのこの値をこっちの値に変えて」「このデータを削除して」のような命令をするときに使います。  

・select文
・insert文
・update文
・delete文

**2.データ定義言語(DDL Data Definition Language)**  
「２．データを入れておく箱をあれこれするときに使う命令」はデータを入れておく箱に関する命令です。  
「このデータが入る箱を作って」「この箱をもっと大きくして」「この箱は使わないから捨てちゃって」のような命令をするときに使います。  

・create文
・drop文
・alter文

**3.データ制御言語(DCL Data Control Language)**  
「３．データベースに対する権限周りをあれこれするときに使う命令」は使ってイイ人やダメな人を指定するときに使う命令です。  
「ピヨ子さんには、この箱の中身は見せないで」「ピヨ太ママには見せていいけど、変更はさせないで」のよう命令をするときに使います。  

・grant文
・revoke文
・commit
・rollback

---

## CASCADE

削除するテーブルに依存しているオブジェクト（ビューなど）を自動的に削除します。  

DROP TABLEは、削除対象のテーブル内に存在するインデックス、ルール、トリガ、制約を全て削除します。  
しかし、ビューや他のテーブルから外部キー制約によって参照されているテーブルを削除するにはCASCADEを指定する必要があります  
（CASCADEを指定すると、テーブルに依存するビューは完全に削除されます。  
しかし、外部キー制約によって参照されている場合は、外部キー制約のみが削除され、その外部キーを持つテーブルそのものは削除されません）。  

---

## ダーティリード、ファントムリードと分離レベル

[トランザクション分離レベルについてのまとめ](https://qiita.com/song_ss/items/38e514b05e9dabae3bdb)  
[[RDBMS][SQL]トランザクション分離レベルについて極力分かりやすく解説](https://qiita.com/PruneMazui/items/4135fcf7621869726b4b)  

READ UNCOMMITTED
