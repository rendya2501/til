# 平成26年春季

---

## セキュリティ

---

## データベース 旅客船Web予約システムの構築

いえーい100点。  
しかも20分。  
この年のデータベースは簡単だな。  
特にいうことがない。  
最後の長文も考えてる事はほぼ同じだった。  
と、思ったら微妙に違ったけど、まぁ部分点はもらえるだろう。  

``` txt : 20分 9/9
## メモ

問題はログまでロールバックされている事か。
ログをトランザクションに含めないようには出来ないのだろうか。
それかロールバックしてからログに書き込めるようにするとか。
変数受けして、ロールバックしてからその変数の内容をログに書き込むなんて対処が出来ればいいけど、あくまで流れだからな。

トランザクションを開始する前と完了した後にログを記録するようにする。
流れと言えばこれくらいか？


a : -
運賃係数
ユーザID = :ユーザID
パスワードハッシュ値 = HASH(:パスワード)
COUNT(*)
座席クラス
B.座席クラス番号 = C.座席クラス番号
A.船便番号,A.船便名,C.座席クラス番号,C座席クラス名
トランザクションを開始する前と完了した後にログを記録するようにする 100%
他)操作ログ表への記録を予約受付処理とは別のトランザクションにする


[a]
〔aについて〕
顧客エンティティとWebユーザエンティティには共通の属性「顧客番号」があります。
この属性「顧客番号」は、顧客エンティティ側では主キーであり、顧客を一意に特定します。
また、Webユーザエンティティ側でも主キーであり、Webユーザを一意に特定します。
どちらののエンティティもある顧客番号につき一意のエンティティですから、同一の顧客番号をもつ複数のレコードが存在することはありません。
したがって、顧客エンティティとWebユーザエンティティのカーディナリティは1対1であり、[a]には「―」が当てはまります。

つまり、主キーが同じなら1対1になるってことだ。


[4]
図4を見ると、「トランザクションを開始」から「トランザクションをコミット／ロールバック」までに予約受付処理自体とその操作ログ表への記録がひとまとめになっていることがわかります。
トランザクションには原子性という性質があり、一連の処理全部が正しく実行されたか、全く実行されなかったかのどちらかの状態で終了しなけばなりません。
このため、予約受付処理が失敗した際のロールバックでは、予約表、予約明細表、座席表だけでなく、操作ログ表もトランザクション前の状態に戻ってしまいます。
これが処理失敗時に操作ログ表のレコードが記録されなかった原因です。

予約受付処理が失敗した際にも、操作ログを操作ログ表に記録するためには、操作ログの記録処理を予約受付処理のトランザクションから分離しなければなりません。
したがって、適切な対応策は「操作ログ表への記録を予約受付処理とは別のトランザクションにする」です。
実装上はエラーハンドリングを行い、例外処理の中でロールバック処理＋操作ログの記録を行うことになります。

∴操作ログ表への記録を予約受付処理とは別のトランザクションにする

→

流れっていうからこの中で何とかするもんだと思うじゃん。
トランザクションの外に出せる回答が許されるならそうしたさ。
これは問題が悪いな。
```

---

## 組込みシステム
