# 令和3年春季

## セキュリティ DNSのセキュリティ対策

もっといけるかと思ったがダメだった。  
というか、実試験の時の回答を見てみたがさんざんだった。  
一番自信があった教科でこれでは万に一つの望みもなかっただろうなぁ。  
そうでなくても自信満々で答えた答えが間違っていた時の衝撃は計り知れない。  
しっかり復習しましょう。  

簡単そうに見えてダメだったのはなぜか。  
DNSサーバーの設定の仕方とか、各種用語をなんとなくで覚えてたり、キャッシュから想定できることが漏れていたからかな。  
つまり・・・、知識不足とかそこまで頭が回らなかったということになる。  

水飲み場攻撃はWebサイトに関係するもの。  
DNSの話もあって、そちらのサイトに誘導されてしまう連想をしてしまったが、ちゃんとした知識があれば解ける問題だった。  
よく訪れるサイトを改ざんする事によって攻撃する手法が水飲み場攻撃です。  

逆引きDNSはLPICでもやった。  
名前からIPアドレスを求める奴の逆ってだけで、それっぽい選択肢に見えてしまった。  
見えてしまった地点でどういうものかわかっていなかったことになるから知識不足が否めない。  

管理者権限については当時、皆目見当も付かなかったが、LPICを勉強した後ならある程度わかるかも。  
サーバーの設定なのだから、管理者権限でファイルの編集が必要だわな。  
これは当時はわからなかったと思う。  
LPIC等の具体的な勉強をしないと正解しない問題だ。  

2回目の復習は7分で完了。100点だった。  
意外と覚えているモノである。  
やっぱり悩まないと覚えられない。  

DNSにおける何を奪取されたのか。  
復習していても結構迷う。  
DNSサーバー情報を書き換えるために何が必要か？  
それは管理者権限である、という流れに落とし込めればいいらしい。  
一番それっぽいデジタル証明書は部外者がDNSサーバーを認証するためのモノなので、ちょっと趣旨が違う。  

後はDNSが外部からの応答ができることのリスクとしてはDDos攻撃を受けてしまうということかな。  
DDos攻撃の内容をDNSクエリにすれば、DNSサーバーは大量の応答に対応しなければならなくなってしまう。  

``` txt : 1回目回答 22分 5/8
ウ、エ

ア
サイトへのレコートは改ざんされていたから  
→顧客がR社の偽サイトに誘導されたから
エ

ア × エ
エ × ア
エ × ア
DNSキャッシュポイズニング
```

``` txt : 本番での回答 4/8
## 1
ウ × ウ、エ

## 2
1. ウ × ア
2. 既にAレコードが改ざんされていたから ○
3. エ  ○

## 3
1. エ ○
2. エ × ア
3. エ × ア
4. DNSキャッシュポイズニング ○
```

``` txt : 解説
### 1
権威DNSサーバ
ドメインの名前解決の情報を保持し、外部からの問合せに対して自身が保持する情報を応答する
キャッシュDNSサーバ
ドメインの名前解決の情報をもたず、外部に問い合わせを行って、その結果をクライアントに返す。結果はキャッシュとして一定時間保持しておく

Y社からR社サイトにアクセスする際には、以下の流れでドメインの名前解決が行われます。

1.Y社の社員がブラウザでR社サイトのURLにアクセスする
2.ブラウザはR社サイトのIPアドレスを取得するため、ドメインの名前解決をZ社のDNSサーバ（キャッシュサーバ）に依頼する
3.Z社のDNSサーバは、キャッシュがあればそれをブラウザに返す。キャッシュがなければ反復問合せを行い、最終的にR社の権威DNSサーバから得られた結果をブラウザに返す
4.ブラウザは受け取ったIPアドレスにアクセスする

調査結果として「R社の権威DNSサーバ上の，R社のWebサーバのAレコード※が別のサイトのIPアドレスに改ざんされていることが分かった。」とありますから、
名前解決の流れを踏まえると、偽のIPアドレスを返したのは、名前解決に介在する2つのDNSサーバ、
すなわち偽のIPアドレス情報を保持する「R社の権威DNSサーバ」または偽のIPアドレス情報をキャッシュとして保持していた「Z社のDNSサーバ」であると判断できます。
したがって「ウ，エ」の組合せが適切となります。

→
実試験では「ウ」しか答えていなかった。
全て答えなさいって部分を読み飛ばしてしまったからだろう。
よくよく考えれば、Z社のキャッシュからも間違った情報を返す可能性もあるのだ。
試験のプレッシャーもあって、そこまで頭が回らなかったのだろう。
当時は自信満々で臨んだけど、これではなぁ。


### 2
1.
権威DNSサーバのAレコードを改ざんするために必要なものが当てはまります。
逆を言えばこれを入手できればDNSサーバの情報の改ざんをすることができるということです。
これに該当するものは「管理者権限」のみです。
DNSサーバの管理者権限があれば、ファイルの編集を含む任意のコマンドを実行することができ、DNS情報（DNSゾーンファイル）の書き換えも可能となります。
表1内の「業務時間外にログインされた形跡が残っていた」という記述から、管理者権限によりリモートセッションを許可、リモートログイン、
ファイル編集という手順でDNS情報の書き換えを行ったものと推察されます。

イ. シリアル番号とはDNS情報を変更した際に増加させるSOAレコードの値のことです。この値を取得してもDNS情報の書き換えはできません。
ウ. ディジタル証明書はDNSサーバの認証に使うものなので誤りです。
エ. 単なる利用者（一般ユーザ）の権限ではDNS情報の書き換えはできないこと、パスワードだけ入手してもユーザIDがわからなければ無意味なので適切ではないと言えます。
∴a＝ア：管理者権限

当時は何を奪取されたので皆目見当も付かなかった。
当時はディジタル証明書と応えたが、それはWebサーバーに対してのものでDNSとは関係ない。

2.
R社の権威DNSサーバのAレコードが改ざんされていたので、ある一定の時期は外部からの名前解決要求に対して偽のIPアドレスを応答し続けていたということになります。
したがって、Y社の社員のみならず、R社サイトにアクセスしようとした他の顧客も偽のIPアドレスによりR社の偽サイトに誘導されていたと考えられます。
R社サイトへのアクセスがほとんどなかったのはこのためです。

全部のアクセスではなくて"ほとんど"のアクセスとなっているのは、正しいIPアドレスのキャッシュが残っていた一部のDNSサーバを利用していた者と、
R社の社内LANからプライベートIPアドレスで直アクセスしていた人は正規のR社サイトに繋がっていたからでしょう。

∴顧客がR社の偽サイトに誘導されたから

3.
キャッシュDNSサーバは、権威DNSサーバに行った問い合わせ結果を一定時間キャッシュとして保持し、
そのキャッシュの有効期限内に再度同じドメインについて問い合わせがあった場合には、権威DNSサーバに問い合わせることなくキャッシュの情報をクライアントに返します。
そして、キャッシュが切れれば再び権威DNSサーバに問い合わせを行います。
この仕組みにより、R社の権威DNSサーバのAレコードが正しいIPアドレスに戻されても、キャッシュの有効期限が切れるまでは従前の(偽の)IPアドレスが返されるので、
アクセス先が正しいR社サイトに戻るまでには一定の時間を要することになります。

設問1の名前解決の流れで説明した通り、Y社にとって名前解決を一任するキャッシュDNSサーバはZ社のDNSサーバですから、
Y社のPCが正しいR社サイトにアクセスできるようになるまで、しばらく時間が掛かったのはキャッシュが「Z社のDNSサーバ」に残っていたからです。

∴エ：Z社のDNSサーバ


### 3
1.
本問では、DNSソフトウェアの脆弱性を悪用した攻撃によってDNSサーバの管理者権限が奪取されています。
表1の権威DNSサーバの行を見ると「DNSソフトウェアのバージョンが古く…」と記載されており、既知の脆弱性であったにもかかわらず、
それに気付かず何のリスク対策もしないまま運用されていたことがわかります。

脆弱性診断を定期的に実施し、適切な対策を講じていれば防ぐことのできたインシデントですから、
同様のインシデントを起こさないための再発防止策としては「定期的に脆弱性検査と対策を実施する」という対策が有効となります。

ア.
逆引きDNSレコード（PTRレコード）とは、通常の名前解決（正引き）とは反対に、IPアドレスからドメイン名・ホスト名を取得するために登録するリソースレコードです。
正引きと逆引きを照合することで簡易的な認証にはなりますが、利用者が管理者権限を奪取されるという今回の問題には有効とは言えません。

ウ.
ゾーン転送とはプライマリDNSサーバ(主系)とセカンダリDNSのサーバ(従系)においてDNS情報の同期するために行われる、
プライマリDNSサーバからセカンダリDNSのサーバへのDNS情報の受渡しです。
今回のインシデントの原因とは関係ありません。

∴エ：定期的に脆弱性検査と対策を実施する。

2.
〔bについて〕
EV証明書を導入したときにR社サイトにおいて確認できるようになることが当てはまります。

EV(Extended Validation)証明書は、証明書発行の際に申請組織が法的・物理的に実在するかを厳格に審査した上で発行されるサーバ証明書です。
実在の確認は、登記事項証明書、企業情報データベースおよび電話などで行います。
EV証明書は Organization Name フィールドに「完全な法的組織名」を記載することが必須となっていて、
2021年7月現在、PCブラウザ（一部を除く）でアドレスバーの鍵マークをクリックしたときに組織名（英語）が表示されるので、
DV証明書と比較して利用者からの信頼性が高くなります。

したがって空欄には「会社名」が当てはまります。

∴b＝ア：会社名

3.
キャッシュDNSサーバが外部に公開されていると、攻撃者から受けたDNSクエリを処理してしまうことになります。
このため、攻撃者が大量のDNSクエリを送り付けるDDoS攻撃が成立する可能性があります。

例えば、公開されているキャッシュDNSサーバを悪用した攻撃として、ランダムサブドメイン攻撃（DNS水責め攻撃）というものがあります。
DDoS攻撃の一種で、実際には存在しない多数のサブドメイン（例えば、a.example.com、b.example.com、…）に対するDNSクエリを発行することで、
権威DNSサーバへの問合せを意図的に大量発生させる攻撃です。
この攻撃を受けた権威DNSサーバは、過負荷状態となりサーバダウンやサービス停止に陥ってしまう可能性があります。
権威DNSサーバがダウンすると、管理下のドメインの名前解決ができなくなるためWebサイトの利用に影響を与えます。
またDNSアンプ攻撃等の反射系DDoS攻撃の踏み台に使われてしまうこともあります。
当然のことながら単純に大量のパケットを送り付けるDDoS攻撃の標的にもなり得ます。

SQLインジェクション
Webアプリケーションへの入力データとしてデータベースへの命令文を構成する文字を与え、想定外のSQL文を意図的に実行させてデータベースを不正操作する攻撃です。
キャッシュDNSサーバの公開とは無関係です。

パスワードリスト攻撃
あるサイトに対する攻撃などによって得られたIDとパスワードのリストを用いて、別のサイトへの不正ログインを試みる攻撃です。キャッシュDNSサーバの公開とは無関係です。

水飲み場攻撃
特定の組織や人に狙いを定める標的型攻撃の一つで、標的ユーザが良く利用するWebサイトにドライブバイダウンロードのコードなどを仕込み、
アクセスした標的ユーザをマルウェアに感染させる攻撃です。
本攻撃が成立するにはWebサイトの改ざんが必要となりますが、キャッシュDNSサーバが公開されているというだけでは、
今回のように管理者権限が奪われることはまずあり得ないので誤りです。

∴ア：DDoS攻撃

4.
キャッシュDNSサーバに偽のキャッシュ情報が登録される、そのキャッシュDNSサーバの利用者が別のサイトに誘導される、
ポートのランダム化が対策となるとくれば「DNSキャッシュポイズニング」です。
DNSキャッシュポイズニングは、キャッシュDNSサーバに攻撃者が用意した偽のキャッシュを登録させ、そのキャッシュDNSサーバを利用したユーザを悪意のあるサイトに誘導する行為です。
午前問題でも頻出ですので、答えておきたいところです。

∴c＝DNSキャッシュポイズニング
```

---

## プログラミング クラスタ分析に用いるk-means法

うーん、悪夢がよみがえって来たって感じ。  
今見ても全然わからん。  
何したいかもさっぱりわからなかった。  
何したいかわからないけど、なんか正解してるのに驚きだ。  
文章とプログラムを見比べてこれかなってものを書いてみたけど意外と当たるんだな。  
てか、何するかわからないものほどあたるのは一体何なんだろうか。  

座標の重心がわからなくなるまでって勘違いしてた!!  
よく見たら重心が「変わらなく」なるまでだ!!  
もうこの地点でいろいろダメなんだよな。  

答えだけを見ると大したことはないのだが、今回ばかりはなぜか問題を理解できなかった。  
プログラムの問題に関しては全問正解なのを見ると、全体を理解しないほうが逆に正解するのではないかとも思えてしまう。  
理解できなかったのはいいとして、結局やるべきことは(1)から(5)までのあれこれをループするってことでしかないから、そこを読み込んで、確かにそう書いてたって確認する程度でいいんじゃないかねぇ。  

``` txt 30分オーバー 6/8
(1.5,3)
空白 × P2,P3,P7

tを1からKまで1ずつ増やす
flag ← 0
flagが0と等しい
cluster[s] ← min_index(grav_length)

ア
Sum(t+1) × Ts/Sum

---

そもそも問題を考える
ここまで解説を見て、じっくりと問題に向き合ってみれば、確かに言っていることはそのままなんだろうな。
図1、表1、表2でやっているのは1回目にロジックを実行した場合の例で、わかりやすくするための例でしかないわけだ。
距離の計算面倒くさいな、どこまでやればいいんだろうなって意識があったのは確か。

重心の求め方はX座標の平均てところがわかれば、表1のような計算はしなくていいってわかるかな。
表1は(2)でやることで、これは1回しかやらないから考える必要がなかったんだ。
最初から躓いてしまうと、あとは何もできないわなって感じ。

やることは重心を再計算する。求めた重心と近い点をクラスタに含める。
で、何回やっても重心がわからなかったら確定。重心が変わらないってことはクラスタも変わらないってことだからってことか。
そう考えると対して難しくないな・・・。
ちゃんと表1は1回しかやらないことで、やるべきは重心とクラスタ作成だけってわかってしまえばどうってことはないか・・・。

おｋ。
この問題の教訓はなんだ。
・文章だけだときついので、図と見比べながら認識しましょう。
・繰り返しやるべき場所とやらなくていい場所を明確にしましょう。

---

[1]
〔アについて〕
クラスタ2の重心G2の座標が入ります。
重心の求め方は、問題文の〔分類方法と例〕(3)に「重心のX座標をクラスタに含まれる点のX座標の平均、Y座標をクラスタに含まれる点のY座標の平均と定義する。ここで求めた重心の番号はクラスタの番号と同じとする。」と説明されています。

クラスタ2に含まれる点は、表1の所属クラスタ番号よりP5とP6であることがわかるので、P5とP6についてX座標とY座標の平均値を求めます。P5＝(1, 3)、P6＝(2, 3) ですから、
重心G2のX座標　(1＋2)÷2＝1.5
重心G2のY座標　(3＋3)÷2＝3
クラスタ2の重心G2は(1.5, 3)なので、空欄には「(1.5, 3)」が当てはまります。

∴ア＝(1.5, 3)
→
まぁこれはね。正解させるための問題でしかないからどうでもいい。


[1][2]
重心の座標が変わらなくなるまで、(3)クラスタに含まれる点で重心を求める、(4)新たな重心を基準にクラスタを再構成する、という手順を繰り返します。
表2は手順(4)で所属クラスタの見直しが終了した時点の状態なので、手順(3)に戻りクラスタごとの重心を求めることから始めます。

クラスタ1に含まれる点は、P1、P2、P3およびP7なので、
重心G1のX座標　(1＋2＋4＋4)÷4＝11／4＝2.75
重心G1のY座標　(0＋1＋1＋3)÷4＝5／4＝1.25
クラスタ2に含まれる点は、P4、P5およびP6なので、
重心G2のX座標　(1.5＋1＋2)÷3＝4.5／3＝1.5
重心G2のY座標　(2＋3＋3)÷3＝8／3
以上より、重心G1＝(2.75, 1.25)、重心G2＝(1.5, 8／3)となります。

次に重心と各点を距離を√(a－c)2＋(b－d)2で計算するのですが、全部計算すると時間が掛かってしまうので、図1中のXYグラフに重心を打点して、各点との距離を見積もることになるでしょう。
pm03_3.gif/image-size:289×224
目分量で測った感じ、P1、P2およびP3は明らかにクラスタ1に、P4、P5およびP6は明らかにクラスタ2に所属することがわかると思います。P7については結構微妙ですが、地道に計算をするか定規等で距離を測ればクラスタ1に所属することが判断できるでしょう（定規が活躍する珍しい問です）。

こうして分類されたクラスタは1回前（表2）のクラスタと変化ありません。所属クラスタに変化がない場合は重心の座標も変わらないため、これで分類が完了したことになります。したがって、分類が完了したときにP1と同じクラスに入る点は、「P2、P3、P7」の3つです。

∴P2，P3，P7




[2]
〔イについて〕
ループ処理の繰返し条件が入ります。
ループ中で実行されている gravity_x と gravity_y はクラスタの重心のXY座標を求める関数、その結果を代入する coordinate_x と coordinate_y は各クラスタの重心のXY座標を格納する配列ですから、ここでは手順(3)の「K個のクラスタのそれぞれについて，クラスタに含まれる全ての点を使って重心を求める。」を行っていることがわかります。
この処理はK個のクラスタのそれぞれについて行う必要があるため、クラスタ1～クラスタKまでの重心座標を配列の1～K個目に格納するように繰り返すことになります。ループ中では変数 t の値を変化させることによって各々の処理が行われるようになっています。本問のプログラムでは配列の添字は1から始まるので、繰返し条件としては「tを1からKまで1ずつ増やす」が当てはまります。

∴イ＝tを1からKまで1ずつ増やす


〔エについて〕
先にこちらから考えた方が分かりやすいので、[ウ]の前に[エ]に入る字句を考えます。

コメント部に「//終了して抜ける」とあるように、この条件式が真のときには return によりプログラムは終了することになります。プログラムを終了するのはクラスタが確定したとき、すなわち1回前と比較して重心が変わらなかったときですから、重心が変わっていないことを判断できる式が入ります。
[エ]の直前のブロックでは、重心の再設定が行われたときに flag に1をセットしています。このことから flag が1であれば1回前と比較して重心が変わっている、flag が1以外であれば変わっていないと言えます。表3を見ると flag の値は0又は1となっていますから、flagが1以外＝flagが0ということです。したがって、プログラムを終了する条件としては「flagが0と等しい」または「flagが1と等しくない」が適切となります。

∴エ＝flagが0と等しい


〔ウについて〕
前述のとおり、変数 flag は重心の再設定が行われたかどうかを表すためのフラグです。

クラスタ見直しの流れを見ると、
ウ
重心の再設定が行われた場合に flag を1にする
flag が0であればプログラムを終了する
新しい重心でクラスタを再構成する
1.に戻る
というようになっていて、重心の再設定が行われなかった場合にプログラム終了となるためには、flag を0で初期化しておく必要があります。したがって、空欄には「flag ← 0」が当てはまります。

∴ウ＝flag←0


〔オについて〕
図2のプログラムの30～35行目の処理は、手順(4)の処理に対応します。ここでは、各点と再計算された各クラスタの重心との距離をそれぞれ計算し、各点から見て距離が最も短い重心の番号を、次の所属クラスタ番号にする処理を行います。

[オ]の直前のループ処理により、現在処理中の点Psにおける各クラスタの重心との距離は、配列 grav_length に格納されています。配列 grav_length 中で最も小さい値を持つ要素の添字が、次の所属クラスタ番号になります。配列 grav_length 中で最も小さい値を持つ要素の添字は、関数 min_index を使って、min_index(grav_length)で取得することが可能です。
その点がどのクラスタに所属するのかの情報は、配列 cluster に格納するので、min_index(grav_length) の結果を cluster[s] に代入することになります。したがって、空欄には「cluster[s]←min_index(grav_length)」が当てはまります。

∴オ＝cluster[s]←min_index(grav_length)



[3]
コアを選ぶ際、残った点のうち、それまでに決まったコアからの距離が長い点ほど選ばれやすくしたいのですから、距離が長い点ほど高い確率を与える必要があります。Tsはそれまでに決まった各コアと点Psとの距離の和ですから、距離が長いほどTsも大きくなります。したがって、Tsが大きいほど高い確率で選ばれるようにします。

∴カ＝大きい

TSはそれまでに決まった各コアと点Psの距離、Sumは残った点のTSの総和です。TSが大きいほど高い確率とするためには、Sum(全体)に対するTSの割合を選ばれる確率として使えばOKです。例えば、TSが10、20、30、40の4つの点（Sum＝100）があったとき、それぞれ10/100、20/100、30/100、40/100にすれば、ランダム性を保ちつつ、距離が長い点ほど選ばれやすくなるという感じです。

したがって、空欄には「Ts／Sum」が当てはまります。

∴キ＝Ts／Sum
```

---

## ネットワーク チャット機能の開発

ネットワーク難しいけど、アーキテクチャよりはとっつきやすいので頑張っていきたい。  
DNSラウンドロビンを覚えていたのが少しうれしい。  
この問題をやっていた時に送信元、送信先の概念がわからなくなってしまった。  
そこそこネットワークの概念が詰まっているので、しっかり復習したい。  

・FWにサーバー証明書をインストールするものなのか？  
・そもそもサーバー証明書ってどこにインストールできるものなの？  
・DNSラウンドロビンを使った分散処理  

・WebSocketのポート番号は80番。  
・IPはエンドツーエンドなので証明書もそれに従って入れれば良い。  
・クライアントはプロキシにお願いして、プロキシはお願いを基にサーバーにアクセスする。  
・プロキシはHTTPSの場合、通信路をトンネリングする。  

・HTTPのKeepAliveはTCPコネクションを維持するオプション  

``` txt : 30分 3/9 実質4問正解
[1]
10.10.0.10
10.10.0.10 × 192.168.0.3
10.1.1.2
イ、ウ、エ × ア、ケ
コネクションが確立され、通信路が暗号化されているため 0%
→プロキシサーバはGETメソッドの内容が見えないから

[2]
イ
IPアドレスをそのまま利用できるため 0%
→同じポートを利用するから

[3]
DNSラウンドロビンを使った分散処理 × DNSラウンドロビン方式
代理会社接続ルーター × APサーバー#1,APサーバー#2

---

[1][b]
販売代理会社の販売店のPCから旅行販売システムへアクセスする場合、プロキシサーバを経由することになります。
プロキシサーバを経由するWebアクセスでは、クライアントはプロキシサーバに対してHTTP(S)リクエストを送り、
プロキシサーバはクライアントから受け取ったHTTP(S)リクエストの内容を使って外部の宛先サーバに代理アクセスします。

<https://www.ap-siken.com/kakomon/03_haru/img/pm05_3.gif>

したがって、販売代理会社の販売店のPCがWebアクセスする際の宛先IPアドレスは、プロキシサーバの販売店側のIPアドレスである「192.168.0.3」になります。
IPはエンドツーエンドの通信を実現するプロトコルなので、宛先IPアドレスには最終的にパケットを届けたい相手を指定します。
このため、"FW#4"や"店舗接続ルータ"を宛先IPアドレスとするのは不適切です。
→
PCが直接サーバーを見に行くのではなく、プロキシサーバーを経由するなら向き先はプロキシになるのが普通か。
あー、今更理解した。
プロキシを通してサーバーにアクセスするイメージでいたけど、違うんだ。
プロキシにお願いして、お願いされたプロキシがサーバーにアクセスするって流れなんだ！！
今まで盛大に勘違いというか、よく理解しないでやってきてた。
じっくり読んで、理解できてよかった。

IPは元、先の指定しかない。だから、ルーターまでみたいな指定をすると基本的に届かない。
この概念も割と抜けてた・・・。
ネットワーク面白い。


[1][2]
本問では販売店側ネットワークにDNSサーバが配置されていないので、販売店側ネットワークにおいてドメイン名で旅行販売システムにアクセスする機器に、E社のDNSサーバのIPアドレスを設定する必要があります。
旅行販売システムの機器と通信する際にIPアドレスが必要になるからです。旅行販売システムにアクセスする、E社販売店のPCと販売代理会社のプロキシサーバがこれに該当します。

∴ア，ケ

→
アクセスする機器に設定するイメージになる。
販売店はプロキシがないので、PCに直接設定する。
代理会社はプロキシがアクセスするので、プロキシに設定されていれば良いということか。

いや、問題よく見返してみたら本当にその通りの事しか言ってないわ。
勘違いしてた。
FWとか中継地点が名前解決ってよく考えればおかしいよな。
相手のDNSサーバーにアクセスするためにその設定をどの危機に入れればいいですか？って話なら、そりゃアクセスする機器ですって事になるわな。


[1][3]
HTTPS通信ではHTTPリクエストの内容がTLSによって暗号化され、復号は受信者である機器（本問だと負荷分散装置）しか行えません。
プロキシサーバは、HTTPリクエストのGETメソッドを参照して代理アクセスのリクエストを組み立てますが、暗号化されているのでGETメソッドの内容を見ることができません。

このためHTTPSでプロキシサーバを利用する場合には「CONNECT」という特殊なメソッドを使って、クライアントはプロキシサーバにTCPコネクションをトンネルするように依頼します。
依頼を受けたプロキシサーバは、宛先サーバとのTCPコネクションを確立し、暗号化されたHTTPリクエストをそのまま受け渡します。
宛先サーバから返ってくる結果も暗号化されているので、プロキシサーバはそのままクライアントに返します。本文中で、PCから受信したデータをそのまま送信するというのは、この一連の動作を指しています。

∴プロキシサーバはGETメソッドの内容が見えないから


[2][1]
HTTPは、クライアントがリクエストを送信し、リクエストを受け取ったサーバがレスポンスを返すというシンプルな通信手順です。
サーバはクライアントからのリクエストに対してデータを返すことはできますが、任意のタイミングでクライアントに対してデータを送ることができません。
このため、サーバ側からもメッセージを送信するチャット機能をHTTPで実現することは困難※となります。

したがって「イ」が適切な理由となります。
HTTPで取得できるのはファイルに限られません。インターネット上の任意のデータを取得することができます。
正しい。HTTPは常にクライアントから通信を開始する性質があるので、サーバからもメッセージを送るチャット機能の実現は困難です。
HTTPレスポンスにKepp-Aliveヘッダを含めることで、TCPコネクションを維持することができます。
クッキーやセッションIDを使えばPCを区別することができます。

※WebSocketの登場前にもチャット機能はありましたが、10秒間隔などで定期的にHTTPリクエストを送って、サーバは更新があったら結果を返すというポーリング方式等によって半ば強引にリアルタイム性を実現していました。
しかし、遅延があり、無駄な通信が生じるため効率は良くありませんでした。

→

これは知ってたから問題ない。
WebSocket事態がサーバーからクライアントに通知するための技術で、そういう技術があるって事は現状のHTTPではそれを実現出来ないってことに鳴るからね。
HTTP事態、リクエストに対してレスポンスを返すってシンプルな仕様だから、相手から何か言ってこない限りこちらから何もできないって弱点がある。


[2][2]
販売代理会社の"FW#3"では「宛先ポートが53番ポート，80番ポート又は443番ポートで宛先ネットワークアドレスが 10.10.0.0 のIPパケットとその返信IPパケットだけを通信許可する設定となっている」ように、IRC（194/TCP）や新たなプロトコルを利用する場合には、そのポートを使った通信を許可するようにFWやルータの設定を変更する必要があります。
E社データセンタの"FW#1"、E社販売店の"FW#2"も同様です。別会社も含めたすべての拠点のFW設定を変えるのは大変でしょう。
この点、WebSocketはHTTP通信を拡張したものなので、使用するポートがHTTPと同じです。
このため、他のプロトコルを利用する場合と比較してFWやルータの設定変更が少なくて済みます。

∴同じポートを利用するから

→

WebSocketが使用するポートは80番らしい。
これは知らなかった。
意外な盲点だった。
そうなると、IPアドレスってのはやっぱり的外れだな。
WebSocket使いたいからって宛先変わるはずがないでしょ。
というかサービスによってポートが変わるんだから、WebSocketというサービスという点で着目すべきはポートだった。



[3][1]
負荷分散装置を利用せずに、E社データ内にある機器を利用した負荷分散という条件があるので、DNSサーバの機能を使用した「DNSラウンドロビン」が当てはまります。
DNSラウンドロビンは、以下のように同じホスト名に対して複数のAレコードを設定することで、アクセスを複数のコンピュータに（単純に順繰りに）振り分けます。
負荷分散装置とは異なり単純な振分けしかできませんが、ある程度の負荷分散効果が望めます。
chat IN A 10.10.0.11
chat IN A 10.10.0.12
∴DNSラウンドロビン方式


[3][2]
DNSラウンドロビンは、2台のAPサーバについて設定することになります。
これまで旅行販売システムへのアクセスは負荷分散装置に集めていたので、TLS証明書は負荷分散装置だけにインストールしておけば良かったのですが、チャット機能ではHTTPS通信の接続先が2台のAPサーバになります。
HTTPS通信を行うには、少なくとも接続先のサーバにTLS証明書（サーバ証明書）をインストールしなければならないので、HTTPSでチャット機能の通信を行うためには、新たに2台のAPサーバにもTLS証明書をインストールする必要があります。

∴APサーバ#1，APサーバ#2
解答に当たり関係はありませんが、〔チャット機能設計レビュー〕の2つの指摘について補足しておきます。
指摘1は、WebSocketではTCPコネクションを確立したままにするので、チャット機能の利用が多くなると負荷分散装置の同時接続数が一杯になり、旅行販売システムの既存機能へのアクセスができなくなってしまうという問題です。
指摘2は、WebSocketは比較的新しいプロトコルなので、対応していないプロキシサーバにおいてupgradeヘッダを含むパケットが破棄されてしまい、プロキシサーバ越えができないという問題です。

→

証明書を求められるのは、サーバーにアクセスしてきたときってのは、わかるけど、証明書ってFWとかルーターとかそういう機器にもインストール出来たっけ？
という疑問を解消してこなかった。
FWとルーターはなさそう？
サーバーは確実としてロードバランサーや負荷分散装置にはいけるっぽい？
負荷分散装置は実質ロードバランサーだから同じようなものだろうけど。

あーーー。わかった。
証明書をインストールする機器は末端じゃないとダメだ。
IPはエンドツーエンドで端っこで通信する。
だから最後で復号できないと通信のしようがないんだ。
その点ロードバランサーはそこで復号してペイロードをサーバーに送るってことができるから候補になるんだ。
すごいな。この年の問題だけでも結構な発見があるぞ。
```

---

## データベース 経営分析システムのためのデータベース設計

試験本番では手も足も出なかった問題。  
今やってみてもチンプンカンプンなので、とにかく答えを見て全体を把握するところから始めたい。  

難しいのは最初だけだったのかもしれない。  
SQL文を組み立てるところは、よく見れば簡単だった。  
当時は問題の意味を理解しないと解けないと思っていたが、案外そうでも無かった。  
しっかりと理論的に考えて行けば解ける内容だった。  

``` txt : 回答 計測していない
## 1
直近はデータの比較検討が出来ない。的な感じ 0%
→
システム稼働後2年間は、過去5年間分の平均車両稼働率の目標比を表示できない

## 2
[1] a : ウ
[2]
b : {車両ID} × {年月日}
c : 貸出実績件数
d : 返却実績時刻 × 年代
e : ←

ここから先は検討すら出来なかった。


## 3
[1]
f : INNER JOIN 貸出実績 J ON R.貸出予約コード =
g : GROUP BY R.貸出予定年月日,R.駐車場ID,R.車種ID,R.会員ID

[2]週次 × 日次


## 4
年月日、車種ID、年代 ×
→年月、駐車場ID、車種ID、会員ID

```

``` txt : 解説
## 1

表計算ソフト
データがあるのは3年分。

貸出管理システム
5年分のデータあり。

経営分析システム
今回刷新するシステム。なのでデータは一切ない。

「また，P社ではKPIの一つとして車両稼働率を重視している。車両稼働率とは，各車両における1日当たりの貸出実績時間の割合である。
平均車両稼働率の目標データは，表計算ソフトのデータとして，年月日別・駐車場別・車種別に過去3年間分が蓄積されており，それ以前のデータは破棄されている。」
見るべきは車両稼働率。

その次の図2の要件の中に「表計算ソフトのデータを用いて、平均車両稼働率の目標比や前年同月比を分析できること」とある。
目標比に関しては3年分は何とかなるが、存在しない2年分はどうしようもない。
こればっかりは、経営分析システムを2年稼働させてからでないと比較判断が出来ない。
その点を40文字以内で収めればいいみたい。

前年同月比は、貸出管理システムにある5年分のデータで何とかなるので、今回は関係ない。


なんで、これ当時はわからなかったのか。
それは経営分析システムのデータは過去から移行するものだと勝手に思い込んでいたから。
過去のデータがあるのだからBI的な比率の出力もできるだろうと踏んでいたのだが、そもそもの前提がこんなのではお話しにならないわけで。

後は、貸出管理システムと経営分析システムがどのように連携されるのか全然想像できなかったことかな。
5年、3年でずれがあるのはわかるけど、表計算って言ってるし、それってどっちのデータの事いってるの？って感じ。
経営分析システムから抽出した3年分の表計算データって言えば、確かに2年分のデータないからそれに関してはどうしようもないねってのは言えるんだけど・・・。
難しいなぁ。
てか、ここまでグダグダ書いたけど結局わからん。
なぜか知らんが、この問題全然イメージ出来ない。

そもそも、なんで2年立たないと目標値を出すことが出来ないのか？
5年のデータと3年のデータで何とかならないのか？
目標って事は未来の予測を立てるわけだけど、今のデータから目標値って出せるもんじゃないのか？
3年と今からのデータで予測出来ないのか？
そこが腑に落ちない。
思うに、この年のデータベースは駄作だ。


## 2

[2]
カレンダエンティティと車両稼働エンティティの間には1対多の関係があります。
エンティティ同士は同じ主キーと外部キーを持たせることによって関連付けますが、カレンダエンティティの主キー"年月日"に相当する属性が車両稼働エンティティにはないので追加する必要があります。
図2には「これらのいずれにおいても，年月，月別，日別，週別，曜日別といった時間軸で傾向を分析できること。」が業務要件として示されているため、
ある1日の駐車場・車種別の平均車両稼働率がわかる必要があります。
よって、車両稼働エンティティでは属性"年月日"，"駐車場ID"，"車種ID"によりレコードが一意に特定されることがわかります。
したがって、車両稼働エンティティの属性"年月日"は主キーの一部であり、空欄には「年月日」が当てはまります。

∴b＝年月日

図2の業務要件には「地区別の人気車種，会員の性別・年代別の人気車種、（中略）駐車場別・会員別の遅延返却発生件数を分析できること。
なお，貸出実績の件数（以下，貸出実績件数という）が多い場合を人気車種であるとみなす。」とあります。この分析を行うために不足している属性を考えることになります。

"地区"は駐車場エンティティに、"性別"は会員エンティティにあるので問題ありません。
しかし"年代"についてはどこにもデータがありません。
また会員エンティティには生年月日がないので、貸出当時の会員の年代を年月日との演算で求めることもできません。
したがって、まずは「年代」を追加する必要があります。

もう一つの属性は、人気車種を分析するときに必要となる「貸出実績件数」です。とちらも主キー属性ではありません。



## 3

[4]
図4のSQL文は、遅延返却発生件数を集計するためのものです。
図2の業務要件には「遅延返却発生件数については前日までの実績を翌営業日の朝に確認できること。」とあり、
この業務要件を満たすためには毎日0時から営業開始までの間に図4のSQL文を実行しなくてはなりません。
実行する頻度を2文字で答えるとなると「日次」や「毎日」「日毎」などが当てはまります。

∴日次



## 4

データマートとは、データウェアハウスに格納されたデータから特定の用途に必要なデータだけを取り出し、構築する小規模なデータベースです。

年月ごとの貸出実績件数や遅延返却発生件数を取得するには、少なくとも貸出テーブルとカレンダテーブルを結合し、"年"列と"月"列でGROUP BYする必要があります。
分析に時間が掛かるのは、リクエストの度にテーブル結合とGROUP BYが実行されているからであると考えられるので、レスポンスを改善する方法として、
データマートとしてあらかじめ年月ごとに集計したデータベースを用意しておく方法があります。
つまり、新たに作成するテーブルは貸出テーブルの"年月日"列を"年月"列に変えたものです。したがって、そのテーブルの主キーは「年月，駐車場ID，車種ID，会員ID」です。

∴年月，駐車場ID，車種ID，会員ID

```

---

## 組み込みシステム ディジタル補聴器の設計

やベーくらいダメだった。  
周波数系の計算問題満載で問題の意味もほとんどわからなかった。  
itecの問題をやり始めたときはサクサク解けたから、この落差には落ち込まざるを得ない。  
それでも、組み込みは選択肢の1つとしてやっていくので、絶対に克服する。  

最初の問題は単位の変換を忘れた事と、3つのブロックという文言を見落としていた。  
計算のファクターはよかったが色々詰めが甘かった。  
それさえ出来ていればもう一問正解出来た。  

てか、この地点でややこしかったのが、周波数だ。
サンプリングで量子化、標本化とかあるけど、あそこの下りももう一度復習しないと混乱してしまう。

あとあれだ、問題に圧倒されて頭の中で整理する時間が増えれば増えるほど、余裕を持って問題を見ることが出来なくなると思った。  
わからない部分がたくさんあると、頑張って理解しようとする。常につまりどういうことだ？状態になる。
そんな状態で最終問題まで行っても、文中にあるヒントを正しく理解する事が出来ずに終わる。
これは本番で感じた混乱している状態そのものだろう。
それにプレッシャーもかかってくるから、もっとうまくいかなくなるはず。
これだ。あの時モヤモヤしていた状態をようやく言語化することが出来た・・・。
そうだよ、こういう状態に陥ってしまったからうまくいかなかったんだ。
つまり、俺の実力不足ってわけ。
計算問題にアレルギーがありすぎて、正確にわからないだけで不安になってしまうんだ。
最初の問題をポカしたら後の問題は連鎖的に出来なくなる構成になっているので、なおさらプレッシャーになる。

最後の問題に関しては周波数など意識する必要が無かった。
しかし、ここまで問題を読んで仕様を理解した上で望まないと、変数や数式の意味を導く事はできないだろう。
計算で四苦八苦しているようでは、そんな段階に至る事はできないのだ。

1の(1)と2の(2)をの理屈がわからなかった。  
もっかい。  

1の(1)  
サイクルがある。  
ADCが書き込んんだ場所にDACがアクセスするには3サイクルしないといけないのがわかる。  
つまり、3サイクルの間にADCは3回の書き込みを行っている。  
入力バッファに1フレームを書き込む時間を考える。  

サンプリング回数 : 24,000/s = 24回/ms  
1フレーム(64サンプル)に要する時間: 64/24 = 8/3 ms  
これを3かい繰り返すので、  
8/3 * 3 = 8ms  

肝は1フレームに書き込む時間を算出するところだな。  
24000という数字はサンプリングの数字。  
1フレームには64サンプルしか入れれない。  
ということは、64フレーム入れるのにどれくらい時間がかかるかって事になるのか。  
だからこの数式になるわけね。なるほどね。  

2の(2)  
1フレーム文のデータを処理する最大実行時間Tdを求めるのは別にいい。  
$Td = 8 * 0.30 * Tframe + 0.05 * Tframe + 0.20 * Tframe$  
$=2.65 * Tframe$  

これを単純に四捨五入すればいいだけらしい。  
なぜか？  

周波数f0を供給した時の処理時間が2.65*Tframe。  
この時点で目標とするTframe以内に治まっていないらしい。  
収めるためには1 / 2.65倍する必要があるとか。  
つまり、単純に逆数をかけて、Td = Tframe にしたいってことか。  
あれ～・・・まさかそれだけの問題だった？  
実行時間は高速クロックの周波数に反比例する→高速クロックには少なくとも2.65倍の周波数が必要。  
今回の高速クロックの周波数とはf0。  
クロックの周波数が上がれば電力消費が上がり、システムの実行時間は短くなる。  
Tdは実行時間なので、短くしたかったら、1/2.65を掛ければいい。  
で、2.65倍じゃなくて、整数倍なので3になるってわけらしい。  
逆数の部分が混乱するな。  

``` txt : 1回目回答  30分 4/10
### 1
a 1024 × 384
b      × 8.0


### 2
(1)
c Tf
d Ts
e Ta
(2) 3.74 × 3


### 3
(1)
ア × dv > 0 and v >= vt
イ vt
ウ (vt-v)M × 0

(2)目標の音量と現在の音量がほぼ近しい時 25%
→
現在の音量が目標値に近く、変化量が0となり音量を変更する必要がない場合
```

``` txt : 解説
### 1
(1)
空欄には、入力バッファ及び出力バッファのサイズ（バイト単位）が入ります。

問題文の〔入力バッファ及び出力バッファ〕には、「入力バッファ及び出力バッファは、それぞれ三つのブロックで構成されている。
一つのブロックには1フレーム分のデータを格納できる。」と説明されています。
この記述から、入力バッファ及び出力バッファのサイズは、「1フレームのデータサイズ×3ブロック」で求められることがわかります。
次に、1フレーム分のデータサイズを考えます。
問題文の〔ハードウェア構成〕の2つ目の箇条書きに、「…1秒間に24,000回サンプリングし、16ビットの符号付き整数のデータに変換して入力バッファに書き込む。64サンプルのデータを1フレームとして書き込み、…」と説明されています。
この記述から、1フレームのデータサイズは、「16ビット×64サンプル」で求められることがわかります。

16ビット＝2バイトであるため、1フレーム（＝1ブロック）のデータサイズは「2バイト×64サンプル＝128バイト」、
これにブロック数の3を乗じた「128バイト×3ブロック＝384バイト」が入力バッファ及び出力バッファのサイズです。

∴a＝384

(2)
ADC、DAC及び制御部がバッファにアクセスする流れは、〔入力バッファ及び出力バッファ〕の説明と図3より、
ADC及びDACは同じ番号のバッファにアクセスし、制御部は1回遅れでそのバッファ間の転送を行う仕組みになっていることがわかります。

![https://www.ap-siken.com/kakomon/03_haru/img/pm07_6.gif]

ADCが書き込んだ入力バッファと同じ番号の出力バッファにDACが再びアクセスするのは3回後です。
1ブロックには1フレームのデータを格納するので、ADCの処理完了後からイヤホンに出力するまでの時間は、
ADCがフレームを3回書き込む（再び同じブロックにフレームを書き込むまでの）時間と同じ時間であることがわかります。
ADCの処理完了後から考えると、①制御部による転送、②アクセス待ち、③DACによる読み出しと処理という流れです。

pm07_7.gif/image-size:465×211

入力バッファに1フレームを書き込む時間（ミリ秒）を考えます。
1フレーム＝64サンプルであり、アナログ信号のサンプリング回数は1秒間に24,000回なので、

サンプリング回数：24,000回／秒＝24回／ミリ秒
1フレーム（64サンプル）に要する時間：64÷24＝8／3ミリ秒

よって、3フレームの書込みに要する時間は、

8／3×3＝8ミリ秒
これがマイクからのアナログ信号がADCで処理されてから、イヤホンから出力されるまでの時間となります。
設問の指示に「小数第1位まで求めよ」とあるので「8.0」と解答することになります。

∴b＝8.0

うわぁ・・・。
解説読めばなるほどねって思うけど、ここまで想定して回答することは出来なかったなぁ・・・。
こりゃすげぇ。



### 2
(1)
制御部で1フレーム分のデータを処理する最大実行時間Tdを求める式を考えます。
Tdは、①の最大実行時間＋②の最大実行時間＋③の最大実行時間で求めることができます。

①の最大実行時間は、8つの帯域それぞれで最大実行時間Tfがかかった場合の、8×Tfとなります。
②の最大実行時間は、問題文で示されている通り、Tsとなります。
③の最大実行時間は、問題文で示されている通り、Taとなります。

よって、Td＝8×Tf+Ts+Ta となるため、[c]には「Tf」、[d]には「Ts」、[e]には「Ta」が当てはまります。TsとTaは入れ替わっていても問題ありません。

∴c＝Tf
∴d＝Ts
∴e＝Ta

(2)
表1の実行時間を、(1)で求めた式に当てはめて1フレーム分のデータを処理する最大実行時間Tdを求めます。

8×0.30×Tframe＋0.05×Tframe＋0.20×Tframe
＝2.65×Tframe

周波数f0を供給したときの処理時間は 2.65×Tframe で、目標とするTframe以内に収まっていません。
Tframe以内に収めるには処理時間を 1／2.65 倍にする必要があり、実行時間は高速クロックの周波数に反比例するので、
高速クロックには少なくともf0の2.65倍の周波数が必要ということがわかります。
問題文中で「高速クロックはf0又はその整数倍」と説明されていますから、2.65以上の最小の整数である「3(倍)」が適切となります。
∴3

自身無かったけど、発想自体は合っていたのが地味にうれしい。
後は、自信を持って答えられるようになるだけだな。
いや、よく見るとダメだな。
奇跡的に近かっただけだ。はぁ・・・。


### 3
(1)
フローチャートには3つの空欄がありますが、[イ]と[ウ]から考えるとわかりやすいと思います。

〔イ、ウについて〕
問題文の〔AVC処理のソフトウェア〕には、「特定の条件では、目標の音量を決定したとき、直ちに音量を目標の音量にする。
そのための判定を網掛けした判定部で行っている。」という説明があります。網掛け部の判定部が"Yes"のときには[イ]と[ウ]を含む処理に移るので、
ここでは「直ちに音量を目標の音量にする」処理を行うべきであると判断できます。
現在の音量を保持する変数は v、目標の音量を保持する変数は vt ですから、現在の音量を目標の音量にする処理は「v ← vt」になります。よって、[イ]には「vt」が当てはまります。
音量が目標の音量に達した場合、その後のフレームでは段階的に音量を増減させる処理は不要となるので、フレームごとの変化分を保持する変数 dv には「0」を設定することになります。

∴イ＝vt
∴ウ＝0

〔アについて〕
音量を変化させた後の判定部であり、この判定が"Yes"の場合には前述の「直ちに音量を目標の音量にする」処理が行われます。
Yesになる条件式の1つ「dv＜0 and v≦vt」の意味を考えると、"変化分がマイナス"かつ"現在の音量が目標音量以下"という状況を表します。
これは、音量を下げている局面において変化分だけ音量を下げた結果、音量が目標音量以下まで下がった状況を検知するための条件式です。
目標音量に達したのですから、現在の音量＝目標音量にして変化を終了させる処理に進むというわけです。

これとは逆に、音量を上げている局面において変化分だけ音量を大きくした結果、音量が目標音量以上まで上がった状況においても、
同じように目標音量まで戻す処理を行わなくてはなりません。
このため、"変化分がプラス"かつ"現在の音量が目標音量以上"のときに"Yes"となるような条件式が必要となります。
したがって[ア]には「dv＞0 and v≧vt」という条件式が当てはまります。

∴ア＝dv＞0 and v≧vt


(2)
条件式の「dv = 0 and v ≠ vt」が"Yes"となるのは、現在の音量が目標音量とは異なるにもかかわらず、変化量が0と算出される場合です。

問題文にある「演算は全て整数演算であり，浮動小数点演算は使用しない。」に着目すると、
「1 / 2 = 0」「5 / 3 = 1」のように除算の商の小数部は切り捨てられる仕様であることがわかります。
したがって1つ前の「dv ← (v－vt)／M」において、(v－vt)がMより小さければdvは0になります。
これはフレームごとの変化分が1未満である状況を示しています。
dvが0のときにはその後のフレームにおいて変化分の増減処理は行われませんから、その場で目標音量に設定しなければなりません。

音量というキーワードを使って状況を説明すると、
「現在の音量と目標の音量が近いため変化量が0となり、徐々に音量を変化させる必要がない場合」などの解答に収斂すると思います。

∴現在の音量が目標値に近く，変化量が0となり音量を変更する必要がない場合
```

---

## 情報システム開発 クーポン券発行システムの設計

30分は超えてしまったが、最後のメインの問題を全て正解出来たのはうれしかった。  
正解出来てよかったけど、かなり悩んでの事なので実践ではこうはいかないだろうな。

アジャイル的な問題だったら躊躇するところだったが、パターンを考える問題だったら当時でもいけたのではなかろうか。
まぁ、あの時は完璧に無理だったけどね。

``` txt : 30分オーバー 7/9
99.77
プロセス × コンテキスト

ア
呼び出し元が複雑になる 0%
→可読性が下がるから

2
3,5
4,
6
4,6,7,5

---

[1][1]
〔Webアプリの処理方式の調査〕には「ブロッキングI/O型のサーバソフトでは，ネットワークアクセスやファイルアクセスなどのI/O処理を行う場合，CPUは低速なI/O処理の完了を待って次の処理を実行する。」とあるので、以下のように全部の処理が逐次的に実行されることになります。
pm08_4.gif/image-size:373×50
表1の処理全体の時間は、

　0.02＋10＋0.06＋2＋15＋5＋2＝35.08秒

このうち、I/O処理の時間（CPU処理でない時間）は35秒なので、I/O処理の完了待ち時間の割合は、

　35÷35.08＝0.99771…＝99.771％
（小数第3位を四捨五入）99.77％

∴a＝99.77

→
試験の時は計算問題ってだけで絶望した記憶がある。
見返して見たら案の定、意味不明な事がかかれていた。
それから比べたら結構成長したような気がするな。

比率を求めたいなら全体で割らないとね。その考えすら、当時は無かったはずだ。
後は、百分率なので、99%に直した後に小数点第3位を求めないといけない点が気を付けるところですかね。


[1][2]
マルチタスクOSでは、タスクスケジューリングに基づいて実行するタスク（プロセスやスレッド）を短い周期で切り替えながら処理を進めます。
このタスクの切替えの際に、実行中のプロセスの状態を保存し、これから実行しようとする中断していたプロセスの状態を復元する処理を「コンテキストスイッチ」と言います。

∴b＝コンテキスト

→
聞き覚えがあるようなないような。
見返してみたらソフトウェアで※でひっそりとかかれていた。


[2][2]
仮に処理1から処理7の処理をコールバック関数を利用して記述した場合を考えると、以下のソースコード例のように、関数の深い入れ子構造（通称、コールバック地獄）が現れることになります。JavaScriptのAjax処理でもそうであるように、コールバック関数を多用したコーディングは処理の順序関係が分かりにくいため、ソースコードが非常に読みにくくなります（可読性が下がる）。これにより保守性の低下を招きます。
処理1;
処理2(callback1(){
　　処理3;
　　処理4(callback3(){
　　　　処理6(callback4(){
　　　　　　　処理7;
　　　　});
　　});
},
callback2(){
　　処理5;
});
∴可読性が下がるから

→
コールバック特有の呼び出し元がわからなくなる問題を意識して回答したつもりが、もっと単純な答えでよかった模様。
これは、部分点くらいもらえる回答では無かろうか？


[3]
リアクタパターンを採用する場合、I/O処理を行う際は、リアクタにそのI/O処理の結果を利用するハンドラの実行を依頼することになります。
表1でI/O処理の完了が開始条件になっているものとして、

処理2の完了が開始条件になっている処理3及び処理5
処理4の完了が開始条件になっている処理6
処理6の完了が開始条件になっている処理7
があるので、処理同士の先後関係としては以下のようになります。
pm08_5.gif/image-size:517×115
これを図2に照らし合わせると、ハンドラ1が処理3,4,5、ハンドラ2が処理6、ハンドラ3が処理7に対応していることがわかります。

〔cについて〕
メイン処理で処理1に続いて実行する処理なので「処理2」が当てはまります。

〔d、eについて〕
処理2の結果を受けて実行する処理ですから、「処理3→処理4」と「処理5」が当てはまります。処理3と処理4は逐次実行する必要があるので、処理3は[d]に処理4は[e]に入れなければなりませんが、処理5は非同期処理なので[d][e]のどちらに入れてもOKです。

〔fについて〕
処理4の結果を受けて実行される処理、処理7を実行するイベントハンドルを依頼する処理ですから「処理6」が当てはまります。

∴c＝2
　d＝3、e＝4，5（またはd＝3，5、e＝4）
　f＝6

処理4は3ミリ秒、処理5は15ミリ秒、処理6は5ミリ秒、処理7は2ミリ秒の処理時間が掛かります。処理3，4，6，7と、処理5は非同期で並列実行されるので、4→6→7→5の順で完了することになります。

```
