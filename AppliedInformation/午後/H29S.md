# 平成29年春季

---

## セキュリティ マルウェア対策

とても簡単だった。  
特にいうことがない。  
強いて言えばWebブラウザの機能で少し迷った程度だろうか。  
オートコンプリート機能と言っているが、つまりは自動入力機能ってことで問題ないだろう。  
このくらいサクサク進んでくれれば助かるのだがなぁ。  

``` txt : 回答 10分 10/10
## 1
a： ク 水飲み場型
b： エ Webページ
c： ウ URLフィルタリング
f： カ 総当たり


## 2
エ


## 3
IDとパスワードの自動保存機能を無効にする 0%
→
オートコンプリートモードを無効にする


## 4
[1]
時系列がわからなくなるので、他の機器のログとの関連性を調査できない
→
各機器のログに記録された事象の時系列の把握が困難になる

[2]
d:DMZ
e:インターネット


## 5
ア、ウ
```

---

## プログラミング 探索アルゴリズム

30分の地点で最後の問題を解けずに終わった。  
だけどそこまでの問題は1問を除いてすべて正解だった。  
まぁ表現の問題でバツはつけられたが、言いたいことはあっている。  
よくよく考えれば文字列の"Y","N"の指定だろうからそこはちゃんとしないと不正解になりそうではある。  
てか、模範解答にもダブルコーテーションついてるからそういうことなんだろう。  

30分すぎた後に最後の問題をやってみたが、すぐにわかる問題だった。  
やっぱり全体的に話はわかったので、この問題も解説は特にいいかな。  
解説というよりもどこに躓いて何が悪かったのかを個人的にまとめたほうがいいな。  

・スタックとキューの問題で問われていることを理解するのに時間がかかった。  
・ダブルクォーテーションのつけ忘れに気を付ける。それもれっきとした回答。  

``` txt 30分オーバー 8/11 , 30分オーバーを含めるなら10問正解
isEmpty()が0である
ansStatus ← currentStatus
ansStatus ← currentStatus
currentStatus.nextIndexが0ではない

N × "N"
Y × "Y"
→ダブルコーテーションのつけ忘れに気を付ける

(A),(B),(C),(D),(E),(F),(G)
(A),(C),(G),(F),(B),(E),(F) → 最後は(D)。確認ミス

ウ × ア

数が大きい順にソートしておく 100%
他)数を降順にソートしておく
早い段階で合計が目標X以上になるから 0%
→早い段階で探索を打ち切ることができる

---

[3]
キューは先入れ先出しのデータ構造です。プログラムの12行目・13行目より、先に次の数を選択した状態をキューに追加し、その後に次の数を選択しない場合の状態をキューに追加していることがわかります。具体的には、以下の手順でキューへの追加・取り出しが行われます（[ ]はキューの内部です）。
初期状態Aをキューに追加する　[A]
初期状態Aをキューから取り出す []→A
状態Bをキューに追加する　[B]
状態Cをキューに追加する　[C，B]
状態Bをキューから取り出す　[C]→B
状態Dをキューに追加する　[D，C]
状態Eをキューに追加する　[E，D，C]
状態Cをキューから取り出す　[E，D]→C
状態Fをキューに追加する　[F，E，D]
状態Gをキューに追加する　[G，F，E，D]
状態Dをキューから取り出す　[G，F，E]→D
状態Eをキューから取り出す　[G，F]→E
状態Fをキューから取り出す　[G]→F
状態Gをキューから取り出す　[]→G
評価はキューから取り出した順に行われるため、キュー構造を使用した場合の評価順は「(A)→(B)→(C)→(D)→(E)→(F)→(G)」になります。

∴(A)→(B)→(C)→(D)→(E)→(F)→(G)

スタックは後入れ先出しのデータ構造です。(1)の処理をスタックに置き換えて考えると、スタックを使用した場合には、以下の手順で追加・取り出しが行われます（[ ]はスタックの内部です）。
初期状態Aをスタックに追加する　[A]
初期状態Aをスタックから取り出す　[]→A
状態Bをスタックに追加する　[B]
状態Cをスタックに追加する　[B，C]
状態Cをスタックから取り出す　[B]→C
状態Fをスタックに追加する　[B，F]
状態Gをスタックに追加する　[B，F，G]
状態Gをスタックから取り出す　[B，F]→G
状態Fをスタックから取り出す　[B]→F
状態Bをスタックから取り出す　[]→B
状態Dをスタックに追加する　[D]
状態Eをスタックに追加する　[D，E]
状態Eをスタックから取り出す　[D]→E
状態Dをスタックから取り出す　[]→D
評価はスタックから取り出した順に行われるため、スタック構造を使用した場合の評価順は「(A)→(C)→(G)→(F)→(B)→(E)→(D)」になります。

∴(A)→(C)→(G)→(F)→(B)→(E)→(D)



[4]
指定されたn個が（10, 34, 55, 77）の場合を考えます。4つの数それぞれに"選択する"と"選択しない"の2つのケースがあるため、全ての組合せを網羅すると「2×2×2×2＝16＝2^4個」の状態が存在します。これを一般化すると、指定された数がn個の場合には2n個の状態を用意しなければならないということがわかります。

状態を1つ格納するのに必要なメモリ使用量が m ですから、指定された数がn個の場合に必要なメモリ領域は、状態数にメモリ使用量を乗じた「2nm」になります。

∴ア：2^nm
→
数式が出てきたので警戒したが、単純に考えればそうだよなって思う。


[5]
探索アルゴリズムでは事前にソートをしておくと、効率良く探索ができます。今回の問題では、"指定されたn個の数"を降順にソートしておくと、早い段階（木構造の根に近い部分で）で目標Xを超えるか否かを判断できるので、探索回数の削減に繋がります。

これらのことから、内容は「数を降順にソートしておく」、理由は「早い段階で探索を打ち切ることができる」が適切です。

∴内容：数を降順にソートしておく
　理由：早い段階で探索を打ち切ることができる
```

---

## ネットワーク レイヤ3スイッチの故障対策

話はわかったがどう答えていいかわからなかったので、確認のために時間がかかった。  
正答率的には悪くない。  
長文の問題も正解していた。  
1つナチュラルに間違ったものがあるのが悔やまれる。  

でも、この年の問題のスレ荒れてるって事は、難しかったって事だよな。  
というか、この年の合格率低かったような？  
この問題、アドレスとポートが2つあって、どっちにアクセスしたらどちらに行くみたいなのがわかりきっていないのがなぁ。  

``` txt 30分 9/12 実質10問正解
イ
コ
オ
エ × カ
ク

K君のPCから業務サーバーへアクセスができるか確認するため
各PCの内部にDNSのキャッシュが残っていたから

1
172.16.2.250
VLAN20

デフォルトゲートウェイ × デフォルトゲートウェイアドレス
VLANインターフェースに仮想IPアドレスを設定する × 172.16.1.200

---

[1][4]
ネクストホップとは、宛先ネットワークに到達するために、次にどの隣接ルータにIPパケットを転送すればよいのかについての情報で、ルーティングテーブルに設定されます。

p1がダウンしたときには、172.16.1.250 からの送出ができないので、代わりにL3SW2を経由してサーバにパケットを届ける必要があります。
ネクストホップに L3SW2のp10側のIPアドレス 172.16.2.251 を設定することで、PCから発せられたサーバ宛て（宛先 172.16.1.0/24）のパケットはL3SW2に転送されるようになります。
よってdには 172.16.2.251 が入ります。

問題文の空欄cの後に、「PCによるサーバアクセスは，L3SW1のp10経由で行われる。L3SW1のp1故障時には，・・・」とありますから、
宛先ネットワークは、サーバが属している172.16.1.0/24です。
解説にも、「PCから発せられたサーバ宛て（宛先 172.16.1.0/24）のパケットはL3SW2に転送されるようになります。」とあります。

[1][5]
ICMPリダイレクトは、L3SWやルータが特定のネットワーク宛てのパケットに関してよりよい経路情報を送信元に伝達するために使用されるメッセージです。
本問のケースで言えば、ネクストホップが設定されたL3SW1は、送信元に対し 172.16.2.251 が適切な転送先である旨のICMPリダイレクトメッセージを返します。
これを受け取った送信元（PC）は、ICMPリダイレクトを解釈し次からサーバ宛てのパケットを 172.16.2.251（つまりL3SW2）に転送するようになります。


[2][1]
pingはネットワークの疎通（つまり対象ノードと通信可能な状態にあるかどうか）を確認するためのコマンドです。
J君は自席のPCから業務サーバを利用できたため、障害の原因がK君のPCから業務サーバ間の通信経路にある可能性を考えました。このためJ君は、K君のPCから172.16.1.1 （業務サーバ）に対してpingを送り、K君のPCから業務サーバへの通信経路に問題がないかどうかを確認したのです。

∴業務サーバへの経路に障害があるかどうかを確認するため

→
メモ
K君のPCがおかしいのか確かめるため。
K君のPCからのアクセスが出来ないのか確かめるため。
そもそもアクセス出来ないのか確かめるため。
複数の環境に置けるネットワークの状況を確認するため

経路を確認するためか。なるほどね。そうかもね。
ネットワークの状況って言い方も抽象的すぎか。
もっと具体的にいうなら経路という概念で表せばよかったってことか。


[2][2]
DNSクライアントが名前解決要求をDNSサーバに送り、DNSサーバは結果をDNSクライアントに返すのがDNSの名前解決の基本動作となりますが、毎回この動作が繰り返されるわけではありません。DNSでは負荷軽減と応答時間短縮のためにキャッシュと呼ばれる仕組みによって手順を簡略化できるようになっています。キャッシュには名前解決で行った問合せの結果が一定時間保存されており、ローカルに有効期限内のキャッシュがある場合、DNSクライアントはその情報を再利用することで再度問合せを行わずに済むようになっています。その後、時間が経過しキャッシュの有効期限が切れると、DNSクライアントはDNSサーバに名前解決要求を行います。

たとえDNSサーバと通信できない状態でも、キャッシュがローカルPCに残っている間はそのキャッシュが使用されるため名前解決自体は問題なく行われます。しかし、キャッシュの有効期限が過ぎると、再度DNSサーバへの問合せが行われます。この時点でDNSサーバと通信できないと名前解決ができず、他のサーバとの通信もできなくなってしまいます。本問では時間が経つに連れてサーバ群を利用できない社員が増えていますが、キャッシュが切れた順に障害に陥ったのだと解釈できます。

つまり、DNSサーバが利用できなくても、サーバ群の利用を正常に行えている社員がいるのは「その社員のPCにDNSキャッシュが残っているから」です。

∴PCにDNSのキャッシュが残っているから


[3]
OSPFが動作しているネットワークでは、通信障害が起こると自動でルーティングテーブルが再構成されます。

L3SW1のp1がダウンすると、PCからサーバ群への経路情報は以下のように変わります。

<https://www.ap-siken.com/kakomon/29_haru/img/pm05_4.gif>

L3SW1のルーティングテーブルのうちサーバ群（172.16.1.0/24）への経路情報を保持しているのは項番1ですのでこれの変更が必要です。
p1のダウン後に、L3SW1の内部ルータが172.16.1.0/24宛てのパケットを受け取った場合、L3SW2に転送するためにp10から送出することになります。
このとき、L3SW1がパケット送出するVLANインタフェースは 172.16.2.250、そのVLANインタフェース(p10)が属するVLAN名はVLAN20ですので、これらを項番1に設定することになります。


[4]
VRRP(Virtual Router Redundancy Protocol)は、ネットワークのデフォルトゲートウェイとなるルータやL3スイッチの冗長構成を実現するプロトコルです。

VRRPでは複数台のルータに共通して使える仮想IPアドレス・仮想MACアドレスを用意し、障害発生時には2つのアドレスをフェールオーバで待機系に引き継ぎ処理を継続します。
この仕組みによってホストのデフォルトゲートウェイの設定値などを変更することなしに、送信先の装置を自動で正常稼働するものに置き換えることが可能になっています。

本文中の「PC及びサーバは，パケットを仮想IPアドレスに向けて送信することによって…」の説明から、VRRPを機能させるためにはPC及びサーバの送信先が仮想IPアドレス宛てになっていなければならないことがわかります。
図1及び図2ではサーバ群のデフォルトゲートウェイアドレスはL3SW1のサーバ側インタフェースである 172.16.1.250 に設定されていますので、これをVRRPグループのうちサーバ側（VRRPグループ1）の仮想IPアドレスである 172.16.1.200 に置き換えることになります。

∴(1)デフォルトゲートウェイアドレス
　(2)172.16.1.200

```

---

## データベース 稟議申請システム

「ユーザー」か「ユーザ」か気を付ける事。  
本文の表現にそぐわない場合、減点される恐れがある。  
ほぼ満点と見ていいだろう。  
表現の問題でダメだった。  
1つ引っかかった部分があるので、そこはしっかり確認しておく。  

``` txt : 29分 9/10
## 1
外部キーがあれば1対多と見て問題なさそう。

購買稟議の場合は，申請者の所属部署の部長，購買部の担当者，購買部の部長の順で，承認が必要となる。」とあるので、1つの承認申請に対して複数の承認者がつくことがわかります。したがって、承認申請エンティティと承認者情報エンティティのカーディナリティは1対多であり、
→
ここの意味合いも認識と合っている。


## 3
クエリの構築。
メイン = T1 ADN T1 = T2とすべきか悩んだ。
メイン = T1 AND メイン = T2とした場合、全ての組み合わせを作るらしい。
そのイメージは持たなかった。


## 4
これはRNでも同じ現象に遭遇したのですぐにわかった。
マスターとJOINさせた場合、過去のデータを残すことが出来ない。
そういうわけで、着眼点はよかったが、単純な「部署名」ではなく、「申請時部署名」としなければならなかった模様。
```

---

## 組み込みシステム スマートウォッチ

後2問は正解したかった。  
難易度的にはかなり優しい。  
計算問題もクソみたいな問題しか無かったし。  

ただ、表現の問題が少し難しい。  
複数の言い回しが可能だから。  

``` txt : 30分 7/10
エ
16
画面入力
画面表示
音声入力
画面作成
機能選択画面 × メールの内容
メール表示 × 機能選択画面
割込み × 優先度
表示される情報が違う 100%
→ 複数画面が混在表示される


1秒間当たりのデータサイズ[バイト] ＝ チャネル数 × サンプリング周波数[Hz] × 量子化ビット数[バイト]

この設問では、チャネル数＝1、サンプリング周波数は「8kHz＝8,000Hz」、量子化ビット数は「16ビット＝2バイト」です。これを式に当てはめると、

　1×8,000Hz×2バイト＝16,000バイト
＝16kバイト



ウォッチがフォンからメール受信通知を受信した直後に、利用者がウォッチのタッチパネルをタッチした場合を想像します。
〔ウォッチの動作仕様〕から、ウォッチがフォンからメール受信通知を受信した場合は、受信したメールの内容をウォッチに表示することがわかります。
また、タッチパネルをタッチした場合は、機能選択画面を表示します。

これらのことから、何の対策も講じていなければ、ウォッチがフォンからメール受信通知を受信した直後に、
利用者がウォッチのタッチパネルをタッチをすると、受信したメールの内容を確認する前に機能選択画面に切り替わってしまうことがわかります。
本問のウォッチでは、これを避けるために、各割込みハンドラの起動時にタッチ操作割込みをマスク（受付無効に）し、メインタスクが適切なタイミングで解除する仕様になっています。

よって、eには「メールの内容」、fには「機能選択画面」が入ります。

∴e＝メールの内容
f＝機能選択画面

→
逆だった。
解説の通りに考えれば、確かに逆だ。
俺は先にタッチパネルを操作している時に受信したらって考えていたから、この思考から抜け出せなかった。
メールの内容に関しては部分点くらいはもらえるのでは無かろうか。



[g]
表2より、画面表示タスクは「画面情報の内容を基に、画面の更新を行う」ことがわかります。
また、画面作成タスクは「メインタスクから受けた情報を基に、表示画面を作成し、画面情報に書き込む。」とあり、画面情報を更新します。

画面表示タスクと画面作成タスクは並行して実行されるため、画面表示タスクを実行中に画面作成タスクが動作すると、画面表示タスクは、
画面作成タスクによって書込み中のメモリから画面情報を読み出すことになります。
このときメモリには更新前と更新後の画面情報が混在することになるので、ウォッチの画面には複数画面が混在表示されることになります。

この問題を解決するためには、それぞれのタスクに優先度を付けて、画面表示タスクを実行中に画面作成タスクを動作しないようにする必要があります。
これらのことから、gは「優先度」、"現象"は「複数画面が混在表示される」が適切です。

∴g＝優先度
　現象：複数画面が混在表示される

→
「表示される情報が違う」で100％判定もらったけど怪しいものである。
画面が変になるのだろうなとは思っていたが、それがどういうものかズバリ答える事が出来なかった。
gについては、「割り込み」か「マスク」しか頭になかったが、プリエンプション型なので、優先度であるべきだった。

プリエンプションは割り込み型。
タイムクオンタムや優先度によってディスパッチやプリエンプションで現在のタスクを切り替える。
割り込みだから優先度とみて問題はないだろう。
並行実行という点でどちらを優先すべきかという発想は普通に考えればどうだとしか思えない。
```

---

## 情報システム開発 アジャイル型開発

アジャイルですが、どっかでやった後なのでとても簡単に感じました。  
ただ、独特な用語が多いので、それを覚えきれていないです。  
といっても、出てくるのって大体プロダクトバックログとかスプリントバックログとかエクストリームプログラミングとかなんで、  
回答するのに困ることはないんですよね。  

1つだけポカミスして外しましたが、それを除けば普通に全問正解でした。  

``` txt : 20分 7/9 実質8
オ
ウ
カ
タスクボード

DBのデータや設定、構成等をまとめて管理することが出来る 100%
DBサーバーの設定やテーブル定地等の構成を一元管理できる

意図せず他人のデータを変えてしまったり、自分のデータを変えられてしまう事 0%
→自身のテストデータと他の開発者のテストデータとの見分けがつかない

ビルドサーバ
CIサーバ × チケット管理サーバ

マイナーバージョンにおける最新のバージョンを取得するようにする 100%
他)利用中のメジャーバージョンの中で最新のマイナーバージョンであること

---

## メモ

レトロスペクティブ？
ボードに張るやつ。

用はバラバラになることを防ぐって事を言えればいいはず。

他の人がデータを操作したときにその影響を受ける
意図せず他人のデータを変えてしまったり、自分のデータを変えられてしまう事

---

[1][1]

アジャイルコーチ
チームにアジャイルの方法論を指導し、成果を産み出せるように支援する役割を指す

インセプションデッキ
プロジェクトの全体像を俯瞰し、わかりやすく伝えるためのドキュメント

スプリントバックログ
現在実行中の開発サイクルで実現するべき機能仕様をまとめたもの。スクラム開発で利用される

ブランニングポーカー
数字の書かれたカードを使い、チームで相談しながら作業工数の見積もりを求める手法

プロダクトバックログ
開発対象のシステムやソフトウェアで最終的に実現されるべき要求機能や要素をまとめたもの。スクラム開発で利用される

ペアプログラミング
二人一組でプログラミングを行う手法。一人がプログラムを書いている間に、もう一人がソースコードのチェック・仕様書の確認・構造検討など、開発がスムーズに進むようなナビゲートを担当する。エクストリームプログラミング（XP）という手法で使われる

ユーザストーリ
顧客の意図や求めている機能・性能を小分けにして書き出した文章

リファクタリング
同等の機能を実現しつつ、より洗練されたプログラムに書き直す作業のこと


[1][2]
「作業状態を可視化した環境」に下線が引かれています。これを実現するためには、チームのメンバが見る壁やホワイトボードに「ToDo（未着手）」「Doing（実施中）」「Done（完了）」に分けてタスクを掲示する「タスクボード」というプラクティスが効果的です。日次ミーティングをタスクボードの前で実施することで、タスクの進捗状況をチームメンバ間で共有し、チーム全体で異常の検知、対策を実施を行います。

タスクボードを利用すると、以下のような状況からの改善が期待できます。
誰も作業をせずに、いつまでも着手されないまま残っているタスクがある
どのタスクが終わったのかわからない
タスクを抱えすぎているメンバの存在に気付かない
∴タスクボード

→

最初はレトロスペクティブって書いたけど、見える化するって事はボードに張るってことだよなーって事で、
なんかそれっぽいやつあったなと思ってタスクボードって答えたら正解しました。

因みにレトロスペクティブは「ふりかえり」って意味だった。



[2]
表1を見ると、開発用PCの概要欄に「PC内のWeb/AP/DBサーバを用いて画面ごとのテストを行う。」とあります。
また結合テスト用サーバの概要欄にも「結合テストで用いるWeb/AP/DBサーバが稼働する」と書かれています。

これだと、同じシステムの検証をするためのDBが複数個所に分散して存在することになり、環境の構築や設定（特にスキーマ変更の際）に多大な手間がかかることが予想されます。共用のDBサーバを用意してスキーマを共用すれば、「DBサーバの設定やテーブル定義などの構成を一元管理できる」という構成管理上のメリットが生まれます。

∴DBサーバの設定やテーブル定義などの構成を一元管理できる

開発作業は複数人で進められますが、開発者がDBのスキーマを共用すると、自分がDBに書き込んだテストデータだけでなく他の人が登録や編集したテストデータも見えてしまい、「自身のテストデータと他の開発者のテストデータとの見分けがつかない」という問題が生じます。
データの命名規則などを定めておくことで混乱を回避することが可能です。

∴自身のテストデータと他の開発者のテストデータとの見分けがつかない


[3]
〔eについて〕
[e]に登録するのは処理手順(5)の結果、すなわちWebテストサーバで実行したテストシナリオの実行結果です。表1を読むとチケット管理サーバの概要欄に「テストなどを計画から実行、結果まで記録するもの」という記述があるため、[e]は「チケット管理サーバ」であるとわかります。


[4]
問題文から、テスト失敗の原因は「インターネットから取得したオープンソースライブラリのインタフェースに問題があった」ためと分析されています。CIサーバは「インターネットから最新のオープンソースライブラリを取得する」ようになっていたので、メジャーバージョンアップの際に問題が発生したことになります。

このオープンソースライブラリは、「マイナーバージョンの更新ではインタフェースは変更せず，セキュリティ及び機能上の不具合の修正だけを行う」ので、インタフェースの問題を起こさないためには、メジャーバージョンは現在利用中の（すなわち動作実績のある）ものから変更しないで、マイナーバージョンの更新だけ行えばよいと判断できます。

したがって、CIサーバには現在利用中のメジャーバージョンの中で最新のマイナーバージョンをダウンロードするように設定することになります。

∴利用中のメジャーバージョンの中で最新のマイナーバージョンであること

```
