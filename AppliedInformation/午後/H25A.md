# H25A

---

## セキュリティ Webサイトのセキュリティ強化策

地味に難しかった。  
全部正解してもおかしく無かったので、あまりうれしくない。  
FQDNの復習とロードバランサに証明書を置かなければならない理由をしっかりやる。  
SSLサーバー証明書なのか、ルート証明書なのか若干迷ったのもよろしくない。  

FQDNは.co.jpとかそこら辺までか。そこから先はファイル名なので違う。  
ロードバランサで必要だったのは、クッキーの情報を読む必要があるから。  
HTTPSなら復号しないと中身が読めない。だからロードバランサに証明書を置いて、そこで復号できる必要がある。  
なるほどねって感じ。  

itec  
>セキュリティ対策の問題。この問題で扱われている4つの脅威については、名称と対策をきちんと理解しておきましょう。  
>また、設問2，3で問われているSSLについては、暗号化に関する知識があれば正解できる内容ですが、解説を通してSSLによる通信の流れを理解しておきましょう。  

``` txt : 回答 25分 10/12
## 1
1: ユーザーID ← 本当はユーザIDじゃないとだめ。本文にはそう書かれているから。
2: パスワード


## 2
[1] エ
[2] イ
[3] オ


## 3
[1]
a: イ
c: オ
d: カ

[2]
b: www.a.co.jp/member/ × www.a.co.jp

[3]
機器 : ロードバランサ
理由 : Webアプリケーションのセッションを維持する必要があるから 0%
→
Cookieの情報を参照する必要があるから


## 4
セキュリティ証明書を更新する 100%
→
SSLサーバー証明書を更新する
```

``` txt : 解説
## 2
[1]
認証情報をやり取りする場面では、必ずHTTPSの暗号化通信を使用するように仕向けているため盗聴対策と判断できます。
HTTPSは「通信の暗号化」「ノード認証」「改ざん検知」の機能を提供しますが、Webアプリケーションへの攻撃を防御する仕組みではないため、この策で対処できるのは盗聴のみです。

∴エ：認証情報の盗聴

[2]
WebサーバがDMZに設置されている場合は外部(インターネット上)の端末とWebサーバが直接コネクションを確立して通信を行います。
しかしWebサーバを内部LANに移設した場合は、外部からのアクセスはHTTPアクセスは、一旦リバースプロキシサーバに渡され、
リバースプロキシサーバが改めてWebサーバと通信を確立する形になります。
リバースプロキシサーバを使用することでWebサーバの情報が外部から隠蔽されるため、Webサーバの内部へ不正アクセスを試みる攻撃へのセキュリティが強化されます。

∴イ：Webサイトの改ざん

[3]
WAF(Web Application Firewall)は、通過するパケットのIPアドレスやポート番号だけでなく
ペイロード部(データ部分・アプリケーション層のヘッダ部)をチェックすることで攻撃を検知・遮断することが可能な、Webアプリケーションに特化したファイアウォールです。

WAFの特徴と本文中にWebアプリケーションに対する攻撃を防御するという旨の記述があることから、
この策はWebアプリケーションの脆弱性を突いて攻撃を行う「SQLインジェクション」および「クロスサイトスクリプティング」からWebサーバやDBサーバを守るものと判断できます。

∴オ：SQLインジェクションおよびクロスサイトスクリプティング



## 3
[1]
〔aについて〕
SSL/TLSでは、暗号化通信に用いる共通鍵を安全に送付・共有するためにサーバの公開鍵が使用されます。
またSSL/TLSでは、通信を開始するのに先立ってサーバが自身の公開鍵証明書をクライアントに送信し、
クライアントが公開鍵証明書に付されている認証局(CA)のディジタル署名を検証することで公開鍵、および通信相手の正当性を確認します(なりすましの防止)。

本文中の「HTTPSを使って通信をするために必要」「認証局に申請して取得する」「機器に導入する」などの記述から、aは、
A社のサーバにインストールするサーバ証明書(公開鍵証明書，ディジタル証明書)ということが分かります。

∴a＝イ：SSLサーバ証明書

ルート証明書はルート認証局の身元を証明する電子証明書。  
まぁ、普通に考えてルートなわけないので、スルーでおけ。


〔cについて〕
まず本文中の「cとペアを成すd」という記述より、cとdがSSL/TLSで使用する公開鍵／秘密鍵の組合せであろうと予想できます。
認証局に申請する証明書署名要求(CSR:Certificate Signing Request)とは、申請した情報(表1の識別名情報)と公開鍵をもとに認証局に対して公開鍵証明書の発行を依頼するメッセージです。要求が成功した場合、申請した情報に認証局のディジタル署名が付された公開鍵証明書が送り返され、証明書として有効状態になります。

本文中の「証明書識別要求には，識別名とcが含まれており…」という記述からcは公開鍵と断定できます。

∴c＝オ：公開鍵

〔dについて〕
公開鍵暗号方式で暗号化通信を行うためには、一対で生成される公開鍵と秘密鍵が必要です。公開鍵はSSLサーバ証明書に含まれクライアント端末上での暗号化に使用されます。サーバにはクライアントから暗号化されたデータが送られてきますが、これを復号するためには暗号化に用いた公開鍵に対応する秘密鍵がサーバに組み込まれていなければなりません。
したがってdは秘密鍵になります。

∴d＝カ：秘密鍵

[2]
〔bについて〕
コモンネーム(CN:Common Name)は、サーバ証明書に含まれる登録情報で、証明書が有効なFQDN、またはそのIPアドレスが格納される項目です。
クライアント側ではアクセスしたURLのドメイン名と証明書のコモンネームを比較することで証明書の正当性を検証します。
また本文中にも「コモンネーム(SSL接続するサイトのFQDN)」と説明が記載されています。
この設問ではSSL/TLS通信の対象URLが "https://www.a.co.jp/member" であるため、
このURLのFQDN(ホスト部＋ドメイン部)にあたる "www.a.co.jp" がコモンネームになります。

https : スキーム名
www : ホスト名
a.co.jp : ドメイン名 → ホスト名+ドメイン名 = FQDN
/member : ファイル名

■FQDN(Fully Qualified Domain Name)
ドメイン名・サブドメイン名・ホスト名の全てを指定する記述形式で「完全修飾ドメイン名」とも呼ばれる。
このサイトでいえばドメインが「ap-siken.com」や「.com」、FQDNは「www.ap-siken.com」になる。

∴b＝www.a.co.jp

[3]
本文中の

「ロードバランサは，ユーザからのHTTP/HTTPSリクエストをCookieの情報をもとにリバースプロキシサーバに振り分ける。」

という記述から、ロードバランサはHTTPヘッダのCookie情報を参照する必要があるとわかります。
クライアントとの通信はHTTP又はHTTPSで行われますが、通信内容がHTTPSで暗号化されているとロードバランサにてCookieの内容が読取れず、リバースプロキシへの振り分け処理が適切にできません。この問題を解決するにはロードバランサで通信内容の復号を行い、Cookie情報を参照できるようにする必要があります。

したがってサーバ証明書及び秘密鍵を導入する機器はロードバランサになります。


∴機器：ロードバランサ
　理由：Cookieの情報を参照する必要があるから



## 4
図2の警告ダイアログの3つのメッセージ中、問題があると考えられるのは2つ目の

「このサイトのセキュリティ証明書は，有効期間に問題があります。」

というメッセージです。これは、サーバ証明書の有効期限が切れているためにブラウザから発せられる警告であるため、サーバ証明書の有効期限を更新することで解消されます。本文中の名称を用いて記述すれば「SSLサーバ証明書を更新する」となります。

∴SSLサーバ証明書を更新する

因みに他の2つのメッセージは以下の場合に警告メッセージになります。
証明書の発行元に関する警告
ブラウザに組み込まれているルート証明書でSSLサーバ証明書の信頼性が確認できない場合
証明書内の名前とページURLが一致しないという警告
ページURLのドメイン名と証明書内のコモンネームが一致しない場合
```

---

## プログラミング リストによるメモリ管理

CとかC++やってる人なら解けるのであろう。  
自分には難しかった。  
理論は分かるんだけど、実践してみると混乱する。  
メモリの空き領域が分散する現象を断片化としか連想できなかったのは痛い。  
午前問題をこなしてフラグメンテーションって単語を見たら即答える条件反射でしか勉強してこなかったからだろう。  

しっかり考え方をまとめたい。  

前提条件  
・ポインタ変数→リストの先頭のアドレスを保持する  
・r->next → 1つ後のメモリブロックの先頭アドレス  
・r->prev → 1つ前のメモリブロックの先頭アドレス  
・r->next->prev → 次のリストの前のリストのアドレスってことは自分自身  

解説を見た限り、ポインタ変数は->nextを表していたりするはず。  

``` txt 30分オーバー 3/12
NULL × EDGEの先頭アドレス
status
size ← msize - q->size × next
q->next × q
q->prev × q->next

'A'
p->size + r->size + 2*HSIZE × p->size + q->size + r->size + 2*HSIZE
q->prev × p
q->size + r->size + HSIZE

断片化 × フラグメンテーション
600 × 2*HSIZE+600
アドレスが変わるから 25%
→メモリブロックの先頭アドレスが変わるから

---

[1][1]
先に[イ]と[ウ]に入る字句を考えてから、[ア]に進むとスムーズです。

〔ウについて〕
q->statusが'A'の場合、すなわち「データ部分は割当て済みメモリである場合」や、q->sizeがmsize未満である場合、すなわち「データ部分のバイト数が割り当てたいバイト数未満」であれば、現在参照しているメモリブロックにメモリを割り当てることはできません。このとき、1つ後のメモリブロックの確認に移るために、q を1つ後のメモリブロックの先頭アドレスで更新することになります。そのメモリブロックの1つ後のメモリブロックの先頭アドレスは、メンバ next が保持しているので、q に q->next を設定する手続きが適切です。

∴ウ＝next

〔アについて〕
ポインタ変数 q の初期値は、変数EDGEのメンバ next（リストの先頭要素）です。前述の通り q が割当てできないメモリブロックである場合には、q は1つ後ろのメモリブロックに移動しますが、割当て可能なメモリブロックが見つかったときは関数の戻り値に q をセットして関数を終了します（〔メモリ割当ての関数〕(4)(5)参照）。ここで、もし末尾のメモリブロックまで適切な空きメモリが見つからず、q に末尾のメモリブロックのメンバ next がセットされたとき、q の値はどうなっているのかを考えます。

問題文では「最後尾のメモリブロックのメンバ next には，… EDGEの先頭アドレスをセットする」と説明されているので、末尾のメモリブロックまで走査した結果、十分な空きメモリをもったメモリブロックがなかった場合、q にはEDGEの先頭アドレスがセットされていることになります。よって、q が「EDGEの先頭アドレス」と等しい場合には、関数の戻り値に NULL をセットして終了することになります。

∴ア＝EDGEの先頭アドレス

→
これは文中に書いてあるからその通りなのだろう。
EDGEは循環リストの受口的な部分だから、次に割り当てるところがなかったらEDGEに戻ってこないといけないってことなんだろうな。


[1][2]
〔メモリ割当ての関数〕(5)の処理は、q をメモリ割当て済みのメモリブロックと、空きメモリブロック r に分割する処理です。
図3「メモリ割り当てによるメモリ分割」より、空きメモリブロック r は q の1つ後ろのメモリブロックになることがわかります。したがって、リスト内のメモリブロックの連結が以下のように変わることになります。
分割前
qの1つ前のブロック ←→ q ←→ qの1つ前のブロック
分割後
qの1つ前のブロック ←→ q ←→ r ←→ qの1つ前のブロック

〔エについて〕
r->prev は、r の1つ前のメモリブロックの先頭アドレスなので、「q」をセットするのが適切です。

〔オについて〕
r->next は、r の1つ後のメモリブロックの先頭アドレスなので、「q->next」をセットするのが適切です。q->next の値を r に更新する処理は最後に行っているので、q->next で分割前の q の1つ後ろのメモリブロックを参照可能です。

∴エ＝q
　オ＝q->next

→
これ全然わからない。
qって何？rって何？
なんで右と左でqの1つ前のブロックを2回も指定するの？



[2]
〔カについて〕
status に設定する値ですので、'A'または'F'の択一です。

関数 freemem 中では、前後のブロックの少なくとも1つが空きブロックである場合には、それらをまとめて1つの空きブロックにします。この際、空きブロックのメンバ size を設定していますが、変数 EDGE はデータ部分を持っていない（size=0）ので、p や r となったときに空きブロックとして扱われてしまうのは適切ではありません。特に p になったときは、変数EDGEのメンバ size を空きブロックのデータサイズで更新してしまうことになります。

よって、変数EDGEのメンバ status には'A'(割当て済)をセットしておき、空きブロックとして扱われないようにしておく必要があります。

∴カ＝'A'

〔キについて〕
コメント部にあるように、この分岐は前後のブロックがともに空きであるときの処理です。
pm02_7.gif/image-size:516×88
この場合、前・解放対象・後の3つのブロックの空き領域を前のブロック（p）にまとめることになります。解放対象のブロック及び後のブロックについては、解放によりヘッダ部分とデータ部分の両方が空き領域となるので、前のブロックのメンバ size に設定する値は以下の3つの合計となります。
前のブロックのデータサイズ
解放対象のブロックのヘッダサイズ＋データサイズ
後のブロックのヘッダサイズ＋データサイズ
pm02_8.gif/image-size:510×108
したがって p->size に設定する値は、p->size、q->size、r->size とヘッダ部分のバイト数である HSIZE 2つ分（HSIZE * 2）の合計となります。

∴キ＝p->size + q->size + r->size + 2*HSIZE

〔クについて〕
空き領域を前のメモリブロックにまとめると、まとめられた側のメモリブロック（qやr）は不要となるのでリストから外されます。このとき、リストの連結を維持するために前のメモリブロック（p）のメンバ next を更新する必要があります。具体的には、p->next の値は関数 freemem の6行目または9行目で次の値で更新されています。
前後とも空きの場合（6行目）
p ←→ q ←→ r ←→ rの1つ後
が
p ←→ rの1つ後
となるので、r->next を設定
前だけが空きの場合（9行目）
p ←→ q ←→ r
が
p ←→ r
となるので、r を設定
本問のリストは双方向のリストなので、p->next（rの1つ後またはr）のメンバ prev には、1つ前のメモリブロックである「p」を設定することになります。

∴ク＝p

〔ケについて〕
コメント部にあるように、この分岐は前が割当て済で、後が空きであるときの処理です。
pm02_9.gif/image-size:516×88
この場合、解放対象・後の2つのブロックの空き領域を解放対象のブロック（q）にまとめることになります。後のブロックについては、解放によりヘッダ部分とデータ部分の両方が空き領域となるので、解放対象のブロックのメンバ size に設定する値は以下の2つの合計となります。
解放対象のブロックのデータサイズ
後のブロックのヘッダサイズ＋データサイズ
pm02_10.gif/image-size:510×108
したがって q->size に設定する値は、q->size、r->size とヘッダ部分のバイト数である HSIZE 1つ分の合計となります。

∴ケ＝q->size + r->size + HSIZE



[3][1]
記憶領域を区画してプログラムに割り当てていくと、その結果として記憶領域上に小さな空き領域が点在した状態になります。この状態になると空き領域の合計としては余裕があるにもかかわらず、サイズの大きな空きメモリの確保が難しくなり、アクセス効率が低下します。この現象を「フラグメンテーション」と呼びます。

∴コ＝フラグメンテーション

[3][2]
〔サについて〕
図6「ヒープ領域の状態」を見ると、割当て済（status='A'）のメモリが4つ、空きメモリ（status='F'）が3つあります。この3つの空メモリの size を合計すると「200＋300＋100=600」となります。メモリコンパクションを行うと複数の空きメモリが1つの大きな空きメモリにまとまるので、ヘッダ部分が1つで済みます。3つの空きメモリを1つの空きメモリにまとめた場合、2つのヘッダ部分の領域もデータ部分として使用できることになります。

したがって、図6の状態にメモリコンパクションを実行した場合にできる空きメモリの大きさは、600バイトに HSIZE 2つ分を足した「2×HSIZE＋600」が適切です。

∴サ＝2×HSIZE＋600

[3][3]
メモリ割当ての関数の戻り値である q は、割当て可能とされたメモリブロックの先頭アドレスです。メモリコンパクションでは、割当て済みのメモリブロックが連続するようにメモリブロックを移動するので、移動対象となった割当て済みメモリについては先頭アドレスが変わることになります。このため、メモリ解放の関数の引数として戻り値の q を指定しても、正しく参照できないことがあります。

∴メモリブロックの先頭アドレスが変わるから
```

``` txt
https://www.ap-siken.com/bbs/2517.html
設問と直接関係ないのですが，どなたかお教えいただけますと幸いです。
2ページ目の最後尾にて（空欄[オ]の後に）「q->next->prev には r を，q->next には r を順にセットする。関数の戻り値に q の値をセットして終了する。」と記載されておりますが，「q->next->prev には r 」の部分に理解が追い付いておりません。
rでなく，qではないのかと思っており，また，この処理自体がなぜ必要なのかが理解できませんでした。
どなたかご説明を，よろしくお願い致します。

→

分割前をq→[1]→[2]とします。
この時、[2]のprevは[1]を指しております。

[1]を[1-1]と[1-2]に分割すると
q→[1-1]→[1-2]→[2]
となります。
（※r→[1-2]となります。）

この時、[2]のprevはこのままだと[1-1](分割前の[1])を指す事になる為
[2]のprevを[1-2]に変更する必要があります。(rに変更する必要があります。)
[2]のprevに相当するものがq->next->prevとなります。
```

---

## ネットワーク ネットワーク障害調査

難しい問題と聞いたのでやってみたが、特に難しいとは感じなかった。  
と、いいつつ、2つ全然わからない奴があったのでそれだけしっかり復習する。  
それ以外は全部わかったので、問題ない。  

``` txt : 30分 9/11
172.16.1.1
172.16.1.252
172.16.0.101
25

オ
エ
プロキシサーバ
DNSサーバー

ルーターが同じネットワークに属していない ×
→調達部FSのデフォルトゲートウェイ
調達部FSのIPアドレスが間違っている
→調達部FSのネットマスク

ブラウザからのアクセスはDMZ経由になるのでFWでブロックされる 0%
→プロキシサーバー経由でFSにアクセスしようとしたから

---

[3]
問題の切り分けについては以下の4点に着目します。
1. 調達部PCから調達部FSにアクセスできているため、調達部FSのIPアドレスは適切に設定されている
2. tracerouteの引数は調達部FS"172.16.1.253"を指している
3. tracerouteのパケットは調達部ルータまで届いている
4. ネットワーク機器は適切に設定されており、障害も発生していない

以上より、tracerouteのパケットは調達部ルータによって適切に配送され、調達部FSに到達していると考えるのが妥当です。
つまりタイムアウトの原因は調達部FSから送出される応答パケットにあると判断できます。
調達部FSに設定した項目のうち、この問題の原因として考えられるのは「ネットマスク」「デフォルトゲートウェイ」の設定です。
もしデフォルトゲートウェイが誤っていれば調達部ルータに応答パケットが届きません。
またネットマスクの誤りでは「送信元の総務部PCが同じネットワーク内の機器である」と誤認識して、応答パケットを調達部ネットワーク内に送出してしまっている可能性が考えられます。

[4]
図2のPCへの設定ガイドでは、プロキシの例外設定が「なし(全てのURLにプロキシサーバを利用)」となっています。
この設定があるため、PCのWebブラウザからFSにアクセスすると、そのリクエストはプロキシサーバに送られます。プロキシサーバは、FSに代理アクセスしようとしますが、P社では「インターネットやDMZから各部のFSにアクセスできないようにファイアウォールを設置している」ので、DMZ上のプロキシサーバからFSへの通信はファイアウォールで遮断されてしまいます。この状態ではPCにはレスポンスが返ってきません。

つまり、FSの利用状況確認ページが表示されなかったのでは、プロキシサーバ経由でのアクセスがファイアウォールで遮断されるからです。

∴プロキシサーバ経由でFSにアクセスしようとしていたから

```

---

## 組み込みシステム ネットワークを使用するインターホンの設計

本当は8問正解だが、言いたいことはほぼ合っているので実質9問正解でいいだろう。  
中々頭が混乱する問題だった。  
何とか制限時間内に解けたからいいけど、あっちいったりこっちいったりする類の問題をやっていると、応用情報だなって思う。  
計算問題はなかったけど、計算がないとこういうことになるんだなって思った。  
計算がない場合の傾向としては、とにかくパターンで攻めてくる感じかな。  
イベントの受信や通信の指示など1つの表に全部まとまって説明されるから頭が混乱してしまう。  
まぁ、組み込みはレギュラー入りなのは確実だが、簡単に点を取らせてくれるものではないのは確かだ。  
でも文系のあの項目を選択するよりはマシか。  

>文章で記述された内容を状態遷移図によって整理できるかという事がこの問題のポイント  
>情報システム設計分野の問題を含めて、状態遷移図などチャート類が出題の中心になっている問題では、このような形式がおおいので、  
>長い問題文を効率よく整理する練習をしてください。  

そう！俺が感じたのもまさにその事。  
残った時間で今日やった問題の解説を読み直すか。  

``` txt : 回答 30分 9/10
## メモ

A → B
青点滅


## 1
[1]
a：ACK応答受信
b：点滅しているボタンにタッチ △ ボタンにタッチ
c：ON通知受信

[2]
端末Cから接続要求を受信し、着呼、通話状態である時 ×
→
端末Bが他の端末と通話するために接続を試みているとき(道場)
他の端末からの応答を待っている場合(itec)


## 2
d：青
e：待受け


## 3
[1] 青
[2] 通話終了指示
[3]
①：OFF通知
②：READY通知
```

``` txt : 解説
## 1

itec解説
端末Bが端末Aからの接続要求を受付られないと判断するのはどのような場合か。

単純に考えると通話中等が思い浮かぶが、表1には通信不可の黄点灯として次のように記述されているから、
端末Bが通話中の時はボタンBが黄点灯で発呼出来ない。
>ボタンで示された端末が自端末以外の端末と発呼、着呼、又は通話状態であり、その端末に対して発呼できない状態
一方、タッチしたボタンは青点灯だが、表1によれば、青点灯となる接続状態には、「待ち受け」と「応答まと」の2つがある。
このうち「待ち受け」状態の場合には、特に問題なく要求を受け入れ、ACK応答を返すだろう。
これに対して「応答待ち」の場合には、端末Bは他の端末からの応答を待っているので、要求を受け付けることはできない。
なので、「他の端末から応用を待っている場合」などと回答する。

なるほど、Bから接続要求を出した場合と、他の端末から接続要求を受けている時の2パターンがあるのはみんな思うことなのか。
でも、Bから要求を出した限りでは、間違いなく他の端末にBUSYを送るので、接続不可になるって事なのかな。
相手からの応答街だと、同時押ししたときにどうなるかって問題に発展して確実性がなくなるのもあれなのかな。

道場解説
端末Bが端末Aからの"接続要求"を受け付けられず、"NAK応答"を返す場合を考えます。
端末Aが端末Bに"接続要求"を送信するのは、端末Aで青点灯のボタン"B"を押したときです。表1を見ると、ボタンが青点灯しているとき、そのボタンで示された端末の接続状態は"待受け"または"応答待ち"のいずれかであることがわかります。"待受け"は「発呼又は着呼が可能な状態」ですので端末Aからの接続要求を拒否する理由がありません。よって、"NAK応答"を返すのは端末Bが"応答待ち"のときと判断できます。

"応答待ち"は「呼び出した端末からの応答を待つ状態」です。つまり、端末Bが他の端末に"接続要求"を送信し、その応答を待っているときということになります。この場合、他の端末からの"接続要求"を受け付けられないので、端末Bは"NAK応答"を返すことになります。

∴端末Bが他の端末と通話するために接続を試みているとき

```

---

## 情報システム開発 ソフトウェアの機能規模の見積り

この問題覚えてるわ。  
2回目の試験でやったときはボロボロだった気がする。  
今回はほとんど出来た。  
この問題は1回でも間違えると全部だめになるタイプだった。  
知識ではなく、問題文から読み取る系の問題なので、特に解説すえる事は無く、ミスリードがなかったかどうか程度で十分かな。  

``` txt : 30分 10/11
開発において使用するプログラム言語の選定基準になるため 100%
他)開発に持ちいるプログラム言語に依存しない見積もりが行えること
→よく見たらだめじゃね？

EIF
ILF
10 × 8
EO

0
1
5
1
58
46.4

---

[1]
問題文冒頭部に、K社では開発に複数のプログラム言語を用いているという記述があります。
ソフトウェア規模を見積もる方法としては、古くからプログラムステップ法（LOC法）という方法がありますが、この見積り法は名前の通りソースコードの行数を基準にソフトウェア規模を推計する方法なので、開発に用いるプログラム言語によってソフトウェア規模が変わってしまうことになります。
※同じ処理を実装する場合でも、プログラム言語によってソースコードの行数が大きく異なることがあります。

ファンクションポイント法は、外部入出力や内部ファイルの数と難易度の高さから論理的にファンクションポイントを算出し、それを基に開発規模を見積もる手法なので、どのプログラム言語を採用したとしても算出される開発規模は同じになります。
開発プロジェクトのコストやスケジュール等は見積もられた開発規模によって決まるので、見積りの正確さは、開発プロジェクトの成否に大きな影響を及ぼします。
したがって、開発に用いるプログラム言語に依存せずに見積りが行えることは、K社にとってのメリットとなります。

∴開発に用いるプログラム言語に依存しない見積りが行えること


[2]
〔aについて〕
表4はデータファンクションの一覧ですので、表3でデータファンクションに分類されているILF、EIFのいずれかが入ります。
図1のDFDを見ると、"入庫指示"は生産管理システムから出力されるデータであることがわかります。
入庫管理システムでは"入庫処理"にて"入庫指示"の参照だけを行い、作成・更新・削除をすることはないので、外部インタフェースファイルを表す「EIF（External Interface File）」が適切です。

∴a＝EIF

〔bについて〕
こちらもILF、EIFのいずれかが入ります。
図1のDFDを見ると、"在庫"は"入庫処理"により作成・更新され、"実績集計"・"数量照会"・"金額照会"の3つのトランザクションファンクションによって参照されていることがわかります。入庫管理システムによって、作成・更新・参照・削除されるデータなので、内部論理ファイルを表す「ILF（Internal Logical File）」が適切です。

∴b＝ILF

〔cについて〕
まず、データ項目数の積算ルールについて整理します。
見出しや定数項目などの固定値項目を除く
アプリケーションに出入りする可変なデータ項目である
同じデータ項目が複数回繰り返し表示される場合は最初の1回とする
データストアの一つの項目が，画面設計の都合によって複数の表示項目に分割される場合も，データ項目数は1とする
ボタンなどの処理のトリガは，まとめて1つとする
各種メッセージについても，まとめて1つとする
このルールに則りデータ項目の個数を数えると、入庫登録のデータ項目数は以下の8つとなります。

https://www.ap-siken.com/kakomon/25_aki/img/pm07_6.gif

→
日付のところを1つずつ数えていましたが、ルール4だと1つとカウントする見たいなので、そこで食い違った見たいです。
確かに複数の表示項目に分割されているので、1つと数えるのかもしれないですね。
```
