# H25S

---

## プログラミング

``` txt
```

---

## 組み込みシステム ワイヤレス充電ステーション

プリエンプション  
優先度に関する問題  

実は特に書くことがない。
100点取れた地点でこれはもういいだろう。

``` txt : 23分 100点
## メモ
10 : 6 = 1 : ?
10? = 6
? = 0.6

51 / 0.6 = 85分
60+25


## 1 ○
01:25


## 2
a 4 ○
b 2 ○
c ア ○
d Stop_Power ○


## 3 ○
機器IDが0


## 4 ○
安全監視タスクでGet_Wattを実行
→
Get_Watt関数を呼び出す
```

---

## 情報システム開発 プロビジョニングシステムの設計

うーん。もっと正解出来た。  
解説を読んでみると、2問は難しかったので仕方ないとしても、もう2問は普通に正解できるレベルの問題だった。  

長文の問題も、解説と照らし合わせてみると検討違いだったことが分かった。  
自分が思っていた以上に入り組んでいる問題だった。  
判定が100％なのは、重要な単語を全部使っているからだろう。  
内容的には何一つ合っていない。  

今回の長文の問題に関しては、次の問題にも関係しているので、すぐに応えるモードに入るのでは無く、前後の文脈をもっとよく見て考えたほうがよかった。  
それだけでも、図解の問題は正解できる確立が上がったはずだ。  
ここまで問題を解いてきてもまだまだ

``` txt 30分 6/9
作成 × 停止
Starting
Deleting

①、③、⑤、⑦ × ②，④，⑥

起動状態でサーバー削除のメッセージを受信するとエラーになるため 100%
他)仮想サーバの状態が、停止になる前にサーバ削除のメッセージが送信されるから

停止中に矢印を延ばしてしまったので不正解です。
最初は削除中に延ばしてたけど、メッセージが違ったので結局だめ。
<https://www.ap-siken.com/kakomon/25_haru/img/pm08_6.gif>

起動
サーバ削除
→サーバーと延ばさないようにね
StopDeleting

---

[1]
サーバーが作られた直後は停止と図2に思いっきり答えが書いてあるのに、選択肢の羅列から憶測してしまった。
普通に考えてもそうだよなって思う。


[2]
メッセージハンドラによって指示されたイベントが完了した旨のメッセージを、システムに送信するかの有無を問うています。

〔プロビジョニングシステムの設計〕には、以下の記述があります。

「メッセージハンドラは、メッセージハンドラの処理完了のイベントを発生させる必要がある場合に限り、呼び出したAPIの処理終了後に処理完了メッセージを生成し、メッセージキューに格納する。」

表3を見ると、処理完了のイベントを契機として生成されるメッセージハンドラは「Created」「Ready」「Stop」「Deleted」の4つです。この4つはそれぞれ"○○中"の処理が完了したとき、次のように仮想サーバの状態を変更する役割があります。
Creating → "作成中" → Created → "停止"
Starting → "起動中" → Ready → "起動"
Stopping → "停止中" → Stop → "停止"
Deleting → "削除中" → Deleted → "削除済"
よって、「Creating」「Starting」「Stoping」および「Deleteing」の4つについては、処理の完了後、仮想サーバの状態変更イベントを発生させるために、処理完了のメッセージを送信しなければなりません。表2の番号で答えるので「②，④，⑥」の組合せが適切です。

∴②，④，⑥

このような仕様になっているのは、「同一のサーバIDに対するAPIを複数のスレッドから同時に呼び出すと，APIがエラーになることがある」からです。処理完了メッセージにAPIが返すサーバIDを含めることで、同一スレッド内で完了処理を行えるようにしています。

→
解説を見終わった後だと何で間違えたんだろうって感じの問題だ。
頭の中だけでは無く、整理するためにも色々書きながらやったほうがいいと思った。
これは、勘違いしたまま応えてしまったからこうなった感じだな。
問題文を読んでいてもややこしく感じていたのは確か。
いつのタイミングで・・・。いや、小難しく考える必要ないな。
表2でいつするかしないかって書いてあるからその通りに書けばよかっただけだなこれ・・・。
うーん。



[3]
最初に現在の仕様における、起動中からサーバ削除までの手順を確認しておきます。
"サーバ停止"メッセージを生成する
メッセージハンドラ「Stopping」により"停止中"に遷移するとともに、StopServerが呼び出される
StopServerの処理が完了（仮想サーバが停止）し、"処理完了"メッセージを生成する
メッセージハンドラ「Stop」が選択され、"停止"に遷移する
"サーバ削除"メッセージを生成する
メッセージハンドラ「Deleting」により"削除中"に遷移するとともに、DeleteServerが呼び出される
DeleteServerの処理が完了（仮想サーバが削除）し、"処理完了"メッセージを生成する
メッセージハンドラ「Deleted」が選択され、"削除済"に遷移する
今回の仕様変更では、"起動"の状態から"サーバ停止"と"サーバ削除"を1回の命令のみで処理できるようにします。これを実現するために「サーバ停止とサーバ削除の二つのメッセージをメッセージキューに格納する」としていますが、サーバ削除はサーバの状態が"停止"のときのみ有効であることに注意しましょう。

ディスパッチャは、メッセージキューに格納されたメッセージを先頭から順次処理していくので、単に停止と削除のメッセージを順番に格納しただけでは、サーバの停止を待たずに"サーバ削除"メッセージが処理されることがあります。表3を見ると、サーバの状態が"停止中"のときに"サーバ削除"のメッセージを取得すると、ディスパッチャは「Err」を生成することが確認できます。このとき、サーバの削除に失敗し、意図した結果を得られません。

設問では、「仮想サーバの状態と送信されるメッセージについて言及し」という条件があるので、
仮想サーバの状態が"停止"になる前に、サーバ削除のメッセージが送信されるから
仮想サーバの状態が"停止中"のときに、サーバ削除のメッセージが送信されるから
などの解答が適切となります。

∴仮想サーバの状態が，"停止"になる前にサーバ削除のメッセージが送信されるから

→
つまり、サーバー停止、サーバー削除をキューに入れるなら「サーバー停止、サーバー停止状態にしてもらう、サーバー削除」って間に停止状態に遷移させるメッセージハンドラを入れないと実現できなって事か。
まぁ、それが無理なんで、そこを指摘するのが答えってわけね。
整理出来てた状態だと、まぁって感じだけど、迷ってる最中にこれはきついんだよな。



[4]
"停止・削除中"状態の前後の状態をイベントで紐づけます。

ここでは問題文中の以下の記述が解答のヒントになっています。
仮想サーバの状態が"起動"のときにサーバ削除のメッセージを受け取ると、仮想サーバは"停止・削除中"の状態に遷移し…
StopServerが完了すると、自動的に"削除中"の状態に遷移し、DeleteServerのAPIが呼び出される
この記述をそのまま表現すると、
"起動"から"停止・削除中"に向けた矢印で、遷移条件が"サーバ削除"
"停止・削除中"から"削除中"に向けた矢印で、遷移条件が"処理完了"
上記の2つが必要です。

[pm08_12.gif/image-size:459×98](https://www.ap-siken.com/kakomon/25_haru/img/pm08_12.gif)

```
