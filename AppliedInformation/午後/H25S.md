# H25S

---

## プログラミング 一般的な表記法の数式を逆ポーランド表記法に変換するアルゴリズム

30分を過ぎた割には正解しなかったなって感じ。  
もう一問くらいは正解したかった。  
逆ポーランドはわかったと思っていたが、全然そんなことはなかった。  
自分の感覚で解いたら失敗した。  
仕事終わりに考えるのが面倒だったからだろうか。  

プログラミングの部分に関しては、前後関係をにらめっこするより日本語をそのままプログラミングに落とし込んだほうが早かった。  
ここができなかったために時間がかかった感じである。  
後は、変換前配列とスタックの優先度の比較で時間がかかった。  
これは頭の中だけで考えてしまったからだと思われる。  
ノートに書きながら右へ左へ比較していれば、少しはましになったと思われる。  

あとあれだ。配列の先頭とスタックの先頭って全く逆なんだ。  
配列の先頭は要素0だけど、スタックって積み重ねていくモノだから先頭は一番最後の要素が先頭になるんだ。  
文中では○○の先頭としか言わないから突然逆になるなんて思わないからな。  
ここの違和感を払拭できなかったのも理解に時間がかかった要因かもしれない。  

ハマったポイントとしてはそんなモノだろうか。  
ただ25Aよりは明らかに理解できたので、復習は楽である。  
25年の問題はスタックやポインタ等、根本的な要素に関する問題ばかりなんだな。  

``` txt : 30分オーバー 10/14
423+× × 23+4×
×
÷
+
-

0
(1)の演算要素の優先度 × スタック上に演算要素があるか否か or スタックが空であるか否か
stack[stackCount]
GetPriority(stackTop)がelementPriority以上
GetPriority(stack[stackCount])がelementPriority(i)以上 × GetElement(i)が")"である

OK × Err
OK
OK
Err

---
[1][1]
問題文の冒頭部で「逆ポーランド表記法とは、演算子を二つの演算対象の後ろに配置することによって、数式を表現する表記法である。」と説明されている通り、通常の数式「A＋B」を逆ポーランド表記法で表現すると「AB＋」になります。
この変換規則に加えて、1回使った演算子は2度使わないことに注意して、普通に計算式を解くのと同じ順序で変換を行っていくことで逆ポーランド表記法の式になります。

数式 (2＋3)×4 は以下のように変換されます。
先に計算する"2＋3"の部分を"変換する。
演算対象の"2"と"3"の後ろに"＋"が配置されるので→23＋×4
"23＋"を1つの項とみなして、演算子×、もう一つの項を4として変換する。
演算対象の"23×"と"4"の後ろに"×"が配置されるので→23＋4×
よって、数式 (2＋3)×4 を逆ポーランド表記法に変換した結果は「23＋4×」が適切です。

∴23＋4×

→
何を勘違いしたのか。
先に4をおいて、そのあと23。で[+]で一回計算してその項を[*]で計算すれば答えになると思い込んでいた。
しかし、文中のロジックを見る限り、先頭から考えるのは必然なので、素直にトレースすればよかった。


[1][2]
逆ポーランドへの変換手順(2)において、スタックの先頭の演算要素の優先度が、参照中である変換前配列の要素の優先度未満になるまで、スタックからのポップ（取り出し操作）を繰り返すという操作手順に注目します。

図1の処理過程で"×"が参照されている時の操作を見ると、"2"はポップされ"＋"はポップされていないことがわかります。
pm02_5.gif/image-size:427×253
つまり、"×"の優先度は"2"と同じかそれより低く、"＋"より高いということです。演算の性質から考えて、"×"と"÷"、"＋"と"－"は同じ優先度のグループとすべきなので、優先度が高い[ア][イ]には"×"と"÷"が、[ウ][エ]には"＋"と"－"が当てはまります。

→
ここの優先度の理解に時間をかけてしまった。
大きいか小さいかを比較するだけなんだけど、これが意外と難しい。
紙とペンをもって見比べながら考えたらまた違っただろうか。



[2][2]

〔カについて〕
手順(2)は次の4つの処理に分解できます。
スタック上に演算要素があるか否かを確認する
スタックの先頭にある演算要素の優先度を参照する
スタックの先頭にある演算要素の優先度が、現在参照している演算要素の優先度以上ならポップする（繰り返し）
スタックの先頭にある演算要素が")"なら繰返しを終了する
(1)の説明の通り null はポップされることのない要素ですので、スタックが空になることはありません。常にスタック上に演算要素がある状態になるので、1番目の「スタック上に演算要素があるか否かを確認する」処理が不要となります。
"[カ]の判定処理"と続くので、「スタック上に演算要素があるか否か」「スタックが空であるか否か」等の字句が当てはまります。

∴スタック上に演算要素があるか否か
　スタックが空であるか否か
→
安直に文中の表現を借りて回答して満足しただけ。
回答した時の違和感はすごかったけどそれを検証するほどの余裕がなかったのでそのまま流してしまった。
(2)の処理がえらいあったので箇条書きにするのが正解だったか。

〔キについて〕
表3中には変数 stackTop の用途について説明がありませんが、続くwhile文の継続条件式内で「stackTop が"（"以外の間繰り返す」とあるので、stackTop はスタックの先頭の演算要素を格納するための変数だということがわかります。表2の注記にあるように「最後に追加された演算要素がスタックの先頭」なので、stackTop には配列 stack[] の末尾要素を格納することになります。

配列 stack[] の添字は1始まりですので、スタックの要素数を保持する変数 stackCount を使えば配列の末尾要素を参照できます。よって、[キ]には「stack[stackCount]」が当てはまります。

∴キ＝stack[stackCount]

〔クについて〕
内側のwhile文内ではスタックからポップし、変換後配列 result に追加する操作が行われています。これを行うのは手順(2)の「スタックの演算要素の優先度が、現在参照している演算要素の優先度以上」の間ですので、[キ]には"スタック先頭の演算要素の優先度"と"現在参照している演算要素の優先度"を比較する式が入ります。

スタックの先頭にある演算要素の優先度は、表3中の優先度を取得する関数 GetPriority を使って「GetPriority(stackTop)」で取得できます。そして、現在参照している演算要素の優先度は変数 elementPriority に格納されています。よって[ク]に入る式は、「GetPriority(stackTop) が elementPriority 以上」が適切です。手順(2)の説明とは逆になりますが「elementPriority が GetPriority(stackTop) より小さい」でもプログラムの動作上は問題ないはずです。

∴ク＝GetPriority(stackTop) が elementPriority 以上

〔ケについて〕
コメント「// 変換前配列を参照し，演算要素を処理する」直後のIF文は、以下の変換アルゴリズムの手順(3)に該当する処理です。

「(1)で参照した演算要素が")"なら，それを破棄し，その際スタックの先頭にあるはずの"("もポップして破棄した後(1)に戻る。(1)で参照した演算要素が")" 以外なら，その演算要素をスタックにプッシュし，(1)に戻る。」

プログラムを見ると、[ケ]の式が真となる場合には stackCount の値をデクリメント（1減算）することでスタックの先頭（stack[] の末尾）にある要素"("を破棄し、偽である場合にはスタックに演算要素をプッシュしています。したがって[ケ]には、現在参照している演算要素が")"である旨の条件式が入ると判断できます。

変換前配列の演算要素は関数 GetElement で取得できるので、現在参照している i 番目の要素を参照するには「GetElement(i)」と記述することになります。この値が")"のとき真となれば良いので、[ケ]には「GetElement(i) が ")" である」が当てはまります。別の年度の午後問題では○と●が同一という字句表現も見られますので、「GetElement(i) と ")" が同一である」でも問題ないでしょう。

∴ケ＝GetElement(i) が ")" である



[3]
〔コについて〕
数値の後に数値が現れる場合です。
〔逆ポーランド表記法への変換アルゴリズム〕で説明されているように、本アルゴリズムでは「数値は0～9の1桁の数」と限定しています。〔エラーチェックの追加〕にはエラーとする例として「数値の演算要素が2個以上連続する場合」とあるので、評価結果は「Err」です。
→
あ、そっか。
普通に考えれば10の桁になるはずだけど、この問題0~9の1桁って仕様だからErrになるわな。
```

---

## 組み込みシステム ワイヤレス充電ステーション

プリエンプション  
優先度に関する問題  

実は特に書くことがない。
100点取れた地点でこれはもういいだろう。

``` txt : 23分 100点
## メモ
10 : 6 = 1 : ?
10? = 6
? = 0.6

51 / 0.6 = 85分
60+25


## 1 ○
01:25


## 2
a 4 ○
b 2 ○
c ア ○
d Stop_Power ○


## 3 ○
機器IDが0


## 4 ○
安全監視タスクでGet_Wattを実行
→
Get_Watt関数を呼び出す
```

---

## 情報システム開発 プロビジョニングシステムの設計

うーん。もっと正解出来た。  
解説を読んでみると、2問は難しかったので仕方ないとしても、もう2問は普通に正解できるレベルの問題だった。  

長文の問題も、解説と照らし合わせてみると検討違いだったことが分かった。  
自分が思っていた以上に入り組んでいる問題だった。  
判定が100％なのは、重要な単語を全部使っているからだろう。  
内容的には何一つ合っていない。  

今回の長文の問題に関しては、次の問題にも関係しているので、すぐに応えるモードに入るのでは無く、前後の文脈をもっとよく見て考えたほうがよかった。  
それだけでも、図解の問題は正解できる確立が上がったはずだ。  
ここまで問題を解いてきてもまだまだ

``` txt 30分 6/9
作成 × 停止
Starting
Deleting

①、③、⑤、⑦ × ②，④，⑥

起動状態でサーバー削除のメッセージを受信するとエラーになるため 100%
他)仮想サーバの状態が、停止になる前にサーバ削除のメッセージが送信されるから

停止中に矢印を延ばしてしまったので不正解です。
最初は削除中に延ばしてたけど、メッセージが違ったので結局だめ。
<https://www.ap-siken.com/kakomon/25_haru/img/pm08_6.gif>

起動
サーバ削除
→サーバーと延ばさないようにね
StopDeleting

---

[1]
サーバーが作られた直後は停止と図2に思いっきり答えが書いてあるのに、選択肢の羅列から憶測してしまった。
普通に考えてもそうだよなって思う。


[2]
メッセージハンドラによって指示されたイベントが完了した旨のメッセージを、システムに送信するかの有無を問うています。

〔プロビジョニングシステムの設計〕には、以下の記述があります。

「メッセージハンドラは、メッセージハンドラの処理完了のイベントを発生させる必要がある場合に限り、呼び出したAPIの処理終了後に処理完了メッセージを生成し、メッセージキューに格納する。」

表3を見ると、処理完了のイベントを契機として生成されるメッセージハンドラは「Created」「Ready」「Stop」「Deleted」の4つです。この4つはそれぞれ"○○中"の処理が完了したとき、次のように仮想サーバの状態を変更する役割があります。
Creating → "作成中" → Created → "停止"
Starting → "起動中" → Ready → "起動"
Stopping → "停止中" → Stop → "停止"
Deleting → "削除中" → Deleted → "削除済"
よって、「Creating」「Starting」「Stoping」および「Deleteing」の4つについては、処理の完了後、仮想サーバの状態変更イベントを発生させるために、処理完了のメッセージを送信しなければなりません。表2の番号で答えるので「②，④，⑥」の組合せが適切です。

∴②，④，⑥

このような仕様になっているのは、「同一のサーバIDに対するAPIを複数のスレッドから同時に呼び出すと，APIがエラーになることがある」からです。処理完了メッセージにAPIが返すサーバIDを含めることで、同一スレッド内で完了処理を行えるようにしています。

→
解説を見終わった後だと何で間違えたんだろうって感じの問題だ。
頭の中だけでは無く、整理するためにも色々書きながらやったほうがいいと思った。
これは、勘違いしたまま応えてしまったからこうなった感じだな。
問題文を読んでいてもややこしく感じていたのは確か。
いつのタイミングで・・・。いや、小難しく考える必要ないな。
表2でいつするかしないかって書いてあるからその通りに書けばよかっただけだなこれ・・・。
うーん。



[3]
最初に現在の仕様における、起動中からサーバ削除までの手順を確認しておきます。
"サーバ停止"メッセージを生成する
メッセージハンドラ「Stopping」により"停止中"に遷移するとともに、StopServerが呼び出される
StopServerの処理が完了（仮想サーバが停止）し、"処理完了"メッセージを生成する
メッセージハンドラ「Stop」が選択され、"停止"に遷移する
"サーバ削除"メッセージを生成する
メッセージハンドラ「Deleting」により"削除中"に遷移するとともに、DeleteServerが呼び出される
DeleteServerの処理が完了（仮想サーバが削除）し、"処理完了"メッセージを生成する
メッセージハンドラ「Deleted」が選択され、"削除済"に遷移する
今回の仕様変更では、"起動"の状態から"サーバ停止"と"サーバ削除"を1回の命令のみで処理できるようにします。これを実現するために「サーバ停止とサーバ削除の二つのメッセージをメッセージキューに格納する」としていますが、サーバ削除はサーバの状態が"停止"のときのみ有効であることに注意しましょう。

ディスパッチャは、メッセージキューに格納されたメッセージを先頭から順次処理していくので、単に停止と削除のメッセージを順番に格納しただけでは、サーバの停止を待たずに"サーバ削除"メッセージが処理されることがあります。表3を見ると、サーバの状態が"停止中"のときに"サーバ削除"のメッセージを取得すると、ディスパッチャは「Err」を生成することが確認できます。このとき、サーバの削除に失敗し、意図した結果を得られません。

設問では、「仮想サーバの状態と送信されるメッセージについて言及し」という条件があるので、
仮想サーバの状態が"停止"になる前に、サーバ削除のメッセージが送信されるから
仮想サーバの状態が"停止中"のときに、サーバ削除のメッセージが送信されるから
などの解答が適切となります。

∴仮想サーバの状態が，"停止"になる前にサーバ削除のメッセージが送信されるから

→
つまり、サーバー停止、サーバー削除をキューに入れるなら「サーバー停止、サーバー停止状態にしてもらう、サーバー削除」って間に停止状態に遷移させるメッセージハンドラを入れないと実現できなって事か。
まぁ、それが無理なんで、そこを指摘するのが答えってわけね。
整理出来てた状態だと、まぁって感じだけど、迷ってる最中にこれはきついんだよな。



[4]
"停止・削除中"状態の前後の状態をイベントで紐づけます。

ここでは問題文中の以下の記述が解答のヒントになっています。
仮想サーバの状態が"起動"のときにサーバ削除のメッセージを受け取ると、仮想サーバは"停止・削除中"の状態に遷移し…
StopServerが完了すると、自動的に"削除中"の状態に遷移し、DeleteServerのAPIが呼び出される
この記述をそのまま表現すると、
"起動"から"停止・削除中"に向けた矢印で、遷移条件が"サーバ削除"
"停止・削除中"から"削除中"に向けた矢印で、遷移条件が"処理完了"
上記の2つが必要です。

[pm08_12.gif/image-size:459×98](https://www.ap-siken.com/kakomon/25_haru/img/pm08_12.gif)

```
