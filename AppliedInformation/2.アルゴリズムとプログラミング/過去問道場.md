# 2章.アルゴリズムとプログラミング.過去問

## 要点

- ソート
- 木構造
- スタック
- リカーシブルとかリエントラントとか
- ポインタ

ここは過去問をやった上で要点をまとめるために使ったほうがいいだろう。  
応用情報のサイトのほうで問題管理はできているので、問題を丸写しにする意味がない。  
というか、やった気になるだけで、逆に害悪になりかねない。  

---

## リカーシブルとかリエントラントとか

- **リエントラント(Reentrant，再入可能)**  
プログラム内で使用する変数部分を各プロセスごとに割り当てることで、複数のプロセスで同時に使用できる特性。  
**再配置可能**なプログラムもある。  
→  
リアルタイムシステムにおいて，複数のタスクから並行して呼び出された場合に，  
同時に実行する必要がある共用ライブラリのプログラムに要求される性質ともいえる。  
- **リユーザブル(Reusable，再使用可能)**  
主記憶へのプログラムの展開を初回実行時のみ行い、それ以降はロードせずとも何度でも正しく使用できる特性。  
**再入可能でない**プログラムもある。  
→  
個人的にstatic的なイメージを持った。  
- **リカーシブ(Recursive，再帰可能)**  
プログラム中において自分自身を呼び出すことができる特性。  
**再入可能**  
- **リロケータブル(Relocation，再配置可能)**  
プログラムを主記憶上のどの位置においても正しく実行できる特性。  
**再使用可能**なプログラムもある。  

---

## ソート

- **シェルソート**  
ある間隔おきに取り出した要素から成る部分列をそれぞれ整列し，  
更に間隔を詰めて同様の操作を行い，間隔が1になるまでこれを繰り返す。  
- **クイックソート**  
中間的な基準値を決めて，それよりも大きな値を集めた区分と，  
小さな値を集めた区分に要素を振り分ける。次に，それぞれの区分の中で同様な処理を繰り返す。  
→  
分割統治  
- **バブルソート**  
隣り合う要素を比較して，大小の順が逆であれば，それらの要素を入れ替えるという操作を繰り返す。  
- **ヒープソート**  
未整列の部分を順序木にし，そこから最小値を取り出して整列済の部分に移す。  
この操作を繰り返して，未整列の部分を縮めていく。  
→  
ヒープは順序木を使う。(データ構造の利用)  
- **マージソート**  
→  
分割統治  
- **2分探索法**  
  ソート済み出使える。計算量は`O(log2N)`

---

## 木構造

- 根、枝、接点、葉  

- **完全2分木**  
「葉以外の節点はすべて二つの子をもち，根から葉までの深さがすべて等しい木」  
木の深さが「n」であれば葉の数は「2n」、葉の数が「n」であれば、  
葉以外の節点の数(根を含む)は「n－1」であるという特徴を持っています。  

- 各接点にキーを4つ持てると言われたら根(ルート)にも4つ持てる  
- 行きがけ順(先行順)深さ優先探索  
  帰りがけ順(後行順)深さ優先探索  
  通りがけ順(中間順)深さ優先探索  
  幅優先探索

---

## ポインタ

- 先頭から後ろへは行けるが、後ろから先頭を把握することはできない。  
- 先頭ポインタ、末尾ポインタと言われたら、先頭のアドレス、末尾のアドレスを持つ何かが線形リストとは別の場所にあるのを想像しろ。  
- もっとも時間がかかる処理は末尾のデータを削除する処理。  
  最後より1つ手前のデータに行きつくまで、リストの数分探索する必要があるから。  

- ポインタを用いた線形リストの特徴  
  ポインタによって指定されている要素の後ろに新たな要素を追加する計算量は，要素の個数や位置によらず一定。  
  単方向リストの場合は新たな要素の追加は以下の手順で行われます。  
  1. ポインタで指定された要素(以降、元要素)を取得する  
  2. 元要素のポインタを新要素のポインタに付け替える  
  3. 元要素のポインタが新要素を指し示すようにする  

---

## スタック領域、ヒープ領域

- **スタック領域**  
一般にコールスタック・制御スタックと呼ばれている。  
LIFO方式で構成されプログラムの実行中サブルーチンの情報を記憶しておくメモリ領域。  
サブルーチン終了後の戻りアドレスや局所変数などを保持する。  
→  
イメージとしてはきれいに積み上げられた山。順番があるので適当にとってこれない。  
- **ヒープ領域**  
2つのラベルを持つ双方向リストで構成されプログラム上から動的(任意)に確保できるメモリ領域。  
動的にメモリ取得・解放を繰り返すことによりメモリ上にどこからも参照されない領域(ガベージ)が発生する。  
ヒープ領域は、双方向リスト  
→  
イメージとしては適当に積み上げられた山。必要になったら適当にとってくる。  

---

## その他

Q:  
ノード1～5をもつグラフを隣接行列で表したもののうち，木となるものはどれか。ここで，隣接行列のi行j列目の成分は，ノードiとノードjを結ぶエッジがある場合は1，ない場合は0とする。  
平成29年秋期　問6  
8問目／選択範囲の問題数36問  

→

これは、自分と相手を考えてつなげて形にすればわかる。  

- 線形探索の計算量は `n + 1 / 2`  
- a:24 - b:12 = n:12 n:12の倍数なら衝突が発生する。a-bがnの倍数。  
- 最大公約数とは  
  ２つ以上の正の整数に共通な約数（公約数）のうち最大のもの  
  例:12 と 18 の公約数は，1,2,3,6 で， 6 が最大公約数  
- 最適適合(best-fit)アルゴリズム  
  求量以上の大きさをもつ空き領域のうちで最小のものを割り当てる  
  1. 未使用領域(空き領域)の大きさにより順序づけられたリスト構造  
  2. 未使用領域(空き領域)の大きさをキーとする2分探索木  

- **モンテカルロ法**  
  数値解析の分野において、確立を近似的に求めるために使われる手法。  
  乱数によるn回のシミュレーションを行い、ある事象がm回起これば、その事象の起こる確立はm/nで近似できる。  
  試行回数nが大きくなるほどより良い近似値を得ることができる。  
  円周率の近似値を求める方法で、正方形内に乱数を用いて多数の点を内、  
  内接円内にある点の数/点を打った数」を計算することで円の面積を近似値敵に求め、そこから円周率を導く。  

---

異なるn個のデータが昇順に整列された表がある。この表をm個のデータごとのブロックに分割し，各ブロックの最後尾のデータだけを線形探索することによって，目的のデータの存在するブロックを探し出す。次に，当該ブロック内を線形探索して目的のデータを探し出す。このときの平均比較回数を表す式はどれか。ここで，mは十分大きく，nはmの倍数とし，目的のデータは必ず表の中に存在するものとする。
平成30年春期　問6
7問目／選択範囲の問題数36問

→

```math
m / 2 + n / 2m
```

線形探索法 平均比較回数 (N＋1)／2回  

最初は、n個のデータをm個ごとのブロックに分割した最後尾のデータのみを探索します。表のデータは昇順に整列されているので、各ブロック最後尾の並びも昇順になっているはずです。この最後尾データの並びに対して「目的のデータ≦各ブロックの最後尾データ」を順次チェックし、目的のデータが存在するブロックを探します。
この1回目の探索では、データを1つずつチェックしていくので線形探索の考え方を準用できます。探索するデータ数は n／m個 なので、目的のデータが存在するブロックが決定するまでの平均比較回数は、

　(n／m＋1)／2 [回]

2回目は、1回目の探索によって見つけたブロック内を線形探索します。探索するデータ数は m個 なので、目的のデータを見つけるまでの平均比較回数は、

　(m＋1)／2 [回]

2つの比較回数の合計は、

　(n／m＋1)／2 + (m＋1)／2 [回]

となります。ここで、mは十分に大きいという条件が与えられていますが、n／mが十分に大きいとは限りませんので定数項の+1は無視できません。よって、以下のように式を変形します。

　 (n／m＋1)／2 + (m＋1)／2
＝{(n／m＋1) + (m＋1)}／2
＝(n／m + m + 2)／2
＝n／2m + m／2 + 2／2
＝n／2m + m／2 + 1

"n／2m"は、nがmより十分大きい場合に十分大きくなり無視できない、"+1"はm／2が十分大きいので無視できると考えると、定数項の＋1を除いて n／2m＋m／2。つまり、1回目と2回目の平均比較回数を合わせるとになります。

※補足
上記の解説ではmが十分に大きいという理由で＋1を除外していますが、線形探索の特性上、目的のデータが必ず存在するならば、最後の1つ前（n－1番目）の要素までの比較で目的のデータが見つからなかった場合、最後の要素が目的のデータであることが確定します。このため最小比較回数を 1回、最大比較回数を n－1回、平均比較回数を n／2回 として考えることもできるでしょう。この考え方だと1回目の平均比較回数が n／2m回、2回目の平均比較回数が m／2回となり、正解の式と一致します。

---
