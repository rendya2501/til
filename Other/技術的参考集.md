# 技術的参考集

こういう記事をまとめる領域も作りたい。  
という事で作った。  

[ソフトウェアエンジニアと技術力](https://speakerdeck.com/soudai/developer-lifework)  

[レベル高いエンジニアが働く土壌ができていない状態で、お金積んでレベル高いエンジニアを雇ったらどうなるの？](https://twitter.com/shin_semiya/status/1473231873866608640)  
→  
辞める。  
自社の欠点がどこかを高い解像度から芯を句った指摘をされる。  

<https://twitter.com/ito_yusaku/status/1488421143426248708>
>優秀なエンジニアなら、知らんことは正直に「知らないです」って答えるよ。  

[GitHubの機能をフルに使って職務経歴書の継続的インテグレーションを実現する](https://zenn.dev/ryo_kawamata/articles/resume-on-github)  

[「Visual Studio」の中の人が作ったプログラマー向け十徳ナイフ「DevToys」](https://forest.watch.impress.co.jp/docs/news/1382919.html)  
<https://twitter.com/_inductor_/status/1485571312383049731?t=HneO12g8gQeElaHUCh2Wkg&s=09>  

---

## 資格系

[IT資格試験『合格のコツ』と『取組みポイント』　～40超の資格取得経験から～](https://qiita.com/ksj555/items/6ff5598c1429c0bc190a)  

[海外で働くのにも役立つ？ 資格「情報処理技術者」のメリット3つ](https://article.yahoo.co.jp/detail/d76b9877ba6933d06779ba8ae158d93c201b8579)  

---

## 平均的プログラマ以前向けのスキルの指標

[平均的プログラマ以前向けのスキルの指標](https://satob.hatenablog.com/entry/2018/10/26/012245)  

レベル1：  
プログラムを書こうとするが、「コードは決まった文法で書かないと受理すらされない」ということを理解できず、プログラム言語の文法に沿わないコードを書き続ける。

レベル2：  
文法に沿ってコードを書こうとはするが、自分の知っている他の文法と食い違いがあるために、そのプログラムの文法を受け入れられない。  「イコール記号は代入を意味する」ということが理解できないケースなど。  

レベル3：  
ターゲットとしている言語の文法を受け入れることができ、その文法に沿ってコードを書こうとはするが、ループが理解できない。  
if文は理解できるため、リストの代わりに「userName1」「userName2」……のように大量の変数を並べて処理を書いたりする。  

レベル4：  
ターゲットとしている言語の文法に従ってコードを書くことができ、ループの概念も理解しているが、コンパイルを通せない。  
エラーメッセージにはコンパイラがエラーを検知した箇所が含まれているということを理解できない。  
コンパイルエラーが発生したら、「プログラムを読み返して、怪しいと思った（多くの場合は見当違いな）場所を修正しては再コンパイル」をエラーが出なくなるまで繰り返す。  

レベル5：  
ターゲットとしている言語のコードを書くことができ、コンパイルを通すことができる。  
コンパイルエラーは解決できるが、実行時エラーを解決できない。コンパイルが通ったからプログラムは完成だと報告を上げてくる。  

レベル6：  
実行時エラーが発生しても、めげずに立ち向かえる。  
エラーの原因を体系的に調査することはできないため、「プログラムを読み返して、怪しいと思った場所を修正しては再実行」をエラーが出なくなるまで繰り返す。  
結果として、プログラムの挙動が当初の想定から意図せず変わっていたりする。  

レベル7：  
実行時エラーログの存在は知っており、業務プログラムが出力した日本語のエラーメッセージは読める。  
一方で、スタックトレースや、英語のエラーメッセージは読めない。  
そのため、フレームワークやライブラリの内部でエラーが発生すると立ち往生してしまう。  

レベル7.5：  
実行時エラーが発生した際に、スタックトレースをもとにエラーの原因箇所を調査できる。  
ただし、エラーメッセージ通りの修正しか行えない。  
たとえば、NullPointerExceptionが発生していたら、発生箇所の直前にnullチェックを入れるくらいしかできず、根本的な原因までさかのぼった修正（メソッドの戻り値がnullにならないよう引数を確認する、など）は行えない。  

レベル8：  
実行時エラーが発生した際に、スタックトレースをもとにエラーの原因箇所を調査できる。  
スタックトレースや英語のエラーメッセージを読んで意味が理解できる。  
一方で、スタックトレースが出力されなかったり、スタックトレースが直接原因箇所を示さなかったりするエラーは解決できない。  

レベル9：  
実行時エラーが発生した際に、体系的に原因を調査できる。  
スタックトレースがなくても、printfデバッグやデバッガの機能を頼りにエラーの発生箇所を特定できる。  
エラーの原因を調査し、正しいかどうかは別としても簡単な修正が行える。  

レベル10：  
ターゲットとしている言語のプログラムを読み書きでき、デバッグも行える。  
ただし、コードを書く際には擬似コードなどで詳細に書かれた内容をもとにする必要があり、与えられた仕様を元に一からコードを書くことはできない。  

レベル11：  
ターゲットとしている言語のプログラムを読み書きできる。  
与えられた仕様を元に一から自分でコードを書こうとするが、基本的にはググって見つかったサンプルコードをコピペして、変数名などを調整することで仕様を満たそうとする。  
作成したコードの中に、与えられた仕様と関係ない処理が混ざっていても、何のためにその処理があるのか理解しておらず、削除するのも怖いので、そのまま放っておく。  

レベル12：  
ターゲットとしている言語のプログラムを読み書きできる。  
処理の流れが単純なプログラムなら、処理内容を把握できるし、自分で一から処理内容を考えることもできる。  
一方で、メソッド呼び出しのネストが深いプログラムでは、処理内容の把握は難しい。  
ソースコード上の記述の順序とプログラム実行時の動きの順序を区別していない。  

レベル13：  
ターゲットとしている言語のプログラムを読み書きできる。  
処理の起点がひとつだけであればプログラムの処理内容を把握できるが、コールバック処理・イベント処理・非同期呼び出しなどがある場合は把握は難しい。  

レベル14：  
ターゲットとしている言語のプログラムを読み書きできる。  
与えられた仕様を元に、コールバック処理・イベント処理・非同期呼び出しなどを  使ってコードを書くことができる（利用法が適切とは限らない）。  
フレームワークのホットスポットにビジネスロジックを実装することはできるが、フレームワークなしでプログラムを書き始めることはできない。  

レベル15：  
ターゲットとしている言語のプログラムを読み書きできる。  
与えられた仕様を満たすコードを自分で考えて書くことができるが、行数・性能の  両面とも効率的なコードを書くことは難しい。  
テーブルルックアップで済む処理をif文の繰り返しやswitch文で実装したり、ハッシュテーブルを使うべき処理でリストを使ったりする。  

レベル16：  
ターゲットとしている言語のプログラムを読み書きできる。  
与えられた仕様を元に、コールバック処理・イベント処理・非同期呼び出しや、扱うデータに合った適切なデータ構造を、必要に応じて利用してコードを書くことができる。  
雛形コードがない場合でも、どのような単位でモジュールを構成すべきかをアプリケーションアーキテクチャをもとに検討して、与えられた仕様を満たすプログラムをスクラッチから開発できる。  

---

## おもしろ

[[Nginx]どうしてもンギックスと呼びたい](https://qiita.com/yonhure/items/51f2e275f6dc9f550c93)  

[staticおじさんの逆襲](https://qiita.com/minebreaker/items/45ffaaa5e8729e16cfb4)  
