# 後でまとめたいやつら


## mariaDBで0埋めして文字列結合するサンプル

意外と調べるのに苦労したのでまとめる。  
GORAPriceに20とか30レコードもあるようなプランがあるか調べたかったので、  
IDを作る要領で3つのキーを0埋めして文字列結合して、GroupByしてCOUNT取ってHAVINGで20以上のIDを表示ってやつ。  

左0埋め→LPAD  
文字列結合→CONCAT  
数値→文字列変換→CAST(数値 AS CHAR)  
数値文字列変換に関してはLPADしてCONCATしたらそのまま行けたので別に必要ないのかも。  

``` SQL
SELECT
    CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode, 6, '0'),LPAD(OpenPlanCode, 6, '0')),
    COUNT(CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode, 6, '0'),LPAD(OpenPlanCode, 6, '0')))
FROM
    TmOpenPlanGORAPrice
GROUP BY
    CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode , 6, '0'),LPAD(OpenPlanCode, 6, '0'))
HAVING
    COUNT(CONCAT(LPAD(GolfCode, 4, '0'),LPAD(PlanCode, 6, '0'),LPAD(OpenPlanCode, 6, '0'))) > 30
```


## JavaScriptもしくはTypeScriptにstring.IsNullOrEmptyに相当する関数は存在するか？

結論から言うとない。  
けど、言語使用上、必要ないみたい。  
そんなものを使わなくても !stringで全部わかるんだとか。  

<https://codereview.stackexchange.com/questions/5572/string-isnullorempty-in-javascript>  


## nginx

nginx再起動コマンド : sudo nginx -s reload
→
通常、Webサーバーの再起動を行った場合、瞬断が発生するが、-sオプションをつけることでそれがなくなるらしい。
-sオプションを指定すると、nginxのworkerプロセスが少しずつ新しいプロセスに置き換わっていくだとかなんだとか。
[[nginx]設定の反映](https://qiita.com/WisteriaWave/items/fa2e7f4442aee497fe46)


伊藤の開発ポートの設定ファイル
/etc/nginx/conf.d/2061.conf : bugfix
/etc/nginx/conf.d/2062.conf : hotfix

fastcgi_intercept_errors on;
をlocation ~ \.php$ {}の中に記述すると300以上のエラーがクライアントに伝わらなくなるので、正常にエラー表示ができなくなる。
2062ファイルにはこれが設定されていたので、hotfixでは意図的に500エラーを発生させても、bugfixのようなエラー表示にならなくて困っていた。
原因はサーバーの設定であって、Laravelの機能ではなかった。
[cakephp3 + CentOS8 + nginx + php-fpmでエラー表示がされないとき](https://blog.supersonico.info/archives/4277/)


[nginx 起動ポートの変更](https://qiita.com/Watercat3/items/38b2bac5fa70b232bee3)


## APIのメッセージを表示する方法(Response型のメッセージを取得する方法)

APIからのメッセージは_bodyプロパティの中にあるみたいが、素直にアクセスしようとすると存在しないというエラーになる。
実行したときは存在するけど、コーディングの段階では存在しないみたいなパターン。
これがJavascriptの仕様なのかTypescriptの仕様なのかはまた別でまとめる。
取り出すときはres.json()でなぜか取り出せる。
これも後でまとめる。

``` TS
    public maintenance(param: any): Promise<Response> {
        return this.apiService.put('system/web-cooperation/plan-cooperation/maintenance/', JSON.stringify(param));
    }
    
    this.goraMaintenanceService
        .maintenance(param)
        .then(
            res => {
                if (res.json() !== null && res.json() !== '') {
                    this.confirmComponent.dialogOk(res.json(), '確認', null)
                }
                this.notify.success('メンテナンスしました。');
                // 成功したら一覧を更新する
                this.getPlanList();
            },
            error => this.notify.error('失敗しました。\n : ' + error.json());
        )
        .then(() => this.isLoading = false);
```


どうでもいいけどこの人すごい。
1990年生まれ。京大卒。

RESTとGraphQLについて
<https://www.utakata.work/entry/2019/12/02/000000>


## DDLについて

[わかりそうデータ定義言語 (DDL)](https://wa3.i-3-i.info/word15639.html)


## NULLのLIKE検索

LIKE検索には引っかからない。

## NULLのORDERBY

[NULLと戯れる: ORDER BYとNULL](https://qiita.com/SVC34/items/c23341c79325a0a95979)  
どうにも、NULLを最小値とするか最大値とするかは、RDBMS毎に違ったり、設定で変更出来たりするみたい。  
Oracleは最大値扱いだが、SQLServerは最小値扱い見たい。  
まぁ、どちらにせよ、先頭か末尾であることに違いはないということですね。  

## COUNT(*)の意味とNULLのCOUNT

[COUNT(*)　が何を意味しているのかわからない](https://ja.stackoverflow.com/questions/42915/count-%E3%81%8C%E4%BD%95%E3%82%92%E6%84%8F%E5%91%B3%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84)  
COUNT(*)は行数を数えてくれる。  

``` txt
OracleではCOUNT(*)とCOUNT(age)の結果は異なります。
ageにnullが入っているとCOUNT(age)では件数にカウントされません。
グループ化していても同様で、ageがnullのグループのみ0件となります。
COUNT(*)ではageにnullが入っていてもレコードの件数をカウントします。

COUNT(*)ではレコードの内容を取得するため、COUNT('X')やSUM(1)を使った方が高速化できると教わったことがあります。(10年ほど前に聞いたノウハウなので現在も適用されるのかは不明ですが…)
```

なるほど。COUNTはNULLはカウントしないのね。  
動作的にCOUNT(name)見たいにフィールド名を指定したほうが高速化できるっぽいけど、単純にレコード数を取得したいならCOUNT(*)でいいのか。  

## NULLをキャスト

(NULL AS CHAR)→NULLのまま
NULL -1 = NULL

## Substring

SUBSTRING ( expression ,start , length )  
SUBSTRING (抜き出す文字列, 開始地点, 切り取り文字数)  

対象の文字列
切り取る対象の文字列を指定します。  

開始位置
切り取りの開始位置を指定します。勘違いしやすいですが、「1」スタートなので、「0」を指定すると何も取得できません。なお、マイナスにしても何も取得できません。  

取得する文字数
expression で返す文字数を正の整数または bigint 式で指定します。 length が負の場合はエラーが生成され、ステートメントは終了します。 start と length の合計が expression の文字数を上回る場合は、start の先頭から値式全体が返されます。
取得する文字数を指定します。対象の文字列より大きい数を指定しても、エラーにはなりません。  

``` SQL
select
-- 右1文字を削除する方法
substring([ReservationNo], 1, len(ReservationNo)-1),
-- 右1文字だけを抜き出す方法
substring([ReservationNo], len(ReservationNo), len(ReservationNo)),
-- 先頭1文字だけを抜き出す方法
substring([ReservationNo], 1, 1),
-- これでも先頭を取れる
substring([ReservationNo], 0, 1),
-- 全部空白になる
substring([ReservationNo], 0, 0),
-- 基本的に、lengthに0を指定すると空白になる。
substring([ReservationNo], 2, 0),
-- 超過しても全文表示されるだけ
substring([ReservationNo], 1, 1000),
-- 何も表示されない。
substring([ReservationNo], -100, 100),
-- 全部NULLになる
-- len(null) = null . null - 1 = null なのでnull
substring([ReservationNo], len(ReservationNo), NULL),
-- エラーになる
-- 空白の場合にlen()の結果は0になる。この状態で-1するとエラーになる。
-- substring([ReservationNo], 1, -1),
*
from TRe_Reservation
```
