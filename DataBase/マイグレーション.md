# マイグレーション

---

## 概要

[DBのバージョン管理で苦労しないために](https://blog.frevo-works.co.jp/entry/2019/01/23/125756)  
[.NET Core で DBマイグレーションを試したら色々ハマった話](https://blog.ecbeing.tech/entry/2019/06/12/125411)  
[データベーススキーマ変更の失敗しにくい管理方法](https://qiita.com/suin/items/fd996de8c5d58d95047d)  
[Entity Frameworkのベストプラクティス-EFCoreをデータアクセスとして選択する必要がありますか？](https://www.youtube.com/watch?v=qkJ9keBmQWo)  

---

SQL Server データベース プロジェクト
名前的にそれっぽいものかと思いましたが構造を管理するものとは少し違いました。
.NetFrameworkに依存していて、直接Linuxで動かすこともできないのであまり詳しくは調べていません。

Entity Framework 6（EF6）
.NetCore対応の旧EntityFramework互換品。
機能的にはまさにこれといえるものではあるが、公式が「現在は積極的に開発されていません。」と明記している。
.NetCore対応と公式に書いていたが、GUIは非対応だったのでEF6を使う意味は無し。

Entity Framework Core（EF Core）
旧EntityFrameworkのマルチプラットフォーム対応後継品。
マルチプラットフォーム対応の為にGUIを捨て、VisualStudioから出来ていたことがかなり削除された。
MSの本命はこちららしく、積極的に開発が続いている。
GUIを補完するためにVisualStudio拡張の「Entity Framework Visual Editor」で旧EntityFrameworkに近い使い勝手になる。

---

どのようにクエリが作られるのか
Migrationの差分を順番に実行していく。

データの注入を組み込めるか
Migrationファイルを編集することで各クエリや生クエリを実行できる関数を組み込める。

Datを１つのダイアグラムで管理すると表示が重すぎるので分割して管理可能か。
分割は可能だがそれでもダイアグラムを開くまでにとても時間がかかる。
ダイアグラムは捨て、DBFirstのみ対応として基準となるサーバからマイグレーションを作成することとしたい。

---

基準となるDBを用意する。（現行だとRound3Dat_20210205が該当？）

コマンドでDBからDBContextとEntityを作成。
Scaffold-DbContext  'Data Source=SQLSV2016;Initial Catalog=Round3Dat_20210205;User ID=sa;Password=Fx67kAP' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Model -ContextDir Context -Context DatContext –DataAnnotations –UseDatabaseNames –Force

コマンドでDBContextからMigrationを作成。
Add-Migration -Name DatInit -OutputDir DBMigration -Context DatContext

基準となるDBの構造を変更する。

コマンドでDBから構造変更をDBContextとEntityに反映する。

コマンドでDBContextからMigrationを作成。

---

Microsoft.EntityFrameworkCore.Tools(PMCツール)
マイグレーションを実行するEXEをDBごとに出力する。（EF Core 6.0から）
すべてのマイグレーションを実行するクエリを発行する
指定したマイグレーション範囲のクエリを発行する。
マイグレーションを実行する。

dotnet-ef（.NET Core CLIツール）
Microsoft.EntityFrameworkCore.Toolsと同等のことが可能。

ASP.Net Core
サービス（IISならアプリケーションプール）実行ごとにappsettings.jsonを参照してマイグレーションを実行することが出来る。  
失敗してもtry-catchでメッセージを取得でき、掌握すれば続行もできる。  

コンソールアプリ
自作実行ファイルでマイグレーションを実行することが出来る。失敗してもtry-catchでメッセージを取得でき、掌握すれば続行もできる。ただし、接続先を外部から注入するのは面倒かもしれない。
