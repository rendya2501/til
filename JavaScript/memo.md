# js色々

## JSON(JavaScript Object Nation)

基本はキーとバリューの組み合わせ。  
`{}`で囲う。
配列ならインデックスでアクセスし、オブジェクトならキーを指定してアクセスできる。
オブジェクトの中に配列を入れることもできるし、配列の要素をオブジェクトにすることもできる。

逆にわからないのは、配列の[]と内部の{}の場合だな。
これさえわかれば、申し分ないだろう。

``` json
{
    "key1": [],
    "key2": []
}

{
    "Array1" : [
        {"obj1" : 1},
        {"obj2" : 2}
    ]
}

{
  "name": "taro",
  "age": 23,
  "sex": "man",
  "hobby": {
    "test" : 12,
    "outdoor": {
      "land": ["running", "walking"],
      "sea": ["swimming", "fising"]
    },
    "indoor": ["movie", "game", "card"]
  }
}
```

``` JS
6. print(json_object["hobby"]["outdoor"]["land"][1])
7. print(json_object["hobby"]["indoor"])
8. print(json_object["hobby"]["test"])

1. waking
2. ['movie', 'game', 'card]
3. 12
```

内部{}はオブジェクト。javascriptのあれ。
なのでPerson['name'][0]とかでアクセスできる。

``` JS
var person = {
  name: ['Bob', 'Smith'],
  age: 32,
  gender: 'male',
};
```

---

## [...array] 表記の意味

<https://sbfl.net/blog/2018/07/04/javascript-array/>  
スプレッド演算子という見たい。  

```js
const array1 = [1, 2, 3];

// スプレッド演算子で配列内に配列を展開
const array2 = [4, ...array]; // [4, 1, 2, 3]

// スプレッド演算子で関数呼び出し内に配列を展開
const max = Math.max(...array1); // Math.max(1, 2, 3) と同じ
```

```ts
// 同組、同予約のListを重複無しで合体させ、検索を行う
this.sameGroupList.
  concat(this.sameReservationList).
  filter((x, i, self) => self.indexOf(x) === i).
  some(
    list => {
      // 名前からVisitListのパラメータを取得
      list.PlayerList.some(
        player => {
          if (player.Name === changedName
          || player.Kana === changedName) {
              changedPlayer = player;
              return true;
          }
        }
      )
      if (changedPlayer) {
          return true;
      }
    }
  );
```

---

## 配列をマージして重複を削除する

``` JS
const member1 = ["2020-08-01", "2020-08-02", "2020-08-03", "2020-08-04"]
const member2 = ["2020-08-03", "2020-08-04", "2020-08-05", "2020-08-06"]
const result = [...member1,...member2].filter((x, i, self) => self.indexOf(x) === i);
console.log(result);

// [
//     '2020-08-01',
//     '2020-08-02',
//     '2020-08-03',
//     '2020-08-04',
//     '2020-08-05',
//     '2020-08-06'
// ]
```

---

## JavaScriptもしくはTypeScriptにstring.IsNullOrEmptyに相当する関数は存在するか？

結論から言うとない。  
けど、言語使用上、必要ないみたい。  
そんなものを使わなくても !stringで全部わかるんだとか。  

[jquery - JavaScriptのstring.isnullorempty（）のような関数はありますか](https://try2explore.com/questions/jp/10503360)  
Javascriptでは、null, undefined, 空文字, 0, NaN、およびfalseすべて「偽」であり、条件付きで失敗します。  

[String.IsNullOrEmpty in JavaScript](https://codereview.stackexchange.com/questions/5572/string-isnullorempty-in-javascript)  
[javascriptでの空文字判定](https://teratail.com/questions/49848)  

```js
var a;

a = '';
if (!a) { /* ここが実行される */ }

a = null;
if (!a) { /* ここが実行される */ }

a = undefined;
if (!a) { /* ここが実行される */ }

a = 1;
if (!a) { /* ここは実行されない */ }
if (!a.length){ /* 数字に「length」というプロパティはないのでここが実行される */ }

a = "1";
if (!a) { /* ここは実行されない */ }
if (!a.length){ /* ここは実行されない */  }
if (a.length == 1) { /* ここが実行される */ }
```

---

## 配列をカンマ区切りの文字列に変換する方法

地味によく使う機能だから覚えておきたい。  

```js
let badPlansName = this.gdoData.GDOGotPlanMasterInfoList
    .map(m => m.PlanMasterName)
    .join(',');
```

---

## 時間の比較方法

これまた色々文献があるので、とりあえず、手っ取り早い奴だけまとめる。

``` js
// ①日付で比較したい場合、setHoursで時間を0にしてミリ秒で比較する
DateInstance.setHours(0,0,0,0) === DateInstance.setHours(0,0,0,0)

// ②getTimeで比較する方法
// ミリ秒単位で比較するので、厳密に同じであることを比較したい場合に用いる
DateTime1.getTime() == DateTime2.getTime()

```

---

## JavaScriptってなんでJavaってつくの？

コラムです。  

最初はLiveScriptって名前だったけど、この当時(1995年)はJavaが注目されており、その人気にあやかるためにJavaScriptに改名したんだとか？  
それか開発元のネットスケープ社とJavaの開発元のサン・マイクロシステムズが提携していたからJavaScriptになったとか？  
まぁ、諸説は諸々あるみたいだ。  

[JavaScriptって、なんで名前に「Java」がつくのだろうか？](https://www.javalife.jp/2018/01/02/post-250/)  
[JavaScriptはJavaとは全く違うのに、こんな似ている名前になったのはなぜですか？](https://jp.quora.com/JavaScript-ha-Java-to-ha-mattaku-chigau-no-ni-konna-ji-te-iru-namae-ni-na-tsu-ta-no-ha-naze-desu-ka)  

---




■勉強

・勉強 : クロージャーについて、即時関数について

この本、JSの言語仕様についての本だから、キーワードだけ検索かけて、調べたらこの本必要ないかも？
というのも、クロージャーを調べていて思ったが、本を読むよりも、ネットで調べたほうがわかりやすいと思ったからだ。
ゴールデンウィーク中の勉強はjsだけにとどまったな。

●クロージャーの章を終わらせる
むずいとりあえず読み進めるだけ読み進めたけどこれだけだと意味がないというか JavaScript をじゃなくてタイプスクリプトでコーディングしているからこの本に書いてあることは実際に使うことはないだろう現状ではネイティブで JavaScript を使う人にとってはいいかもしれないがタイプスクリプトを使っている身としてはあくまで使用するためだけの教養でしかないからなクロージャーから発展して関数の振る舞いをオーバーライドするっていうところここから一気にわからなかった即時関数は毎年は分かってるけどそれを実際に運用しようとするとここに書かれてある行動をいちいち追わないとどうなってるのか自分でも想像ができなくなってきた何だろう何が分かんないんだろう何かも平気でプロトタイプに使ってるからそこで頭ん中で動作が思いつかなくなるのかもしれないこっから先はとにかく気になった動作を一つ一つ確認していくことして歯科書いている意味を理解する術はないだろう何を MOTO 2この情報を使いたいのかその想定ができてないからちんぷんかんぷん実際にこの状況に遭遇してその解決策を調べる意味合いでこの章読んでいるんだったらもっと違うんだろうけど今の俺にはふーんそうなんだ程度にしかならないから全然頭に入ってこない実際に調べたいという欲求があるが今日はもう疲れたココアサイド具体的に明日調べることになるだろう

・勉強 : クロージャーについて
●クロージャー(閉包)
動作全般で順を追ってこれがクロージャーだ、って説明をしないと説明できない。
関数情報が破棄された後でも、関数実行に必要な情報を内部に保持する保護膜のような存在がクロージャーって言ってもわけわかめ。
だけど言葉で説明するにはそういうことになる。


クロージャとは？
通常、関数を書く時には下記のように記述しますね。
[通常の関数]
```
1. function timeDown() {
2. var time = 10;
3.  
4. time -= 1;
5. console.log(time);
6. }
7.  
8. timeDown(); // 「9」
9. timeDown(); // 「9」のまま
10. timeDown(); // 「9」のまま
```
[実行結果]
```
1. 9
2. 9
3. 9
```
この関数では、timeDown()がなんど呼ばれても、タイマーの値が入った変数(time)は9のままです。
呼び出される都度、変数timeは10で初期化されたあとに、-1されるため、得られる結果は変わらず9のままになります。
では、クロージャを使った例を見てみましょう。
[クロージャ]
```
1. var createTimer = function () {
2. var time = 10;
3.  
4. return function timeDown() {
5. time -= 1;
6. console.log(time);
7. };
8. };
9.  
10. //グローバル変数にセットされたことで、クロージャになる
11. var timer = createTimer();
12. timer(); // 「9」
13. timer(); // 「8」
14. timer(); // 「7」
```
[実行結果]
```
1. 9
2. 8
3. 7
```
クロージャの例の場合、実行結果として9,8,7とtimer()が呼ばれるたびに結果が変わっているのがわかりますね。
これは、関数（createTimer()）の中で定義された変数（time）と関数（timeDown()）の結果が、セットで保存されているためです。
この、セットで保存されるという現象そのものがクロージャです。


・勉強 : プロトタイプチェーンについて
●プロトタイプチェーン
すべてのオブジェクトが持っているprototypeに別のオブジェクトを追加することで、あるオブジェくトはprototypeに追加した別のオブジェクトの処理を使うことができる。これを連結していくことで、各オブジェクトが持っている処理をあらゆるオブジェクトで使うことができる。
そういう仕組み。
確か、つないだ分、あるオブジェクトの中に処理がなかったら別のオブジェクトを探索しに行くんでなかったっけ？
そういうjsの仕様だと聞いたことがある。

```
var User = function() {};
var MemberA = function() {};
var MemberB = function() {};

// 1
MemberA.prototype = new User();
// 2
MemberB.prototype = new MemberA();

1の地点でMemberAはUserオブジェクトが持つ処理を使うことができる。
しかし、UserはMemberAオブジェクトが持つ処理を使うことはできない。

2の地点でMemberBはUserとMemberAが持つ処理を使うことができる。
これをチェーンしていく。
jsにおける継承はプロトタイプチェーンを用いて実現する。
```


・勉強 : JSNInja,JSについて
●シンタックスシュガー

プログラミング言語における、やってくれる処理は同じだけど本来の書き方よりも簡単な書き方のこと
大胆に端折って一言で言えば「省略した書き方」が「シンタックスシュガー」です。


●function() {} , () => {}

https://qiita.com/mejileben/items/69e5facdb60781927929
この記事がすべてを解決してくれている。
thisも、シンタックスシュガーも、グローバルオブジェクトも

4_16のサンプルが動かない原因がこれらしい。
どうやら単純なシンタックスシュガーではない？
そんなバナナ。jsが嫌いになります。

MDNより
```
アロー関数式 は、function 式 と比べてより短い構文を持ち、this の値を語彙的に束縛します (ただし、自身の this や arguments, super, new.target は束縛しません)。
```
つまりアロー関数式で宣言された関数は、宣言された時点でのthisを束縛して、呼び出し元のオブジェクトにかかわらず不変のものにするということです。
アロー関数式は、ただ既存の文法をより短くしたものではなく、挙動が異なるものだったのです。

・this
一般的にJavaScriptでは、関数の中でthisを使うと、その呼び出し元のオブジェクトになります。
単純に自分自身というわけではない。じゃあthisなんて使わないでcallerとかにしろよ。


●prototype

JavaScriptでは、すべてのオブジェクトが「プロトタイプ」をベースにして作られています。
JavaScriptはプロトタイプベースのオブジェクト指向言語であり、関数的言語であり、弱い動的型付け言語である。
まぁベースってこと。
プロトタイプチェーンさえわかれば後は大丈夫な概念かな。




●JSNinja : 4章_関数を使いこなす_読了

.call .applyとはなんだったか。
好きなオブジェクトを明示的に呼び出しコンテクストとして指定するためのメソッド。
第2引数に渡したい引数を指定する。

オブジェクトに対してメソッドを登録する処理が確認できていない。
引数を判定してoldに追加する処理がなんとも。。。、
独特の動作過ぎてなぁ。
後、サンプル通りに動いてくれない。
thisの参照先がwindowになってしまう。
呼び出し元があれ、って言っていたから、なんか別の奴から呼び出せばいいのか？


●JSNinja
今のところはJSの言語仕様についてつらつらと書いている状態だな。
しかし、それは今後の章を進めるための前提知識なのだから、そうならざるを得ないか。
でないと、ただでさえ独特な言語なのだから、動作がわからなくなってしまう。

・jsonの文字列は""でないとだめ。''渡してエラーになった。

・関数やメソッドの名前は一般に「それが何をするか」を示す動詞で始まり、最初の文字は小文字にする。
それとは対照的にコンストラクタの名前は「構築されるオブジェクト」を示す名詞であることが多く大文字で始まる。

・無名関数の一般的な使い方について
呼び出し方3種類

・無名関数の例として再帰を用いた紹介



●
JavaScriptの関数が第一級のオブジェクトで有ることの説明。
Array.sort()の処理を書き換えたい場合をJavaと比較。
Javaはインターフェイスの定義から行わないといけない。(具象クラス、インラインの無名実装という方法もあるらしいが)
それに対し、JavaScriptは無名関数を宣言し、sortメソッドに直接渡すだけで可能である。
javascriptは関数型言語である。関数を自立したエンティティとして作ることができ、他の型のオブジェクトと同じく、関数を引数とすることもできるし、パラメーターとして受け取ることもできる。
これがファーストクラスの待遇である。Javaのような非関数型言語にはできないことである。


●JavaScriptNinja
・assertを使ったテストコードのサンプルを作成した。
・非同期のテストコードのサンプルを作成した。
→
assertをオーバーライドして、画面に表示するだけでしたが、余り馴染みのないコードではあったので、無駄ではなかったと思います。

・JavaScriptは関数をファーストクラス(第一級)のオブジェクトとして扱う。
そっか、javascriptは関数でクラスを定義するもんな。
だから、オーバーライドしているように見えて、それはクラスの中で関数を定義しているに過ぎないのか。
いや、違うなthis.○○の場合はオーバーライドじゃないのか？
でした。

あー、もっと勉強していたかった。


●JavaScriptNinja デバッグとテストについて
第一章はクロスブラウザで動作させるための基礎となる考え方とデバッグとテスト方法について紹介があった。
これだけでは大した知識の収穫にはならなかった。
クロスブラウザは今のところ、意識する必要がなく、デバッグは文献が古いので仕方がないのだろうが、Chromeのデバッグツールで事足りる。
唯一、テストについては載っているサンプルコードを実行して動作を確認したいなと思った。




●JavaScriptNinja
・windowってなんだ？
グローバル変数。スクリプトを実行しているウィンドウを表している。
タブってことかな？それともブラウザ的な意味？
→
多分タブ。window.open()で新しいタブを開くから。

・this
オブジェクト指向におけるthis
「メソッドが定義されたクラスのインスタンスを指し示すもの」
javascriptにおけるthis
「その関数が呼び出された方法によって定義されるもの」
「呼び出しコンテクストとしての役割を果たすオブジェクトへのリファレンスである」

関数型言語であるゆえんというか、それを強く感じた。
思い出してみれば、jsはクラスも関数として定義してnewしてそれっぽく使う言語だったな。


