# 最大/最小の値のレコードを取得する

`GROUP BY した結果の1件目を取得する`の亜種になるだろうか。  

Window関数を知ってからは、そんなのWindow関数を使えば一発じゃんって思う。  
愚直にサブクエリでMAXかMINで抽出して、その中でさらに条件を絞って、最終的に出力するみたいな感じになるみたい。  
またはEXITSのような相関副問い合わせやJEFT JOIN を組み合わせるやり方など、やり方はたくさんあるみたい。  

全面的にここの記事を採用しつつアレンジしている。  
[SQLで同一グループの中で最大/最小のレコードを取得する](https://qiita.com/inouet/items/4f1d7f299725597d8407)  

---

## 要件

``` sql
create table items (
    id int not null primary key,
    name varchar(100),
    price int,
    category varchar(100)
);

insert into items values(1, 'りんご', 190, 'くだもの');
insert into items values(2, 'みかん', 100, 'くだもの');
insert into items values(3, 'きゅうり', 80, '野菜');
insert into items values(4, '人参', 110, '野菜');
insert into items values(5, 'キャベツ', 110, '野菜');
insert into items values(6, '豚肉', 300, '肉');
insert into items values(7, '牛肉', 400, '肉');
```

こうやって表示させたい。

``` txt
id  name    price  category
1   りんご  190    くだもの
7   牛肉    400    肉    
4   人参    110    野菜  
```

---

## window関数案

一番最初に自分が思いついた案。  
categoryで区切って、priceをDescしてidは早いほうを採用。  
サブクエリからrk = 1のモノを取得すればいける。  

``` sql : window関数を使った例
SELECT
    *
FROM (
    SELECT
        *,
        ROW_NUMBER() OVER(PARTITION BY category ORDER BY price DESC,id) rk
    FROM
        [items]
) AS [A]
WHERE
    [A].[rk] = 1
```

---

## LEFT OUTER案

自分自身より金額が低いものをJoinする。  
若しくは同じ金額でidが大きいモノをJoinする。  
そうすると金額が高くてidが小さいレコードはNULLとなる。  
WHEREでNULLのレコードを取得すれば結果となる。  

``` sql : left join
SELECT s1.*,s2.*
FROM [items] s1
LEFT JOIN [items] s2 
ON s1.category = s2.category
AND (s1.price < s2.price OR (s1.price = s2.price AND s1.id > s2.id))
WHERE s2.id IS NULL
```

---

[SQLで同一グループの中で最大/最小のレコードを取得する](https://qiita.com/inouet/items/4f1d7f299725597d8407)  
[SQL ある列の値が最大もしくは最小の値のレコードを取得する](https://zukucode.com/2017/08/sql-row_number-technique.html)  
[特定のカラムのグループごとの最大値が格納されている行](https://dev.mysql.com/doc/refman/5.6/ja/example-maximum-column-group-row.html)  
