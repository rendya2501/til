# SQLメモ

---

## 検索条件にマッチするデータが存在しない場合にデフォルト値を返す

レコードが存在したらそのままINSERTして、レコードがなければデフォルト値をINSERTしたい。  

単純そうな課題だったが、30分くらい調べたのでまとめる。  

結果としてCOALESCEで実現できた。  
COALESCEはNULLの場合の置換だと思っていたが、レコードがなくても動いてくれる模様。  

sql 条件によってselectを変える
SQL 0件の場合
COALESCE　レコードなし
[検索条件にマッチするデータが存在しない場合にデフォルト値を返す](https://sebenkyo.com/2020/04/14/post-774/)
[NULLと戯れる: 集約関数とNULL](https://qiita.com/SVC34/items/dc1bc52c2d7b44a65459)
[レコードがない場合のselect結果](https://teratail.com/questions/57768)  

``` sql : データ用意
DROP TABLE IF EXISTS TestTable
CREATE TABLE TestTable (ID INT PRIMARY KEY,Hoge varchar(50))
INSERT INTO TestTable VALUES(1,'AAA'),(2,'DDD')
```

``` sql : 案1
SELECT COALESCE(
    (SELECT Hoge FROM TestTable WHERE ID = 1),
    'XXX'
)
-- 結果
--(列名なし)
--XXX
```

MAXは0件ならNULLを返す。  
COALESCEは結果がNULLなら指定した値に置き換えるので本来の動作に準拠したものになる。  
なのでこちらのほうがいいのかも？  

``` sql : 案2
SELECT COALESCE(
    (SELECT MAX(Hoge) FROM TestTable WHERE ID = 9),
    9999
)
```

存在しないIDの場合レコードはない

``` sql
SELECT Hoge FROM TestTable WHERE ID = 9
-- 結果
-- (列名なし)
```

CASE WHENを使って実現しようとしたが、駄目だったのでそれもまとめる。  

``` sql : 試行錯誤
SELECT 
    CASE WHEN EXISTS(SELECT Hoge FROM TestTable WHERE ID = 9)
        THEN Hoge
        ELSE 9999
    END
FROM TestTable
WHERE ID = 9

SELECT 
    CASE WHEN COUNT(*) = 0
        THEN Hoge
        ELSE 'XXX' 
    END AS 料金CD
FROM TestTable
WHERE ID = 9

SELECT
    CASE WHEN (CASE WHEN ID = 9 THEN 1 ELSE 0 END) = 0
        THEN Hoge
        ELSE 'XXX'
    END    
FROM TestTable
-- AAA
-- DDD
```

---

## ORDER BY で特定のレコードを先頭にする

sql order by 特定  

代表者テーブルとメンバーテーブルがあるとする。  
代表者を先頭にしたい。  

``` sql
drop table if exists MainTable;
create table MainTable(MainKey varchar(32) primary key,SubKey varchar(32));
insert into MainTable values('Key001','AAA');
insert into MainTable values('Key002','DDD');

drop table if exists SubTable;
create table SubTable(MainKey varchar(32),SubKey varchar(32),TestNumber varchar(5) CONSTRAINT [PK_SubTable] PRIMARY KEY (MainKey,SubKey));
insert into SubTable values('Key001','AAA','0001');
insert into SubTable values('Key001','BBB','0002');
insert into SubTable values('Key002','CCC','0003');
insert into SubTable values('Key002','DDD','0004');
insert into SubTable values('Key002','EEE','0005');
```

``` txt : 表示させたい結果
MainKey  SubKey TestNumber
Key001   AAA    0001 ←代表者
Key002   DDD    0004 ←代表者
Key001   AAA    0002
Key002   DDD    0003
Key002   DDD    0005
```

SQLServerではCASE WHEN句を使う。  
他のデータベースではORDER BYの中で`=`を使うことができる模様。  

``` sql
SELECT
    [MainTable].[MainKey],
    [MainTable].[SubKey],
    [SubTable].[TestNumber]
FROM 
    [MainTable]
    JOIN [SubTable]
    ON [MainTable].[MainKey] = [SubTable].[MainKey]
ORDER BY
    CASE
        WHEN [MainTable].[MainKey] = [SubTable].[MainKey] 
            AND [MainTable].[SubKey] = [SubTable].[SubKey] THEN 0
        ELSE 1 
    END,
    [MainTable].[MainKey]

-- MainKey  SubKey TestNumber
-- Key001   AAA    0001
-- Key002   DDD    0004
-- Key001   AAA    0002
-- Key002   DDD    0005
-- Key002   DDD    0003
```

[SQLServer Order By 並べ替え](https://hironimo.com/prog/sql/orderby/)  

---

## CONSTRAINT 句

`CONSTRAINT 制約の名前 制約`  

`CONSTRAINT [○○_PKC] PRIMARY KEY ([フィールド1],[フィールド2],・・・)`  

テーブルのインデックスフォルダの中を見ると`Customers_PKC(クラスター化)`という名称でインデックスが生成される。  
CONSTRAINT でインデックス名の指定をしない場合`PK_Customer_*****(クラスター化)`という名称でインデックスが生成される。  
`*****`の部分は16桁のランダムな16進数となる模様。  

制約を生成するのでFOREIGN KEY等も作成可能な模様。  

CONSTRAINT句で制約名を設定しなくても複合主キーは設定できるが、ランダムチックな制約名になってしまう。  
SQLServer2016の教科書でもできるなら任意の名前をつけたほうがよいとのこと。  

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    PRIMARY KEY(CustomerID,CustomerName)
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    CONSTRAINT [Customers_PKC] PRIMARY KEY(CustomerID,CustomerName)
);
```

外部キー制約も作れる。

``` sql
CONSTRAINT `制約の名前`
    FOREIGN KEY (`このテーブルの列名を外部キーに設定`)
    REFERENCES `データベース名`.`テーブル名` (`カラム名`)
    ON DELETE NO ACTION ←親テーブルの削除時何もしない
    ON UPDATE NO ACTION ←親テーブルの更新時何もしない
```

CONSTRAINT : 制限、強制  

[SQL文でのINDEX句、CONSTRAINT句について](https://toru-takagi.dev/article/3)  

---

## 制約名を変更する方法

`EXEC sp_rename N'Tamp_Table_PKC', N'Table_PKC', N'OBJECT';`  

■以下、昔の書き込み  

削除して追加する。  
制約名を更新する命令はない模様。  

``` sql : 主キー制約の変更
-- 制約削除
ALTER TABLE [テーブル名] DROP CONSTRAINT [削除する制約名]

-- 制約の追加
ALTER TABLE [テーブル名] ADD CONSTRAINT [追加する制約名]
PRIMARY KEY ([フィールド1],[フィールド2],...)
```

外部キー制約を確認するクエリ  

``` sql
select * from sys.key_constraints
```

[【SQL Server】外部キー制約の一覧を確認する](https://sqlserver.work/2021/01/06/%E3%80%90sys-foreign_keys-%E3%80%91%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC%E5%88%B6%E7%B4%84%E3%81%AE%E4%B8%80%E8%A6%A7%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B/)  

---

## PRIMARY KEY指定

主キーが1つだけの場合は`フィールド名 型 PRIMARY KEY`でもよいし、一番最後に`PRIMARY KEY (フィールド名)`のどちらでもよい。  
主キーが複数の場合は、CREATE TABLEの一番最後に`PRIMARY KEY (フィールド1,フィールド2,・・・)`の形でなければならない。  

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    PRIMARY KEY(CustomerID)
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20) PRIMARY KEY,
    CustomerName nvarchar(20),
    CustomerAdd nvarchar(50) NULL
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    CONSTRAINT [Customers_PKC] PRIMARY KEY(CustomerID)
);
```

---

## SELECT a.NULL FROM (SELECT NULL FROM テーブル名) a

>SELECT NULL FROM テーブル名;  
>はできるのに  
>SELECT a.NULL FROM (SELECT NULL FROM テーブル名) a;  
>はエラーになるんだね(´・ω・｀)  
>a.NULLを列名扱いに出来ないらしい  
><https://twitter.com/cc02041110/status/1605500362634715137>  

SQLServer2022での検証。  

とりあえずこういうデータがあるテーブルで実験  

``` sql
SELECT * FROM [SchemaVersions]

-- Id | Name
-- ---+---------------------------------------
-- 1  | 001_Create_Table_TeacherMaster.sql
-- 2  | 002_Create_Table_DesignationMaster.sql
-- 3  | 003_Fill_DesignationMaster.sql
```

NULLにしたらレコード分が全部NULLになる。  

``` sql
SELECT NULL FROM [SchemaVersions]

-- Id | Name
-- ---+---------------------------------------
-- 1  | NULL
-- 2  | NULL
-- 3  | NULL
```

Twitterの構文ではそもそもエラーとなり実行できない。

``` sql
-- NULL付近に不適切な構文があります。
-- 'SQ'の列1に列が指定されませんでした。
SELECT SQ.NULL FROM (SELECT NULL FROM [SchemaVersions]) AS [SQ]

-- NULL付近に不適切な構文があります。
SELECT SQ.NULL FROM (SELECT NULL AS TEST FROM [SchemaVersions]) AS [SQ]
```

列名を定義して、列名でアクセスすればもちろんいける。  

``` sql
SELECT SQ.TEST FROM (SELECT NULL AS TEST FROM [SchemaVersions]) AS [SQ]

-- Id | Name
-- ---+---------------------------------------
-- 1  | NULL
-- 2  | NULL
-- 3  | NULL
```

---

## 重複レコードを削除する方法

- Window関数を使った方法(rk where rk = 1)  
- GROUP BY HAVING  
- EXCEPTを使った方法(A EXCEPT B)  
- EXISTSを使った方法

window関数は重いので基本的に候補にはならない。  

重複がなければEXCEPT。  
重複があるならEXSISTSを使えばいいのではなかろうか。  

あれ？単純にEXCEPTでいいのでは？  
SELECT AFiled,BField FROM A
EXCEPT
SELECT DISTINCT AField,BField FROM B

---

``` sql
WITH TmpTable AS (
    SELECT 1 AS ID, 1 AS RowNum, 'and seventy nine' AS [Data]
    UNION
    SELECT 1, 2, 'five hundred'
    UNION
    SELECT 1, 3, 'two thousand'
)
select
    ID,
    [Data]
from
    (SELECT * FROM TmpTable ORDER BY RowNum DESC ) t1
group by
    t1.ID

-- メッセージ 1033、レベル 15、状態 1、行 12
-- TOP、OFFSET、または FOR XML が指定されていない場合、ビュー、インライン関数、派生テーブル、サブクエリ、および共通テーブル式では ORDER BY 句は無効です。
```

---

## DISTINCT vs EXISTS

>ところで、なぜこんなノウハウが生まれてきたかというと、以前の Oracle は、DISTINCT や GROUP BY が使用されると、一部のケースを除いて、結果セットをソートすることで重複行を取り除いていました。  
>ソート処理は負荷が高い処理なので、EXISTS句に置き換えることでソート処理がなくなり高速化する可能性が高いという理屈です。  
>ただ、最近の Oracle は DISTINCT や GROUP BY に対して、基本的にソートすることなく重複行を取り除くようになっています。  
>なので、無駄な結合を含む EXISTS 句を使用した文にするよりも、普通に DISTINCT の方が速いことが多いのではないかと思います。  
>ただし、etmagroさんが言われているように、いつも DISTINCT と EXISTS の文の結果が一緒になるわけではありません。  
>結果が一緒にならないケースでは、目的に応じて使い分ける必要があります。  

<!--  -->
>『DISTINCT』の代わりに『EXISTS』を用いるなんて初耳で、何だろうと思ってリンク先を見てみましたが、なんのことはない、  
>
>「複数テーブルから情報を取得する際、内部結合だと、結合時のテーブル件数比によっては、抽出結果がだぶってしまうことがある。それを防ぐために、  
>・DISTINCTで重複を除外する  
>・内部結合をやめてEXISTSを用いた相関サブクエリを使用する  
>この２つの方法があり、後者の方が処理速度が速い（ことが多い）」  
>
>というだけの話でした。  
>要は、EXISTSを用いるテクニックは、複数テーブルから情報を取得したい…という限定されたシチュエーションでのみ有効なもので、そこから離れて「重複を削除したい」という一般的な目的には使えません。  
>
>DISTINCT と同様の働きをするのは、GROUP BY です。  
>これについては、下記の質問を参照してください。  

``` sql
create table HOGEXX
(
    ID int,
    SGCD varchar(10),
    ANO varchar(10)
)
insert into HOGEXX values
    (1,'HOGEHOGE','a'),
    (2,'HOGEHOGE','a'),
    (3,'HOGEHOGE','b'),
    (4,'HOGEHOGE','c'),
    (5,'HOGEHOGE','d'),
    (6,'HOGEHOGE','d'),
    (7,'HOGEHOGE','d'),
    (8,'HOGEHOGE','d'),
    (9,'HOGEHOG3','x')

-- 57%
SELECT DISTINCT ANO
FROM HOGEXX
WHERE SGCD = 'HOGEHOGE';

-- 43%
SELECT ANO
FROM HOGEXX T1
WHERE EXISTS(
    SELECT *
    FROM HOGEXX T2
    WHERE T2.ID = T1.ID
    AND T2.ID = ( SELECT MIN( T3.ID ) FROM HOGEXX T3 WHERE T3.ANO = T1.ANO )
)
AND T1.SGCD = 'HOGEHOGE';
```

[『DISTINCT』の代わりに『EXISTS』を用いる方法について。 ... - Yahoo!知恵袋](https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q10140606955)  

---

## GROUP BY vs DISTINCT

>単に「重複データを除去したい」というだけなら、distinct も group by も結果は変わりません。
結果は同じでも、データベースの仕組み上、group by の方が処理が速い（distinctは内部でソートが発生する）場合が多いようですが、よほどの大容量データでもない限り、速度に大きな違いはなく、使いやすい方を使えばいいでしょう。  

<!--  -->
>Management Studio で全カラムを選択するクエリのクエリプランを確認すると、DISTINCT も GROUP BY も同じクエリプランを生成します。つまり、SQL Server ではどちらでも実行時間は同じです。
>クエリプランが読めれば根拠に基づいてパフォーマンスチューニングができるようになりますから、ぜひとも読み方を覚えることをお勧めします。
>
>単純にユニークな行を選択したいだけなら、DISTINCT を使うのが書き方が単純でいいのですが、サブクエリや結合を含んだクエリの場合、DISTINCTは潜在的な問題を包み隠してしまう場合もあり注意が必要です。
>本来なら重複した結果があるべきではない場合に、DISTINCT を使うと表面的には問題は解決しますが、例えば、サブクエリや結合の条件式が正しくなくて重複した結果が返っている可能性もあります。そのような場合、問題の本質は重複した結果ではなく、重複した結果を返すクエリであり、それによって生じるパフォーマンスのロスです。
>私はチームのプログラマが書いたSQLのレビューをすることが仕事の一部ですが、プログラマがDISTINCTを使った場合は、その必要性について完全に説明できなければレビューを通しません。そのぐらいDISTINCTの使用は要注意なのです。

[select文でグルーピングする場合、先頭にdistinctを記述する場合... - Yahoo!知恵袋](https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q12139645547)  

---

## LEFT JOIN と RIGHT JOIN の併用

実務でこういう構文があった。  

``` sql
SELECT
    *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    LEFT OUTER JOIN dbo.ホテル
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD
    ON  dbo.料金.FeeCD = dbo.予約.FeeCD
```

なぜこんな書き方をしたのか理解に苦しむが、分からないままにするのは嫌なので解析する。  

まずONの位置。  
すごく気持ち悪いけどOKらしい。  
なぜONをすっ飛ばしてJOINできるのか謎だが、紐解いてみれば以下のようになる模様。  
後で検証するが、結果も同じとなることが分かった。  

``` sql
-- これと
SELECT
    *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    LEFT OUTER JOIN dbo.ホテル
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD
    ON  dbo.料金.FeeCD = dbo.予約.FeeCD

-- これは同じ結果となる
SELECT
    *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    ON  dbo.料金.FeeCD = dbo.予約.FeeCD
    LEFT OUTER JOIN dbo.ホテル
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD
```

全部LEFT JOINに置き換えてやってみたけど、これは駄目らしい。  

``` sql
SELECT
    * 
FROM
    dbo.予約
    LEFT OUTER JOIN dbo.料金
    LEFT OUTER JOIN dbo.ホテル
    -- マルチパート識別子"dbo.予約.FeeCD"をバインドできませんでした。
    ON  dbo.予約.FeeCD = dbo.料金.FeeCD
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD
```

ONについてはこれでいいとして、次はRIGHTしてLEFTした時はつまりどういう結果になるのかを検証していく。  
まずはデータの用意。  
料金もホテルもない予約って何って感じだがテストなので勘弁。  

``` sql
CREATE TABLE 予約
(
    RevNo varchar(255) not null,
    FeeCD int,
    HotelCD int
)
INSERT INTO 予約
VALUES
    ('yyyymmdd0001',1000,10),
    ('yyyymmdd0002',2000,10),
    ('yyyymmdd0003',3000,20),
    ('yyyymmdd0004',3000,30),
    ('yyyymmdd0005',null,null),
    ('yyyymmdd0006',5000,null)


CREATE TABLE 料金
(
    FeeCD int,
    FeeName nvarchar(255)
)
INSERT INTO 料金
VALUES
    (1000,'Fee1'),
    (2000,'Fee2'),
    (3000,'Fee3'),
    (4000,'Fee4'),
    (5000,'Fee5')


CREATE TABLE ホテル
(
    HotelCD int,
    HotelName nvarchar(255)
)
INSERT INTO ホテル
VALUES
    (10,'Hotel1'),
    (20,'Hotel2')

```

>right joinだったら右が基準で左は付け足しです。  
>left joinだったら左が基準で右は付け足しです。  
>[SQLにはright joinとleft joinがありますよね。仕組みはわかるんですが、具体的にはどのような用途で使い分けるものなのでしょうか？ - Quora](https://jp.quora.com/SQL%E3%81%AB%E3%81%AFright-join%E3%81%A8left-join%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%82%88%E3%81%AD-%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%AF%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%93%E3%81%A7%E3%81%99%E3%81%8C-)  

つまり、料金が先に来ているが、あくまで予約が主体で、それに料金が紐づく、というわけか。  
でも、JOINの順序関係的に、SELECTした場合に先に来るのは料金。  

``` sql
SELECT *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    ON dbo.料金.FeeCD = dbo.予約.FeeCD

-- +---------+---------++--------------+-------+---------+
-- | FeeCD   | FeeName || RevNo        | FeeCD | HotelCD |
-- +---------+---------++--------------+-------+---------+
-- | 1000    | Fee1    || yyyymmdd0001 | 1000  | 10      |
-- | 2000    | Fee2    || yyyymmdd0002 | 2000  | 10      |
-- | 3000    | Fee3    || yyyymmdd0003 | 3000  | 20      |
-- | 3000    | Fee3    || yyyymmdd0004 | 3000  | 30      |
-- | NULL    | NULL    || yyyymmdd0005 | NULL  | NULL    |
-- | 5000    | Fee5    || yyyymmdd0005 | 5000  | NULL    |
-- +---------+---------++--------------+-------+---------+
```

で、料金と予約が結合した結果(左側)を主体にして右側にホテルをくっつけるイメージね。

``` sql
SELECT *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    ON dbo.料金.FeeCD = dbo.予約.FeeCD
    -- 追加
    LEFT OUTER JOIN dbo.ホテル
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD

-- +---------+---------++--------------+-------+---------++---------+-----------+
-- | FeeCD   | FeeName || RevNo        | FeeCD | HotelCD || HotelCD | HotelName |
-- +---------+---------++--------------+-------+---------++---------+-----------+
-- | 1000    | Fee1    || yyyymmdd0001 | 1000  | 10      || 10      | Hotel1    |
-- | 2000    | Fee2    || yyyymmdd0002 | 2000  | 10      || 10      | Hotel1    |
-- | 3000    | Fee3    || yyyymmdd0003 | 3000  | 20      || 20      | Hotel2    |
-- | 3000    | Fee3    || yyyymmdd0004 | 3000  | 30      || NULL    | NULL      |
-- | NULL    | NULL    || yyyymmdd0005 | NULL  | NULL    || NULL    | NULL      |
-- | 5000    | Fee5    || yyyymmdd0005 | 5000  | NULL    || NULL    | NULL      |
-- +---------+---------++--------------+-------+---------++---------+-----------+
```

全部LEFT JOINに置き換えた場合。

``` sql
SELECT 
    料金.*,予約.*,ホテル.* 
FROM 
    dbo.予約
    LEFT JOIN dbo.料金
    ON dbo.予約.FeeCD = dbo.料金.FeeCD
    LEFT JOIN dbo.ホテル
    ON dbo.予約.HotelCD = dbo.ホテル.HotelCD
```

LEFTとRIGHTを併用した時のメリットは`SELECT *`だけで「料金、予約、ホテル」の順に出力しつつ、全ての大本を予約とすることができる点だろうか。  
LEFT JOINの場合は、大本が絶対に一番左に来るので、`SELECT *`しただけだと「予約、料金、ホテル」の順になってしまう。  
なので、同じように出力したい場合は、`SELECT 料金.*,予約.*,ホテル.*` としないといけない点だろうか。  
だとして、分かりにくさのほうがやばいので、やる意味はほぼないけどね。  

最後に比較用としてコピペすれば動く、全部同じになる書き方を乗せる。  

``` sql
-- 元々の構文
SELECT
    *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    LEFT OUTER JOIN dbo.ホテル
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD
    ON  dbo.料金.FeeCD = dbo.予約.FeeCD

-- ONの位置を調整
SELECT
    *
FROM
    dbo.料金
    RIGHT OUTER JOIN dbo.予約
    ON  dbo.料金.FeeCD = dbo.予約.FeeCD
    LEFT OUTER JOIN dbo.ホテル
    ON  dbo.予約.HotelCD = dbo.ホテル.HotelCD

-- LEFT JOIN案
SELECT
    料金.*,予約.*,ホテル.* 
FROM 
    dbo.予約
    LEFT JOIN dbo.料金
    ON dbo.予約.FeeCD = dbo.料金.FeeCD
    LEFT JOIN dbo.ホテル
    ON dbo.予約.HotelCD = dbo.ホテル.HotelCD
```
