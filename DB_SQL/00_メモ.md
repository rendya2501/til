# SQLメモ

---

## 検索条件にマッチするデータが存在しない場合にデフォルト値を返す

レコードが存在したらそのままINSERTして、レコードがなければデフォルト値をINSERTしたい。  
単純そうな課題だったが、30分くらい調べたのでまとめる。  

結果としてCOALESCEで実現できた。  
COALESCEはNULLの場合の置換だと思っていたが、レコードがなくても動いてくれる模様。  

``` sql : データ用意
DROP TABLE IF EXISTS TestTable
CREATE TABLE TestTable (ID INT PRIMARY KEY,Hoge varchar(50))
INSERT INTO TestTable VALUES(1,'AAA'),(2,'DDD')
```

■案1

``` sql
SELECT COALESCE(
    (SELECT Hoge FROM TestTable WHERE ID = 1),
    'XXX'
)

--XXX
```

■案2

MAXは0件ならNULLを返す。  
COALESCEは結果がNULLなら指定した値に置き換えるので本来の動作に準拠したものになる。  
なのでこちらのほうがいいのかも？  

``` sql
SELECT COALESCE(
    (SELECT MAX(Hoge) FROM TestTable WHERE ID = 9),
    9999
)

-- 9999
```

存在しないIDの場合レコードはない

``` sql
SELECT Hoge FROM TestTable WHERE ID = 9
-- 結果
-- (列名なし)
```

CASE WHENを使って実現しようとしたが、駄目だったのでそれもまとめる。  

``` sql : 試行錯誤
SELECT 
    CASE WHEN EXISTS(SELECT Hoge FROM TestTable WHERE ID = 9)
        THEN Hoge
        ELSE 9999
    END
FROM TestTable
WHERE ID = 9

SELECT 
    CASE WHEN COUNT(*) = 0
        THEN Hoge
        ELSE 'XXX' 
    END AS 料金CD
FROM TestTable
WHERE ID = 9

SELECT
    CASE WHEN (CASE WHEN ID = 9 THEN 1 ELSE 0 END) = 0
        THEN Hoge
        ELSE 'XXX'
    END    
FROM TestTable
-- AAA
-- DDD
```

sql 条件によってselectを変える  
SQL 0件の場合  
COALESCE　レコードなし  

[検索条件にマッチするデータが存在しない場合にデフォルト値を返す](https://sebenkyo.com/2020/04/14/post-774/)  
[NULLと戯れる: 集約関数とNULL](https://qiita.com/SVC34/items/dc1bc52c2d7b44a65459)  
[レコードがない場合のselect結果](https://teratail.com/questions/57768)  

---

## ORDER BY で特定のレコードを先頭にする

sql order by 特定  

代表者テーブルとメンバーテーブルがあるとする。  
代表者を先頭にしたい。  

``` sql
drop table if exists MainTable;
create table MainTable(MainKey varchar(32) primary key,SubKey varchar(32));
insert into MainTable values('Key001','AAA');
insert into MainTable values('Key002','DDD');

drop table if exists SubTable;
create table SubTable(MainKey varchar(32),SubKey varchar(32),TestNumber varchar(5) CONSTRAINT [PK_SubTable] PRIMARY KEY (MainKey,SubKey));
insert into SubTable values('Key001','AAA','0001');
insert into SubTable values('Key001','BBB','0002');
insert into SubTable values('Key002','CCC','0003');
insert into SubTable values('Key002','DDD','0004');
insert into SubTable values('Key002','EEE','0005');
```

``` txt : 表示させたい結果
MainKey  SubKey TestNumber
Key001   AAA    0001 ←代表者
Key002   DDD    0004 ←代表者
Key001   AAA    0002
Key002   DDD    0003
Key002   DDD    0005
```

SQLServerではCASE WHEN句を使う。  
他のデータベースではORDER BYの中で`=`を使うことができる模様。  

``` sql
SELECT
    [MainTable].[MainKey],
    [MainTable].[SubKey],
    [SubTable].[TestNumber]
FROM 
    [MainTable]
    JOIN [SubTable]
    ON [MainTable].[MainKey] = [SubTable].[MainKey]
ORDER BY
    CASE
        WHEN [MainTable].[MainKey] = [SubTable].[MainKey] 
            AND [MainTable].[SubKey] = [SubTable].[SubKey] THEN 0
        ELSE 1 
    END,
    [MainTable].[MainKey]

-- MainKey  SubKey TestNumber
-- Key001   AAA    0001
-- Key002   DDD    0004
-- Key001   AAA    0002
-- Key002   DDD    0005
-- Key002   DDD    0003
```

[SQLServer Order By 並べ替え](https://hironimo.com/prog/sql/orderby/)  

---

## SELECT a.NULL FROM (SELECT NULL FROM テーブル名) a

>SELECT NULL FROM テーブル名;  
>はできるのに  
>SELECT a.NULL FROM (SELECT NULL FROM テーブル名) a;  
>はエラーになるんだね(´・ω・｀)  
>a.NULLを列名扱いに出来ないらしい  
><https://twitter.com/cc02041110/status/1605500362634715137>  

SQLServer2022での検証。  

とりあえずこういうデータがあるテーブルで実験  

``` sql
SELECT * FROM [SchemaVersions]

-- Id | Name
-- ---+---------------------------------------
-- 1  | 001_Create_Table_TeacherMaster.sql
-- 2  | 002_Create_Table_DesignationMaster.sql
-- 3  | 003_Fill_DesignationMaster.sql
```

NULLにしたらレコード分が全部NULLになる。  

``` sql
SELECT NULL FROM [SchemaVersions]

-- Id | Name
-- ---+---------------------------------------
-- 1  | NULL
-- 2  | NULL
-- 3  | NULL
```

Twitterの構文ではそもそもエラーとなり実行できない。

``` sql
-- NULL付近に不適切な構文があります。
-- 'SQ'の列1に列が指定されませんでした。
SELECT SQ.NULL FROM (SELECT NULL FROM [SchemaVersions]) AS [SQ]

-- NULL付近に不適切な構文があります。
SELECT SQ.NULL FROM (SELECT NULL AS TEST FROM [SchemaVersions]) AS [SQ]
```

列名を定義して、列名でアクセスすればもちろんいける。  

``` sql
SELECT SQ.TEST FROM (SELECT NULL AS TEST FROM [SchemaVersions]) AS [SQ]

-- Id | Name
-- ---+---------------------------------------
-- 1  | NULL
-- 2  | NULL
-- 3  | NULL
```

---

## なんだったか

FOR XML使うときは、ORDER BYの位置に気をつけないといけない。  
その検証用として作ったクエリだった気がするが、忘れてしまった。  
後でまとめる。  

``` sql
WITH [TmpTable] AS (
    SELECT 1 AS [ID], 1 AS [RowNum], 'and seventy nine' AS [Data]
    UNION ALL
    SELECT 1, 2, 'five hundred'
    UNION ALL
    SELECT 1, 3, 'two thousand'
)
SELECT
    [ID],
    [Data]
FROM
    (SELECT * FROM [TmpTable] ORDER BY [RowNum] DESC ) [t1]
GROUP BY
    [t1].[ID]

-- メッセージ 1033、レベル 15、状態 1、行 12
-- TOP、OFFSET、または FOR XML が指定されていない場合、ビュー、インライン関数、派生テーブル、サブクエリ、および共通テーブル式では ORDER BY 句は無効です。
```

あれ？単純にEXCEPTでいいのでは？  
SELECT AFiled,BField FROM A
EXCEPT
SELECT DISTINCT AField,BField FROM B

---

## DataBaseProjectの差分から出力したクエリ

自動生成されたコードとして、参考になるのでメモしておく。

``` sql
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_TestTable] (
    [OfficeCD]      NVARCHAR (3)   NOT NULL,
    [BusinessDate]  DATE           NOT NULL,
    [PlayerNo]      NVARCHAR (16)  NOT NULL,
    [GroupCD]       NVARCHAR (5)   NOT NULL,
    [PackCD]        INT            NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_TestTable_PKC1] PRIMARY KEY CLUSTERED ([OfficeCD] ASC, [BusinessDate] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[TestTable])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_TestTable] ([OfficeCD], [BusinessDate], [PlayerNo])
        SELECT   [OfficeCD],
                 [BusinessDate],
                 [PlayerNo]
        FROM     [dbo].[TestTable]
        ORDER BY [OfficeCD] ASC, [BusinessDate] ASC;
    END

DROP TABLE [dbo].[TestTable];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_TestTable]', N'TestTable';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_TestTable_PKC1]', N'TestTable_PKC', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
GO



GO
PRINT N'拡張プロパティ [dbo].[TestTable].[MS_Description] を作成しています...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'精算設定', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TestTable';


GO
PRINT N'拡張プロパティ [dbo].[TestTable].[OfficeCD].[MS_Description] を作成しています...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'事業所コード', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TestTable', @level2type = N'COLUMN', @level2name = N'OfficeCD';


GO
PRINT N'拡張プロパティ [dbo].[TestTable].[BusinessDate].[MS_Description] を作成しています...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'営業日', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TestTable', @level2type = N'COLUMN', @level2name = N'BusinessDate';


GO
PRINT N'拡張プロパティ [dbo].[TestTable].[PlayerNo].[MS_Description] を作成しています...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'精算来場者No', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TestTable', @level2type = N'COLUMN', @level2name = N'PlayerNo';


GO
PRINT N'拡張プロパティ [dbo].[TestTable].[GroupCD].[MS_Description] を作成しています...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'グループCD', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TestTable', @level2type = N'COLUMN', @level2name = N'GroupCD';


GO
PRINT N'拡張プロパティ [dbo].[TestTable].[PackCD].[MS_Description] を作成しています...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'パックCD', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TestTable', @level2type = N'COLUMN', @level2name = N'PackCD';
```
