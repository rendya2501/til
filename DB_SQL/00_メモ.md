# SQLメモ

---

## DROP TABLEやTRUNCATE TABLEはロールバック可能か？

SQLServerではロールバック可能であることを確認した。  
他はDBによる模様。  
ロールバック不可能なDBに関してはdrop tableやtruncate等のDDL(テーブル構造)命令は、RollBackが利かないらしい。  

``` sql
drop table if exists employees;
create table employees(dept_id int,name varchar(32));
insert into employees(dept_id,name) values(1,'田中');
insert into employees(dept_id,name) values(2,'玉木');
insert into employees(dept_id,name) values(3,'鈴木');
GO

BEGIN TRY
    BEGIN TRANSACTION;

    DROP TABLE employees;
    -- TRUNCATE TABLE employees;
    SELECT 1/0

    COMMIT TRANSACTION;
END TRY

BEGIN CATCH
    ROLLBACK TRANSACTION;
    SELECT
        ERROR_NUMBER() AS ErrorNumber,
        ERROR_SEVERITY() AS ErrorSeverity,
        ERROR_STATE() AS ErrorState,
        ERROR_PROCEDURE() AS ErrorProcedure,
        ERROR_LINE() AS ErrorLine,
        ERROR_MESSAGE() AS ErrorMessage;
END CATCH
GO

select * from employees
```

---

## DDLのトランザクション

■**PostgreSQL**  

CREATE TABLEやALTER TABLEなどのDDL命令もCOMMIT、ROLLBACKの対象になる。  

PostgreSQLでは、CREATE TABLE や DROP TABLE などの DDL もトランザクションの一部となるため、トランザクションの途中でDROP TABLE を実行した場合でも、最後に ROLLBACK すれば、DROP したテーブルが元に戻ります。  

■**Oracle**

DDLはトランザクション対象にはならない。暗黙コミットされる。

■**MySQL**

DDLはトランザクション対象にはならない。暗黙コミットされる。

■**SqlServer**

DDL(create文等)はロールバックすることが出来る。  
SQL Server ではTransaction 管理下ではRollback が可能なようです。

[DDLのトランザクション(PostgresSQL,Oracle,MySQL)](https://tamata78.hatenablog.com/entry/2017/02/20/112026)  
[SqlServerではDDL(create文等)をロールバックすることが出来る](https://culage.hatenablog.com/entry/20110129/p6)  
[SQL Server でDDLがRollbackできる？](https://www.ilovex.co.jp/Division/ITD/archives/2005/05/sql_server_ddlr.html)  

---

### DELETE文

表内のデータを(全)削除する。  

`DELETE FROM (表名);`  

- 語訳は「削除」  
- DML(データ操作言語)  
- COMMITしていなければロールバック可能です。  

### TRUNCATE文

表内のデータを全削除する。

`TRUNCATE TABLE (表名);`  

- 語訳は「切り取る」  
- DDL(データ定義言語)  
- TRUNCATE文はWHERE句で指定できませんのでテーブルのデータを全て削除する。  
- テーブルごと削除してから再作成するのでDELETE文よりも高速。  
- トランザクションが効かない。  
- ロールバックができない。  

### DROP文

表内のオブジェクトを完全に削除する。  

`DROP TABLE (表名);`  

- 語訳は「捨てる」  
- DDL(データ定義言語)  
- 完全に削除するのでロールバックができません。表構造も残りません。  
- DROP文はオブジェクトに対するSQL文なのでTABLEを変えてあげれば索引なども削除できる。  

[DELETE文 TRUNCATE文 DROP文の違い(SQL構文)](https://www.earthlink.co.jp/engineerblog/technology-engineerblog/2680/)  

---

## 暗黙的なコミット

MySQLでの話にはなるが、概要として理解するには十分なのでそのまま引用する。  

MySQLの暗黙的なコミットは、特定のクエリを実行した際に現在のセッションで実行されているトランザクションを全てコミットしてから実行されるクエリで、クエリ自身の実行後もコミットされます。  

DROP TABLEを行ったクエリの順番で考えていきます。

``` sql
mysql> START TRANSACTION;
mysql> DROP TABLE zipcode;
mysql> ROLLBACK;
```

上記のクエリに、先ほど説明した内容の暗黙的なコミットを明示的に入れ込んでみると、以下のようになります。

``` sql
mysql> START TRANSACTION;
mysql> COMMIT; -- 処理の前に自動的にコミットされる
mysql> DROP TABLE zipcode;
mysql> COMMIT; -- 処理の後に自動的にコミットされる
mysql> ROLLBACK;
```

ということで、ROLLBACKを打ったとしても結果が全てコミットされてしまっているため、元に戻せないことがわかります。

よくある悲劇的な話としては、テーブル内のデータの削除の高速化のためにDELETE文で削除していたものを、TRUNCATE TABLEに変更した時などに起こります。  
トランザクション処理の途中で単純に置き換えをしてしまった場合に、暗黙のコミットが挟まってしまって予期せぬ挙動になってしまうことがあります。  

[DDLと暗黙的なコミットについて](https://gihyo.jp/dev/serial/01/mysql-road-construction-news/0134)  

---

## 検索条件にマッチするデータが存在しない場合にデフォルト値を返す

レコードが存在したらそのままINSERTして、レコードがなければデフォルト値をINSERTしたい。  

単純そうな課題だったが、30分くらい調べたのでまとめる。  

結果としてCOALESCEで実現できた。  
COALESCEはNULLの場合の置換だと思っていたが、レコードがなくても動いてくれる模様。  

sql 条件によってselectを変える
SQL 0件の場合
COALESCE　レコードなし
[検索条件にマッチするデータが存在しない場合にデフォルト値を返す](https://sebenkyo.com/2020/04/14/post-774/)
[NULLと戯れる: 集約関数とNULL](https://qiita.com/SVC34/items/dc1bc52c2d7b44a65459)
[レコードがない場合のselect結果](https://teratail.com/questions/57768)  

``` sql : データ用意
DROP TABLE IF EXISTS TestTable
CREATE TABLE TestTable (ID INT PRIMARY KEY,Hoge varchar(50))
INSERT INTO TestTable VALUES(1,'AAA'),(2,'DDD')
```

``` sql : 案1
SELECT COALESCE(
    (SELECT Hoge FROM TestTable WHERE ID = 1),
    'XXX'
)
-- 結果
--(列名なし)
--XXX
```

MAXは0件ならNULLを返す。  
COALESCEは結果がNULLなら指定した値に置き換えるので本来の動作に準拠したものになる。  
なのでこちらのほうがいいのかも？  

``` sql : 案2
SELECT COALESCE(
    (SELECT MAX(Hoge) FROM TestTable WHERE ID = 9),
    9999
)
```

存在しないIDの場合レコードはない

``` sql
SELECT Hoge FROM TestTable WHERE ID = 9
-- 結果
-- (列名なし)
```

CASE WHENを使って実現しようとしたが、駄目だったのでそれもまとめる。  

``` sql : 試行錯誤
SELECT 
    CASE WHEN EXISTS(SELECT Hoge FROM TestTable WHERE ID = 9)
        THEN Hoge
        ELSE 9999
    END
FROM TestTable
WHERE ID = 9

SELECT 
    CASE WHEN COUNT(*) = 0
        THEN Hoge
        ELSE 'XXX' 
    END AS 料金CD
FROM TestTable
WHERE ID = 9

SELECT
    CASE WHEN (CASE WHEN ID = 9 THEN 1 ELSE 0 END) = 0
        THEN Hoge
        ELSE 'XXX'
    END    
FROM TestTable
-- AAA
-- DDD
```

---

## ORDER BY で特定のレコードを先頭にする

sql order by 特定  

代表者テーブルとメンバーテーブルがあるとする。  
代表者を先頭にしたい。  

``` sql
drop table if exists MainTable;
create table MainTable(MainKey varchar(32) primary key,SubKey varchar(32));
insert into MainTable values('Key001','AAA');
insert into MainTable values('Key002','DDD');

drop table if exists SubTable;
create table SubTable(MainKey varchar(32),SubKey varchar(32),TestNumber varchar(5) CONSTRAINT [PK_SubTable] PRIMARY KEY (MainKey,SubKey));
insert into SubTable values('Key001','AAA','0001');
insert into SubTable values('Key001','BBB','0002');
insert into SubTable values('Key002','CCC','0003');
insert into SubTable values('Key002','DDD','0004');
insert into SubTable values('Key002','EEE','0005');
```

``` txt : 表示させたい結果
MainKey  SubKey TestNumber
Key001   AAA    0001 ←代表者
Key002   DDD    0004 ←代表者
Key001   AAA    0002
Key002   DDD    0003
Key002   DDD    0005
```

SQLServerではCASE WHEN句を使う。  
他のデータベースではORDER BYの中で`=`を使うことができる模様。  

``` sql
SELECT
    [MainTable].[MainKey],
    [MainTable].[SubKey],
    [SubTable].[TestNumber]
FROM [MainTable]
JOIN [SubTable]
ON [MainTable].[MainKey] = [SubTable].[MainKey]
ORDER BY
    CASE
        WHEN [MainTable].[MainKey] = [SubTable].[MainKey] 
            AND [MainTable].[SubKey] = [SubTable].[SubKey] THEN 0
        ELSE 1 
    END,
    [MainTable].[MainKey]

-- MainKey  SubKey TestNumber
-- Key001   AAA    0001
-- Key002   DDD    0004
-- Key001   AAA    0002
-- Key002   DDD    0005
-- Key002   DDD    0003
```

[SQLServer Order By 並べ替え](https://hironimo.com/prog/sql/orderby/)  

---

## CONSTRAINT 句

`CONSTRAINT 制約の名前 制約`  

`CONSTRAINT [○○_PKC] PRIMARY KEY ([フィールド1],[フィールド2],・・・)`  

テーブルのインデックスフォルダの中を見ると`Customers_PKC(クラスター化)`という名称でインデックスが生成される。  
CONSTRAINT でインデックス名の指定をしない場合`PK_Customer_*****(クラスター化)`という名称でインデックスが生成される。  
`*****`の部分は16桁のランダムな16進数となる模様。  

制約を生成するのでFOREIGN KEY等も作成可能な模様。  

CONSTRAINT句で制約名を設定しなくても複合主キーは設定できるが、ランダムチックな制約名になってしまう。  
SQLServer2016の教科書でもできるなら任意の名前をつけたほうがよいとのこと。  

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    PRIMARY KEY(CustomerID,CustomerName)
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    CONSTRAINT [Customers_PKC] PRIMARY KEY(CustomerID,CustomerName)
);
```

外部キー制約も作れる。

``` sql
CONSTRAINT `制約の名前`
    FOREIGN KEY (`このテーブルの列名を外部キーに設定`)
    REFERENCES `データベース名`.`テーブル名` (`カラム名`)
    ON DELETE NO ACTION ←親テーブルの削除時何もしない
    ON UPDATE NO ACTION ←親テーブルの更新時何もしない
```

CONSTRAINT : 制限、強制  

[SQL文でのINDEX句、CONSTRAINT句について](https://toru-takagi.dev/article/3)  

---

## 制約名を変更する方法

削除して追加する。  
制約名を更新する命令はない模様。  

``` sql : 主キー制約の変更
-- 制約削除
ALTER TABLE [テーブル名] DROP CONSTRAINT [削除する制約名]

-- 制約の追加
ALTER TABLE [テーブル名] ADD CONSTRAINT [追加する制約名]
PRIMARY KEY ([フィールド1],[フィールド2],...)
```

外部キー制約を確認するクエリ  

``` sql
select * from sys.key_constraints
```

[【SQL Server】外部キー制約の一覧を確認する](https://sqlserver.work/2021/01/06/%E3%80%90sys-foreign_keys-%E3%80%91%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC%E5%88%B6%E7%B4%84%E3%81%AE%E4%B8%80%E8%A6%A7%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B/)  

---

## PRIMARY KEY指定

主キーが1つだけの場合は`フィールド名 型 PRIMARY KEY`でもよいし、一番最後に`PRIMARY KEY (フィールド名)`のどちらでもよい。  
主キーが複数の場合は、CREATE TABLEの一番最後に`PRIMARY KEY (フィールド1,フィールド2,・・・)`の形でなければならない。  

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    PRIMARY KEY(CustomerID)
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20) PRIMARY KEY,
    CustomerName nvarchar(20),
    CustomerAdd nvarchar(50) NULL
);
```

``` sql
CREATE TABLE Customers(
    CustomerID nvarchar(20), 
    CustomerName nvarchar(20), 
    CustomerAdd nvarchar(50) NULL,
    CONSTRAINT [Customers_PKC] PRIMARY KEY(CustomerID)
);
```
