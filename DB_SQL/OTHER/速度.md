# 速度

---

## group by vs distinct

distinctはインデックスの影響を受けるが、group byは受けないので安定しているとか。  
そもそも両者は結局ほぼ同じになるとか。  

distinctは専用命令なのにgroup byは副作用で重複が削除されているだけ。  
専用命令としてdistinctが用意されているのだから早いに決まっているし、そうじゃなければ存在価値がないという意見。  

ざっと調べてみたが、わからん。  
インデックスやバージョンにもよるっぽいが、そういうのも含めてgroup byのほうに軍配が上がる記事が多い印象。  
ただ、重複を削除するなら専用命令であるDISTINCTのほうが可読性はいい。  
そういう使い分けで良いのではなかろうか？  

[【SQL入門】group by,distinctどちらが性能がよいのか](https://forse.hatenablog.com/entry/2014/03/13/204259)  

### DISTINCTが早い派

[SQL distinctとgroup byの実行計画が全く同じなのに大きな速度差が出る](https://style.potepan.com/articles/22702.html)  

### 違いはない派

>GROUP BYとDISTINCTの実行プランはほぼ同じです。  
[SQLパフォーマンス：SELECT DISTINCTとGROUP BY](https://www.web-dev-qa-db-ja.com/ja/sql/sql%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%EF%BC%9Aselect-distinct%E3%81%A8group-by/1070117836/)  

<!--  -->
>検証結果としましては、実行計画は全く同じで実行速度もほぼ同じ結果となりました。
[DISTINCT vs GROUP BY](https://devblog.thebase.in/entry/2021/12/19/110000)  

### DISTICTよりEXISTS派

>DISTINCT句よりEXISTS句の使用を検討する  
DISTINCTは、条件に一致するレコードを取り出し暗黙のソート処理後に重複レコードを排除することに対し、EXISTS句は条件に一致するレコード１件でもあればそこで処理は終了する為、暗黙のソート処理をしない分、DISTINCTに比べると負荷が小さくなる  
[忘れっぽいエンジニアのオラクルSQLリファレンス](http://oracle.se-free.com/tuning/B1_sql3.html#distinct)  

→  
多分これはない。  
条件に一致するまで検索するので、EXISTSの平均は「(1+N)/2」。  
早い段階で見つかればそれで処理終了だが、見つからない場合は全件捜査することになる。  
EXISTSとINNER JOINであれば、JOINに軍配が上がる記事も多い。  
アイデアとしては面白いが普通にDISTINCTを使ったほうが良い。  

[基礎から理解するデータベースのしくみ](https://xtech.nikkei.com/it/article/COLUMN/20060111/227105/)  

### アンチパターン サブクエリでDISTINCT

これは明確に遅くなる模様。  
今回の場合に関しては純粋な速度なので、ちょっと違うが、後学のために残しておく。  

[SQLのパフォーマンス的にNG集](http://db2.blog.jp/archives/73952121.html)  

---

## IN vs EXISTS vs INNER JOIN

INNER JOIN > EXISTS > IN

>以上のことから、SQL Server では IN 句と EXISTS 句の実行速度に違いがないことが分かりました。  
>キャッシュの有無で実行速度に違いはあり、実行する度に経過時間は変化しますが、どちらもおおよそ22秒に収束する事、実行計画（実行プラン）が同じことからも、同じ処理がなされていますので、同じ実行時間となると考えられます。
>
>ただし、他の RDB では同じような実行結果にはなりませんので、IN 句自体の使用は控えておくと DB が変更になってもスムーズに開発や移行ができると思いますので、私自身としましては、EXISTS 句を使用することをお勧めしたいと思います。  
>また、INNER JOIN では Merge Join にコストがかかるようになっており、実行計画に若干の違いが見受けられます。  
>最速なのはやはり INNER JOIN ですね。  
>それぞれ、開発の状況に応じて使い分けをする必要があると思いますが、なるべく INNER JOIN > EXISTS > IN の優先順位で使用したいですね。  
>[IN 句と EXISTS 句で実行速度が速いのはどちらの方か検証してみました | SQL Server](https://itblogdsi.blog.fc2.com/blog-entry-406.html)

<!--  -->
>よくINよりEXISTSの方が速いからEXISTSを使えーなんて言われたことがあり、鵜呑みにしてなるべくEXISTSを使っていた時期がありました。  
>そして以前ネットで検索したときに「EXISTSの方が速くなる場合が多いってだけやん！」ってことがわかったので...略
>
>EXISTSを使うならINNER JOINで書き換えた方が速いという意見もありますし、いろいろと選択肢は考えられそうです。  
>
>[INとEXISTS速度の違い](https://struggling-engineer.com/in-or-exists/)  

<!--  -->
>SQLのWHERE句でレコードの存在チェックを行う時などの表現を、IN句でもEXISTS句でも行えるが、EXISTS句は条件に一致するレコードが1件でもあればそこで処理を終了するのに比べて、IN句は条件に当てはまるデータを全て抽出するため、EXISTS句を利用した方が処理が速くなることが多い。  
>[Oracle上でWHERE句内でIN句を利用した場合とEXISTS句を利用した場合の性能を測定してみた](https://www.purin-it.com/spring-boot-oracle-performance-in-exists)  

<!--  -->
>よく、EXISTSの方が速いのでEXISTSを使うべきと言われていたりしますが、それは間違いです。  
>用途に合わせて使っていくのが正しい使い方になります。  
>いろいろ調査してみた結果、以下のような使い分けが良いでしょう。  
>
>1. 別テーブルの情報を出力対象にしたい場合：JOINを使う。  
>2. 別テーブルの情報を抽出条件に使用し、主テーブルの選択性が高い場合：EXISTSを使う。  
>3. 別テーブルの情報を抽出条件に使用し、従テーブルの選択性が高い場合：INを使う。  
>
>MySQLの場合は特殊  
>なお、Web業界の実務でよく使われるMySQLでは相関サブクエリはかなり遅くなるので、EXISTSを使うのであればJOINを使った方が良いケースが多いようです。（INを使ったサブクエリも内部的にEXISTSに書き変わるようなので、INNER JOINの方が早いのでしょう。）  
>ただ、JOIN + DISTINCTで重複排除処理にコストがかかるようなSQLであれば、EXISTSの方がパフォーマンスに優れる場面が発生するという感じでしょうかね。  
>なので、MySQLの場合はINNER JOINとEXISTSを使い分けましょうという話になるのでしょう。  
>
>[【SQL】INとEXISTS、JOINの違い](http://www.code-magagine.com/?p=14768)  

---

## IN

`where in`は遅いと言われる。なぜなのか。  

>SQLの（NOT）INの遅い理由  
>（NOT）INがなぜ遅いかというとデータベースに登録されている対象のテーブルの全レコードを先頭から順番に読み込みしなければならないからです。  
>
>`SELECT * FROM TEST WHERE id NOT IN(20,30);`
>`SELECT * FROM TEST WHERE id IN(20,30);`
>
>例えば、上記のようなSQLがあった場合に、idが20、.30以外のデータを取得するのに最初から最後のレコードまでidをチェックするようです。  
>[【MySQL】SQLで（NOT）INは、遅いらしいので（NOT）EXISTSを使うべき！？](https://the-zombis.sakura.ne.jp/wp/blog/2015/02/12/post-2734/)  

■INでやっている事  

IN演算子の後にサブクエリがある場合、SQLはサブクエリから実行されます。  

`select * from products where category in (select category from sale)`

上記のSQLであれば、IN以降の副問い合わせは入力として処理されるため、下記のコードと同様になります。  

``` js
saleresult = exec("select category from sale");
for (int i=0; i< saleresult.count; i++){
 match = execsql("select * from products where category = saleresult [i]");
 if (match==true){
   (結果セットに挿入)
 }
}
```

[IN 演算子の高速化](https://www.ipentec.com/document/sql-tuning-in-operator)  

■AIに聞いてみた。  

Q.where in は遅いのですか？  

>それは、使用されるデータベースによって異なります。一般的に、WHERE INステートメントは、少ない行を取得する場合は速く動作しますが、大量の行を取得する場合は遅い可能性があります。  

Q.なぜ大量の行がある場合、遅くなる可能性があるのですか？  

>WHERE INステートメントは、検索条件を満たすデータを検索するために、データベースが1つずつの行をスキャンする必要があります。  
>このプロセスでは、データベースが大量の行をスキャンする必要があるため、処理が遅くなります。  

---

## EXISTS

>（NOT）EXISTSが早い理由として挙げられるが、（NOT）INのように、全レコードを検索するのではなく、（NOT）EXISTS は条件に合致する行を見つけたらそこで検索を打ち切る為、全レコードを検索の必要がないので高速だといわれています。  
>[【MySQL】SQLで（NOT）INは、遅いらしいので（NOT）EXISTSを使うべき！？](https://the-zombis.sakura.ne.jp/wp/blog/2015/02/12/post-2734/)  

■EXISTSでやっている事  

`select * from products where exists ()`  

一方、上記のSQLの場合は、相関問い合わせ(相関クエリ/相関サブクエリ)になり、メインのクエリの結果に対してサブクエリでの評価をするため、下記のコードと同様になります。  

``` js
foreach(record in execsql("select * from products")){
 match = execsql("select id from sale where record.category = sale.category");
 if (match==true){
   (結果セットに挿入)
 }
}
```

[IN 演算子の高速化](https://www.ipentec.com/document/sql-tuning-in-operator)  

---

## DISTINCTを高速化するにはEXISTSを使う

[DISTINCTを高速化するにはEXISTSを使う](https://www.greptips.com/posts/386/)  

---

ソートはかなり重い処理に分類されるため、基本的に一番最後に行う。  
