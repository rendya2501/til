# SQLアンチパターン

[「SQLのアンチパターン」3パターンを解説します！](https://products.sint.co.jp/topsic/blog/sql-anti-pattern)  

---

## NULL値の多用

[NULLを排除した設計①](http://onefact.jp/wp/2014/08/26/null%E3%82%92%E6%8E%92%E9%99%A4%E3%81%97%E3%81%9F%E8%A8%AD%E8%A8%88/)  

<https://twitter.com/rude_rockers/status/1522311142689107969>  
>データベースにNULLは極力使わない  
>SQLは基本的にTRUEかFALSEで検知しているが、そこにNULLがあるとunknownが入りバグの温床に（3値理論）  
>数値の場合、-1や最大値などシステム上あり得ない数値を入れる。  
>文字列なら空文字などで対応する。  
>日付の場合「1980/01/01」「9999/12/31」などを使う。  
>とは言え完全にNULLのない世界は難しい  

予約テーブルにおいて、CancelFlagにnullを許可しているのは、nullが「まだ操作されていないことを表している」ということらしいが、どうなのだろうか。  
思いっきり3値理論になってるし、それ以外のnullの意味合いも出てきそうでシステムを知らない人間がみたら不思議に思いそうな気もするが。  

### 未知と適用不能

- プログラミング言語に置ける「null」は「値が未知（unknown）であること」を意味する。  
- SQLにおける「null」は「適用不能」であることも追加される。  
- LEFT JOINで結合する際の「null」が適用不能の例の1つ。  
- SQLでは2つの意味のNULLが存在するので、そのNULLが一体何を指しているのかが分かりにくいというデメリットがある。  

### = nullが意図しない結果を返却するのはなぜ？

Q. nullを比較する際、なぜ[= null]ではなく[is null]なのか。  
→  
A. SQLでの値とnullの比較は全て「unknown」という結果になるから。  

基本的に条件文はtrueかfalseのどちらかを返す「2値理論」が使われます。  
これは非常に直感的で分かりやすいです。  
しかし、SQLの条件文はtrueとfalseの他にunknownを返す場合があり、これを「3値理論」と呼びます。  
この3値理論が人間の直感から大きく外れており、理解しにくい元凶です。  

### 比較時

式の中にNULLが含まれているものを比較しようとすると、必ずunknownになります。
なぜかと言うと、比較した結果がtrueなのかfalseなのかが分からないからです。
SQLはtrueになった行のみ返すので、falseはもちろんunknownになった行も返しません。

もしNULLかどうかでケース分けするのを忘れると、結果が取得できずバグに直結します。  

### 算術演算と結びついても結果をNULLにしてしまいます

算術演算と結びついても結果をNULLにしてしまいます。  
「値がNULLの場合は0にする」とか「NULLの場合は計算しない」とかをSQL内に記述する必要が出てきます。  
NULLは演算の中に入ってくると、結果を全てNULLにしてしまう特性を持っており、これもバグに直結します。  

これがNULL(unknown)の危険性です。  
このようにNULLは直感性に欠ける挙動を起こすことがあり、それがバグを引き起こす原因となるので多用すべきではありません。  

### Null値の多用の回避方法

- 数値の場合：システム上あり得ない数値を入れる  
例えば-1や最大値など、システム上あり得ない数値を入れることでNULLを回避できます。  
もちろんこれでも条件文を記述する必要に変わりはありませんが、unknownを排除できるので2値理論の中で条件を記述することができ、シンプルになります。  

- 文字列の場合：空文字を入れる  
文字列の場合は単純に空文字を入れておくことでNULLを回避できます。  
しかし「空文字が意味を持つ列」の場合はこれだとダブルミーニングになってしまうので、その場合はNULLが必要になるでしょう。  

- 日付の場合：1980/01/01と9999/12/31を使う  
日付の場合も数値と同じくあり得ない最小値や最大値を使うことでNULLを回避できます。  

---

## SQLがDRYではない

ある結果を取得するためのSQLを、至る所で使用しているのはDRY(Don't Repeat Yourself)ではありません。  
DRY原則を守ることは再利用性に優れたSQLを記述できるという点で非常に重要です。  
ですので、ビュー機能を使い、同じクエリ結果を1つのビューにしてしまうことをおすすめします。  

ただし、SQLの抽象化は手続型言語の抽象化に比べ、レスポンスに大きな影響を及ぼしがちなので、パフォーマンスと原理原則のどちらを優先すべきかはその時々の要件によって異なります。  
少し扱いは難しいですが、場合によってはマテリアライズドビューの検討も視野に入れてみましょう。  

---

## インデックスが使われていない

大量のデータが格納されているテーブルは、主キーだけでは検索パフォーマンスに優れず、時間がかかり過ぎてしまうことも多いです。  
そういった場合はインデックスを作ることが基本ですが、インデックスを作成するとインデックス用のデータを作成するので容量を圧迫する点に注意が必要です。  

また、インデックスを作成すると検索は早くなりますが、その分更新処理を行う場合はインデックスデータの書き換えが発生し、更新に時間がかかるようになります。  
なので、作ったインデックスはしっかりと使われるようにしましょう。  
作ったインデックスが使われないパターンの例は以下です。  

### 否定形を使う

基本的に否定形を使用するとインデックスは使われません。否定形の条件に合致した行を取得するには全ての行を参照する必要があるからです（これを全表検索と言います)。  

<>やNOT INなどが対象です。  

安易に否定形を使わずに同じことができないかを模索してみましょう。  

### ORを使う

別々のインデックスを持った列をORを使って条件を結合するとインデックスが利用されなくなります。  
ただし、ORの場合はビットマップ・インデックスというOR検索に向いたインデックスが利用できます。  

しかし、これも作成することで更新時のレスポンスに影響を及ぼしますので、パフォーマンスへの影響を加味しながら導入を検討してください。  

### IS NULLを使う

インデックスデータにNULLは存在しないので、IS NULLを使うと強制的に全表検索になり、インデックスは使われません。  
なぜインデックスデータにNULLがないのかと言うと、NULLが値ではないからです。  

なるべくNULLを使わず、別の値に置き換えてNULLを表現することでインデックスが使えるようになります。  
