# バンドル検証

---

## バンドルの作成条件

`dotnet ef migrations bundle`コマンドを実行することでバンドルを作成することができる。  

しかし、色々と前提条件がある。  

基本的にバンドルはコンソールアプリやWebアプリ等、単独実行可能なプロジェクトであれば作成可能。  
クラスライブラリからでも発行可能らしいが、そこまで検証していない。  

bundle生成において重要なのはスタートアッププログラムにおいてHostingを行う事。  
Webプロジェクトは最初からHostingを行う構成になっているので、必要なパッケージは少なく済む。  
コンソールアプリでも可能だが、Webプロジェクト以上に必要な操作が多い。  

>ASP.NET Core 2.2 アプリで dotnet ef コマンドを実行する場合は、 Program.cs に CreateWebHostBuilder メソッドが必要な模様。  
[dotnet ef migrations でエラーになった話](https://qiita.com/wukann/items/53462f4b21104ed75c31)  

上記サイトで紹介されている通り、Hosting関係のメソッドを使って作成している様なので、Hostingが必要であ る。  

### 作成できた例  

コンソールアプリの場合は`Microsoft.Extensions.Hosting`パッケージをnugetからインストールする必要がある。  

appsettings.jsonを読み取る場合は次のようになる。

``` cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((hostContext, services) =>
    {
        services
            .AddDbContext<DbContext>(options =>
            {
                var appsettings = hostContext.Configuration.GetConnectionString("DefaultConnection");
                options.UseSqlServer(appsettings);
            });
    })
    .Build();
// Runまでせずともbundleを作成する事ができた。  
// host.Run();
```

作成するだけなら接続文字列も必要ないので以下のように記述することができる。  

``` cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services => services.AddDbContext<DbContext>(options => options.UseSqlServer()))
    .Build();
```

Webアプリではサービスに登録することで作成可能となる。  
今回の例では、空のWebアプリとするが、基本的にどのWebアプリであってもスタートアップでサービスを登録すればよい。  
Webアプリでは最初からホスティングが保証されているらしいので、`Microsoft.Extensions.Hosting`は必要ない。  

``` cs
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DbContext>(options =>options.UseSqlServer());
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

作成だけのサンプルなので、ジェネリックはDbContextとしているが、本来であればDbContextを継承した対象のContextとする事。  

### 作成できなかった例  

コンソールアプリでの検証。  
ContextクラスにDIするだけではダメだった。  

``` cs
var services = new ServiceCollection();
services.AddDbContext<DatContext>(options => options.UseSqlServer(connectionString));
ServiceProvider serviceProvider = services.BuildServiceProvider();
_datContext = serviceProvider.GetService<DatContext>();
```

バンドルは作成できないが、`_datContext.Database.Migration();`とすればマイグレーション可能ではある。  

- 参考  
  - [デザイン時 DbContext 作成](https://learn.microsoft.com/ja-jp/ef/core/cli/dbcontext-creation?tabs=dotnet-core-cli)  
  - [Accessing dbContext in a C# console application](https://stackoverflow.com/questions/49972591/accessing-dbcontext-in-a-c-sharp-console-application)  
  - [How to Add Entity Framework Core DBContext in .NET Core Console Application](http://www.techtutorhub.com/article/How-to-Add-Entity-Framework-Core-DBContext-in-Dot-NET-Core-Console-Application/86)  

- 検索文字列 : dependency injection dbcontext console app  

---

## 接続文字列の有無による挙動の違い

コーディングの段階において、接続情報をプログラム内に埋め込んでいる場合、そのまま移行が実行される。  
コーディングの段階において、接続情報をappsettings.jsonから参照するようにしている場合、appsettings.jsonがないとエラーとなる。  
接続情報を一切記述しない状態でバンドルを発行した場合、実行すると接続エラーとなる。  

ダブルクリックによる誤動作防止対策として、接続文字列は記述せず、`--connection`コマンドによる、接続先の指定をするのがよいかと思われる。  

---

## トラブルシューティング

### dotnet ef migrations bundle のエラー

バンドルを作成しようとした時にエラーが発生。  

``` txt
Build started...
Build succeeded.
Specify --help for a list of available options and commands.
Unrecognized command or argument 'bundle'.
```

この時の.Netバージョンは5。  
バンドルはEF Core 6.0からの機能なので、バージョンによるエラーとなる。  

[Unrecognized command or argument 'optimize' on Entity Framework Core .NET Command-line Tools 5.0.7](https://github.com/dotnet/efcore/issues/25135)  

### -oによる出力

`-o`で出力先を指定する場合、ファイル名まで指定しないといけない。  
フォルダも事前に作っておかなければならない。  
フォルダだけ指定して、後はefbundleで発行してもらえればと思ったが、駄目だった。  

`dotnet ef migrations bundle --self-contained -r linux-x64 -o linux-x64/efbundle -f`  

### /pオプションの指定

プロジェクトファイルに対して指定するオプションを入れて発行してみたが、エラーになった。  
使わなくてよい。  

`dotnet ef migrations bundle --self-contained -r linux-x64 -o linux-x64/efbundle -f /p:PublishProtocol=FileSystem`

---

この方式でバンドルを発行すると、絶対にappsettings.jsonが隣にないと動かない。  

``` cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(options =>options.UseSqlServer("name=ConnectionStrings:DefaultConnection"));
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

接続情報を空白にすることで問題なくappsettings.jsonがない場合に--connectionで設定可能。  

``` cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(options =>options.UseSqlServer());
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

コンソールアプリで以下のようにappsettings.jsonを参照するように記述するとappsettings.jsonがなくても、--connectionオプションを指定することで動く。  

``` cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((hostContext, services) =>
    {
        services
            .AddDbContext<AppDbContext>(options =>
            {
                options.UseSqlServer(hostContext.Configuration.GetConnectionString("DefaultConnection"));
            });
    })
    .Build();
```

■バンドル + web方式

この方式でバンドルを発行すると、絶対にappsettings.jsonが隣にないと動かない。  

``` cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(options =>options.UseSqlServer("name=ConnectionStrings:DefaultConnection"));
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

●linux
jsonあり ない状態で直接実行 ×→もちろんだめ
jsonあり ある状態で直接実行 ○→もちろん普通に実行される
jsonあり ない状態でコネクション指定 ×　→これだ。これのせいで混乱したんだ。windowsではこれは許可される。
linux jsonあり ある状態でコネクション指定 ○ →コネクションの設定もちゃんと反映される
linux 内包 直接実行 → ○いけた
linux 内包 + connectionstring →○オプションの設定が優先して使用されることを確認した。

●win
win jsonあり ない状態で直接実行 ×→もちろんだめ
win jsonあり ない状態でコネクション指定 ×→あれ？windowsはOKな気がしたけど、駄目みたい。。となれば、バンドルの動作はwinもlinuxも同じか？

●バンドル + console方式 + linux
linux jsonあり ない状態で直接実行 ×→もちろんだめ
linux jsonあり ある状態で直接実行 ○→もちろん普通に実行される
linux jsonあり ない状態でコネクション指定 ○→行けた。
linux jsonあり ある状態でコネクション指定 ○ →オプションの設定が優先して使用される事を確認した。
linux 内包 ○→動く
linux 内包 + connectionstring →○オプションの設定が優先して使用される事を確認した。

●バンドル + console方式 + win
win json ない状態でコネクション指定 →○動いた。web方式では動かないやつはこちらでは動く。
他もおそらくLinuxと同じはず。
win 内包 ○→動く
win 内包 + connectionstring →○オプションの設定が優先して使用される事を確認した。
