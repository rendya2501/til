# バンドル検証

---

## バンドルの作成条件

`dotnet ef migrations bundle`コマンドを実行することでバンドルを作成することができる。  

しかし、色々と前提条件がある。  

基本的にバンドルはコンソールアプリやWebアプリ等、単独実行可能なプロジェクトであれば作成可能。  
クラスライブラリからでも発行可能らしいが、そこまで検証していない。  

bundle生成において重要なのはスタートアッププログラムにおいてHostingを行う事。  
Webプロジェクトは最初からHostingを行う構成になっているので、必要なパッケージは少なく済む。  
コンソールアプリでも可能だが、Webプロジェクト以上に必要な操作が多い。  

>ASP.NET Core 2.2 アプリで dotnet ef コマンドを実行する場合は、 Program.cs に CreateWebHostBuilder メソッドが必要な模様。  
[dotnet ef migrations でエラーになった話](https://qiita.com/wukann/items/53462f4b21104ed75c31)  

上記サイトで紹介されている通り、Hosting関係のメソッドを使って作成している様なので、Hostingが必要であ る。  

### 作成できた例  

コンソールアプリの場合は`Microsoft.Extensions.Hosting`パッケージをnugetからインストールする必要がある。  

appsettings.jsonを読み取る場合は次のようになる。

``` cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((hostContext, services) =>
    {
        services
            .AddDbContext<DbContext>(options =>
            {
                var appsettings = hostContext.Configuration.GetConnectionString("DefaultConnection");
                options.UseSqlServer(appsettings);
            });
    })
    .Build();
// Runまでせずともbundleを作成する事ができた。  
// host.Run();
```

作成するだけなら接続文字列も必要ないので以下のように記述することができる。  

``` cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services => services.AddDbContext<DbContext>(options => options.UseSqlServer()))
    .Build();
```

Webアプリではサービスに登録することで作成可能となる。  
今回の例では、空のWebアプリとするが、基本的にどのWebアプリであってもスタートアップでサービスを登録すればよい。  
Webアプリでは最初からホスティングが保証されているらしいので、`Microsoft.Extensions.Hosting`は必要ない。  

``` cs
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DbContext>(options =>options.UseSqlServer());
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

作成だけのサンプルなので、ジェネリックはDbContextとしているが、本来であればDbContextを継承した対象のContextとする事。  

### 作成できなかった例  

コンソールアプリでの検証。  
ContextクラスにDIするだけではダメだった。  

``` cs
var services = new ServiceCollection();
services.AddDbContext<DatContext>(options => options.UseSqlServer(connectionString));
ServiceProvider serviceProvider = services.BuildServiceProvider();
_datContext = serviceProvider.GetService<DatContext>();
```

バンドルは作成できないが、`_datContext.Database.Migration();`とすればマイグレーション可能ではある。  

- 参考  
  - [デザイン時 DbContext 作成](https://learn.microsoft.com/ja-jp/ef/core/cli/dbcontext-creation?tabs=dotnet-core-cli)  
  - [Accessing dbContext in a C# console application](https://stackoverflow.com/questions/49972591/accessing-dbcontext-in-a-c-sharp-console-application)  
  - [How to Add Entity Framework Core DBContext in .NET Core Console Application](http://www.techtutorhub.com/article/How-to-Add-Entity-Framework-Core-DBContext-in-Dot-NET-Core-Console-Application/86)  

- 検索文字列 : dependency injection dbcontext console app  

---

## 接続文字列の有無による挙動の違い

コーディングの段階において、接続情報をプログラム内に埋め込んでいる場合、そのまま移行が実行される。  
コーディングの段階において、接続情報をappsettings.jsonから参照するようにしている場合、appsettings.jsonがないとエラーとなる。  
接続情報を一切記述しない状態でバンドルを発行した場合、実行すると接続エラーとなる。  

ダブルクリックによる誤動作防止対策として、接続文字列は記述せず、`--connection`コマンドによる、接続先の指定をするのがよいかと思われる。  

---

## トラブルシューティング

### dotnet ef migrations bundle のエラー

バンドルを作成しようとした時にエラーが発生。  

``` txt
Build started...
Build succeeded.
Specify --help for a list of available options and commands.
Unrecognized command or argument 'bundle'.
```

この時の.Netバージョンは5。  
バンドルはEF Core 6.0からの機能なので、バージョンによるエラーとなる。  

[Unrecognized command or argument 'optimize' on Entity Framework Core .NET Command-line Tools 5.0.7](https://github.com/dotnet/efcore/issues/25135)  

### -oによる出力

`-o`で出力先を指定する場合、ファイル名まで指定しないといけない。  
フォルダも事前に作っておかなければならない。  
フォルダだけ指定して、後はefbundleで発行してもらえればと思ったが、駄目だった。  

`dotnet ef migrations bundle --self-contained -r linux-x64 -o linux-x64/efbundle -f`  

### /pオプションの指定

プロジェクトファイルに対して指定するオプションを入れて発行してみたが、エラーになった。  
使わなくてよい。  

`dotnet ef migrations bundle --self-contained -r linux-x64 -o linux-x64/efbundle -f /p:PublishProtocol=FileSystem`

---

この方式でバンドルを発行すると、絶対にappsettings.jsonが隣にないと動かない。  

``` cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(options =>options.UseSqlServer("name=ConnectionStrings:DefaultConnection"));
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

接続情報を空白にすることで問題なくappsettings.jsonがない場合に--connectionで設定可能。  

``` cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(options =>options.UseSqlServer());
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

コンソールアプリで以下のようにappsettings.jsonを参照するように記述するとappsettings.jsonがなくても、--connectionオプションを指定することで動く。  

``` cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((hostContext, services) =>
    {
        services
            .AddDbContext<AppDbContext>(options =>
            {
                options.UseSqlServer(hostContext.Configuration.GetConnectionString("DefaultConnection"));
            });
    })
    .Build();
```

■バンドル + web方式

この方式でバンドルを発行すると、絶対にappsettings.jsonが隣にないと動かない。  

``` cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<DatContext>(options =>options.UseSqlServer("name=ConnectionStrings:DefaultConnection"));
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

●linux
jsonあり ない状態で直接実行 ×→もちろんだめ
jsonあり ある状態で直接実行 ○→もちろん普通に実行される
jsonあり ない状態でコネクション指定 ×　→これだ。これのせいで混乱したんだ。windowsではこれは許可される。
linux jsonあり ある状態でコネクション指定 ○ →コネクションの設定もちゃんと反映される
linux 内包 直接実行 → ○いけた
linux 内包 + connectionstring →○オプションの設定が優先して使用されることを確認した。

●win
win jsonあり ない状態で直接実行 ×→もちろんだめ
win jsonあり ない状態でコネクション指定 ×→あれ？windowsはOKな気がしたけど、駄目みたい。。となれば、バンドルの動作はwinもlinuxも同じか？

●バンドル + console方式 + linux
linux jsonあり ない状態で直接実行 ×→もちろんだめ
linux jsonあり ある状態で直接実行 ○→もちろん普通に実行される
linux jsonあり ない状態でコネクション指定 ○→行けた。
linux jsonあり ある状態でコネクション指定 ○ →オプションの設定が優先して使用される事を確認した。
linux 内包 ○→動く
linux 内包 + connectionstring →○オプションの設定が優先して使用される事を確認した。

●バンドル + console方式 + win
win json ない状態でコネクション指定 →○動いた。web方式では動かないやつはこちらでは動く。
他もおそらくLinuxと同じはず。
win 内包 ○→動く
win 内包 + connectionstring →○オプションの設定が優先して使用される事を確認した。

---

## `--configurations Bundle`の意味

[Introduction to Migration Bundles - What can they do the migration scripts don't?](https://www.youtube.com/watch?v=mBxSONeKbPk)  
この動画で紹介されているバンドルの作成コマンドは`dotnet ef migrations bundle --configurations Bundle`で紹介されている。  
別にこれで普通にできるのだが、`--configurations Bundle`の意味は何なのか気になったので調べて見た。  

>`--configuration`はビルドの設定（例：Release、Debug）に対して行うモノであり、appsettings.jsonの設定を使いたい場合は`--environment`を指定すれば良い。  
それか、コマンドを実行する前に`ASPNETCORE_ENVIRONMENT`環境変数を設定してから`dotnet ef databese update`を実行すべし。  
[dotnet ef does not respect configuration](https://stackoverflow.com/questions/52665058/dotnet-ef-does-not-respect-configuration)  

<!--  -->
>ありがたいことに、この問題はBundle-Migration errors with "cannot access file...being used by another process" #25555で報告されており、将来的には修正されるはずです。  
回避策として、コマンドにパラメータ --configuration Bundle を追加すると、このエラーはなくなります。  
[GitLab CI/CD Series: Building .NET API Application and EF Core Migration Bundle](https://maciejz.dev/gitlab-ci-cd-series-building-net-api-application-and-ef-core-migration-bundle/)  

<!--  -->
>ここでも、上記と同じエラーが表示されました。  
この問題を回避する方法は、dotnetコマンドラインスクリプトに-configurationパラメータを追加し、そのパラメータにdebugやrelease以外のものが含まれていることを確認することでした。  
`dotnet ef migrations bundle --verbose --configuration abc`  
これでうまくいき、efbundles.exe ファイルが生成されました。  
[EF Core 6 new features and changes for .NET 6](https://www.roundthecode.com/dotnet/entity-framework/ef-core-6-new-features-and-changes-for-net-6)  

どうやらエラー回避のためのオプションとして有効な模様。  
それ以外はわからないが、バンドル生成の時につけておいて損はないのかもしれない。  

2つある海外の記事では

■**予想**  

`--configurations`でdebug,release以外の文言で生成しないとdllを参照しているからブロックされてエラーになってしまう。  
それをこのコマンドで回避できる可能性。  

■**検証結果**  

実際に検証してみたが、効果はなかった。  
VisualStudioからPMCコマンドで`Migration-Bundle`を実行した場合、普通にエラーとなった。  
dotnet-efコマンドで`dotnet ef migrations bundle`を実行して、同じくエラー。  
dotnet-efコマンドで`dotnet ef migrations bundle --configurations Bundle` or `--configurations abc`を実行してみたが、エラーとなった。  
コンフィグレーションの指定は関係ない模様。  
`--verbose`結果の中で`--runtime' を使用する場合は、'--self-contained' または '--no-self-contained' オプションのいずれかが必要です。`とあったので、試しに`--self-contained`を入れて見たらコンフィグレーション関係なくバンドルが作成できてしまった。  

検証結果的には、`--configuration Bundle`ではなく`--self-contained`が重要であることが分かった結果となった。  
結果として、`--configuration Bundle`はバンドル生成時のエラー回避のためのおまじない程度でしかないということで決着だろうか。  

検証が終わった後に#25555のスレッドを見てみたが、`--configuration Bundle`は常にうまくいくとは限らない模様。  
うまくいったり行かなかったりで、やはりおまじないの域は出ないのかもしれない。  
2022/11/25 Friの書き込みでは`dotnet ef migrations bundle --no-build --force --configuration Production`で回避できるらしい。  
`appsetting.[EnvironmentName].json`を用意して、`EnvironmentName`をConfigurationに指定するといいっぽい。  
[「ファイルにアクセスできません...別のプロセスで使用されています」というバンドル移行エラー #25555](https://github.com/dotnet/efcore/issues/25555)  
