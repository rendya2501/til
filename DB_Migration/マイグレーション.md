# データベースマイグレーション

---

## 概要

>**データベースマイグレーション**
>
>アプリケーションの変更に伴い、データベースのスキーマ情報の変更を必要とする場合があります。  
>例えば以下のケースです。  
>
>- 新機能の実装に必要となるカラムを追加したい  
>- ビジネスロジックの変更に伴いカラムの制約を変更したい  
>- パフォーマンスチューニングのためにインデックスを追加したい  
>
>データベースに保存されているデータを保持したままスキーマ情報を変更することをデータベースマイグレーションと呼びます。  
>そのデータベースマイグレーションにより、仕様変更や機能追加でスキーマ情報の変更が発生しても柔軟に適応できます。  
>しかし、環境ごとのスキーマ管理や更新のためのDDL文を実行する手間など、新たな課題が浮上します。  
>
>**データベースマイグレーションツール**
>
>上記の課題を解決する手段の1つとして、データベースマイグレーションツールがあります。  
>データベースマイグレーションツールは、スキーマ情報の変更に伴うDDL文の実行を管理するためのツールです。
>
>多くのデータベースマイグレーションツールは、現時点と最新のスキーマ情報の差分から実行が必要なDDL文だけを実行してくれます。  
>そのため、開発環境や本番環境ごとにスキーマ情報を管理し、更新に必要なDDL文を1つ1つ手動で実行するという手間を省くことができます。  
>
>[sqldefへのSQL Server対応のコントリビュート 〜OSS活動を通して紐解くDBマイグレーションツールの実装〜](https://techblog.zozo.com/entry/database-migration-with-sqldef)  

---

## スキーマ管理・バージョン管理が必要な理由

<!--  -->
>DDL、DMLを手動で管理することによる事故の危険性  
>
>[C#のORM（オブジェクト関係マッピング）における理想形を考えてみる](https://qiita.com/ikuosaito1989/items/f332863dfbe5f30fdf4a)  

<!--  -->
>おそらく多くのプロジェクトでは  
>
>- 初期化パラメーター：Excelシートで管理  
>- スキーマ情報：DDL生成機能を独自追加したExcelシートで管理  
>
>くらいが平均的なところでしょう。
>
>システム開発の現場では、本番環境や検証環境、開発環境など同一システムが複数あるのが一般的です。  
>さらに開発環境は、同一システムに数十個存在することもあります。  
>このような複雑な環境下で、手動管理するのには限界があります。  
>そのため、以下のようなトラブルが発生しています。  
>
>- 本番環境と検証環境の初期化パラメーターが乖離して、設計書と違うものになっている。そして履歴管理していないため、変更した理由がわからない  
>- 開発環境のスキーマ変更情報を検証環境に反映し忘れて、アプリケーションエラーになる  
>- ストアド・プロシージャとテーブル定義がミスマッチでエラーになる  
>- 環境によってパフォーマンスが違うので調べてみたら、インデックスの有無が違っていた  
>
>そして本文では説明しませんでしたが、第一歩はDDL文の監査です。  
>少なくとも、いつ誰が何を変更したかは、わかるようにしてください。  
>
>[第9回 バージョン管理していますか？](https://www.intellilink.co.jp/column/oracle/2016/080800.aspx)  

<!--  -->
>DBは開発工程前に予め設計するのですが、やはり変更はつきものです。  
>しかもDBはアプリケーションの核になっているので、構成が変わるとエラーが発生したり、随時更新していかないと環境によって構成が異なったりします。  
>
>私も周知漏れなどで、自分のところでは動くけど、他の環境では動かないなどは日常茶飯事でした。  
>ちゃんと管理しろって話ですが、エンジニアの人数も少なかったので、管理コストに比べたら、トライアルアンドエラーの方が良かったりします（汗 ただし、エラーログに「〜の列が見つかりません。」のような、エラーのトレースができることが前提ですね。  
>
>ここで問題なのが、他の環境でも適用が必要だということです。  
>変更した人が、チャットやメールなどで他のエンジニアに周知する必要が出てきます。  
>しかも、周知されたエンジニアは後回しにする可能性があり、結局、エラーになったときにExcelを確認し、DBを更新することになります。  
>
>多くの場合、アプリのバージョンとDBのバージョンはリンクしており、DBのみ最新にしてもエラーになることがあります。  
>なので、DBの履歴管理上でアプリのどのバージョンに対応などに記載が必要な場合もあります。  
>ちゃんとやろうとすると、管理コストがかかってしまうのです。  
>
>[DBのバージョン管理で苦労しないために](https://blog.frevo-works.co.jp/entry/2019/01/23/125756)  

<!--  -->
>- 私のプロジェクトでは、スキーマ更新がバージョン管理システムで管理されていません。  
>   - 私のプロジェクトでは、各テーブルのスキーマ更新(ALETER クエリ), ビューやトリガー、プロシージャの作成クエリがバージョン管理システムで管理されていません。  
>    これらの更新情報は、テーブル定義書やプロジェクトwikiを参照する必要があります。  
>- 私のプロジェクトでは、スキーマ更新がモジュールごとに分散しています。  
>   - 私のプロジェクトでは、スキーマ更新はバージョン管理されています。  
>     しかし、それぞれの更新クエリは各モジュールに分散しています。  
>     サーバに適用するたびに、私は各モジュールに更新クエリが追加されていないか探しまわらなければなりません。  
>- 私のプロジェクトでは、どの環境にどのスキーマ更新を適用したか記録がありません。  
>   - 私のプロジェクトでは、本番環境、ステージング環境、開発環境がありますが、どのスキーマ更新をどの環境にどこまで適用したか記録がありません。  
>
>[データベーススキーマ変更の失敗しにくい管理方法](https://qiita.com/suin/items/fd996de8c5d58d95047d)  

---

## どのようにバージョン管理すればよいか？

>原始的な方法として思いつくのは、テキスト化できる操作やパラメーターをSubversionやGitで管理する方法です。  
>少人数開発で小規模アプリケーションならば、なんとかなりそうです。  
>しかし、規模が大きくなるほど大変になり、記録漏れも発生しそうです。  
>
>そのため実際には  
>
>- 設計書→開発環境→検証環境→本番環境  
>
>のような一方向の伝搬だけでなく、現状の環境をキャプチャーし、  
>
>- 「検証環境と本番環境」「設計書と開発環境」のギャップ分析  
>
>のようなリバースエンジニアリング&比較機能もあるのが理想的です。  
>
>実際のところ、この分野の議論をインターネットで検索しても意見はさまざまです。  
>それぞれのソリューションで、コンセプトや機能に違いがあり、同一基準では判断できないからです。  
>また何が適しているのかは、使用する組織の文化やプロジェクト次第でしょう。  
>
>[第9回 バージョン管理していますか？](https://www.intellilink.co.jp/column/oracle/2016/080800.aspx)  

---

## そもそも実現したいことは？

- ある時点の基準となるデータベース構造を吸い上げてマイグレーション管理する。  
- 発行のタイミングでデプロイするプログラムが使用するデータベースとの比較を行う。  
- その差分から変更クエリを出力する or 差分の記録を残す。  

EFCoreではデータベースの構造のリバースエンジニアリングはできるけど、全部上書きしてしまうので、差分を抽出することができない。  
モデルの生成までではなく、あくまで差分の抽出だけやってほしいのだが、リバースエンジニアリングの機能ってモデルを作りつつ、コンテキストの生成までやるし、モデルありきじゃないとコンテキストの生成はできないから、やっぱりEFCoreによるリバースエンジニアリングは駄目だな。  

目指すべきは発行のタイミングで差分を検出し、そこから適切なクエリを吐き出すことだろうか。  
なんかそういうツール作ればいいのでは？と思ったりしなくもない。  
コンソールアプリケーションでも十分だとは思うけど、既製品で既に存在しないか探すしかないな。  

クエリを作る。
フォルダに入れる。
フォルダの中のクエリからDBに当てる。
その開発でいったん区切りを付けてバージョンとする。
他の環境にデプロイする時に差分を検出して実行に必要なDDLを判断してもらう。

---

## Googleのデータベースマネージメントに関する記事

>継続的デリバリーで成果を上げているチームは、データベースの変更をバージョン管理のスクリプトとして保存することで、本番環境のアプリケーションの変更と同じ方法で管理しています。  
>さらに、アプリケーションの変更でデータベースの変更が必要な場合は、本番環境のデータベースを担当しているグループと協議し、エンジニアリング チームが保留中のデータベースの変更の進行状況について把握できるようにしています。  

[DevOps 技術: データベースのチェンジ マネジメント](https://cloud.google.com/architecture/devops/devops-tech-database-change-management?hl=ja)  

---

## マイグレーションについての良記事

[Database Migrations In .NET Core](https://dotnetcoretutorials.com/2017/02/25/database-migrations-net-core/)  

[Database versioning best practices](https://enterprisecraftsmanship.com/posts/database-versioning-best-practices/)  
[State vs migration-driven database delivery](https://enterprisecraftsmanship.com/posts/state-vs-migration-driven-database-delivery/)
[Database versioning tools](https://enterprisecraftsmanship.com/posts/database-versioning-tools/)  

>1. データが失われないことを確認してください  
>2. スクリプトを変更または削除しないでください  
>3. バージョン管理にタイムスタンプを使用する  
>4. 適切な DSL を使用する  
>5. 移行ツール以外でデータベースの変更を行わないでください  
>6. 選択した移行ツールを使用して、データベースをどこにでも展開します  
>7. 移行を書き留めて時間を無駄にしない  
>8. アプリケーションの起動時に移行するのは悪い考えです  
>9. 移行を Docker 化する  
>10. ビジネス担当者と移行について話すことを恐れないでください  
>
>[Database migrations tips(データベース移行のヒント)](https://mcode.it/blog/2020-03-15-database_migrations_tips/)  

---

## 逆移行

TestDBのTestTableの情報を逆移行(リバースエンジニアリング)するコマンド

``` txt : Scaffold-DbContext
Scaffold-DbContext 'Data Source=TestDB;Initial Catalog=TestTable;User ID=**;Password=*****;Integrated Security=False' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Repository/Models -Context DatContext -ContextDir Repository –DataAnnotations –UseDatabaseNames –Force
```

`Integrated Security`がTrueだとログインできないという警告が出る。  
Falseにすることで解決するがそれでよいかどうかは知らない。  
SecurityをFalseにするのであまりよい印象はない。  

`–UseDatabaseNames`オプションがないとテーブル名が完全一致しない。
`TMa_Master`テーブルのテーブル名が`TmaMaster`みたいになってしまう。  

[ASP.NET Core - Scaffolding with Entity Framework Core (Database first approach)](https://www.youtube.com/watch?v=SnU4Ulee_NI)  

---

## SQL Developer Data Modeler

Oracle製のデータベースクライアント  
差分を検出してクエリを作ってくれるらしいが、クライアントのダウンロードにはオラクルへのログインが必要で、SQLServerを使えるようにするためには、プラグインを組み込まないといけない。  
そのプラグインが2008以降存在するのか確認していない。  

---

## EntityFrameworkCore

>**実環境での Dapper と EF のハイブリッド使用**
>
>完璧なデータ永続化のために、数え切れないほどのシステムが Dapper を使用しています。  
しかし、今回このテーマを取り上げるのは、開発者たちがハイブリッド ソリューションを選択しているためです。  
たとえば、特定の問題領域の調整を目的にその部分に EF を導入しているシステムがあります。  
また、クエリにはすべて Dapper を使用し、保存にはすべて EF を使用することを選択しているチームもあります。  
>@garypochron のチームによれば、**「効果の高い領域には Dapper を使い、SQL のオリジンを管理するためにリソース ファイルを使うようにしている」**とのことです。  
>人気の EF Reverse POCO Generator の製作者 Simon Hughes (@s1monhughes) が、既定では Dapper を使用し、技術的に難しい問題には EF を使用しているという、逆の方向に向かっていると知ったのは驚きでした。  
>彼は、「可能であれば Dapper を使い、複雑な更新には EF を使う」と話しています。  
>
>また、ハイブリッド アプローチは、パフォーマンスの強化よりも、懸案事項の分離がきっかけになっていることに関するさまざまな議論も目にしました。  
>最も多かった意見は、既定では EF の ASP.NET Identity の信頼を利用し、ソリューションの残りの永続性には Dapper を使用するというものでした。  
>
>[データ ポイント - Dapper、Entity Framework、およびハイブリッド アプリ](https://learn.microsoft.com/ja-jp/archive/msdn-magazine/2016/may/data-points-dapper-entity-framework-and-hybrid-apps)

普通にEFCoreでスキーマ管理してるところもあるのかもなぁ。  
「Dapper + EFCore スキーマ管理」  
→  
ありました。  

<!--  -->
>Dapper と Entity Framework Core の両方を使用して最大限に活用できるのに、なぜどちらを選択するのかということです。  
>Dapper は、複数の結合と非常に長いビジネス ロジックを扱う複雑なクエリを処理するのに非常に優れています。  
>Entity Framework Core は、クラスの生成、オブジェクトの追跡、複数の入れ子になったクラスへのマッピングなどに最適です。  
>したがって、これら 2 つの ORM について話すときは、通常、パフォーマンスと機能です。  
>
>[ASP.NET Core での Entity Framework Core と Dapper の使用](https://morioh.com/p/09c8bea3cedb)  

---

## SQL Server Database Project

database migration sqlserver

[How To Put Your SQL Server Database in Version Control (Git)](https://www.youtube.com/watch?v=FWAx0pdMLfQ)  
[データベースの変更追跡 (Visual Studio と Git を使用)](https://www.youtube.com/watch?v=skPhTDlaPEA)  
[Introduction to SQL Server Change Tracking](https://www.youtube.com/watch?v=ZNUN9qejCfc)  

Visual Studio database project best practices
visual studio database project deploy

[DATABASE DEVELOPMENT IN VISUAL STUDIO](https://marcin.gminski.net/blog/database-development-in-visual-studio/)
[Top Features in SQL Server Data Tools for Database Projects](https://www.mssqltips.com/sqlservertip/6749/ssdt-top-features-database-projects/)
[Best Practices for multi-environment database development](https://sqlbits.com/Sessions/Event14/Best_Practices_for_multi-environment_database_development_in)
[Visual Studio で SQL Server データベース プロジェクトを作成する方法](https://www.c-sharpcorner.com/article/how-to-create-sql-server-database-project-with-visual-studio/)  

---

## SQLServer

DDLTriggerなるものを使えば、テーブルに対して行ったスキーマー変更の履歴を残すことができる。  
あくまで残すだけなので、そこからどうするってのは考えないといけない。  

でも、開発テーブルにこの仕組みを作っておいて、何を適応してきたのか履歴を作るのは何かのきっかけで調査する必要があった時に役に立つ時が来るのでは？と思ったり。
開発環境でマイグレーション管理をしないなら、せめて履歴管理くらいはしてもいいと思ったり。  

[データベースのスキーマ変更を検出してみる(SQLServer)](https://recruit.cct-inc.co.jp/tecblog/database/ddl_trigger/)  

SQL Source Control

製品なのでダメ。

[Using SQL Server Management Studio to Push Changes to a Git Remote Repository | Redgate](https://www.youtube.com/watch?v=Pv13GpjGVmY)

database version control
[CI/CD for SQL Databases (both SSDT and EF)- A TimCo Retail Manager Video](https://www.youtube.com/watch?v=TuHf0Ty80jA)  

[SSMS でのソース管理](https://www.youtube.com/watch?v=1iJMuUDB5MU)

---

## DBeaver

無料の複数種類のDBに対応したデータベースの操作ができるツール。  
HeidiSQLと同じやつ。  

このクライアントからDBに接続して色々できる。  
ER図とか書き起こしてくれる模様。  
でもマイグレーション管理的な文献が見当たらなかった。  

---

## SQL Server Data Tools

>SQL Server Data Toolsは、SQL Serverを使用するアプリケーション開発者のための開発支援ツールです。  
開発者がSQL Server Management Studioで実施していたテーブルの作成や変更などのデータベース関連タスクを、Visual Studioで完結することを目的としています。  
<https://codezine.jp/article/detail/6531>  

古いのとバージョン管理的な文言が見当たらなかった。  
というか、この機能は2017年あたりからVisualStudioに統合されたっぽい？  
DatabaseProjectにおける差分比較機能はDataToolsの機能で実装されているような感じがした。  

とりあえず、あまり考えなくてよさそう。

[方法:スキーマ比較を使用して各種のデータベース定義を比較する](https://learn.microsoft.com/ja-jp/sql/ssdt/how-to-use-schema-compare-to-compare-different-database-definitions?view=sql-server-ver16)  

---

## FluentMigrator

- DotNetのデータベース管理ライブラリ  
- EFCoreほど大規模でガッツリしたものではない。Dapper的な立ち位置。つまりお手軽。  

>dotnet系プロジェクトでのデータベースマイグレーションというと、真っ先に思いつくのがEntity Framework Core(EFCore)によるものだろう。
実際多くの場合で、EFCoreを使えば問題は無い。
だが、筆者の場合、クエリはほぼDapper経由で出しているため、クエリビルダ等は必要なく、欲しいものはマイグレーションのみとなる。
マイグレーションのみの用途となると、EFCoreは大がかりに見えて、個人的にはちょっと扱いにくいなと思った。
そこで、よりマイグレーションのみに特化したライブラリは無いものかと探して、FluentMigratorを見つけた。
自分にとっては丁度良い規模感だったため、今回の記事で紹介する。

[FluentMigratorでデータベースマイグレーションを行う(dotnet)](https://qiita.com/skitoy4321/items/ba294a3ae35b617d207f)  
[FluentMigration の基本機能メモ](https://kendik.hatenablog.com/entry/2015/07/02/231529)  
[C#のORM（オブジェクト関係マッピング）における理想形を考えてみる](https://qiita.com/ikuosaito1989/items/f332863dfbe5f30fdf4a)  

---

## Flyway

- データベースのスキーマに対してバージョン管理するツール  
- Java製。なのでJava実行環境(JavaVirtualMachine) が必要  
- データベース管理ツールで調べると一番に出てくる程メジャーな模様。  

[Flywayの使い方](https://garafu.blogspot.com/2020/06/how-to-use-flyway.html)  

---

## sqldef

これとflywayがツールとしては本命になりそう。  

>目標とするスキーマを書くと, DBに接続して現在のスキーマと比較し, DBのスキーマが現在のスキーマに一致するように CREATE TABLE や ALTER TABLE などを実行してくれるGo製のcliツール。  
[sqldefをマイグレーションコード生成ツールとして使う](https://kgtkr.net/blog/2022/02/10/sqldef-for-generate-migration)  

[sqldefへのSQL Server対応のコントリビュート 〜OSS活動を通して紐解くDBマイグレーションツールの実装〜](https://techblog.zozo.com/entry/database-migration-with-sqldef)  
[DBスキーマ変更管理ツール sqldef を試してみた](https://qiita.com/abe_masanori/items/7fd2a470e7eba2f255a4)  
[マイグレーションツールをsqldefに移行した話](https://zenn.dev/ko30005/articles/5712a1d4731627)  

---

データベースマイグレーションツール
Database change management best practices
sqlserver スキーマー　変更　追跡

[データベースのスキーマ変更を検出してみる(SQLServer)](https://recruit.cct-inc.co.jp/tecblog/database/ddl_trigger/)  

[その他の変更の追跡の機能](https://learn.microsoft.com/ja-jp/ef/core/change-tracking/miscellaneous)  
[SQL Server Data Tools](https://learn.microsoft.com/ja-jp/sql/ssdt/sql-server-data-tools?view=sql-server-ver16)  

[データ ポイント - Dapper、Entity Framework、およびハイブリッド アプリ](https://learn.microsoft.com/ja-jp/archive/msdn-magazine/2016/may/data-points-dapper-entity-framework-and-hybrid-apps)  
[DB マイグレーションツールの Fluentmigrator がいい感じかも](https://kendik.hatenablog.com/entry/2015/06/30/203134)  

[C#のORM（オブジェクト関係マッピング）における理想形を考えてみる](https://qiita.com/ikuosaito1989/items/f332863dfbe5f30fdf4a)  

[sqldefへのSQL Server対応のコントリビュート 〜OSS活動を通して紐解くDBマイグレーションツールの実装〜](https://techblog.zozo.com/entry/database-migration-with-sqldef)  

[DBのバージョン管理で苦労しないために](https://blog.frevo-works.co.jp/entry/2019/01/23/125756)  
[.NET Core で DBマイグレーションを試したら色々ハマった話](https://blog.ecbeing.tech/entry/2019/06/12/125411)  
[データベーススキーマ変更の失敗しにくい管理方法](https://qiita.com/suin/items/fd996de8c5d58d95047d)  
[Entity Framework のマイグレーションを基礎から理解する](https://qiita.com/yutotakakura/items/31ab539321502deacd88)  

[Entity Frameworkのベストプラクティス-EFCoreをデータアクセスとして選択する必要がありますか？](https://www.youtube.com/watch?v=qkJ9keBmQWo)  
[CRUD with a .NET 6 Web API & Entity Framework Core 🚀 Full Course](https://www.youtube.com/watch?v=Fbf_ua2t6v4)  
[ASP.Net Core Web API - Entity Framework Core Transaction | Commit | Rollback](https://www.youtube.com/watch?v=VBFlI0-mbh4)  

マイグレーションツール一覧
<https://qiita.com/cocoa-maemae/items/d55c7b53f95425efdce8>  

---

``` md
SQL Server データベース プロジェクト
名前的にそれっぽいものかと思いましたが構造を管理するものとは少し違いました。
.NetFrameworkに依存していて、直接Linuxで動かすこともできないのであまり詳しくは調べていません。

Entity Framework 6（EF6）
.NetCore対応の旧EntityFramework互換品。
機能的にはまさにこれといえるものではあるが、公式が「現在は積極的に開発されていません。」と明記している。
.NetCore対応と公式に書いていたが、GUIは非対応だったのでEF6を使う意味は無し。

Entity Framework Core（EF Core）
旧EntityFrameworkのマルチプラットフォーム対応後継品。
マルチプラットフォーム対応の為にGUIを捨て、VisualStudioから出来ていたことがかなり削除された。
MSの本命はこちららしく、積極的に開発が続いている。
GUIを補完するためにVisualStudio拡張の「Entity Framework Visual Editor」で旧EntityFrameworkに近い使い勝手になる。

---

どのようにクエリが作られるのか
Migrationの差分を順番に実行していく。

データの注入を組み込めるか
Migrationファイルを編集することで各クエリや生クエリを実行できる関数を組み込める。

Datを１つのダイアグラムで管理すると表示が重すぎるので分割して管理可能か。
分割は可能だがそれでもダイアグラムを開くまでにとても時間がかかる。
ダイアグラムは捨て、DBFirstのみ対応として基準となるサーバからマイグレーションを作成することとしたい。

---

基準となるDBを用意する。

コマンドでDBからDBContextとEntityを作成。
`Scaffold-DbContext  'Data Source=SQLSV2016;Initial Catalog=[DataName];User ID=**;Password=******' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Model -ContextDir Context -Context DatContext –DataAnnotations –UseDatabaseNames –Force`

コマンドでDBContextからMigrationを作成。
Add-Migration -Name DatInit -OutputDir DBMigration -Context DatContext

基準となるDBの構造を変更する。

コマンドでDBから構造変更をDBContextとEntityに反映する。

コマンドでDBContextからMigrationを作成。

---

Microsoft.EntityFrameworkCore.Tools(PMCツール)
マイグレーションを実行するEXEをDBごとに出力する。（EF Core 6.0から）
すべてのマイグレーションを実行するクエリを発行する
指定したマイグレーション範囲のクエリを発行する。
マイグレーションを実行する。

dotnet-ef（.NET Core CLIツール）
Microsoft.EntityFrameworkCore.Toolsと同等のことが可能。

ASP.Net Core
サービス（IISならアプリケーションプール）実行ごとにappsettings.jsonを参照してマイグレーションを実行することが出来る。  
失敗してもtry-catchでメッセージを取得でき、掌握すれば続行もできる。  

コンソールアプリ
自作実行ファイルでマイグレーションを実行することが出来る。失敗してもtry-catchでメッセージを取得でき、掌握すれば続行もできる。ただし、接続先を外部から注入するのは面倒かもしれない。
```
