# Dapperメモ

## Dapper where in

``` C#
string sql = "SELECT * FROM SomeTable WHERE id IN @ids"
var results = conn.Query(sql, new { ids = new[] { 1, 2, 3, 4, 5 }});
```

Dapperが括弧で括ってくれる模様。  

[SELECT * FROM X WHERE id IN (...) with Dapper ORM](https://stackoverflow.com/questions/8388093/select-from-x-where-id-in-with-dapper-orm)  

---

## Dapper Like

``` C#
// 案1 CONCAT関数を使用する
string sql = "SELECT * FROM SomeTable WHERE Name LIKE CONCAT('%',@name,'%')"

// 案2 +演算子を使用する
string sql = "SELECT * FROM SomeTable WHERE Name LIKE '%' + @name + '%'"

// 案3 パラメーターで頑張る
var results = conn.Query(sql, new { name = "%" + name + "%" });
```

`LIKE '%' || @name || '%'`も紹介されていたが、SQLServerでは使えなかった。  
`||`演算子による文字列連結はOracleやPostgreSQLで有効な模様。  
SQLServerはもっぱら`CONCAT`か`+`演算子になる模様。  

[Does Dapper support the like operator?](https://stackoverflow.com/questions/6030099/does-dapper-support-the-like-operator)  
[文字列を連結する](https://www.sql-reference.com/string/concatenate.html)  

---

## Dapper boolの受け取り

SELECTで `1 AS [Flag]` とか `0 AS [Flag]` と定義して、boolで受けようとしても取得できない。  
intとして解釈されるため、型の関係で取得できない模様。  

`CONVERT(BIT,'TRUE') AS [Flag]` のように、ちゃんとコンバートしないと取得できない模様。  

[SQLServerでboolean型（True/Falseの真偽値）を扱うbit型](https://johobase.com/sqlserver-boolean-bit/)  

---

## メモ

``` txt
実行するときにコネクションを取得。
終わったら解放。
取得してやるか、Actionを渡してやるか。

一貫してトランザクションを実行したい場合、TransactionScopeのOnScopeの中でやるか。
実務ではそうしている。
だけどOnScopeの中でOnScopeというあれもある。
実務のやつが地味に優秀だったのかなぁ。
あとは、各種Selectの種類と簡単な接続ラップサンプルをやりたい。
```

---

## DapperAction

リポジトリパターンを実装している時に、参考動画を元にDapperContextクラスを作った。  
コネクションをオープンにして返すだけでDapperとついているが、DapperをUsingしていない。  
そして使用するときはDapperのクエリを呼ぶだけ。  
なら使用と同時にオープンして結果を返すようにしてしまったほうが良いのではないかと思った。  

[Using a Dapper Base Repository in C# to Improve Readability](https://exceptionnotfound.net/using-a-dapper-base-repository-in-c-to-improve-readability/)  
このリンクの通り、Dapperメソッドをラップして、エラー制御とコネクション制御までやってくれている。  
使う側はDapperのラップクラスのメソッドを用途に応じて使用するだけ。  
なんで、この方法を皆取らないのだろうかと不思議に思う。  

``` cs : Program.cs
builder.Service.AddSingleton<DapperContext>();
```

``` cs : DapperContext
using Microsoft.Data.SqlClient;
using System.Data;

public class DapperContext
{
    private readonly IConfiguration _configuration;
    private readonly string _connectionString;

    public DapperContext(IConfiguration configuration)
    {
        _configuration = configuration;
        _connectionString = _configuration.GetConnectionString("DefaultConnection");
    }

    public IDbConnection CreateConnection() => new SqlConnection(_connectionString);
}
```

``` cs
public class BookRepository : IBookRepository
{
    private readonly DapperContext _context;

    public BookRepository(DapperContext context)
    {
        _context = context;
    }

    public async Task<IReadOnlyList<Book>> GetAllAsync()
    {
        var sql = "SELECT * FROM Book";
        using var connection = _context.CreateConnection();
        var result = (await connection.QueryAsync<Book>(sql)).ToList();
        return result;
    }

    public async Task<int> AddAsync(Book entity){}
    public async Task<int> DeleteAsync(int id){}
    public async Task<Book> GetByIdAsync(int id){}
    public async Task<int> UpdateAsync(Book entity){}
}
```

[Using Dapper with ASP.NET Core Web API](https://www.youtube.com/watch?v=C763K-VGkfc&t=147s)  

---

## join dynamic

Joinした結果を受け取るPOCOがない。  
もしくは定義するのに値しない。  
サクッと受け取りたい場合どのようにすればよいのか。  

**dynamic**で受けるべし。  

それか素直にTuple作って受け取ればいい。  

``` cs
const string sql = @"
select 
    Products.ProductId, 
    Products.ProductName, 
    Products.ProductCategory, 
    ProductPrice.Amount, 
    ProductPrice.Currency
from Products join ProductPrice 
on Products.ProductId = ProductPrice.ProductId
";

// get dynamic
IEnumerable<dynamic> products = sqlConnection.Query(sql);

// get tuple
(int ProductId, string ProductName, byte ProductCategory, int Amount, decimal Currency) tupleProduts = sqlConnection.Query(sql);
```

>最初の例では、テーブルの各行を1つではなく、2つのオブジェクト（商品と仕入先）にマッピングするマルチマッピングを行っていますが、これは商品が返される前に参照によってリンクされます。  
動的なオブジェクトでは、このようなことはできないと思います。  
なぜなら、Dapperは、列をどのように分割すればよいのか、わからないからです。  
一般的なパラメータ`<Product, Supplier, Product>`を`<dynamic, dynamic, dynamic>`に置き換えて、テストで確認することができます。  
[Using dynamic list of objects in dapper join queries](https://stackoverflow.com/questions/35254330/using-dynamic-list-of-objects-in-dapper-join-queries)  

公式でもそうしろって言ってる。  
[github_dapper](https://github.com/DapperLib/Dapper#execute-a-query-and-map-it-to-a-list-of-dynamic-objects)  

---

## 動的に条件文を組み立てる

``` cs
var sql = "select * from customers" + (gender != null ? " where gender = @Gender" : "");
```

上記、動的生成は下記のように書き換え可能。  
割と盲点だった。  
インデックスは不明な模様。  

``` cs
const string sql = @"
select * 
from customers
where (gender = @Gender or @Gender is null)
";
var customers = _connection.Query(sql, new {Gender = (object) null});
```

[Dapper のクエリ](https://qiita.com/masakura/items/3409a766e46580a5ad99)  

---

## カラムと値の出力

[Dapper ORMのQueryでカラム名を取得する方法 – EXCEEDSYSTEM](https://www.exceedsystem.net/2021/11/16/how-to-get-column-names-from-dynamic-type-result-records-using-query-method-of-dapper/)  

---

## トランザクション

Executeメソッドの第三引数にSqlTransactionインスタンスを渡せば良い。  

``` C#
{
    //トランザクション開始
    using (var tran = connection.BeginTransaction())
    {
        try
        {
            var result = connection.Execute(query, param, tran);
            tran.Commit();
        }
        catch (Exception e)
        {
            tran.Rollback();
            throw;
        }
        finally
        {
            connection.Close();
        }
    }
}
```

[C# DapperでDB接続する方法（トランザクション編）](https://learning-collection.com/c-dapper%E3%81%A7db%E6%8E%A5%E7%B6%9A%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%EF%BC%88%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E7%B7%A8%EF%BC%89/)  

---

## コンストラクタ

``` cs
using Dapper;
using System.Data.SqlClient;

string constr = @"Server=.\SQLEXPRESS;Database=<db_name>;Integrated Security=True;";
using SqlConnection connection = new SqlConnection(constr);
var query = "SELECT * FROM <table>";
var result = connection.Query<dynamic>(query);

class Items
{
    public int id { get; set; }
    public string name { get; set; }
    public int price { get; set; }
    public Category category { get; set; }

    public Items(params dynamic[] items)
    {
        _ = items;
    }
    
    public Items(dynamic items)
    {
        _ = items;
    }
}

// 例外が発生しました: CLR/System.InvalidOperationException
// 型 'System.InvalidOperationException' のハンドルされていない例外が Dapper.dll で発生しました: 'A parameterless default constructor or one matching signature (System.Int32 id, System.String name, System.Int32 price, System.String category) is required for Items materialization'
```

---

## DapperのSelectサンプル

1. Database1というローカルDBを作成する  
2. ローカルDB上でテーブル生成クエリを流しておく  
3. 適当なクラスを作って、コードを貼り付けて実行する  

``` sql
CREATE TABLE Person(
    [ID] INT,
    [Name] NVARCHAR(100)
)
INSERT INTO [Person] VALUES (1, N'山田'), (2, N'鈴木'), (3, N'佐藤')
```

``` C#
using Dapper;
using System.Data.SqlClient;

public void Execute()
{
    SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder
    {
        DataSource = @"(LocalDB)\MSSQLLocalDB",
        AttachDBFilename = System.IO.Path.GetFullPath(@"..\..\Database1.mdf"),
        IntegratedSecurity = true,
    };
    using (var connection = new SqlConnection(builder.ConnectionString))
    {
        connection.Open();
        var query = "SELECT * FROM [Person]";
        // SQLの発行とデータのマッピング
        // 取得データは IEnumerable<Person> 型
        var result = connection.Query<Person>(query);
        foreach (var p in result)
        {
            Console.WriteLine($"{nameof(Person.ID)}: {p.ID}  {nameof(Person.Name)}: {p.Name}");
        }
    }
}

/// <summary>
/// マッピング用クラス
/// </summary>
class Person
{
    public int ID { get; set; }
    public string Name { get; set; }
}
```
