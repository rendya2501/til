# Dapperメモ

## メモ

``` txt
実行するときにコネクションを取得。
終わったら解放。
取得してやるか、Actionを渡してやるか。

一貫してトランザクションを実行したい場合、TransactionScopeのOnScopeの中でやるか。
実務ではそうしている。
だけどOnScopeの中でOnScopeというあれもある。
実務のやつが地味に優秀だったのかなぁ。
あとは、各種Selectの種類と簡単な接続ラップサンプルをやりたい。
```

---

## DapperAction

リポジトリパターンを実装している時に、参考動画を元にDapperContextクラスを作った。  
コネクションをオープンにして返すだけでDapperとついているが、DapperをUsingしていない。  
そして使用するときはDapperのクエリを呼ぶだけ。  
なら使用と同時にオープンして結果を返すようにしてしまったほうが良いのではないかと思った。  

[Using a Dapper Base Repository in C# to Improve Readability](https://exceptionnotfound.net/using-a-dapper-base-repository-in-c-to-improve-readability/)  
このリンクの通り、Dapperメソッドをラップして、エラー制御とコネクション制御までやってくれている。  
使う側はDapperのラップクラスのメソッドを用途に応じて使用するだけ。  
なんで、この方法を皆取らないのだろうかと不思議に思う。  

``` cs : Program.cs
builder.Service.AddSingleton<DapperContext>();
```

``` cs : DapperContext
using Microsoft.Data.SqlClient;
using System.Data;

public class DapperContext
{
    private readonly IConfiguration _configuration;
    private readonly string _connectionString;

    public DapperContext(IConfiguration configuration)
    {
        _configuration = configuration;
        _connectionString = _configuration.GetConnectionString("DefaultConnection");
    }

    public IDbConnection CreateConnection() => new SqlConnection(_connectionString);
}
```

``` cs
public class BookRepository : IBookRepository
{
    private readonly DapperContext _context;

    public BookRepository(DapperContext context)
    {
        _context = context;
    }

    public async Task<IReadOnlyList<Book>> GetAllAsync()
    {
        var sql = "SELECT * FROM Book";
        using var connection = _context.CreateConnection();
        var result = (await connection.QueryAsync<Book>(sql)).ToList();
        return result;
    }

    public async Task<int> AddAsync(Book entity){}
    public async Task<int> DeleteAsync(int id){}
    public async Task<Book> GetByIdAsync(int id){}
    public async Task<int> UpdateAsync(Book entity){}
}
```

[Using Dapper with ASP.NET Core Web API](https://www.youtube.com/watch?v=C763K-VGkfc&t=147s)  

---

## コンストラクタ

`Items`クラスのようなクラスとプロパティがあったとして、コンストラクタを定義する時、型と引数の数は一致してないとエラーになる。  
dynamicやobjectや可変引数で受け取ることはできない模様。  

``` cs
using Dapper;
using System.Data.SqlClient;

string constr = @"Server=.\SQLEXPRESS;Database=<db_name>;Integrated Security=True;";
using SqlConnection connection = new SqlConnection(constr);
var query = "SELECT * FROM <table>";
var result = connection.Query<Items>(query);

class Items
{
    public int id { get; set; }
    public string name { get; set; }
    public int price { get; set; }
    public Category category { get; set; }

    // dynamicな可変引数
    public Items(params dynamic[] items)
    {
        _ = items;
    }
    
    // 引数の数は同じでobjectで受け取る
    public Items(object items, object item2, object item3, object item4)
    {
        _ = items;
    }

    // 引数の数は同じでdynamicで受け取る
    public Items(dynamic items, dynamic item2, dynamic item3, dynamic item4)
    {
        _ = items;
    }

    // dynamicで受け取る
    public Items(dynamic items)
    {
        _ = items;
    }

    // 引数が足りない場合エラー
    public Items(int id, string name, int price)
    {
        id = id;
        name = name;
        price = price;
    }
}

// 例外が発生しました: CLR/System.InvalidOperationException
// 型 'System.InvalidOperationException' のハンドルされていない例外が Dapper.dll で発生しました: 'A parameterless default constructor or one matching signature (System.Int32 id, System.String name, System.Int32 price, System.String category) is required for Items materialization'
```
