# 11. コメント 保守と変更の正確性を高める書き方

コメントは読み手にコードの理解を促すために記述する。  
ただし、注意して扱わないとコメントも悪魔と化し、バグの原因になる。  

本省では、どのようなコメントが読み手を混乱させてしまうのかを示す。  
そのうえで、理解を促し、保守や変更の正確性を高めるコメントの仕方を解説する。  

---

## 11.1 退化コメント

ゲームでは、敵の攻撃で毒状態となった時などに、メンバーが苦しそうな表情へ変化するものがよく見受けられる。  
リスト11.1は、メンバーの表情を変更する架空のロジックとする。  

``` java
// リスト11.1
// どういう状態の時に表情変化するかをコメント

// 毒、マヒ状態の場合に、メンバーの顔を苦しそうな表情に変更する。
if (member.isPainful()) {
    face.changeToPainful();
}
```

member.isPainfulメソッドが毒、または麻痺であるかを判定しているものと読める。  
どういったときに表情変化するか、一見親切でわかりやすいコメントのようにも思える。  
しかし、開発が進み、コードが変わっていくなど実装が変遷していくにつれて、コメントへの評価が変化する。  

``` java
// リスト11.2
// よく見るとコメントが不正確

class Member {
    private final States states;

    // 苦しい状態の場合trueと返す。
    // 毒、マヒ状態の場合trueを返す。
    boolean isPainful() {
        if (states.contains(StateType.poison) ||
            states.contains(StateType.paralyzed) ||
            states.contains(StateType.fear)) {
            return true;
        }
        return false;
    }
}
```

ここでも「毒、マヒ状態の場合trueを返す」とコメントされている。  
ところがロジックをよく見てみると、3つの状態を判定している。  
poisonは毒、paralyzedは麻痺、fearは恐怖です。  
恐怖状態についてコメントと異なる。  
実際のコードでも、度々見受けられるこの現象だが、なぜこんなことおが起きるのだろうか。  

それは、コードと比べてコメントはメンテナンスされにくいためである。  
始めの仕様では、isPainfulは毒と麻痺だけを判定の対象としていたとする。  
この時、親切にも、なんの状態を対象とするかコメントされることがある。  
しかし、その後の仕様変更により、恐怖状態が追加されたとき、問題が発生する。  
コードが変わった時、コメントもセットで更新されればいいのだが、忙しかったり、注意が欠けていたりするとコメントのメンテナンスが疎かになってしまうことがある。  

実装と比べてコメントの情報が古くなった時点で、コメントは噓をつき始める。  
このように情報が古くなり、実装を正しく説明しなくなったコメントを**退化コメント**と呼ぶ。  

コメントが偽情報としてふるまうようになるわけなので、読み手が混乱してしまう。  
その結果、バグを埋め込んでしまう可能性がある。  

退化コメントが発生しないよう、実装に合わせてコメントも同時に更新すべきだが、次に示すように注意が必要となる。  

---

### 11.1.1 コメントは劣化コピーに過ぎないことを理解すること

プログラミングに限らず一般的に、コミュニケーション上、会話でも文章でも、どんな形であれ、言葉は話者や聞き手の医師の劣化コピーに過ぎない。  
当然、クラスやメソッドの名前、コメントもすべて劣化コピーとなる。  
伝えたい内容の情報が劣化していく。  
そのため、可能な限り制度よく意図が伝わるようにクラスに命名したり、コメントしたりしなければならない。  

---

### 11.1.2 ロジックの挙動をなぞるだけのコメントは退化しやすい

リスト11.2では、コードの挙動をそのままコメントとして起こしている。  
しかし、劣化コピーの観点から考えると、挙動をなぞるだけのコメントは退化しやすいといえる。  

まず、コード変更するたびにコメントを更新しなければならなくなる。  
isPainfulの例にあるように、恐怖状態のロジック追加に伴い、更新が必要になる。  
うっかり更新を忘れると、ロジックとコメントが乖離する。  

また、ただの伝言ゲームになりがちとなる。  
ロジックをそのまま書き起こしたつもりでも、事実とは異なる内容を書いてしまう可能性がある。  

このように、ロジックの挙動をなぞるだけのコメントは理解にさほど貢献しない上、逆に偽情報が紛れ込んで害をなす可能性があり、役に立たない。  
さらに次のように、コメントすることで命名がないがしろになってしまう場合もある。  

---
---

## 11.2 コメントで命名をごまかす

ついつい書いてしまいがちなよくないコメントをもう一つ上げる。  
次の判定メソッドは何を判定するものなのか、理解できるだろうか。  

``` java
// リスト11.3
// 意図の読み取りが困難なメソッド

class Member {
    private final States states;

    boolean isNotSleepingAndIsNotParalyzedAndIsNotConfusedAndIsNotStoneAndIsNotDead() {
        if (states.contains(StateType.poison) ||
            states.contains(StateType.paralyzed) ||
            states.contains(StateType.confused) ||
            states.contains(StateType.stone) ||
            states.contains(StateType.dead) ) {
            return false;
        }
        return true;
    }
}
```

これは、プレーヤーの指示通りにメンバーが行動可能かを判定するメソッドとなる。  
RPGでは、睡眠、マヒ、混乱など、プレイヤーの指示通りに行動できないくなる状態がある。  
このメソッドでは、状態を調べて行動可能かを判定している。  
しかし、メソッド名からはさっぱり意味が伝わってこない。  
この手の意味が伝わりにくいメソッドでは、意味を再説明するコメントが書かれがちになる。  

``` java
// リスト11.4
// ロジックの挙動を再説明したコメント

// 睡眠、マヒ、混乱、石化、死亡以外のとき行動可能
boolean isNotSleepingAndIsNotParalyzedAndIsNotConfusedAndIsNotStoneAndIsNotDead() {
```

再説明すると何が起こるだろうか。  
それは前節でも説明した通り、コメントが退化しやすくなるのだ。  
このコメントの仕方では、行動不能になる状態として「恐怖」が追加された場合など、わざわざコメントを更新しなければならなくなる。  
また、メソッド名に「恐怖」を意味する文言が入っていないため、実装と乖離してしまう。  

このようなダメなメソッドに対してコメントで補足説明するのではなく、メソッド名自体をブラッシュアップすべき。  

``` java
// リスト11.5
// メソッド名自体をブラッシュアップする

class Member {
    private final States states;

    boolean canAct() {
        // 行動不能の仕様が変更された場合、
        // 本ロジックの変更を検討すること。
        if (states.contains(StateType.poison) ||
            states.contains(StateType.paralyzed) ||
            states.contains(StateType.confused) ||
            states.contains(StateType.stone) ||
            states.contains(StateType.dead) ) {
            return false;
        }
        return true;
    }
}
```

メソッドの可読性を上げることで、再説明のコメントが不要となり、退化コメントが発生しにくくなる。  

---
---

## 11.3 意図や仕様変更時の注意点を読み手に伝えること

コードはいつ、どういう目的で読まれるだろうか。  
機会として最も多いのは、保守と仕様変更時だろう。  

コード保守の際、読み手が気にするのは「このロジックはどういう意図で動いているか」となる。  
仕様変更の際、読み手が気にするのは「何に注意すれば安全に変更できるか」となる。  

これらの課題を解決できるように、意図や仕様変更時の注意点をコメントする。  

``` java
// リスト11.6
// 意図や仕様変更時の注意点をコメントしよう

class Member {
    private final States states;

    // 苦しい状態の場合trueを返す。
    boolean isPainful() {
        // 今後仕様変更で状態異常による表情変化が追加される場合、
        // 本メソッドへロジック追加すること。
        if (states.contains(StateType.poison) ||
            states.contains(StateType.paralyzed) ||
            states.contains(StateType.fear) ) {
            return true;
        }
        return false;
    }
}
```

---
---

## 11.4 コメントのルールまとめ

コメントについてのルールをまとめると、表11.1になる。  

表11.1 コメントルール
|ルール|理由|
|:-|:-|
|ロジック変更時、同時に必ずコメントも変更すること。|コメントを変更しないと、ロジックと乖離した「退化コメント」が生じ、</br>読み手が混乱するため。|
|ロジックの内容をなぞるだけのコメントをしない事。|あまり可読性に貢献しない上、コメントのメンテナンスが大変になるため。</br>退化コメントも発生しやすい。|
|可読性の悪いロジックを補足説明するようなコメントをしないこと。</br>代わりにロジックの可読性を高めること。|コメントのメンテナンスが大変になるため。</br>退化コメントも発生しやすい。|
|ロジックの意図や仕様変更時の注意点をコメントすること。|保守や仕様変更時の助けになる。  |

---
---

## 11.5 ドキュメントコメント

プログラミング言語には、ドキュメントコメントの仕様を持つものがある。  
ドキュメントコメントとは、コメント記法の一種で、フォーマットに従って記述すると、APIドキュメントの生成や、ソースコードエディタ上でコメント内容のポップアップ表示ができるものである。  
例えば、JavaではJavadoc、C#ではDocumentation comments、RubyではYARDが用意されている。  

JavaのJavadocの例に説明する。  
リスト11.7のソースコードでは`/**`から`*/`までの範囲がJavadoc形式のコメントとなる。  
addメソッドの説明に対応するものだ。  

``` java
// リスト11.7
// Javadoc形式で書かれたコメント

class Money {
    // 中略

    /**
     * 金額を加算する
     *
     * @param other 加算する金額
     * @return 加算後の金額
     * @throws IllegalArgumentException 通貨単位が異なる場合スロー
     */
    Money add (final Money other) {
        if (!currency.equals(oter.currency)) {
            throw new IllegalArgumentException("通貨単位が違います。");
        }
        int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

`@param`や`@return`といった`@`付きの要素はJavadocタグとなる。  
Javadocタグを使うと、引数や戻り値などに対応する説明をコメントできる。  

表11.2 Javadocタグの例
|Javadocタグ|用途|
|:-|:-|
|@param|引数の説明|
|@throws|スローする例外の説明|
|@return|戻り値の説明|

このようにフォーマットにのっとってコメント記述すると、APIドキュメントを自動生成できる。  
また、それだけではなく、エディタ上でカーソルを合わせると、コメント内容をポップアップ表示できる。  
メソッド定義位置にジャンプしなくても、メソッド呼び出し側で説明コメントを参照できるようになり、可読性が飛躍的に高まる。  

C#のDocumentation commentsやRubyのYARDでも同様の機能が提供されている。  
開発効率、特にコードの保守に大きく効果を発揮するため、使いこなすべし。  
