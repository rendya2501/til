# 12. 関数(メソッド) 良きクラスには良きメソッドあり

## 12.1 必ず自身のクラスのインスタンス変数を使うこと

インスタンス変数を安全に操作するようメソッドを設計することで、クラス内の正常性を担保できる仕組み。  

メソッドはからなず自身のクラスのインスタンス変数を使うように設計すべし。  
例外もまれにあるが、これが原則。  

``` java
// リスト5.4
// 引数の変更をしている

class  ActorManage{
    void shift (Location location,int shiftX,int shiftY){
        location.x += shiftX;
        location.y += shiftY;
    }
}
```

リスト5.4のように、他のクラスのインスタンス変数を変更するメソッド構造にしてはいけない。  
低凝縮に陥ってしまう。  

他のクラスのインスタンス変数を変更するメソッドを書きたくなった場合、変更したいインスタンス変数を持つクラスに変更メソッドを実装すべし。  

---
---

## 12.2 不変をベースに予期せぬ動作を防ぐ関数にすること

可変なインスタンス変数などを変更する関数(メソッド)は、意図せず別の個所に影響を及ぼし、予測しない動作が生じる場合がある。  
結果の予測が難しく、保守が大変になる(4.2.2参照)。  

不変による堅牢性を活かして、予期せぬ動作を防ぐメソッドを設計すべし(4.2.5参照)。  

---
---

## 12.3 尋ねるな、命じろ

5.6の`equipArmor`メソッドのように、あるクラスがよそのクラスの状態を判断したり、状態に応じて、よその値を変更したりする、「よそのクラスを気にしたりいじったりするメソッド構造」は低凝縮構造となる。  

getter/setterは「よそのクラスを気にしたりいじったりするメソッド構造」に陥りやすく、開発生産性がよくないソフトウェアのソースコードでは頻繁に見受けられる。  

メソッドの呼び出し側で複雑な処理をさせるのではなく、「尋ねるな、命じろ」の考えのもと、5.6.1の`Equipments`クラスのように、呼び出されるメソッド側で複雑な制御をするよう設計すべし。  

---
---

## 12.4 コマンド・クエリ分離

リスト12.2のメソッドは状態の変更と取得を同時に行っている。  

``` java
// リスト12.2
// 状態の変更と取得を実行している

int gainAndGetPoint() {
    point += 10;
    return point;
}
```

状態の変更と取得を同時に行うメソッドは、混乱しやすい上に、利用者にとっても使いにくいもの。  
取得だけしたい、変更だけしたいケースに対応できず、良いことがない。  

メソッドはコマンド(=変更) またはクエリ(=問い合わせ) のどちらか一方だけを行うように設計する。  
これが**コマンド・クエリ分離(CQS)**と呼ばれる考え方。  

メソッド種別  

|メソッド種別|説明|
|:-|:-|
|コマンド|状態を変更する|
|クエリ|状態を返す|
|モディファイア|コマンドとクエリを同時に行う|

リスト12.2のコードはコマンドとクエリを同時に行うモディファイアとなる。  
モノによってはモディファイアで作らざるを得ないメソッドがあるが、例外的なものとしてなるべく避けるべき。  

コマンド・クエリ分離の考え方に従って、`gainAndGetPoint`をコマンドとクエリに分離した場合は、リスト12.3のようになる。  

``` java
// リスト12.3
// コマンドとクエリを別々のメソッドに分離

// ポイントを増やす(コマンド)
void gainPoint() {
    point += 10;
}

// ポイントを返す(クエリ)
int getPoint(){
    return point;
}
```

---
---

## 12.5 引数

引数は入力値として用いる。  

---

### 12.5.1 引数は不変にすべし

引数を変更すると値の意味が変わり、どんな意味なのか推測が困難になる。  
また、どこで変更されたのか分かりにくくなる。  

引数にはconst等、不変の修飾子を付与し、イミュータブルにすべし。  
引数を変更したい場合は、不変なローカル変数を用意し、そのローカル変数に変更値を代入する実装にすべし。  

---

### 12.5.2 フラグ引数は使わない

6.6のフラグ引数付きのメソッドは、何が起こるか読み手に想像を難しくさせる。  
何が起こるのか理解するには、メソッド内部のロジックを見に行かなければならず、可読性が低下する。  

ストラテジーパターンを使うなど、別の機能切り替え機構に設計を修正すべし。  

---

### 12.5.3 nullを渡さない

nullを前提としたロジックは、`NullPointerException`によるトラブルや、nullチェックによる複雑化等、様々な弊害を招く(9.6参照)。  

引数にnullを渡さない設計にすべし。  

nullを渡さない設計にするためには、nullに意味を持たせないようにする。  
例えば、9.6.1の例のように、未装備状態をnullではなく`Equipment.EMPTY`で表現する等。  

---

### 12.5.4 出力引数は使わない

5.4のように、出力引数を使うと低凝縮構造に陥る。  
引数は入力値として用いるのが基本。  
出力値として用いると読み手が混乱する。  

可読性低下の原因となるので、出力引数は使わないようにする。  

---

### 12.5.5 引数は可能な限り少なくする

引数は可能な限り少なくなるよう設計すべし(5.5参照)。  

多くの引数を使いたいメソッドでは、引数を使う分だけ処理内容が増大することを意味する。  
処理内容が増えるとロジックが複雑化し、様々なバグの温床となる。  

引数が多くなりそうな場合、5.5の`MagicPoint`クラスのように、別クラスへの分割を検討すべし。  

---
---

## 12.6 戻り値

戻り値の設計における注意点のまとめ。

---

### 12.6.1 「型」を使って戻り値の意図を表明すること

リスト12.4の`Price.add`メソッドは価格を返しているが、`int`型である。  
int型のような単純なプリミティブ型では、returnされた後に意図がわからなくなりがちになってしまう。  

``` java
// リスト12.4
// プリミティブ型では意図が不明瞭になる

class Price{
    int add(final Price other){
        return amount + oter.amount;
    }
}
```

リスト12.5ではproductPriceはPrice型であり、addメソッドでint型の価格を返している。  
ところが、他の割引金額や配送料までint型で表現されている。  

金額計算では、ある金額が別の金額計算に使われるなど、様々な種類の金額を一度に扱うことが多い。  
int型を返す作りでは、どの値が何の金額なのかわからなくなってくる。  

``` java
// リスト12.5
// どれがどの金額かわかりにくくなる

int price = productPrice.add(otherPrice); // 商品価格の総額
int discountedPrice = calcDiscountedPrice(price); // 割引金額
int delivertPrice = calcDeliveryPrice(disountedPrice); // 配送料
```

不注意から、配送料と商品価格を間違えてしまうこともあり得る。  

``` java
// リスト12.6
// 値の渡し間違え

// 配送手数料 DeliveryChargeには配送料が渡されるべき。
// しかし、商品価格の総額が渡されてしまっている。
DeliveryCharge deliveryCharge = new DeliveryCharge(price);
```

プリミティブ型を使わず、独自の型を使って、戻り値の意図を明確に表明することが大切。  

リスト12.7では`add`メソッドで`Price`型を返す。  
価格を返す意図が明確に伝わる。  

``` java
// リスト12.7
// 価格を返すことが明瞭

class Price {
    Price add (final Price other){
        final int added = amount + other.amount;
        return new Price(added);
    }
}
```

同様に、他の金額についても独自の型として作ると、より意図が明瞭になる。  
型が違うため、値を取り違えた場合にコンパイラで弾くことができる。  

``` java
// リスト12.8
// 金額の種類が一目瞭然

Price price = productPrice.add(otherPrice);
DiscountedPrice discountedPrice = new DiscountedPrice(price);
DeliveryPrice deliveryPrice = new DeliveryPrice(discountedPrice);
```

---

### 12.6.2 nullを返さない

引数にnullを渡さないのと同様に、nullを返さないようにする。  

---

### 12.6.3 エラーは戻り値で返さない、例外をスローすること

リスト12.9は問題のあるエラー処理。  

``` java
// リスト12.9
// エラーをLocation型の特定の状態で表現している

// 位置を表現するクラス
class Location {

    // 位置を移動する
    Location shift(final int shiftX,final int shiftY){
        int nextX = x + shiftX;
        int nextY = y + shiftY;
        if (valid(nextX,nextY)) {
            return new Location(nextX,nextY);
        }
        // (-1,-1)はエラー値
        return new Location(-1,-1);
    }
}
```

Location.shiftは位置を移動させるメソッドだが、移動後の座標が有効でない場合、エラー値として`Location(-1,-1)`を返している。  

この実装だと、エラー値として`Location(-1,-1)`を返す仕様を呼び出し側が知っている必要があり、さらに呼び出し側でエラー処理を確実に実装する必要がある。  
エラー実装を忘れると、`Location(-1,-1)`は後続の処理で正常値として扱われてしまい、バグになる。  

ある値に複数の意味を持たせることを**ダブルミーニング**という。  
`Location(-1,-1)`のように、取りえる値の一部を座標ではなく、エラーとして扱うのはダブルミーニングとなる。  
ダブルミーニングは状況によって意味が異なるため、どう解釈するか読み手が混乱する。  

また、状況判断のための条件分岐があちこちに増える。  
`Location(-1,-1)`か同課を判定し、エラー処理へ分岐させる実装が散らばってしまう。  
ロジックが複雑化してしまうことになるため、ダブルミーニングは避けるべし。  

9.7.2のとおり、不正状態に対して寛容になるべきではない。  
戻り値でエラーを返すのではなく、例外をスローする。  

``` java
// リスト12.10
// エラーは例外をスローする形にする

// 位置を表現するクラス
class Location {

    Location(final int x,final int y) {
        if (!valid(x,u)) {
            throw new IllegalArgumentException("不正な位置です");
        }
        this.x = x;
        this.y = y;
    }

    // 位置を移動する
    Location shift(final int shiftX,final int shiftY){
        int nextX = x + shiftX;
        int nextY = y + shiftY;
        return new Location(nextX,nextY);
    }
}
```

---
---

## コラム

### メソッドの名前設計

メソッドの構造的問題が、名前として表出するものがある(10章参照)。  

「動詞 + 目的語」のメソッド名(10.6.1)は、責務外のロジック実装を誘発する命名。  
可能な限り動詞1語になるようメソッド、およびクラスを設計すべし(10.6.2)。  

他には、不適切な居場所のboolenaメソッド(10.6.3)も注意が必要。  

---

### static メソッドの扱いに注意

staticメソッドは、自身のクラスのインスタンス変数操作できない(5.1)。  
データとデータを操作するロジックがバラバラになり、低凝縮の原因になりがち。  

staticメソッドの仕様は、ファクトリメソッド(5.2.1)や、横断的関心毎(5.3.3)など、低凝縮の心配がないケースに限定すべし。  
