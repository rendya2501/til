# 9. 設計の健全性を損なう様々な要因

- デッドコード  
- YAGNI原則  
- マジックナンバー  
- 文字列型執着  
- グローバル変数  
- null問題  
- 例外の握り潰し  
- 設計秩序を破壊するメタプログラミング  
- 技術駆動パッケージング  
- サンプルコードのコピペ  
- 銀の弾丸  

---
---

## 9.1 デッドコード

``` java
// リスト9.1
// デッドコード

if (level > 99) {
    level = 99;
}

// 中略

if (level == 1) {
    // メンバーのヒットポイントや装備などを初期化する
} else if (level == 100) {
    // レベル100ボーナスとして、固有の特別能力を付与する
    addSpecialAbility();
}
```

addSpecialAbilityは実行されることはない。  
このように、どんな条件であっても、決して実行されないコードを**デッドコード**、または**到達不能コード**と呼ぶ。  
この悪魔はおとなしいように見えて、様々な弊害をもたらす。  

まず、コードの可読性が低下する。  
コードの読み手がデッドコードの周辺を読むたびに、どういう条件で実行されるかを読み手の考えさせてしまう。  
実際には実行されないにも関わらずである。  
また、なぜ実行されないようなコードが残っているのか、何か意図があるのでは？と、読み手を混乱させる場合がある。  

また、将来バグになる可能性もある。  
これまで到達不能だったものが、なんらかの仕様変更により、デッドコード周辺のロジックが変わり、到達可能になる場合がある。  
ゾンビのように読みがってしまうのだ。  
蘇ったコードが仕様と異なっていればバグになる。  

デッドコードは、発見次第すぐに削除しよう。  
Gitを使っていれば、変更履歴を管理できるので、コードを消すことに不安を覚える必要はない。  

---
---

## 9.2 YAGNI原則

フィクションでは、「こんなこともあろうかと」のセリフとともに、科学者や技術者がリスクを予見して下準備しておいた予備機能を発動させ、危機を乗り越えるというシーンがある。  
実際の開発においても、将来の仕様を予見し、ついつい先回りして作りこんでしまうことがあるだろう。  
しかし、先回りで実装されたロジックは、現実にはほとんど使われないばかりか、バグの原因になるなど、悪魔化することが多い。  

**YAGNI**と呼ばれるソフトウェア原則がある。  
「You aren't going to need it.」
「必要ないでしょう」の意味になる。  
実際に必要になったときにのみ実装せよ、という方針だ。  
では、YAGNI原則を守らず先回りして作ると何が起こるのか？  

ソフトウェアに対する要求は日々変化している。  
仕様として確定しておらず、明確に言語化もされていない要求に対して実装しても、ほとんどの場合予測は外れる。  
予想が外れ使わなくなったロジックは、デッドコードになる。  
また、先回りで作られたロジックは、往々にして複雑である。  
可読性が低下し、読み手を混乱させる。  
何かの変更をきっかけに実行されるとバグになる可能性が非常に高い。  
なぜなら先回りで作られたロジックは仕様にないためである。  

先回りで作りこんだ分だけ時間が無駄になる。  
今必要な機能だけを作り、構造をシンプルにしよう。  
可読性が高くなり、保守や変更が容易になる。  
無駄な工数がかからなくなり、もっと重要な仕事に取り組めるようになる。  

---
---

## 9.3 マジックナンバー

説明なき数値は、開発者を混乱させる。  
以下のコードはWebコミックサービスにおける架空のコードである。  

``` java
// リスト9.2
// マジックナンバー

class ComicManager {
    // 中略
    boolean isOK() {
        return 60 <= value;
    }

    void tryConsume() {
        int tmp = value - 60;
        if (tmp < 0) {
            throw new RuntimeException();
        }
        value = tmp;
    }
}
```

複数の個所で60が登場している。  
いったい何の数値なのだろうか。  

この60は、無料でWebコミックをお試し購読するときに消費するポイントとなる。  
そしてisOkメソッドはお試し購読可能かどうかを返すメソッドで、tryConsumeメソッドはお試し購読により購読ポイントを消費するメソッドとなる。  
ここまで説明しないと、60の意図がほとんどわからない。  

このようにロジック内に直接書き込まれている意図不明な数値を**マジックナンバー**と呼ぶ。  
マジックナンバーは実装者本人にしかほとんど意図を理解できない。  
また、同一のマジックナンバーは複数の個所で実装されがちで、重複コードを生み出す。  
仕様変更でお試し購読の消費ポイントが60から50に変更されたら、マジックナンバーの実装箇所全てを修正しなければならなくなる。  
修正漏れがあるとバグになる。  

マジックナンバーを書かないようにするためには、定数として定義しよう。  
次のコードは、コミックの購読ポイントを値オブジェクトとして設計したものである。  
そしてこのReadingPointクラス内で、お試し購読の消費ポイントを定数`TRIAL_READING_POINT`として定義している。  

``` java
// リスト9.3
// static final な定数として数値の意味を表現する

// コミックの購読ポイント
class ReadingPoint {
    // ポイントの最小値
    private static final int MIN = 0;

    // お試し購読の消費ポイント
    private static final int TRIAL_READING_POINT = 60;

    // 購読ポイント
    final int value;

    // コミックの購読ポイントReadingPointのコンストラクタ
    // @param value 購読ポイント
    ReadingPoint(final int value) {
        if (value < MIN ) {
            throw new IllegalArgumentException();
        }
        this.value = value;
    }

    // お試し可能かどうかを返す
    // @return お試し購読可能の場合true
    boolean canTyrRead() {
        return TRIAL_READING_POINT <= value;
    }

    // お試し購読する
    // @return お試し購読後のポイント
    ReadingPoint consumeTrial() {
        return new ReadingPoint(value - TRIAL_READING_POINT);
    }

    // 購読ポイントを追加する。
    // @param point 追加ポイント
    // @return 追加後のポイント
    ReadingPoint add (final ReadingPoint point) {
        return new ReadingPoint(value + point.value);
    }
}
```

---
---

## 9.4 文字列型執着

次のコードでは、単一のString変数に複数の値をカンマ区切りで格納している。  
こうした変数を、splitメソッドを使って、頑張って分解して値を取り出すといったことをしているものがある。  

``` java
// リスト9.4
// 単一のString変数に複数の値を格納

// ラベル文字、表示色(RGB)、上限文字数
String title = "タイトル,255,250,240,64";
```

読み込んだCSVからデータを取り出すためにsplitメソッドを使うケースはある。  
しかし、そういった用途もないのに、意味の異なる複数の値をString変数に無理に付け込むと、意味がわかりにくくなり、splitメソッドなどでロジックが無駄に複雑化して、可読性が著しく低下する。  

これはプリミティブ型執着(5.5.1)が先鋭化し、クラス追加どころか変数の追加まで嫌がる場合に陥りがちになる。  
意味の異なる値は、それぞれ別の変数に格納すべし。  

---
---

## 9.5 グローバル変数

どこからでもアクセス可能な変数を**グローバル変数**と呼ぶ。  

``` java
// リスト9.5
// グローバル変数

public OrderManager {
    public static int currentOrderId;
}
```

Javaの言語仕様には、グローバル変数はない。  
しかし、変数をpublic static宣言することでグローバルアクセス可能となる。  
どこからでも参照、操作可能な変数であるため、一見扱いやすいと思うかもしれないが、実態はその逆である。  

多くのロジックでグローバル変数を参照し、値を変更していると、どこで、どのタイミングで値が書き変わったのか把握が非常に困難になる。  
グローバル変数を参照しているロジックに変更が入りそうなら、他にグローバル変数を参照しているロジックにバグが生じないか、慎重に検討しなければならない。  

検討の結果、排他制御が必要な場合も生じる。  
排他制御は慎重に設計しないと、ロック時間が長くなってパフォーマンスが低下する。  
排他設計の誤りにより、デッドロックに陥る可能性もある。  

グローバル宣言された変数だけがグローバル変数の「性質」を持つとは限らない。  
巨大データクラス(8.2.7)もグローバル変数としての「性質」を非常に帯びやすい。  
様々なデータを保有しているために、多くの個所から参照されやすいためである。  
さらに排他制御に関しては、巨大データクラスはグローバル変数より悪質である。  
排他制御したいインスタンス変数が１個であっても、他のインスタンス変数までロックされてしまうため、パフォーマス上大きな問題となる。  

設計が不十分なシステムでは、巨大データクラスが非常に生み出されやすい。  
**グローバル変数を使っていなくとも、グローバル変数と同質のものを知らず知らずのうちに使っていることになる。**  

大変陥りがちなポイントであるため、注意すべし。  

---

### 9.5.1 影響範囲を最小化するよう設計すること

グローバル変数(および巨大データクラス)は、影響範囲が広すぎる。  
多くの個所から呼び出し可能な構造/呼び出されやすい構造となる。  

影響範囲が最小化するように設計すべし。  
無関係なロジックからはアクセスできないように設計すべし。  
呼び出し化h租が少なく、局所化されているほど、ロジックの理解が容易になる。  
正しく動作するロジックを実装しやすくなる。  

どうしてもグローバル変数を使いたい場合は、必要性をよく検討すべし。  
グローバル変数を参照したい箇所はそれほど多くないのではなかろうか？  
可能な限りグローバル変数にはせず、限られたクラスだけがアクセス可能なように設計すべし。  

---
---

## 9.6 null問題

次のコードは、装備防具の防御力をすべて加算した、総合防御力を返すメソッドである。  
防具はhead,body,armの3カ所があり、それぞれは防具を表すEquipmentクラスとなる。  

``` java
// リスト9.6
// 装備防具と防御力を行減するロジックの一部

class Member {
    private Equipment head;
    private Equipment body;
    private Equipment arm;
    private int defence;

    // 中略

    // 防具の防御力を加味した総合防御力を返す
    int totalDefence() {
        int total = defence;
        total += head.defence;
        total += body.defence;
        total += arm.defence;
        return total;
    }
}
```

しかし、このコードを実行すると、NullPointerExceptionがスローされてしまう場合がある。  
次に示すように、防具を装備していない状態をnullで表現していたためである。  

``` java
// リスト9.7
// 装備していない状態をnullで表現している

class member {
    // 中略

    // すべての防具を外す
    void takeOffAllEquipments() {
        head = null;
        body = null;
        arm = null;
    }
}
```

この前提で例外がスローされないためには、nullであるかの判定が必須となる。  
totalDefenceメソッドにおいて、`+=`する前に`head != null`などの判定を加えれば例外はスローされなくなる。  
しかし、いちいちこんなことを記述する時点で効率が悪い。  
でもって、他のメソッドでもスローされることが分かったとしたらどうだろうか。  
他の個所でも同じようにnullチェックを入れる必要があるだろうか？  

これでいいわけがない。  
nullが入り込む前提でロジックを組むと、いたるところでnullチェックしなければならなくなる。  
nullチェックだらけでコードの見通しが悪くなるし、nullチェックが漏れるとバグになる。  

そもそもnullとは何だろうか。  
未初期化状態のメモリ領域へのアクセスは制御上トラブルの原因となる。  
こうした事態を避けるためにnullが発明された。  
nullは最低限メモリアクセストラブルを防止するための仕組みであって、null自体は無効な扱いとなる。  

しかし、防具を装備していない状態をnullで表現している例と同様に、商品名が未設定の状態、商品の配送先が未設定の状態など、主に未設定状態をnullとして実装しているコードが世の中に多く存在する。  
何かを持っていない状態や未設定状態も、立派な状態なのだ。  
いわば、その状態すら存在していないのがnullである。  
nullは多大な損失を生みかねない。[^1]  

[^1]こうしたnullに伴う脆弱性やシステムクラッシュにより、10億ドルにのぼる損害を引き起こしたとして、nullを発明したアントニー・ホーア氏が謝罪している。  

---

### 9.6.1 nullを返さない、渡さない

null例外によるトラブルやnullチェックを避けるために、そもそもnullを取り扱わない設計にすることが大事になる。  
具体的には次を満たす設計にする。  

- nullを返さない。  
- nullを渡さない。  

nullを返さない設計とは、メソッドの戻り値としてnullをreturnしない事である。  
nullを渡さない設計とは、nullを変数に代入しない事である。  

防具の例では、装備していない状態をnullとして表現していた。  
nullではなく、Equipment型のstatif finalなインスタンス変数EMPTYとする。  
「装備なし」も立派な状態である。  

``` java
// リスト9.11
// 「装備なし」をnulllで表現しない方法で実現

class Equipment {
    static final Equipment EMPTY = new Equipment("装備なし",0,0,0);

    final String name;
    final int price;
    final int defence;
    final int magicDefence;

    Equipment(final String name, final int price, final int defence, final int magicDefence) {
        if (name.isEmpty()) {
            throw new IllegalArgumentException("無効な名前");
        }
        this.name = name;
        this.price = price;
        this.defence = defence;
        this.magicDefence = magicDefence;
    }

    // リスト9.12
    // 防具を外す場合、EMPTYを代入する
    void takeOffAllEquipments() {
        head = Equipment.EMPTY;
        boyd = Equipment.EMPTY;
        arm = Equipment.EMPTY;
    }
}
```

``` mermaid
---
title: 図9.2 nullを使わない状態設計
---
classDiagram
    class Member {
        - defence int

        totalDefence() int
        takeOffAllEquipments() void
    }
    class Equipment {
        EMPTY Equipment$
        name String
        price int
        defence int
        magicDefence int

        Equipment(name : String , price : int , defence : int , magicDefence : int)
    }

    Member --> Equipment : 関連
```

このように、装備なし状態も含めてhead,body,armに常にインスタンスが存在するようにしておけば、null例外で落ちる心配がなくなる。  
nullチェックも不要となる。  

---

### 9.6.2 null安全

null安全とは、nullが原因のエラーを発生させない仕組みのことを言う。  
一部のプログラミング言語には、null安全の仕様を持つものがある。  

null安全を実現する機能の一つに、**null非許容型**がある。  
null非許容型とは、nullを保持できない型のことである。  
Kotlinは、デフォルトでnull非許容。
nullを代入しようとするコードはコンパイルエラーとなる。  

``` Kotlin
// リスト9.13
// kotlinではnull非許容がデフォルト

val name: String = null; //コンパイルエラーとなる。
```

null安全の機能があるなら、積極的に利用すべし。  

---
---

## 9.7 例外の握り潰し

次のコードは、ECサイトにおいて商品を予約するコードとなる。  

``` java
// リスト9.14
// 例外をcatchして何もしていない

try {
    reservations.add(product);
}
catch (Exception e) {
}
```

addメソッドは予約リストへの商品追加において、何らかの原因で予約が失敗した時に例外をスローする仕様。  
しかし、このコードではtry catchで例外をキャッチしても、何の処理もしていない。  
これは**例外の握り潰し**と呼ばれる、極めで極悪なロジックとなる。  

---

### 9.7.1 原因分析困難に陥り開発者を疲弊させる

例外を握り潰すことの問題は、エラーが起こっても、外から検知する術がなくなってしまうことにある。  
内部的にはデータが壊れるなど、不正状態に陥っているものの、外からは何の問題もなく動いているように見えてしまう。  
壊れたデータに基づき、さらに別の壊れたデータが連鎖的に作られてしまう可能性すらある。  

そうした不正は発生してすぐにではなく、しばらくしたのち、サービスの利用者によって発見・報告されることが多い。  
この予約の例なら「予約リストが変だ」「予約取り扱いできない商品の予約依頼が来ている」といった報告かもしれない。  

インシデント報告があってから開発側で原因調査することになる。  
例外を握りつぶしているせいで、いつ、どのタイミングで、なんのコードが原因で不正状態になったのかわからない。  
データベースのレコードや各種ログ、関連しそうなコードを目を皿のようにして追っていかなければならなくなる。  
開発者の時間と体力を著しく浪費させることになりかねない。  

---

### 9.7.2 問題検出時にけたたましく叫ばせる

こうした恐ろしい事態を避けるためにも、不正状態に対して寛容になるべきではない。  
状態が不正なまま通常処理を続行するのは、爆弾の導火線に火がついているのも知らずに、爆弾をもってウロウロ歩き回るのと同じことだ。  
導火線の火に即座に気が付き、消し止めなければならない。  

以上にはすぐに気づける仕組みにすべし。  
例外をキャッチした時には、通知や記録、場合によってはリカバリ処理を実行する。  

エラーをどう設計するかについてはユースケースや発生リスクに応じて多岐にわたるため、ここでは解説しない。  
商品予約の例では、catch句のスコープに、少なくともログへの記録や、上位レイヤーのクラスに対してエラー通知を要求するロジックを実装すべきである。  

``` java
// リスト9.15
// 確実にエラー検知できるようにする


try {
    reservations.add(product);
}
catch (Exception e) {
    // エラー報告し、ログへ記録する
    reportError(e);
    // 上位レイヤーに対してエラー通知を要求する
    requestNotifyError("予約できない商品です");
}
```

ガード節(3.2.1)付きコンストラクタも不正を許さない設計となっている。  
コンストラクタに不正なデータが渡された段階で例外がスローされ、不正データを持ったインスタンスが存在できない仕組みとなっている。  
問題検出時にけたたましく叫ぶ上、不正に対し頑強な構造である。  

---
---

## 9.8 設計秩序を破壊するメタプログラミング

プログラム実行時に、そのプログラムの構造自体を制御するプログラミングをメタプログラミングと呼ぶ。  
メタプログラミング技術の一つとして、C#やJavaではクラス構造を読み書きできる機構としてリフレクションが用意されている。  

メタプログラミングは、通常のプログラミングではできないアクセスを可能にするなど、裏技的なことができる。  
故に一部では黒魔術などと呼ばれている。  
しかし、用法や意図を理解せずに使うと、設計が台無しになってしまう危険性がある。  

---

### 9.8.1 リフレクションによるクラス構造および値の変更

以下のプログラムは、ゲームにおいてメンバーのレベルを表現する値オブジェクトのLevelクラスとなる。  

``` java
// リスト9.16
// メンバーのレベルを表現するクラス

class Level {
    private static final int MIN = 1;
    private static final int MAX = 99;
    final int value;

    private Level (final int value) {
        if (value < MIN || MAX < value) {
            throw new IllegalArgumentException();
        }
        this.value = value;
    }

    // 初期レベルを返す
    static Level initialize() {
        return new Level(MIN);
    }

    // レベルアップする
    Level increase() {
        if (value < MAX) return new Level(value + 1);
        return this;
    }
}
```

このクラスのインスタンス変数valueはfinal修飾子が付与され、後から変更ができないようになっている。  
レベルは1~99の範囲で有効であることが定数で定められ、ガード節で無効値を弾くようにもなっている。  
increaseメソッドにより、レベルは1ずつ上昇する仕組みとなっている。  
不正なレベル値が入り込むスキがないように見えるが、以下のコードを実行すると、期待した動作を満たさない。  

``` java
// リスト9.17
// リフレクションを用いた値の書き換え

Level level = Level.initialize();
// Level : 1

Field field = Level.class.getDeclaredField("value");
field.setAccessible(true);
field.setInt(level,999);
// Level : 999
```

不変であるはずのインスタンス変数valueの値が書き変わってしまった。  

リフレクションを使うと、finalで不変にした変数を可変にしたり、privateインスタンス変数を外部から変更できたりしてしまう。  
やり方によっては定数も書き換え可能。  

リフレクションを濫用すると、不正状態を防護する設計や、影響範囲を閉じ込める設計が全く意味をなさなくなってしまう。  

---

### 9.8.2 型の強みを生かせなくなるハードコード

Javaに代表される静的型付け言語は、静的解析により性格にコード分析可能なのが強みとなる。  
しかし、メタプログラミングはそうした型の強みを打ち消してしまう。  

リスト9.19のようなUserクラスがあったとする。  

``` java
// リスト9.19
// Userクラス

package customer;

class User {
    // 省略
}
```

クラスのインスタンス生成には、普通はnewキーワードを用いるが、リフレクションを使うとメタ情報からインスタンスを生成できる。  
リスト9.20に示すgenerateInstanceメソッドは、パッケージ名とクラス名を文字列で与えると、そのクラスのインスタンスを生成して返す。  

``` java
// リスト9.20
// メタ情報からインスタンスを生成

// クラス名を指定してインスタンス生成する
// @param packageName パッケージ名
// @param className インスタンス生成したいクラス名
// @return 指定したクラスのインスタンス
static Object generateInstance(String packageName, String className) throws Exception {
    String fillname = packageName + "." + className;
    Class klass = class.forName(fillName);
    Constractor constructor = klass.getDeclaredConstructor();
    return constructor.newInstance();
}

// リスト9.21
// メタ情報からUserクラスのインスタンスを生成
User user = (User)generateInstance("customer", "User");
```

IntelliJ IDEA などの IDE には、クラスやメソッドなどの名前を一括で変更してくれる機能がある。  
Userクラスの名前をEmployerに変更するとした場合、IDEの名前変更機能を使うと、Userを参照している箇所を、すべて漏れなく正確に変更してくれる。  

しかし、メタ情報から生成したクラスに対しては、名前変更機能を用いても、思ったように名前変更できない。  
名前変更機能でUser型はEmployer型に変更されるが、generateInstanceメソッドに渡される文字列"User"は書き変わらない。  

``` java
// リスト9.22
// 文字列としての「User」まで書き変わらない

Employer user = (Employer)generateInstance("customer", "User");
```

このコードはコンパイルエラーとならないが、実行時には該当するクラスが存在しないためエラーになる。  
IDEの静的解析により、どのクラスがどこから参照されているのか正確に分析できる。  
そのため、名前変更機能は参照しているすべての個所を一括で変更できる。  
ところが、単純に文字列としてハードコードされた"User"は、User型に関係するものだと認識されない。  
そのため、名前変更の対象とならない。  

IDEの静的解析は、名前変更機能のほかに、定義元へのジャンプや参照箇所の全検索など、開発の効率化や正確性向上に役立っている。  
メタプログラミングの濫用は、こういった開発上の利点を殺してしまう。  

---

### 9.8.3 デメリットを理解し用途を限定すること

メタプログラミングが使えると特別な能力を身に着けたかのような気分になってしまうかもしれない。  
しかし、デメリットを理解しないとメンテナンスや変更が本当に困難になる。  
「黒魔術」とはよく言ったもので、失敗すると凶悪な悪魔を呼び寄せ破壊してしまう。  

システム解析用途に限定する、メタプログラミングの利用箇所を極めてスコープの狭い特定箇所に閉じるなど、リスクが生じない工夫が必要となる。  

---
---

## 9.9 技術駆動パッケージング

パッケージの区切り方、フォルダの分け方に注意しないと悪魔を呼び寄せる原因になりかねない。  

図9.3は、ECサイトのフォルダ構成を表したものとなる。  
分かりやすいように、ファイル名は日本語にしている。  
各ファイルはクラスと1:1であり、ファイル名とクラス名は同じものとする。  

``` txt
図9.3
設計パターンごとにフォルダ分け

│
├─ UseCases
│  ├─ 在庫ユースケース.java
│  ├─ 注文ユースケース.java
│  └─ 支払いユースケース.java
├─ Entities
│  ├─ 入庫エンティティ.java
│  ├─ 出庫エンティティ.java
│  ├─ 買い物かごエンティティ.java
│  ├─ 注文エンティティ.java
│  ├─ 発注エンティティ.java
│  └─ 請求エンティティ.java
└─ ValueObjects
    ├─ 安全在庫量.java
    ├─ 在庫回転期間.java
    ├─ 発注金額.java
    ├─ 注文先.java
    ├─ 請求金額.java
    ├─ 割引ポイント.java
    └─ クレジットカード番号.java
```

ユースケースを表現したユースケースパターン(Use Case)、一意性を責務とするエンティティパターン(Entity)がある。  
このフォルダ構成は、設計パターンごとにファイル分類したものになる。  

これらのファイルは、どれがどれに強く関係し合うだろうか。  
例えば、`注文先`は、`注文ユースケース`など注文関連であることが分かる。  
では`発注金額`はどうだろうか。  
一見`注文`に関係がありそうに見えるが、そうではなく実は`在庫ユースケース`で用いられるものとなっている。  
名前的にわかりにくく、何かの拍子にうっかり`注文`関係で`発注金額`が使われてしまう可能性がある。  
当然バグ化する可能性が高まる。  

また、`安全在庫量`や`在庫回転期間`は`在庫`関連でしか用いられない。  
しかし、何かの仕様を満たすために、`在庫`以外の用途で無理に`安全在庫量`が使われたりすると、本来の用途以外のものと結びついてロジックが非常に混乱してしまう。  

このフォルダ構成では、様々な混乱が生じてしまう。  
どういう観点で分けるべきだろうか。  

これらのファイルは、大きく種類分けすると、在庫、注文、支払いに大別される。  
しかし、設計パターンでフォルダ分けしているために、どれがどの種類に関連があるのか見分けが難しくなっている。  
このように設計パターンなど、構造的に似ているものどうしでフォルダ分け、パッケージ分けするのを**技術駆動パッケージング**と呼ぶ。  

Railsなど、多くのWebフレームワークはMVCアーキテクチャー[^1]を採用している。  
こうしたフレームワークは技術駆動パッケージングといえる。  
フレームワークの標準構造が技術駆動パッケージングであるためか、それをお手本に内部の様々なフォルダ構造も技術駆動パッケージングになりがちとなる。  

この例で示した買い物かごエンティティや安全在庫量など、ビジネス概念を表すクラスを、**ビジネスクラス**と呼ぶ。  
ビジネスクラスを技術駆動パッケージングでフォルダ分けすると、本来強く関係し合うファイルどうしがバラバラになり混乱する。  
ファイル単位で低凝集になってしまう。  

ビジネスクラスは図9.4のように、ビジネス概念として強く関係し合うものどうしが一緒になるようフォルダ分けすべし。  

``` txt
図9.4
ビジネス概念の種類ごとにフォルダ分け

│
├─ 在庫
│  ├─ 在庫ユースケース.java
│  ├─ 発注ユースケース.java
│  ├─ 入庫ユースケース.java
│  ├─ 出庫ユースケース.java
│  ├─ 安全在庫量.java
│  ├─ 在庫回転期間.java
│  └─ 発注金額.java
├─ 注文
│  ├─ 注文ユースケース.java
│  ├─ 買い物かごエンティティ.java
│  ├─ 注文エンティティ.java
│  └─ 注文先.java
└─ 支払い
    ├─ 支払いユースケース.java
    ├─ 請求エンティティ.java
    ├─ 請求金額.java
    ├─ 割引ポイント.java
    └─ クレジットカード番号.java
```

このようにすることで、在庫ユースケースでしか使われない安全在庫量クラスをpackage privateにでき、注文や支払いなど無関係なユースケースから参照される危険性(8.2.3)がなくなる。  

同じ分類どうしでまとまっているので、例えば支払い関係に仕様変更が生じた場合、支払いフォルダ内のファイルを読みに行けばよくなる。  
関連ファイルをあちこち探し回る手間が低減する。  

[^1]MVCとは、Model、View、Controllerの3層に分けたアーキテクチャー構造のこと。  
MVCのように、役割ごとの層(レイヤー)で分割するアーキテクチャーをレイヤードアーキテクチャーと呼ぶ。  
レイヤードアーキテクチャーには、MVCのほかにMVVMなどがある。  

---
---

## 9.10 サンプルコードのコピペ

ネット上には様々なプログラミング言語やフレームワークの公式サイトがある。  
各サイトには言語仕様やライブラリのドキュメントがあり、多くがサンプルコード付きで説明されている。  
また、技術コミュニティサイトやQ&Aサイト、エンジニア個人のブログ等でも、サンプルコード付きで数多く技術解説が咲慣れている。  

注意してほしいのは、サンプルコードをそのままなぞって実装(サンプルコードをコピペ)すると、設計上良くない構造になりがちだという点である。  

サンプルコードはあくまで言語仕様やライブラリの機能性を説明するために書かれたものであって、保守性や変更容易性まで考えて書かれたものではない。  
「サンプルコードがこうだったから」と鵜呑みにして実装すると、あっという間に粗悪なロジックが出来上がり、悪魔を呼び寄せてしまう。  

サンプルコードとは離れて、あるべきクラス構造を設計しよう。  

※著者の知人の話では、ネット上に落ちているサンプルコードのコピペだけで製品を動かしてしまう「コピペ職人」なるプログラマーがいるそうで。  
著者の観測範囲でもサンプルコードをコピペしているプログラマーが一部にいるので、以外に根深い問題なのかもしれない。  

---
---

## 9.11 銀の弾丸

新しい技術や手法を知ると、つい使ってみたくなるものである。  
素晴らしい手法は、開発現場のあらゆる問題を解決してくれそうなほど魅力的に見えることがある。  

しかし、現実の仕事で発生する問題は、特定の手法だけで解決可能なほど単純なものではない。  
ほとんどは複雑性の高い問題ばかりである。  
そうした状況でやみくもに、何でもかんでも「自分が知っている便利な手法」を使うとどうなるだろうか。  
課題解決に対して貢献しないどころか、逆に問題を深刻化してしまうケースすらあり得る。  

ソフトウェア設計には、「GoFのデザインパターン」と呼ばれる、有名な設計パターン集がある。  
著者は、GoFデザインパターンの一部が無理矢理適用された、機能拡張困難なソースコードに遭遇したことがある模様。  
覚えたてのデザインパターンをつい使いたくなったのか、前任者の思惑は分からないが、改修担当となった著者は機能拡張のために苦労して再設計することになった模様。  

西洋では、狼男や悪魔は銀の弾丸で撃退できるとされている。  
厄介な問題を撃退可能な、特効薬的な表現であるが、ソフトウェア開発には銀の弾丸は存在しない。  
※類似した考え方に、「マズローのハンマー」と呼ばれる心理バイアスがある。  
「金槌を持っていると、何でも釘であるかのように取り扱ってしまう」というバイアスのこと。  

紹介している手法は、仕様変更に伴う苦労の低減を目的としたものである。  
このため、実験的に開発したプロトタイプや寿命間近で仕様変更が伴わないソフトウェアに対しては効果を発揮しない。  
逆に設計コストが高くついてしまう。  

大事なのは、どんな課題があるか、ある手法がその問題解決に効果的か、コスト的に問題にならないかを評価して判断する姿勢である。  
課題と目的を意識して技術選択できるようになるべし。  

設計にbestはあり得ない。  
常にbetterを目指していこう。  
