# 関数型プログラミング

## OOPとFPの比較

OOP

``` cs
var elevator = new Elevator();
elevator.GoUp().GoUp().GoDown();

class Elevator {
    private int CurrentFloor;

    Elevator(){
        this.CurrentFloor = 1;
    }

    public Elevator GoUp(){
        this.CurrentFloor++:
        return this;
    }
    public Elevator GoDown(){
        this.CurrentFloor--;
        return this;
    }
}
```

FP

``` cs
IElevatorState initialState = {CurrentFloor = 1};
var finalState = GoDown(GoUp(GoUp(initialState)));

interface IElevatorState {
    int CurrentFloor
}

IElevatorState GoUp(IElevatorState state) {
    return state.CurrentFloor + 1;
}

IElevatorState GoDown(IElevatorState state) {
    return state.CurrentFloor + 1;
}
```

``` cs
IElevatorState initialState = new ElevatorState(1);
var finalState = GoDown(GoUp(GoUp(initialState)));

Console.WriteLine($"Current floor: {finalState.CurrentFloor}");

static IElevatorState GoUp(IElevatorState state)
{
    return new ElevatorState(state.CurrentFloor + 1);
}

static IElevatorState GoDown(IElevatorState state)
{
    return new ElevatorState(state.CurrentFloor - 1);
}

public interface IElevatorState
{
    int CurrentFloor { get; }
}

public struct ElevatorState : IElevatorState
{
    public int CurrentFloor { get; }

    public ElevatorState(int currentFloor)
    {
        CurrentFloor = currentFloor;
    }
}
```

``` fs
type ElevatorState = { CurrentFloor: int }

let goUp (state: ElevatorState) =
    { state with CurrentFloor = state.CurrentFloor + 1 }

let goDown (state: ElevatorState) =
    { state with CurrentFloor = state.CurrentFloor - 1 }

[<EntryPoint>]
let main (_argv: string array) =
    let initialState: ElevatorState = { CurrentFloor = 1 }
    let finalState: ElevatorState = initialState |> goUp |> goUp |> goDown

    printfn "Current floor: %d" finalState.CurrentFloor
    0
```

この例では、ElevatorStateというレコード型を定義し、goUpおよびgoDown関数を作成しています。
これらの関数は、それぞれの操作を行い、新しい状態を返します。
F#では、パイプライン演算子 |> を使って、関数の結果を次の関数に渡すことができます。
この例では、initialStateをgoUp、goUp、goDownの順に適用しています。
このコードは、関数型プログラミングの原則に従っており、状態が不変であることが保証されています。

``` haskell
data ElevatorState = ElevatorState { currentFloor :: Int } deriving (Show)

goUp :: ElevatorState -> ElevatorState
goUp (ElevatorState floor) = ElevatorState (floor + 1)

goDown :: ElevatorState -> ElevatorState
goDown (ElevatorState floor) = ElevatorState (floor - 1)

main :: IO ()
main = do
    let initialState = ElevatorState 1
    let finalState = goDown (goUp (goUp initialState))
    putStrLn $ "Current floor: " ++ show (currentFloor finalState)
```

[replit.com](https://replit.com/languages/haskell)  

---

[(17) 初探Functional Programming：徹底改變程式思維 - 基礎概念篇 - YouTube](https://www.youtube.com/watch?v=qpOcRG3e9Q8&t=701s)  
