# プログラミングに関するメモ

## static

### そもそもstaticって結局何なのか？  

[C#初心者のための基礎！staticスタティックの意味と使い方を解説#25](https://anderson02.com/cs/cskiso/cskisoniwari-25/)  

staticはインスタンスを生成しない。  
staticはプログラム実行時にメモリ領域が確保される。  
なので、そのアプリケーションにただ1つだけ生成したい時に使用される。  
staticの用途としては、最初に1回定義したら後は変更されないような情報になるので、データベース接続情報などが適している。  

※インスタンスを生成するということはヒープ領域から領域を拝借するのだから、  
1回だけということはサイズは決まっているので、おそらくスタック領域に展開されるはず。  

### staticクラスのメンバーにthisでアクセスできないのはなぜなのか？  

[staticメソッド内でstaticでないメンバを参照できない理由](https://shirakamisauto.hatenablog.com/entry/2015/06/15/181428)  

thisは自分自身のインスタンスを参照する命令。  
staticはインスタンスを生成しないのは①でやった通り。  
インスタンスが存在しないのだから、自分自身のインスタンスにアクセスできるわけがないので、staticクラスでthisは使えない。  

### その他

[staticクラス、staticメソッドの意味と利点](https://teratail.com/questions/174252)  
インスタンス毎に返す値が違うならstaticでないほうがいいし、Mathのsqrtのように誰がどう計算してもそうなるしかないものはstaticであるほうがいい。  
なぜならインスタンス毎に挙動が変わって欲しくないし、そういう共通で使う処理は起動時に一回だけメモリに確保して、いつでも使えるようにしたほうが効率がいいし、  
いちいちnewしてメモリを確保する手間がいらない。  

[わい、static変数とstaticメソッドについて熱く語る](https://qiita.com/Nekonecode/items/19f3a261a8391853ddec)  

---

## アンチパターン (anti-pattern)

[wiki_アンチパターン](https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)
[分かりそう](https://wa3.i-3-i.info/word19389.html)  

システム開発とかにおける「これは悪い意味で定番だよね」な内容をまとめたもの。  
「あ～、それって一見すると良く見えるかもしれないけどさ～。それをやると、まず間違いなく悪い結果になるんだよね～。でも、よくやっちゃうよね～」なやり方を何となくパターン化してまとめたもの  

デザインパターンはアンチパターンの反対語。  
設計における「経験豊富な人だったら、こうするだろうね」なノウハウをまとめた定石集。  

デザインパターン : やったほうがいいことまとめ  
アンチパターン : やらないほうがいいことまとめ  

---

## タイプセーフ(型安全)

1. 型の違いによってエラーが起こることを防ぐ仕組みのこと  
2. コンパイラがコンパイル中に型を検証し、変数に間違った型を割り当てようとするとエラーをスローすること  

``` C#
Cookie obj = new Cookie("cookie1", "Value1");
string str = new String('A', 10);

// タイプセーフの場合
// ==演算子の長所：タイプセーフなので型が違うとコンパイルエラー
WriteLine($"obj == str {obj == str}");

// タイプセーフではない場合
// Equalsメソッドは型が違っても比較できてしまう
// 出力：obj[Cookie].Equals(str[String]) False
WriteLine($"obj[Cookie].Equals(str[String]) {obj.Equals(str)}");
```

---

## nullセーフ

[null安全](https://relearn-java.com/null-safe/)  

``` TXT
null安全とは 実行時にnullが原因のエラー（NullPointerException）を発生させないような仕組みです。  
SwiftやKotlinなど比較的新しい言語では積極的に取り入れられています。  
```

チェックアウトのことで福田さんと話している時に、なぜわざわざnewだけして返却しているのか聞いた時の話。  
曰く「nullsafeのため」ということだったので、まとめることにした。  

nullで返却してもいいけども、返却した先でnullチェックしてなかったらエラーになってしまうだろうから、それならオブジェクトを代入して返してやったほうがいいよね。  
あなたちゃんとnullチェックしてるって自信を持って言える？  
そうでなくてもnullが来てもバグが発生しない安全なプログラミングをしておいて損はないでしょ。  
って感じだった。  

---

## 車輪の再発明

地味に意味を知らなかったのでまとめ。  

``` txt : うぃき<https://ja.wikipedia.org/wiki/%E8%BB%8A%E8%BC%AA%E3%81%AE%E5%86%8D%E7%99%BA%E6%98%8E>
「広く受け入れられ確立されている技術や解決法を知らずに、または意図的に無視して再び一から作ること」を指すための慣用句。
一般的には、古くからタダで皆に使われている技術や技法があるのなら、それをそっくりそのまま模倣して使えば、ほとんど時間もかからず労力もほとんど使わずに済む。
それなのに、わざわざまた自分でゼロからアイディアを練る段階から始めていては、時間・労力・コストなどの無駄なので、「車輪の再発明」は基本的には、時間の無駄、愚かなこと、ばかばかしいこと、というニュアンスで用いられている。

特にIT業界、なかでもSEやプログラマの間で好んで用いられている表現、概念である。

再発明を行ってしまう理由としては、「既存のものの存在を知らない」「既存のものがあることを知っていたはずなのに、つい思い出しそこなった」「既存のものを一応探したが、見つけそこなった」「既存のものが意図的に隠されていた（時間を無駄遣いするように罠をかけられていた）」「既存のものの意味を誤解している」などということがある。
```

→  
つまり、「誰かが既に生み出した何かを自分で生み出そうとして時間を無駄にすること」の意味。  
Wikiの説明がいちいち面白い。  

---

## コンパイルとビルドの違い

<https://twitter.com/itengr_matome/status/1488270286302507009>  

>Compileは文字通り翻訳なので、ソースコードを中間言語とかバイトコードとか機械語とかに翻訳する行為。
>インタプリタ言語なら実行時にコンパイルしてたりする。  
>Buildは製品としてデプロイ可能な状態にすること（コンパイル、テスト、パッケージング等）  
>と習ったかなぁ・・・  

---

## Windowsデスクトップ向け業務アプリ開発には何を採用すべきか？

[Windowsデスクトップ向け業務アプリ開発には何を採用すべきか？](https://qiita.com/sengoku/items/fb4948e0d2746e3cc26f)  

- UWPで要件を満たせるのであれば[UWP]  
- Webに慣れた開発者が多ければ[Electron]か[React Native]  
- iOS/Android向けアプリも一緒に開発するなら[Xamarin]か[React Native]  
- そうでなければ[WPF]一択  

WPFを選択した場合、.NET Framework 4.7/4.8にするか、.NET Core 3にするのかも選ばなければいけません。  
将来的なサポートやテストしやすさを考えれば、.NET Core 3から.NET 5へと続く道へ。  
リリースが間近か、現在ある資産をどうしても手放せないのであれば、.NET Framework 4.7/4.8でしょうか。  

---

## バイナリ

こんなに勉強してきて「バイナリとは何か？」をまとめていなかったのは意外である。  
というわけでまとめ。  

``` txt : ZDNet
バイナリとは、コンピュータ用語としては、データが「0」と「1」で表現されているデータ形式のこと。
あるいは、テキストではない情報でデータが書かれているファイル一般のことである。
バイナリ（binary）とは、元々「2進数の」という意味の英語である。

コンピュータはデータを処理するために、全ての情報を2進数に変換しているので、コンピュータが解釈するために用意されたデータはすべてバイナリ形式となっている。
一般的には、データがバイナリで記述されているファイルはバイナリファイル、バイナリファイルのデータはバイナリデータと呼ばれている。
バイナリファイルの主なものには、音声ファイルや画像ファイル、実行形式のプログラムファイル、圧縮ファイルなどがある。
バイナリデータは、人間が読んでも、意味を解釈することはきわめて困難である。
テキストはテキストエディタで表示・編集することができるが、バイナリデータはテキストエディタでは開くことができない。
このため、テキストでないデータ形式のデータをバイナリデータと総称している場合も多い。

 ちなみに、データ構造の一種である2分木は、2つに分岐するという意味でバイナリツリーと呼ばれている。
```

大抵の説明では0か1ばかりのファイルとあるが、それを表示するバイナリエディターでは16進数で表示されている。  
まぁ、01を永遠と見させられるよりは、16進数で2つにまとめて見せたほうが、効率がいいよね。  
wikiみたら、バイナリエディタでは16進数で表示するのが一般的みたいなので、あながち間違いではなさそうだ。  

---

## リテラル(literally)

リテラル(英: literal)は、「文字どおり」「字義どおり」を意味する語で、letter と同じくラテン語の littera（文字）に由来する。  
数理論理学とコンピュータプログラミングで異なる意味の専門用語として使われる。  

ソースコード内の値となる、文字列、数字、式を直接表記したもの。  
変数を箱を例えるなら、その変数の中に入る値をリテラルという。  

下記のような処理があったら、代入された値の"Hello World"や"10"のことをリテラルという。

``` C#
var string = "Hello World";
var num = 10;
```

---

## 関数リテラル

[関数リテラルという言葉を理解する](https://amimimi.hatenablog.com/entry/2013/11/16/174019)  

無名関数のことを関数リテラルとも言う。  
変数に関数を代入して記述することを関数リテラルという。  
関数リテラル、無名関数、匿名関数の3つはほぼ同義。  

``` js
// function() {} が無名関数であり、関数リテラルに当たる部分
var test = function() {}
```

---

## 関数シグネチャ

[F5 GLOSSARY_シグネチャ](https://www.f5.com/ja_jp/services/resources/glossary/signature#:~:text=%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3%E3%81%A8%E3%81%AF%E3%80%81%E4%B8%80%E8%88%AC%E3%81%AB%E3%81%AF,%E3%81%AF%E8%A8%80%E8%AA%9E%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E7%95%B0%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%EF%BC%89%E3%80%82)  
>シグネチャとは、一般には「署名」を意味します。  
>またプログラミングの世界では、メソッド名、パラメータの型、数、順序、戻り値の型等で構成された、メソッドを識別するための情報という意味があります（具体的な定義は言語によって異なります）

[MDN Web Docs 用語集: ウェブ関連用語の定義Signature (シグネチャ)](https://developer.mozilla.org/ja/docs/Glossary/Signature)  
>関数シグネチャ (もしくは型シグネチャ、メソッドシグネチャ) はFunctionやMethodの入力と出力を定義します。  

[e-Words](https://e-words.jp/w/%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3.html)  
>プログラミングの分野では、関数やメソッドの名前、引数の数やデータ型、返り値の型などの組み合わせのことをシグネチャという。  
言語によっては、同じクラスなどの中で名前が同じだが引数の型などが異なるメソッドを複数同時に宣言することができる場合があり、それらはシグネチャによって識別される。  
>
>例えば、2つの引数の算術和を求めるメソッドを作りたいとき、通常は引数や返り値の型ごとに、整数用の int add_int（int x,int y）、浮動小数点用の float add_float（float x,float y）…といった具合に同じ機能のメソッドをそれぞれ用意して使い分けなければならない。  
シグネチャによる識別が可能な言語では、すべて同じ add（x,y） メソッドとして宣言すれば、呼び出し時に引数の型に応じて処理系が適切なものを選択してくれる。  

(もしくは型シグネチャ、メソッドシグネチャ) は関数やメソッドの入力と出力を定義します。  
シグネチャは以下のものを含みます:  

・パラメーター とその 型  
・返り値とその型  
・スローされる可能性のある例外  
・オブジェクト指向 プログラムにおける利用可能性の情報(public、static、prototype のようなキーワード)。  

---

## デグレード：degrade

[デグレとは　種類や原因と共に、対策の考え方を解説](https://service.shiftinc.jp/column/4923/#:~:text=%E3%83%87%E3%82%B0%E3%83%AC%E3%81%A8%E3%81%AF%E3%80%81%E6%AD%A3%E7%A2%BA%E3%81%AB,%E3%81%AE%E3%81%93%E3%81%A8%E3%82%92%E3%81%84%E3%81%84%E3%81%BE%E3%81%99%E3%80%82)  

正確にいえば英語の「degrade」(低下する、下がる)の略語で、IT業界で使われる場合は、ソフトウェア開発のなかで、不具合を修正した場合などにそれまで動作したものが動かなくなってしまうというように、品質が低下してしまうトラブルのことをいいます。  

---

## POCO(Plain Old CLR Object)

メソッドを持たず、プロパティだけ持つ、データを格納するだけが目的のクラス。  
共通言語ランタイム（Common Language Runtime、CLR）のみに依存するプレーンなオブジェクト。  

これに限らずASP.NetCoreを説明しているあれを全てまとめたい勢いだ。  

---

## エラーに関して

- 業務エラーは例外としてスローし、上位で適切な処置を行う必要があります。  
- 業務エラーを例外で表すことにより、可読性・保守性の向上に繋がります。  
- 業務エラーを例外で表しても、適切な設計を行えばパフォーマンスに問題はありません。  
- 業務エラーを表す例外に対して適切な処理を行っている限り、型以外の例外情報は不要です。  
- 業務エラーを表す例外がハンドルされなかった場合、例外情報がとても重宝します。  
- 業務エラーを表す例外はException クラスから派生させます。  

業務エラーはExceptionクラスを派生して業務エラー用のクラスを作ってそれを検知するというのが正しい例外処理のようだ。  
それならば本来の例外と業務エラーをごっちゃにしてExceptionだけで取得する必要がなくなる。  
業務エラーなら派生クラスで再定義、本来のエラーはexceptionで取得。  
業務エラーをフォームに組み込むならば、親クラスで定義してもらわないと無理だな。  

---

## ストリーム

[ストリームとは | IT用語辞典 e-Words](https://e-words.jp/w/%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0.html)  

>ストリームとは、小川、流れ、連続などの意味を持つ英単語で、ITの分野では連続したデータの流れや、データの送受信や処理を連続的に行うことなどを意味する。  
>プログラミングの分野では、データの入出力全般を扱う抽象的なオブジェクトやデータ型を意味する場合が多い。  
>データが出入りする何らかの対象（メモリ領域やファイル、ネットワークなど）をプログラム中で扱えるように抽象化したもので、接続や切断、書き込みや読み込みなどを簡易な操作で行うことができる。  

[ストリーム | Programming Place Plus　用語集](https://programming-place.net/ppp/contents/glossary/sa/stream.html)  

>プログラミングにおいて、連続するデータの入出力を行うための抽象的なオブジェクトのことです。  
>「ストリーム（stream）」とは「流れ」のことであり、データを入出力する様子を、データが流れているように見立てたものです。  
>入力であればデータの入力元となる存在（キーボードやファイル、ネットワークなど）、出力であればデータの出力先となる存在（ディスプレイやファイル、ネットワークなど）をプログラム中で区別なく扱えるように抽象化したオブジェクトのことです。  
>データの入力時には入力用のストリーム（入力ストリーム）を通し、データの出力時には出力用のストリーム（出力ストリーム）を通します。  

---

## セマフォ

<https://e-words.jp/w/%E3%82%BB%E3%83%9E%E3%83%95%E3%82%A9.html#:~:text=%E3%82%BB%E3%83%9E%E3%83%95%E3%82%A9%E3%81%A8%E3%81%AF%E3%80%81%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%81%A7,%E3%82%92%E8%A1%A8%E3%81%99%E5%80%A4%E3%81%AE%E3%81%93%E3%81%A8%E3%80%82>

``` txt
セマフォとは、コンピュータで並列処理を行う際、同時に実行されているプログラム間で資源（リソース）の排他制御や同期を行う仕組みの一つ。
当該資源のうち現在利用可能な数を表す値のこと。
```

セマフォを資源を使っているかどうか、その状態を表す信号機のようなものだと認識していたが、  
本来は並列処理がメインの概念みたいだ。  

Yr君からセマフォって何？って聞かれたのと、「セマフォがタイムアウトしました。」ってエラーを見せられたので、調べてみた次第です。  
ドンピシャな回答があったので乗せておく。  
「tcp プロバイダー セマフォがタイムアウトしました。」  
<https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q14134357014>  

要約すると、A、B、Cってプロセスが並行してて、  
ある資源が全然解放されないって時にセマフォがタイムアウトエラーを発生させるってことらしい。  

---

## シャローコピーとディープコピー

[シャローコピーとディープコピーの違い](https://itsakura.com/it-program-shallow)  
[C# DeepCopyする方法](https://tomisenblog.com/c-sharp-deepcopy/)  

シンボリックリンクとハードリンクみたいなやつ。  
シャローコピーは明らかにシンボリックリンクだな。  
いや、多分正確には違うと思うけど。  

### シャローコピー

・オブジェクトの参照先をコピーします。  
・コピー元のオブジェクトとコピー先のオブジェクトが同じアドレスの値(インスタンス)を参照します。  
・片方のオブジェクトの値を変更すると、もう一方のオブジェクトの値も変更されます。  
・英語ではshallow copyです。shallowは、浅いという意味です。  

変数だけ別の用意して、参照先は同じやつ。  

``` C# : シャローコピー
    var srcMember = new Member { Name = "鈴木", Address = "東京都" };
    var dstMember = srcMember;
    dstMember.Address = "千葉県";
    // src側も変わってる
```

### ディープコピー

・オブジェクトの値(インスタンス)をコピーします。  
・コピー元のオブジェクトとコピー先のオブジェクトがそれぞれ別のアドレスの値(インスタンス)を参照します。  
・片方のオブジェクトの値を変更しても、もう一方のオブジェクトの値は変更されません。  
・英語ではdeep copyです。deepは、深いという意味です。  

変数も別で参照先も別のやつ。  
でも、どっちも入ってる値は同じ。  
C#ではデフォルトでやってくれるやつはないので自分で実装する必要がある。  
といっても、Newして片方のデータをそのまま新しいほうにグルグルセットするだけだけどね。  
シリアライズとデシリアライズでやる方法もあるか。  

ソースはシャローコピーのdst側を千葉県ってやってもsrcの値はそのままになるだけだから省略するよ。  
