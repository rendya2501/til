
# O/Rマッピング (Object/RelationalDataBase Mapping)

[e-Word]  
>O/Rマッピングとは、オブジェクト指向プログラミング言語におけるオブジェクトとリレーショナルデータベース（RDB）の間でデータ形式の相互変換を行うこと。  
>そのための機能やソフトウェアを「O/Rマッパー」（O/R mapper）という。  
>インスタンスのデータをデータベースの対応するテーブルへ書き出したり、データベースからデータを読み込んでインスタンスに代入したりといった操作を自動的に行なってくれる。  

[Wiki]  
>データベースとオブジェクト指向プログラミング言語の間の非互換なデータを変換するプログラミング技法である。  

[2]  
データベースのテーブルのフィールドと同じプロパティやメンバー変数を持ったクラスを用意して、SELECTしたら自動的にそのクラスのメンバーに値が入ったり、クラスの値をデータベースに保存したりするアレがそう。  

[O/Rマッパーを使う理由](https://tikasan.hatenablog.com/entry/2018/08/06/110000)  
>つまり、オブジェクト指向とデータベースの考えの差分を吸収して、どっちでもいい感じに使えるようにする技法。  

---

## 登場した背景

オブジェクト指向言語で、リレーショナルデータベース（以下データベースとする）を使う時に、取得してきたレコードをオブジェクトにマッピングする作業が必要になります。

``` C#
    Connection conn = DriverManager.getConnection(url, user, password);
    Statement stmt = conn.createStatement();
    String sql = "SELECT id, first_name FROM users";
    ResultSet rs = stmt.executeQuery(sql);
    List<User> users = new ArrayList<User>();
    while(rs.next()) {
        User user = new User();
        // usersテーブルのid を UserクラスのIdフィールドに入れる（マッピング）
        user.setId(rs.getString("id"));
        user.setFirstName(rs.getString("first_name"));
        users.add(user);
    } 
```

こういったマッピングを毎クエリ書く必要が出てきます。  
これはオブジェクト指向言語が悪いとか、データベースが悪いという話ではなく、設計のズレによって生じる問題。  
これをインピーダンスミスマッチと言います。  

- リレーショナルデータベース設計： 検索や登録更新処理に最適なモデル定義  
- オブジェクト指向設計：データモデルを現実世界のモデルに即したものとして定義  

そもそも思想が違うので、どちらかの思想が合わせるといったことすると、不都合が起きることは当然ですよねっていうことはこの時点でわかる。  
それらの不都合を解決するために出てきたのがO/Rマッパーです。  

---

## O/Rマッパーがない世界

SQLにはオブジェクト指向を考慮した設計はなされていないため、SQLを扱おうとすると、オブジェクト指向にある柔軟性のメリットが無に帰すわけです。どういうことか？  

何かのSQL構築したいと考えた場合、オブジェクトに入れたデータをデータベースに保存するために、一旦オブジェクトからデータを抜き出し、SQLを構築する専用メソッドが必要があります。  
これだけでもだるい作業なのですが、もし、データベース側でカラム名、型の変更があった時に、SQL作成部分のコードは毎度実装修正する必要が出てきます。（再利用性とは・・・状態）  

また、マッピングを書く処理は非常に単調で退屈なコードです。  
しかし、これを間違えると普通に事故ります。  
しかも、型が同じであればそれっぽく動いたりもするので、これを人間が手作業で全部やるのは辛い。  
※コードジェネレーターで解決するという手もある  

---

## 使うことで得られるメリット

よくあるO/Rマッパーは、オブジェクトを作成して、データベースのデータを更新するメソッドに渡すだけで、あとはそのメソッド内で、クエリ作成に必要なマッピングを中でやってくれます。  
もし、フィールドを増やしたい減らしたいといったことが起きても、updateメソッドに渡すオブジェクトに変更加えるだけで済みます。  
このメリットはレコードを取得する時にもです。  

ちなみに、マッピング情報をxml形式で書いたり、アノテーションで定義をすることが多いです。  
面倒のように思えますが、そこさえ書けていれば、コードを書く時はオブジェクトを扱うように操作が出来るようになります。  

``` C#
User user = new User();  
user.setId(1);
user.setFirstName("hoge");
// いい感じに変換してくれる（型解釈や構文の構築など）
// UPDATE users SET first_name = 'hoge' WHERE id = 1
db.update(user);
```

---

## SQLを考えなくてよくなる？

オブジェクト指向言語からオブジェクトをそのまま扱うような感覚でデータベースを扱うことが出来るようにしたのが、O/Rマッパーですが、だからといってSQLを知らなくていいというわけではありません。  
これはどういったクエリが発行されているのか？は理解しておかないと、「スロークエリ」や「N + 1問題」といった問題に対して何も出来なくなってしまうので、精通しているまではやらなくても、読めるようにしておくことは必須です。  

そもそも、O/Rマッパーが登場した背景には、SQL理解しなくても使えるようにではなく、**分かっていることを何度も書かないで済むようにしたいや、オブジェクト指向とリレーショナルデータベースのメリットを最大限発揮するために考えられたものなので**、知らなくていいやという話ではないのです。  

---

## インピーダンスミスマッチ

[wiki]  
>レイヤや領域が異なるシステム間の界面（インタフェース）において、想定された設計と異なる使われ方（ユースケース）であったり、「セマンティックギャップ」がある場合に、その界面を挟んだ処理の効率の低下や、プログラミングなどの実装の工数の著しい増加などといった非効率が発生することから、そういった不整合を「インピーダンスミスマッチ」と俗に呼ぶことがある。  
>特に、アプリケーション開発においてしばしば発生するオブジェクト指向言語とリレーショナルデータベースとのギャップのことを指す。  
>システム開発上、煩雑となりがちで生産性が著しく低下する要因として挙げられる。  
>主に、この問題を解決するO/Rマッピングなどの手法を説明する文脈で用いられる。  

[2]  
「インピーダンスミスマッチ」というのは「オブジェクト指向言語」と「リレーショナルデータベース」との間の構造のギャップの事です。  

[インピーダンスミスマッチとは？を分かりやすく説明](https://rainbow-engine.com/inpedance-mismatch/)  

---

## N + 1 問題

N+1 問題とは、OR マッパーを使用しているときに発生しがちな問題です。  

何かの一覧画面を作成しているときに、

- 一覧に表示するデータを取得するために SELECT を 1 回実行（N レコード返される）  
- 各データの関連データを取得するために SELECT を N 回実行  
- データベースアクセス（SELECT）が合計 N+1 回も実行される（JOIN して 1 回の SQL で取得した方が効率的）  

というものです。  

[Railsライブラリ紹介: N+1問題を検出する「bullet」](https://www.techscore.com/blog/2012/12/25/rails%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E7%B4%B9%E4%BB%8B-n1%E5%95%8F%E9%A1%8C%E3%82%92%E6%A4%9C%E5%87%BA%E3%81%99%E3%82%8B%E3%80%8Cbullet%E3%80%8D/)  
