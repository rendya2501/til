# アルゴリズム

プログラミングの中ではなく、アルゴリズムフォルダ単体で作っても十分なレベルだが、
もっと充実するまではここで細々とやっていく。

## 最近見つかったシンプルなソート法

``` C#
var array = new int[2,4,5,6,4,6,8,2,8,9,4];

for(var i = 0 ; array.length; i++){
    for(var j = 0 ; array.length; j++){
        if (array[j] < array[i]){
            swap(array[i],array[j]);
        }
    }
}

// O(n^2)
```

---

## クイックソートの計算量のO(n logn)の頭のnってなによ？

[クイックソートの時間計算量の評価（メモ）](https://qiita.com/warper/items/ae769e105862bfa25310)  

再帰計算なので、漸化式なるものを使って計算量を求める事になるらしい。  
なので、厳密にやろうとするとまず漸化式を勉強しなきゃいけないし、  
勉強してる最中に別のことがわからなくなって更に別の勉強をしてどんどん再帰的になって、本末転倒になりかねない。  

知りたいのは、計算量の求め方ではなく、なぜそうなるのかという理論なのでそこだけでも頑張って汲み取る。  

``` math
サイズnが2^kの配列が2分割されていく状況を考える  \\

n = 2^k  \\

一つの配列要素に注目したときに、その要素の位置を確定させるまでに必要な分割回数は、大雑把にk回。  \\
どの配列の要素に関しても、位置を確定させるために、k回の分割過程を要する。  \\

k = logn  \\

分割回数がわかったので、分割前に行う要素の比較回数を求めます。  \\
要素数mのあるグループを持ってきた際、その中での要素の比較回数は m−1です。  \\

ですので、分割が1回進み、要素数2^{k−1}のグループが2つ存在する状況では、2回目の分割を進めるために、  \\

2(2^{k−1}−1) = 2^k-2 =  n−2 ~ n = O(n) \\

この計算を同様に、3回目、4回目・・・k回目の分割を進める場合についても行うと、どの場合も比較回数はO(n)になることがわかります。  \\
ゆえに、配列が二分割されながらソートが進む場合、その時間計算量は  \\

O(nk) = O(nlogn)  \\
∵(k=logn)  \\
```

[なぜクイックソートの平均繰り返し回数がO(logn)で平均の計算量がO(nlogn)なんですか？？](https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q12159958462?__ysp=6KiI566X6YePLOOCr%2BOCpOODg%2BOCr%2BOCveODvOODiA%3D%3D)  

``` math
＊＊大雑把に言って＊＊ \\
n個のソート対象を約n/2個の２つの対象に分けます。 \\
その際の比較回数は約n/2回です。  \\
これを再帰的に行います。  \\
再帰の段数（＝平均繰り返し数）  \\
はおおむねfloor(log(2,n))回でありつまりソート完了まで  \\

n/2 + 2(n/4) + 4(n/8) + .... + 2^(floor(log(2,n))-1)n/2^floor(log(2,n))  \\
= n(1/2 + 1/2 + ..(floor(log(2,n))個).. + 1/2)～nlog(2,n)/2～nlogn  \\

回の比較が行われるわけです。
```

### つまり？

うーん。  
まず、配列を2分割する計算量はO(logn)。  
クイックソートは単純にそれだけでは無く、ピボットとか色々確定させないといけないことがあるからそれがO(n)。  
合わせてO(nlogn)。  
という、かなり乱暴な理論。  

これが正確なわけがないのはわかっているけど、理論的にはそういう事だよね。  
単純な2分割だけならlog nは俺でも知ってる。  
それ以外にも色々やってるんだからnくらいつくさ程度でいいような気がする。  
何より飽きた。  
クイックソートの性質もある程度わかったし、専門家ではないので計算量を応えられるだけで十分ではないか？  

・安定ではない。  
・外部メモリを使わない内部ソートである。  
・分割統治法である。  
・最悪計算量はO(n^2)  
・平均計算量はO(nlogn)  

### 沼

[計算量オーダーの求め方を総整理！ 〜 どこから log が出て来るか 〜](https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0)  
[ソートを極める！ 〜 なぜソートを学ぶのか 〜](https://qiita.com/drken/items/44c60118ab3703f7727f#6-1-%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AE%E8%A8%88%E7%AE%97%E9%87%8F)  

はやり調べ始めたら沼に嵌りそう。  
奥が深い世界だった。  
