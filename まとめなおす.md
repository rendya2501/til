# 後でちゃんと書き換える

---

## 検索条件にマッチするデータが存在しない場合にデフォルト値を返す

レコードが存在したらそのままINSERTして、レコードがなければデフォルト値をINSERTしたい。  

言葉にすると単純なのだが、30分くらい調べたのでまとめる。  
調べても全然スマートなのが出てこなかった。  

結果としてCOALESCEで実現できた。  
その前段としてCASE WHEN使って実現しようとしたが、なんと駄目だったのでそれもまとめる。  

てか、COALESCEってNULLの場合の置き換えだと思っていたが、レコードがなくても動いてくれるのか。  
2,3調べてみたけど、どこにも0件の場合についての記事が見つからない。  
確実に言えるのはNULLを指定した値に置き換えるというものだけだ。  

sql 条件によってselectを変える
SQL 0件の場合
COALESCE　レコードなし
[検索条件にマッチするデータが存在しない場合にデフォルト値を返す](https://sebenkyo.com/2020/04/14/post-774/)
[NULLと戯れる: 集約関数とNULL](https://qiita.com/SVC34/items/dc1bc52c2d7b44a65459)
[レコードがない場合のselect結果](https://teratail.com/questions/57768)  

``` sql : CASE WHEN案  
-- 一見行けそうに見えるが、GROUP BYしないと駄目だった。

SELECT CASE
    -- レコードがあれば料金CDをそのままいれる。なければデフォルト値として9999をいれる。
    WHEN COUNT(*) != 0
    THEN 料金CD
    ELSE 9999 
END AS 料金CD
FROM RoundDat_OCC.dbo.TM_料金 
WHERE 資格区分CD = 9

-- エラー
-- 列 'RoundDat_OCC.dbo.TM_料金.料金CD' は選択リスト内では無効です。この列は集計関数または GROUP BY 句に含まれていません。
```

``` sql : COALESCE案
-- レコードがなくても動いてくれたのは以外だった。
-- 何はともあれ理想の動作を実現できた。

SELECT COALESCE(
    (SELECT FeeCD FROM TMa_Fee WHERE PrivilegeTypeCD = 9),
    9999
)
```

``` sql : COALESCE案2
-- こっちのほうがいいのかも。
-- MAXは0件ならNULLを返す。COALESCEは結果がNULLなら指定した値に置き換えるので本来の動作に準拠したものになる。

SELECT COALESCE(
    (SELECT MAX(FeeCD) FROM TMa_Fee WHERE PrivilegeTypeCD = 9),
    9999
)
```

``` sql
SELECT 
    CASE WHEN EXISTS(SELECT 料金CD FROM RoundDat_OCC.dbo.TM_料金 WHERE 資格区分CD = 0)
        THEN [A].料金CD
        ELSE 9999
    END


    SELECT IIF(COUNT(*) != 0, 料金CD,9999)
    FROM RoundDat_OCC.dbo.TM_料金 
    WHERE 資格区分CD = 0



    SELECT CASE 
        WHEN (SELECT COUNT(*) FROM RoundDat_OCC.dbo.TM_料金) != 0 
        THEN 料金CD
        ELSE 9999 
    END AS 料金CD
    FROM RoundDat_OCC.dbo.TM_料金 
    WHERE 資格区分CD = 0

    
    SELECT CASE 
        WHEN COUNT(*) = 0
        THEN 料金CD
        ELSE 9999 
    END AS 料金CD
    FROM RoundDat_OCC.dbo.TM_料金 
    WHERE 資格区分CD = 9


SELECT
    CASE WHEN COUNT(CASE WHEN 資格区分CD = 9 THEN 1 ELSE 0 END) = 0
        THEN 料金CD
        ELSE 9999
    END    
FROM RoundDat_OCC.dbo.TM_料金


select COALESCE(
    (SELECT 料金CD FROM RoundDat_OCC.dbo.TM_料金 WHERE  資格区分CD = 9),
    9999
)
```

---

## WHEREの実行タイミングで結果が変わる

WHEREをどのタイミングで実行するかによって結果が変わってくるパターンに遭遇したのでメモっておく。  
端的にいえば、最終結果に対してWHEREするか、結果を構築する最中にWHEREするかの違いだ。  

1. 全部JoinしてからWHERE→ダメ  
2. Joinする最中にWHERE→一番OK  
3. WHEREで絞った結果をサブテーブルで受け取ってJoin→OK  

``` txt
出力されてほしい結果
1 カード 166666.00
2 QR 0.00

間違った結果
1 カード 166666.00
```

QRレコードが表示されてほしいのだが、全部JOINしてからWHEREするパターンでは間違った結果になってしまう。  
愚直にWHEREした結果をサブテーブルで受け取ってからJOINすることで解決したが、それ以外にもJOIN中に条件を指定することでも解決できた。  

``` sql : 全部JoinしてからWHERE → ダメ
-- ダメなパターン

-- LEFT JOINした時点では、存在しないレコードもNULL行として表示されるが、そこからWHEREでレコードの判定を行う。
-- 結果、NULLのBusinessDateは対象外となるので、NULLを0と表示したいレコードは消えてしまう。

-- 結果
-- 1 カード 166666.00

SELECT
    [TMa_PaymentCls].[PaymentClsCD],
    [TMa_PaymentCls].[PaymentClsName],
    SUM(ISNULL([TCs_CardBalance].[TodayAccountsReceivable],0)) AS [Price]
FROM
    [TMa_PaymentCls]
    LEFT OUTER JOIN [TMa_PaymentType] 
    ON [TMa_PaymentCls].[OfficeCD] = [TMa_PaymentType].[OfficeCD]
    AND [TMa_PaymentCls].[PaymentClsCD] = [TMa_PaymentType].[PaymentClsCD]
    LEFT OUTER JOIN [TCs_CardBalance]
    ON [TMa_PaymentType].[OfficeCD] = [TCs_CardBalance].[OfficeCD]
    AND [TMa_PaymentType].[PaymentTypeCD] = [TCs_CardBalance].[PaymentTypeCD]
WHERE 
    [TCs_CardBalance].[OfficeCD] = 'ESV'
    AND [TCs_CardBalance].[BusinessDate] = '2022/04/02'
GROUP BY
    [TMa_PaymentCls].[PaymentClsCD],
    [TMa_PaymentCls].[PaymentClsName]
ORDER BY
    [TMa_PaymentCls].[PaymentClsCD]
```

``` sql : Joinする最中にWHERE → 一番OK
-- 一番スマートな解決法だと思われる

-- JOINする最中に指定日付のモノだけを抽出し、そのままLEFT JOINするので、存在しないレコードも最終結果に残る。
-- 結果、ISNULLでNULLのレコードを0として出力することが可能。

-- 結果
-- 1 カード 166666.00
-- 2 QR 0.00

SELECT
    [TMa_PaymentCls].[PaymentClsCD],
    [TMa_PaymentCls].[PaymentClsName],
    SUM(ISNULL([TCs_CardBalance].[TodayAccountsReceivable],0)) AS [Price]
FROM
    [TMa_PaymentCls]
    LEFT OUTER JOIN [TMa_PaymentType] 
    ON [TMa_PaymentCls].[OfficeCD] = [TMa_PaymentType].[OfficeCD]
    AND [TMa_PaymentCls].[PaymentClsCD] = [TMa_PaymentType].[PaymentClsCD]
    LEFT OUTER JOIN [TCs_CardBalance]
    ON [TMa_PaymentType].[OfficeCD] = [TCs_CardBalance].[OfficeCD]
    AND [TMa_PaymentType].[PaymentTypeCD] = [TCs_CardBalance].[PaymentTypeCD]
    AND [TCs_CardBalance].[OfficeCD] = 'ESV'
    AND [TCs_CardBalance].[BusinessDate] = '2022/04/02'
GROUP BY
    [TMa_PaymentCls].[PaymentClsCD],
    [TMa_PaymentCls].[PaymentClsName]
ORDER BY
    [TMa_PaymentCls].[PaymentClsCD]
```

``` sql : WHEREで絞った結果をサブテーブルで受け取ってJoin → OK
-- 一番愚直ではあるが、一番長く野暮ったい

-- サブクエリの中でNULLのレコードも出力しておき、そのまま結果に依存しない列でJOINすることで存在しないレコードを最終結果に残す。

-- 結果
-- 1 カード 166666.00
-- 2 QR 0.00

SELECT
    [TMa_PaymentCls].[PaymentClsCD],
    [TMa_PaymentCls].[PaymentClsName],
    SUM(ISNULL([TodayAccountsReceivable],0)) AS [Price]
FROM
    [TMa_PaymentCls]
    LEFT OUTER JOIN
        (
            SELECT
                [TCs_CardBalance].[OfficeCD],
                [TCs_CardBalance].[TodayAccountsReceivable],
                [TMa_PaymentType].[PaymentClsCD]
            FROM
                [TCs_CardBalance]
                LEFT JOIN [TMa_PaymentType]
                ON  [TCs_CardBalance].[OfficeCD] = [TMa_PaymentType].[OfficeCD]
                AND [TCs_CardBalance].[PaymentTypeCD] = [TMa_PaymentType].[PaymentTypeCD]
            WHERE
                [TCs_CardBalance].[OfficeCD] = 'ESV'
                AND [TCs_CardBalance].[BusinessDate] = '2022/04/02'
        ) AS [CardBalance]
    ON  [TMa_PaymentCls].[OfficeCD] = [CardBalance].[OfficeCD]
    AND [TMa_PaymentCls].[PaymentClsCD] = [CardBalance].[PaymentClsCD]
GROUP BY
    [TMa_PaymentCls].[PaymentClsCD],
    [TMa_PaymentCls].[PaymentClsName]
ORDER BY
    [TMa_PaymentCls].[PaymentClsCD]
```

---

## 分子分母を出力するサンプル

``` sql
SELECT
    ReservationFrameNo,
    [SQ].[Numerator] + '/' + [SQ].[Denominator] + CASE WHEN COUNT(*) > 1 THEN '+' ELSE '' END  AS [FrameCount]
FROM (
    SELECT
        [A].ReservationFrameNo,
        [A].ReservationNo,
        CONVERT(nvarchar,[SQ_Numerator].[Numerator]) AS [Numerator],
        CONVERT(nvarchar,[SQ_Denominator].[Denominator]) AS [Denominator]
    FROM (
   -- 予約枠を上から見ていった時のシーケンス(分子:Numerator)
        SELECT
            [ReservationFrameNo],
            [ReservationNo],
            ROW_NUMBER() OVER(PARTITION BY [ReservationNo] ORDER BY ReservationFrameNo) AS Numerator
        FROM 
            [TRe_ReservationPlayer]
        WHERE
            ISNULL(ReservationCancelFlag,0) = 0
        GROUP BY
            ReservationFrameNo,ReservationNo
        ) AS [A]
    JOIN (
   -- 予約が持っている予約枠数(分母:Denominator)
        SELECT
            [ReservationNo],
            COUNT(DISTINCT [ReservationFrameNo]) AS Denominator
        FROM 
            [TRe_ReservationPlayer]
        WHERE 
            ISNULL(ReservationCancelFlag,0) = 0
        GROUP BY 
            [ReservationNo]
    ) AS [B]
    ON [A].ReservationNo = [B].ReservationNo
) AS [SQ]
GROUP BY
    [ReservationFrameNo]
```

``` sql : もっと簡単にできた
SELECT
    [ReservationFrameNo],
    [ReservationNo],
    ROW_NUMBER() OVER(PARTITION BY [ReservationNo] ORDER BY [ReservationFrameNo]) AS [Numerator],
    COUNT(1) OVER(PARTITION BY [ReservationNo]) AS [MinAccountNo]
FROM 
    [TRe_ReservationPlayer]
WHERE
    ISNULL([ReservationCancelFlag],0) = 0
GROUP BY
    [ReservationFrameNo],[ReservationNo]
```

[COUNT OVER(PARTITION BY)](https://zukucode.com/2017/08/sql-over-partition-by.html)  

``` sql
SELECT
  last_name,
  --全体の総件数
  COUNT(1) OVER() total_count,
  --部門ごとの件数
  COUNT(1) OVER(PARTITION BY department_id) section_count,
  --部門ごとの最大身長
  MAX(height) OVER(PARTITION BY department_id) section_max_height,
  --部門ごとの身長順（身長順に並び替えたときの行番号）
  ROW_NUMBER() OVER(PARTITION BY department_id ORDER BY height DESC) section_height_order,
  --全体の身長順（身長順に並び替えたときの行番号）
  ROW_NUMBER() OVER(ORDER BY height DESC) height_order
FROM
  employee
ORDER BY
  id
```

---

## SELECT GROUPで1件目を取得

<https://oshiete.goo.ne.jp/qa/3819843.html>  
「group by 先頭1件」で検索。  
Rank() Over構文を使うらしい。  

``` SQL
INSERT INTO
    TMa_SubjectSummary
SELECT
    (SELECT TOP 1 OfficeCD FROM TMa_CompanyBasicInfo) AS OfficeCD,
    x.集計CD AS SubjectSummaryCD,
    '' AS SubjectSummaryName,
    '' AS SubjectSummaryShortName,
    - 16777216 AS Color,
    - 1 AS BackgroundColor,
    x.集計CD AS Sort,
    1 AS ValidFlag,
    '' AS SearchKey,
    x.作成日 AS InsertDateTime,
    '' AS InsertStaffCD,
    '' AS InsertStaffName,
    x.更新Prg AS InsertProgram,
    x.ComputerName AS InsertTerminal,
    x.更新日 AS UpdateDateTime,
    '' AS UpdateStaffCD,
    '' AS UpdateStaffName,
    x.更新Prg AS UpdateProgram,
    x.ComputerName AS UpdateTerminal
FROM
(
    SELECT
        Rank() over(partition by CONVERT(int, 集計CD) order by 科目分類CD) as rk,
        CONVERT(int, 集計CD) AS 集計CD,
        作成日,
        更新日,
        更新Prg,
        ComputerName
    FROM 
        [RoundDatMigrationSource].[dbo].[TM_科目分類]
) AS x
WHERE 
    rk=1
```

---

## グループ毎に1行だけ取り出したけど、それぞれ何行がひとまとまりになったのか表示する

[ndid単位で抜き出したけど、それぞれ何行がひとまとまりになったのだろうか？](https://ameblo.jp/lovetanpopo/entry-10280370777.html)  
`COUNT(フィールド名) OVER ( PARTITION BY フィールド名 )`  

RANK,ROW_NUMBER,COUNTにOVERを使えるあたり、OVERはOVERでそういう構文になっているのだろうか。  

組数を表示するときに使った。  
予約枠でサマった時にGROUPBYするほどではないけど、2つあったら「+」を表示したい。  
その時に活躍した。  

``` sql
select *
from
(
 select
  id,name,ndid,stid,
  row_number()
    over( partition by ndid order by stid ) row_num,
  count(ndid) over ( partition by ndid ) cn
 from test
)
where row_num = 1
```

``` sql : 成果物その1
SELECT
    [SQ].[ReservationFrameNo],
    [SQ].[Numerator] + '/' + [SQ].[Denominator] + CASE
        WHEN [SQ].[Count] > 1 THEN '+'
        ELSE ''
    END AS [FrameCount]
FROM
    (
        SELECT
            [SQ_Numerator].[ReservationFrameNo],
            [SQ_Numerator].[ReservationNo],
            [SQ_SeatNo].[SeatNo],
            COUNT(*) OVER(PARTITION BY [SQ_Numerator].[ReservationFrameNo]) AS [Count],
            CONVERT(nvarchar, [SQ_Numerator].[Numerator]) AS [Numerator],
            CONVERT(nvarchar, [SQ_Denominator].[Denominator]) AS [Denominator]
        FROM
            (
                SELECT
                    [ReservationFrameNo],
                    [ReservationNo],
                    ROW_NUMBER() OVER(PARTITION BY [ReservationNo] ORDER BY [ReservationFrameNo]) AS [Numerator]
                FROM
                    [TRe_ReservationPlayer]
                WHERE
                    ISNULL([ReservationCancelFlag], 0) = 0
                GROUP BY
                    [ReservationFrameNo],
                    [ReservationNo]
            ) AS [SQ_Numerator]
            INNER JOIN
                (
                    SELECT
                        [ReservationNo],
                        COUNT(DISTINCT [ReservationFrameNo]) AS [Denominator]
                    FROM
                        [TRe_ReservationPlayer]
                    WHERE
                        ISNULL([ReservationCancelFlag], 0) = 0
                    GROUP BY
                        [ReservationNo]
                ) AS [SQ_Denominator]
            ON  [SQ_Numerator].[ReservationNo] = [SQ_Denominator].[ReservationNo]
            INNER JOIN
                (
                    SELECT
                        [ReservationFrameNo],
                        [ReservationNo],
                        MIN([SeatNo]) AS [SeatNo]
                    FROM
                        [TRe_ReservationPlayer]
                    WHERE
                        ISNULL([ReservationCancelFlag], 0) = 0
                    GROUP BY
                        [ReservationFrameNo],
                        [ReservationNo]
                ) AS [SQ_SeatNo]
            ON  [SQ_Numerator].[ReservationNo] = [SQ_SeatNo].[ReservationNo]
            AND [SQ_Numerator].[ReservationFrameNo] = [SQ_SeatNo].[ReservationFrameNo]
    ) AS [SQ]
WHERE
    [SQ].[SeatNo] = 1
```

---

## ある列の値が最大もしくは最小の値のレコードを取得する

働かない頭で「sql minれこーど」で調べたらやりたいことが出てきてくれた。  

[SQLで同一グループの中で最大/最小のレコードを取得する](https://qiita.com/inouet/items/4f1d7f299725597d8407)  
[SQL ある列の値が最大もしくは最小の値のレコードを取得する](https://zukucode.com/2017/08/sql-row_number-technique.html)  
[特定のカラムのグループごとの最大値が格納されている行](https://dev.mysql.com/doc/refman/5.6/ja/example-maximum-column-group-row.html)  

SQLServerなら`ROW_NUMBER関数`を使っていい感じに実現できた。  
愚直にやるならMAXかMINで抽出して、そのサブクエリの中でさらに条件を絞って、最終定期に出力するみたいな感じになるみたい。  
またはEXITSのような相関副問い合わせやJEFT JOIN を組み合わせるやり方など、やり方はたくさんあるみたい。  

``` SQL
    SELECT
        [A].[SlipID],
        [A].[AccountNo],
        [A].[Name]
    FROM(
        SELECT
            -- SlipIDでまとめて、AccountNoを昇順で並べる。
            -- Whereで1番目を取れば、同一グループの中の最小値レコードを取得できる。
            ROW_NUMBER() OVER(PARTITION BY [TFr_Slip].[SlipID] ORDER BY [TRe_ReservationPlayer].[AccountNo]) [MinAccountNo],
            [TFr_Slip].[SlipID],
            [TRe_ReservationPlayer].[AccountNo],
            [TRe_ReservationPlayer].[Name]
        FROM
            [TFr_Slip]
            LEFT OUTER JOIN [TRe_ReservationPlayer]
            ON [TFr_Slip].[OfficeCD] = [TRe_ReservationPlayer].[OfficeCD]
            AND [TFr_Slip].[BusinessDate] = [TRe_ReservationPlayer].[BusinessDate]
            AND [TFr_Slip].[PlayerNo] = [TRe_ReservationPlayer].[PlayerNo]
        WHERE
            [TFr_Slip].[OfficeCD] = 'ALP'
            AND [TFr_Slip].[BusinessDate] = '2020/07/25'
            AND [TFr_Slip].[SlipType] = '150'
            AND [TFr_Slip].[DetailType] <> 99
        ) AS [A]
    WHERE
        [A].[MinAccountNo] = 1
```

---

## SQL てく

2022年5月21日  
名前の苗字を北海道の市区町村に置き換えたい。  
カタカナも置き換えたい。  
他のフィールドにある名前も置き換えたい。  
そんな要求を実現したのでまとめ。  

奇跡的に姓名がスペースで別れていたので、スペースでsplit。  
苗字の1文字目のUNICODEを取得して3桁を見る。  
その3桁が別テーブルに定義したFromToのどの範囲に当たるか検索。
対象FromToの市区町村名を取得。  
その市区町村名を苗字に割り当てる。  
苗字の置き換えはREPLACE関数で行った。  

``` SQL
-- 改良後
UPDATE [Base]
SET
    [MemberName] = REPLACE([Base].[MemberName],[Base].[Myouji],[CT].[Name]),
    [MemberKana] = REPLACE([Base].[MemberKana],[Base].[MyoujiKana],[CT].[Kana]),
    [SearchKeyName] = REPLACE([Base].[SearchKeyName],[Base].[Myouji],[CT].[Name]),
    [SearchKeyKana] = REPLACE([Base].[SearchKeyKana],[Base].[MyoujiKana],[CT].[Kana]),
    [SearchKeyNameIdentification] = REPLACE([Base].[SearchKeyNameIdentification],[Base].[myouji],[CT].[Name])
FROM
    (
        SELECT 
            CASE 
                WHEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','') <> '' 
                THEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','')
                ELSE [MemberName]
            END AS [Myouji],
            CASE 
                WHEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','') <> '' 
                THEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','')
                ELSE [MemberKana]
            END AS [MyoujiKana],
            *
        FROM TMc_Member
    ) AS [Base]
    JOIN [ConversionTable] AS [CT]
    ON RIGHT(UNICODE(LEFT([Base].[myouji],1)),3) BETWEEN [CT].[From] AND [CT].[To]


-- 改良前
UPDATE [Base]
SET 
    -- わざわざ左から苗字の文字数分を指定してるけど、そんなことする必要なかった。
    -- REPLACE関数は苗字と同じ部分だけを置き換えてくれるから。
    [MemberName] = REPLACE([Base].[MemberName],LEFT([Base].[MemberName],LEN([SQ].[Myouji])),[CT].[Name]),
    [MemberKana] = REPLACE([Base].[MemberKana],LEFT([Base].[MemberKana],LEN([SQ].[MyoujiKana])),[CT].[Kana]),
    SearchKeyName = REPLACE([Base].[SearchKeyName],LEFT([Base].SearchKeyName,LEN([SQ].[Myouji])),[CT].[Name]),
    SearchKeyKana = REPLACE([Base].[SearchKeyKana],LEFT([Base].[SearchKeyKana],LEN([SQ].[MyoujiKana])),[CT].[Kana]),
    SearchKeyNameIdentification = REPLACE([Base].SearchKeyNameIdentification,LEFT([Base].SearchKeyNameIdentification,LEN(myouji)),[CT].[Name])
FROM
    -- わざわざ自分自身テーブルと改めてJOINする必要はなかった。
    TMc_Member AS [Base]
    JOIN 
    (
        SELECT 
            CASE 
                WHEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','') <> '' 
                THEN REPLACE(SUBSTRING([MemberName], 1, CHARINDEX(' ', [MemberName] )),' ','')
                ELSE [MemberName]
            END AS [Myouji],
            CASE 
                WHEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','') <> '' 
                THEN REPLACE(SUBSTRING([MemberKana], 1, CHARINDEX(' ', [MemberKana] )),' ','')
                ELSE [MemberKana]
            END AS [MyoujiKana],
            *
        FROM TMc_Member
    ) AS [SQ]
    ON [Base].MemberCD = [SQ].MemberCD
    AND [Base].[HistoryNo] = [SQ].[HistoryNo]
    JOIN [ConversionTable] AS [CT]
    ON RIGHT(UNICODE(LEFT([SQ].[myouji],1)),3) BETWEEN [CT].[From] AND [CT].[To]
```

``` sql
select * from TMc_Customer
select * from TMc_CustomerAddress
select * from TMc_Member
select * from TRe_Reservation
select * from TRe_ReservationPlayer


--文字列を「-」で前後に分割する
SELECT
     CASE WHEN LEN(ISNULL(CustomerName,0)) > 1 THEN SUBSTRING(CustomerName, 1, CHARINDEX(' ', CustomerName )  ) ELSE CustomerName END AS before
    -- ,SUBSTRING( CustomerName, CHARINDEX( @separator, CustomerName ) + 1, LEN( @target_str ) - CHARINDEX( @separator, @target_str )) AS after
FROM
    TMc_Customer

    --文字列を「-」で前後に分割する
SELECT
    CHARINDEX(' ', CustomerName ),
     SUBSTRING(CustomerName, 1, CASE WHEN CHARINDEX(' ', CustomerName ) > 0 THEN CHARINDEX(' ', CustomerName ) -1 ELSE 0 END) AS before
    -- ,SUBSTRING( CustomerName, CHARINDEX( @separator, CustomerName ) + 1, LEN( @target_str ) - CHARINDEX( @separator, @target_str )) AS after
FROM
    TMc_Customer



select * from ConversionTable
where [Name] = '鶴居'


select (UNICODE('井')),(UNICODE('五'))
select RIGHT(UNICODE('井'),3),RIGHT(UNICODE('五'),3)





DECLARE @Count INT = 100;
SELECT   TOP (@Count)
         ROW_NUMBER() OVER (ORDER BY object_id)-1 AS SeqNo
FROM     sys.all_objects
ORDER BY SeqNo;



SELECT * FROM (
    SELECT   TOP (1000)
             ROW_NUMBER() OVER (ORDER BY object_id)-1 AS SeqNo,
             ROW_NUMBER() OVER (ORDER BY object_id)+3 AS SeqNoTo
    FROM     sys.all_objects
    ORDER BY SeqNo
) AS rn_q
WHERE rn_q.SeqNo%5 = 0

```

---
---

## タブコントロールのタブを幅いっぱいにする修正

元々ビヘイビアでやっていたところをスタイルから修正することにした。  
添付プロパティや添付プロパティを含めたDataTriggerの分岐のやり方とか色々発見があったのでまとめる。  

### 最終的な作品

``` XML
    <ControlTemplate TargetType="{x:Type TabControl}">
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition x:Name="ColumnDefinition0" />
                <ColumnDefinition x:Name="ColumnDefinition1" Width="0" />
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition x:Name="RowDefinition0" Height="Auto" />
                <RowDefinition x:Name="RowDefinition1" Height="*" />
            </Grid.RowDefinitions>
            <Grid
                x:Name="HeaderPanelGrid"
                Grid.Row="0"
                Grid.Column="0"
                Panel.ZIndex="1">
                <mah:Underline
                    x:Name="Underline"
                    Background="{DynamicResource MahApps.Brushes.WindowTitle}"
                    BorderBrush="{TemplateBinding mah:TabControlHelper.UnderlineBrush}"
                    LineThickness="{TemplateBinding BorderThickness}"
                    Placement="Bottom"
                    SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                    Visibility="Collapsed" />
                <!-- 今回実装したところ -->
                <UniformGrid
                    x:Name="HeaderPanel"
                    Columns="{TemplateBinding helper:TabControlHelper.Colums}"
                    IsItemsHost="true"
                    KeyboardNavigation.TabIndex="1"
                    Rows="{TemplateBinding helper:TabControlHelper.Rows}" />
            </Grid>
        </Grid>
    </ControlTemplate>
```

``` C#
using System.Windows;

    /// <summary>
    /// タブコントロールヘルパー
    /// </summary>
    public class TabControlHelper
    {
        #region ColumsProperty
        /// <summary>
        /// Columsプロパティ
        /// </summary>
        public static readonly DependencyProperty ColumsProperty =
            DependencyProperty.RegisterAttached(
                "Colums",
                typeof(int),
                typeof(TabControlHelper),
                new FrameworkPropertyMetadata()
            );
        /// <summary>
        /// Columsを取得します。
        /// </summary>
        /// <param name="dp"></param>
        /// <returns></returns>
        public static int GetColums(DependencyObject dp)
        {
            return (int)dp.GetValue(ColumsProperty);
        }
        /// <summary>
        /// Columsを設定します。
        /// </summary>
        /// <param name="dp"></param>
        /// <param name="value"></param>
        public static void SetColums(DependencyObject dp, int value)
        {
            dp.SetValue(ColumsProperty, value);
        }
        #endregion

        #region RowsProperty
        /// <summary>
        /// Rowsプロパティ
        /// </summary>
        public static readonly DependencyProperty RowsProperty =
            DependencyProperty.RegisterAttached(
                "Rows",
                typeof(int),
                typeof(TabControlHelper),
                new FrameworkPropertyMetadata(1)
            );
        /// <summary>
        /// Rowsを取得します。
        /// </summary>
        /// <param name="dp"></param>
        /// <returns></returns>
        public static int GetRows(DependencyObject dp)
        {
            return (int)dp.GetValue(RowsProperty);
        }
        /// <summary>
        /// Rowsを設定します。
        /// </summary>
        /// <param name="dp"></param>
        /// <param name="value"></param>
        public static void SetRows(DependencyObject dp, int value)
        {
            dp.SetValue(RowsProperty, value);
        }
        #endregion
    }
```

``` XML
    <TabControl
        x:Name="FeeTabControl"
        Width="970"
        Height="320"
        behavior:MoveFocusBehavior.IsSkip="All"
        ItemsSource="{Binding SeasonList, Mode=OneWay}"
        SelectedItem="{Binding SeasonSelectedItem, Mode=TwoWay}">
        <!-- 添付プロパティの設定 -->
        <!-- 行が0なら1にするTrigger。ここでもあれこれあった。できれば直接添付プロパティを参照したかったけどそうしたらStackOverFlowしやがった。 -->
        <TabControl.Style>
            <Style BasedOn="{StaticResource {x:Type TabControl}}" TargetType="{x:Type TabControl}">
                <Setter Property="helper:TabControlHelper.Rows" Value="{Binding Path=Items.Count, RelativeSource={RelativeSource Self}, Converter={StaticResource DivideConverter}, ConverterParameter=4}" />
                <Style.Triggers>
                    <DataTrigger Binding="{Binding Path=Items.Count, RelativeSource={RelativeSource Self}, Converter={StaticResource DivideConverter}, ConverterParameter=4}" Value="0">
                        <Setter Property="helper:TabControlHelper.Rows" Value="1" />
                    </DataTrigger>
                </Style.Triggers>
            </Style>
        </TabControl.Style>
        <TabControl.ItemTemplate>
            <DataTemplate>
                <TextBlock Text="{Binding SeasonName}" />
            </DataTemplate>
        </TabControl.ItemTemplate>
        <TabControl.ContentTemplate>
            <DataTemplate>
            </DataTemplate>
        </TabControl.ContentTemplate>
    </TabControl>
```

### ボツ作品

総数を列の数で割って行を求めようとした。  
ほぼできたし動くのも確認できたけど、現存するConverterだけでは無理そうだったのと、そもそも2行にするプログラムは料金台帳しかないから、View及びViewModel側から値を設定できたほうが楽でいいんじゃないかと気が付いてやめた。  
まぁ、色々検証できたのでこれはこれでよかったけど。  

``` XML
<Grid
    x:Name="HeaderPanelGrid"
    Grid.Row="0"
    Grid.Column="0"
    Panel.ZIndex="1">
    <mah:Underline
        x:Name="Underline"
        Background="{DynamicResource MahApps.Brushes.WindowTitle}"
        BorderBrush="{TemplateBinding mah:TabControlHelper.UnderlineBrush}"
        LineThickness="{TemplateBinding BorderThickness}"
        Placement="Bottom"
        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
        Visibility="Collapsed" />
    <!--<TabPanel
        x:Name="HeaderPanel"
        IsItemsHost="true"
        KeyboardNavigation.TabIndex="1" />-->
    <UniformGrid
        x:Name="HeaderPanel"
        Columns="{TemplateBinding helper:TabControlHelper.Colums}"
        IsItemsHost="true"
        KeyboardNavigation.TabIndex="1">
        <UniformGrid.Style>
            <Style TargetType="{x:Type UniformGrid}">
                <Setter Property="Rows" Value="1" />
                <Style.Triggers>
                    <DataTrigger Binding="{Binding Path=Columns, RelativeSource={RelativeSource Self}, Converter={StaticResource NegativeToBoolConverter}}">
                        <Setter Property="Rows">
                            <Setter.Value>
                                <MultiBinding Converter="{StaticResource DivideMultiConverter}" ConverterParameter="{x:Type sys:Int32}">
                                    <MultiBinding.Bindings>
                                        <Binding Path="Items.Count" RelativeSource="{RelativeSource FindAncestor, AncestorType={x:Type TabControl}}" />
                                        <Binding Path="Columns" RelativeSource="{RelativeSource Self}" />
                                    </MultiBinding.Bindings>
                                </MultiBinding>
                            </Setter.Value>
                        </Setter>
                    </DataTrigger>
                </Style.Triggers>
            </Style>
        </UniformGrid.Style>
        <!--<UniformGrid.Rows>
            <MultiBinding Converter="{StaticResource DivideMultiConverter}" ConverterParameter="{x:Type sys:Int32}">
                <MultiBinding.Bindings>
                    <Binding Path="Items.Count" RelativeSource="{RelativeSource FindAncestor, AncestorType={x:Type TabControl}}" />
                    <Binding Path="Columns" RelativeSource="{RelativeSource Self}" />
                </MultiBinding.Bindings>
            </MultiBinding>
        </UniformGrid.Rows>-->
    </UniformGrid>
</Grid>
```

``` xml : なんかYr君が最初に提示してくれた案
ItemsPanel
    <Setter Property="ItemsPanel">
        <Setter.Value>
            <ItemsPanelTemplate>
                <Grid></Grid>
            </ItemsPanelTemplate>
        </Setter.Value>
    </Setter>
```

---

## TriggerActionに値を渡すサンプル

2021/10/06 Wed  
C1MultiSelectのカスタムコントロールが全然できないので、そもそも本当に選択状態を反映させることができるのか実験するために、TriggerAction方式でやってみることにした。  
単純な値を渡すだけでもInteractionが必要だったので、ついでにまとめることにした。  
ちなみに選択状態の反映はうまくいった。  

``` C# : Front.DutchTreat.ViewModels.cs
{
    // 科目大区分の選択状態を反映させる
    await Messenger.RaiseAsync(
        new InteractionSetSelectedItemsOfSubjectLargeType(
            "SetSelectedItemsOfSubjectLargeTypeAction",
            SubjectLargeTypeList
                .Where(w => settlementSet.SubjectLargeTypeCDList
                    .Contains(w.SubjectLargeTypeCD))
        )
    );
}
```

``` XML : Front.DutchTreat.Views.EditWindow.xaml
    <i:Interaction.Triggers>
        <l:InteractionMessageTrigger MessageKey="SetSelectedItemsOfSubjectLargeTypeAction" Messenger="{Binding Messenger}">
            <localaction:SetSelectedItemsOfSubjectLargeTypeAction />
        </l:InteractionMessageTrigger>
    </i:Interaction.Triggers>
```

``` C# : Front.DutchTreat.Interaction.cs
    /// <summary>
    /// C1MultiSelectに選択状態を反映させるためのインタラクション
    /// </summary>
    public class InteractionSetSelectedItemsOfSubjectLargeType : InteractionMessage
    {
        /// <summary>
        /// コンテキスト
        /// </summary>
        public IEnumerable<SubjectLargeTypeWithSubjectCDList> List { get; set; }
        /// <summary>
        /// コンストラクタ
        /// </summary>
        /// <param name="messageKey"></param>
        public InteractionSetSelectedItemsOfSubjectLargeType(string messageKey) : base(messageKey) { }
        /// <summary>
        /// コンストラクタ
        /// </summary>
        /// <param name="messageKey"></param>
        /// <param name="list"></param>
        public InteractionSetSelectedItemsOfSubjectLargeType(string messageKey, IEnumerable<SubjectLargeTypeWithSubjectCDList> list) : this(messageKey) => List = list;
        /// <summary>
        /// 派生クラスでは必ずオーバーライドしてください。Freezableオブジェクトとして必要な実装です。
        /// 通常このメソッドは、自身の新しいインスタンスを返すように実装します。
        /// </summary>
        /// <returns>自身の新しいインスタンス</returns>
        protected override Freezable CreateInstanceCore() => new InteractionSetSelectedItemsOfSubjectLargeType(MessageKey, List);
    }
```

``` C# : Front.DutchTreat.TriggerAction.cs
    /// <summary>
    /// C1MultiSelectに選択状態を反映させるためのアクション
    /// </summary>
    public class SetSelectedItemsOfSubjectLargeTypeAction : TriggerAction<C1MultiSelect>
    {
        /// <summary>
        /// 選択状態を反映させます。
        /// </summary>
        /// <param name="parameter"></param>
        protected override void Invoke(object parameter)
        {
            if (parameter is InteractionSetSelectedItemsOfSubjectLargeType message)
            {
                // 値が重複したらエラーになるので念のため消してからセットする。
                AssociatedObject.ListBox.SelectedItems.Clear();
                foreach (var item in message.List) AssociatedObject.ListBox.SelectedItems.Add(item);
            }
        }
    }
```

---

## 幅いっぱいのやつと中央のやつの違い

白い帯が幅いっぱいになるタイプのダイアログとウィンドウタイプのダイアログ。  
どちらも実装したけれど、具体的に何が違うのかずっと疑問だったのでまとめた。  

InteractionMessage

インタラクショントリガー
ウィンドウがアクティブな状態でF8が押下されたときに実行しますよ。
上から順に実行しますよ。
1行1行がTrrigerAction。
Invokeを必ず持つ。

Invokeは実行する関数。

インタラクショントリガー
→
イベントトリガー
→
アクショントリガー

・ウィンドウ ShowMetroDialogAsync 専用TriggerAction  XAMLあり  
・幅OKのみ   ShowMessageAsync     共通TriggerAction  XAMLなし  
・幅入力あり ShowMetroDialogAsync 共通TriggerAction  XAMLあり  

つまりはそういうことだ。  
何かしらのカスタムをしたかったら、XAML作ってShowMetroDialogAsyncをする必要がある。  
ボタンだけの簡潔なダイアログだけならMetro固有の何かで十分なのだろう。  

### チェックイン入力F7伝票入力(中央のやつ)

ウィンドウタイプの代表としてチェックイン入力のF7伝票入力を採用することにした。  
一番身近で出しやすかったから。  
ウィンドウタイプとして出すためには、出力する画面を設計して、間にトリガーアクションを挟む必要がある。  
いまだにトリガーアクションとコードビハインドの書き方がわからない。  

``` C#  : Front.CheckInTSheet.ViewModels.EditWindowViewModels.cs
    ShowSlipDialogCommand = new DelegateCommand(
        () => Messenger.Raise(new InteractionModalDialogMessage("ShowSlipDialog", "伝票入力", this)), 
        () => !IsBusy
    );
```

``` XML : Front.CheckInTSheet.Views.EditWindow.xaml
    <i:Interaction.Triggers>
        <l:InteractionMessageTrigger MessageKey="ShowSlipDialog" Messenger="{Binding Messenger, Mode=OneWay}">
            <local_ctrl:ShowModalDialogAction DialogWidth="1240" IsBusy="{Binding IsBusy, Mode=OneWay}" />
        </l:InteractionMessageTrigger>
    </i:Interaction.Triggers>
```

``` C#  : Front.CheckInTSheet.Control.ShowModalDialogAction.cs
    /// <summary>
    /// ModalDialogを開くTrrigerAction
    /// </summary>
    public class ShowModalDialogAction : TriggerAction<MetroWindow>
    {
        
        /// <summary>
        /// CustomDialogを開きます
        /// </summary>
        /// <param name="parameter"></param>
        protected override async void Invoke(object parameter)
        {
            if (parameter is InteractionModalDialogMessage message)
            {
                var setting = new MetroDialogSettings()
                {
                    AnimateHide = false,
                    AnimateShow = false
                };
                _Dialog = new ModalDialog(setting)
                {
                    Content = message.DataContext,
                    ContentTemplate = DialogContent,
                    Title = message.Title,
                    Padding = new Thickness(30),
                };
                var content = AssociatedObject.Content as UIElement;
                bool contentIsEnabled = true;
                if (content != null)
                {
                    //値を保持
                    contentIsEnabled = content.IsEnabled;
                    //ダイアログ表示中にウィンドウ下の要素に対しての操作を不能にする
                    content.IsEnabled = false;
                }
                _Dialog.CloseCommand = new DelegateCommand(async () =>
                {
                    await AssociatedObject.HideMetroDialogAsync(_Dialog);
                    //ダイアログを破棄
                    _Dialog = null;
                    if (content != null)
                        content.IsEnabled = contentIsEnabled;
                    // 終了時に行う処理があれば実行(DataContextにIDisposableを持っても良いかもしれない。)
                    if (message.ClosedCallback != null)
                    {
                        var closedCallback = message.ClosedCallback;
                        message.ClosedCallback = null;
                        closedCallback();
                        closedCallback = null;
                    }
                });
                _Dialog.SetBinding(
                    ModalDialog.IsBusyProperty, 
                    new Binding("IsBusy")
                    {
                        Source = this,
                        Mode = BindingMode.OneWay,
                    }
                );
                _Dialog.DialogWidth = DialogWidth;
                await AssociatedObject.ShowMetroDialogAsync(_Dialog);
                var ctrlContent = _Dialog.FindChild<ContentPresenter>("PART_Content");
                var child = ctrlContent.FindVisualChild<UIElement>();
                if (child != null)
                {
                    var focusCtrl = FocusManager.GetFocusedElement(child);
                    if (focusCtrl != null)
                    {
                        focusCtrl.Focus();
                    }
                    else
                    {
                        child.Focus();
                    }
                }
                await _Dialog.WaitUntilUnloadedAsync();
                child = null;
                ctrlContent = null;
                setting = null;
            }
        }
    }
```

``` C#  : Front.CheckInTSheet.Control.SlipDialog.cs
    // ウィンドウのコードビハインド
    /// <summary>
    /// SlipDialog.xaml の相互作用ロジック
    /// </summary>
    public partial class SlipDialog : CustomDialog
    {
        //  MahApps.Metro.Controls.Dialogs.CustomDialog : BaseMetroDialog
    }
```

### 商品台帳のF8保存のバリデーションエラーの時に表示されるやつ(幅いっぱい)

OKボタンしかないタイプのもの。一番よく見かけるやつ。  
横いっぱいのタイプも基本的にはトリガーアクションでMetroのshow系の命令を叩くが、こちらはオリジナルで定義したXAMLは呼び出していない。  

``` C#  : Common.Util.DialogUtil.MessageDialogUtil.cs
    // F8→ViewModelBase→MessageDialogUtil

    /// <summary>
    /// エラーダイアログを表示します。
    /// </summary>
    /// <param name="messenger">メッセンジャー</param>
    /// <param name="message">メッセージ</param>
    public static void ShowWarning(InteractionMessenger messenger, string message)
    {
        messenger.Raise(
            new InteractionDialogMessage(
                "MessageDialog",
                "エラー",
                message,
                MessageDialogStyle.Affirmative,
                response => { }
            )
        );
    }
```

``` XML : Master.Product.Views.EditWindow.xaml
    <i:Interaction.Triggers>
        <l:InteractionMessageTrigger MessageKey="MessageDialog" Messenger="{Binding Messenger}">
            <action:ShowDialogAction />
        </l:InteractionMessageTrigger>
    </i:Interaction.Triggers>
```

``` C#  : Common.TriggerAction.ShowDialogAction.cs
    /// <summary>
    /// Dialogを開くTrrigerAction
    /// </summary>
    public class ShowDialogAction : TriggerAction<MetroWindow>
    {
        /// <summary>
        /// Dialogを開きます
        /// </summary>
        /// <param name="parameter"></param>
        protected override void Invoke(object parameter)
        {
            if (parameter is InteractionDialogMessage message)
            {
                var content = AssociatedObject.Content as UIElement;
                bool contentIsEnabled = true;
                if (content != null)
                {
                    //値を保持
                    contentIsEnabled = content.IsEnabled;
                    //ダイアログ表示中にウィンドウ下の要素に対しての操作を不能にする
                    content.IsEnabled = false;
                }
                // MahApps.Metro.Controls.Dialogs.MetroDialogSettings
                var settings = new MetroDialogSettings()
                {
                    FirstAuxiliaryButtonText = message.FirstAuxiliaryButtonText,
                    SecondAuxiliaryButtonText = message.SecondAuxiliaryButtontext,
                    AnimateHide = false,
                    AnimateShow = false,
                    DefaultButtonFocus = message.DefaultButtonFocus
                };
                if (!string.IsNullOrEmpty(message.AffirmativeButtonText))
                    settings.AffirmativeButtonText = message.AffirmativeButtonText;
                if (!string.IsNullOrEmpty(message.NegativeButtonText))
                    settings.NegativeButtonText = message.NegativeButtonText;

                Dispatcher.Invoke(
                    async () =>
                    {
                        var result = await AssociatedObject.ShowMessageAsync(message.Title, message.Message, message.Style, settings);
                        if (content != null)content.IsEnabled = contentIsEnabled;
                        message.Callback(result);
                        settings = null;
                    }, 
                    System.Windows.Threading.DispatcherPriority.Render
                );
            }
        }
    }
```

### チェックイン入力F3会計No変更の場合のやつ(幅いっぱい)

簡単な入力欄があるタイプのもの。  
基本的に入力があるものはXAMLを設計するらしい。  

``` C#  : Front.CheckInTSheet.ViewModel.EditWindow.cs
    // 会計No入力ダイアログ表示
    ShowAccountNoInputDialogCommand = new DelegateCommand(
        () => Messenger.Raise(
            new InteractionInputTextDialogMessage(
                "ShowAccountNoInputDialog",
                "会計No変更",
                string.Format(Message.RequestInput, "会計No"),
                null,
                4,
                InputMethodType.ImeOff,
                null,
                async value =>
                {
                }
            )
        ),
        () => !IsBusy && !string.IsNullOrEmpty(Data?.AccountNo)
    );
```

``` XML : Front.CheckInTSheet.Views.EditWindow.xaml
    <i:Interaction.Triggers>
        <l:InteractionMessageTrigger MessageKey="ShowAccountNoInputDialog" Messenger="{Binding Messenger, Mode=OneWay}">
            <action:ShowInputTextDialogAction />
        </l:InteractionMessageTrigger>
    </i:Interaction.Triggers>
```

``` C#  : Common.TriggerAction.ShowInputTextDialogAction.cs
    /// <summary>
    /// テキスト入力Dialogを開くTrrigerAction
    /// </summary>
    public class ShowInputTextDialogAction : TriggerAction<MetroWindow>
    {        
        /// <summary>
        /// Dialogを開きます
        /// </summary>
        /// <param name="parameter"></param>
        protected override async void Invoke(object parameter)
        {           
            if(parameter is InteractionInputTextDialogMessage message)
            {
                 // CustomDialogはMahApps.Metro.Controls.Dialogs名前空間のBaseMetroDialogを継承したクラス
                var dialog = new CustomDialog(){ Title = message.Title };
                // カスタムコントロールのインスタンス
                InputTextDialog dialogContent = new InputTextDialog()
                {
                    Message = message.Message,
                    Input = message.Input,
                    MaxLength = message.MaxLength,
                    InputMethod = message.InputMethod,
                    Format = message.Format,
                    AffirmativeCommand = new DelegateCommand<string>(async response =>
                    {
                        await AssociatedObject.HideMetroDialogAsync(dialog);
                        message.Callback(response);
                        dialogContent = null;
                        dialog = null;
                    }),
                    NegativeCommand = new DelegateCommand<string>(async response =>
                    {
                        await AssociatedObject.HideMetroDialogAsync(dialog);
                        message.Callback(null);
                        dialogContent = null;
                        dialog = null;
                    })
                };
                dialog.Content = dialogContent;
                await AssociatedObject.ShowMetroDialogAsync(
                    dialog,
                    new MetroDialogSettings()
                    {
                        AnimateHide = false,
                        AnimateShow = false
                    }
                );
            }
        }
    }
```

``` C#  : Common.Control.InputTextDialog.cs
    /// <summary>
    /// InputTextDialog.xaml の相互作用ロジック
    /// </summary>
    public partial class InputTextDialog : UserControl
    {
    }
```
