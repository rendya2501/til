# インデックスメモ

## union all 後のindex

例えば、AテーブルとBテーブルがあります。  
AテーブルとBテーブルは同じ構造です。  
Aテーブルは当日・未来の情報を保持し、Bテーブルは過去の情報を保存するテーブルです。  
BIツールのように、データを収集して表示したい場合に、テーブルを連結して、日付等でBETWEENしたいです。  
AテーブルもBテーブルも何かしらのコードや日付等にインデックスが貼られているものとします。  
その時、日付やコードを条件に含めた場合に、union all後のサブテーブルへの検索にはインデックスは効くと思われますか？  
イメージとしてはこんな感じです。  

C#でDapperを使ったアクセスを想定し、データベースはSQLServerとします。

``` sql
SELECT SUM(Amount)
FROM (
    SELECT * FROM A_Table
    UNION ALL
    SELECT * FROM B_Table
) AS SQ
WHERE MainCD = @mainCD
AND BusinessDate BETWEEN @businessDateTermFrom AND @businessDateTermTo
AND ItemCD BETWEEN @FromCD1 AND @ToCD1
```

A: このようなクエリの場合、インデックスが効くかどうかはデータベースのオプティマイザに依存しますが、効く可能性は高いです。  
ただし、より効率的なクエリを書くことで、インデックスの効果をさらに向上させることができます。  

具体的には、UNION ALLの前にWHERE句を適用して、それぞれのテーブルでフィルタリングを行うと、データベースがインデックスをより効果的に使用できます。  
以下のようなクエリを検討してみてください。  

``` sql
SELECT SUM(Amount)
FROM (
    SELECT * FROM A_Table
    WHERE MainCD = @officeCD
    AND BusinessDate BETWEEN @businessDateTermFrom AND @businessDateTermTo
    AND ItemCD BETWEEN @FromCD1 AND @ToCD1
    UNION ALL
    SELECT * FROM B_Table
    WHERE MainCD = @officeCD
    AND BusinessDate BETWEEN @businessDateTermFrom AND @businessDateTermTo
    AND ItemCD BETWEEN @FromCD1 AND @ToCD1
) AS SQ
```

このようにクエリを変更することで、それぞれのテーブルに対してフィルタリングが行われるため、インデックスが適切に使われる可能性が高まります。  
ただし、実際のパフォーマンスはデータベース管理システム（DBMS）やデータの分布、インデックスの設定などに依存します。  

最適なパフォーマンスを得るためには、実行計画を確認し、インデックスが適切に使用されているかどうかをチェックしてください。  
また、必要に応じてインデックスの設定を調整して、クエリのパフォーマンスを向上させることができます。  
