# 正規化

## 正規化とは？

データとかを使いやすいように整理したり変形したりすること。  
正規化の目的は冗長性の排除することで更新時異状を回避し、データベースの一貫性を確保すること。  
DB上で扱うデータの重複を排除し、「矛盾」の発生を「設計レベル」で防ぐこと。  
正規化はパフォーマンス向上のために行うわけではない。  

---

## 第1正規形

同一行内に置ける重複の排除  

ポイント：レコードの繰り返し項目を別のレコードへと分割する  

パッと見DBに格納できる状態ではあるが、重複しまくっているので使い物にはならない状態。  

---

## 第2正規形

部分関数従属の排除  

複合主キーの部分キーによって一意に定まる属性を別表に移したもの。  
主キーに部分従属している属性を分離したもの。  
ポイント：テーブルの主キーに着目し、その項目に関数従属する非キー項目を見つける。  

この項目はこの主キーとこの主キーの組み合わせで特定できるよね？  
逆にこの項目はこの主キーだけで特定できるよね？  
ってのを上げて、それぞれのテーブルに分離した状態。  

---

## 第3正規形

推移的関数従属の排除  

主キー又は主キーの一部に推移的に関数従属する属性を別表に移します。  
どのテーブルであってもすべての属性が主キーに対して完全従属であるテーブルにします。  
`a→b→{f，g，h}、受注番号→顧客コード→顧客名`  
ポイント：非キー項目に着目して、関数従属する項目を見つける  

それぞれのテーブルに分けたのはいいけれど、分けた後のテーブルの中に主キーじゃないキーで特定できる項目(非キー項目)が残ってるよね。  
このキーとなりえる項目とそれに紐づく名称とかの情報は別のテーブルとして独立させることができるよね？  
ってのを探して、それを分離させた状態。  
つまり、マスターとして独立した状態。  

---

## 結局のところ、第1正規系と第2正規系と第3正規系って何が違うの？

第1正規系はわかる。  
正規化される前の状態はレコードが重複しまくって、データベースに格納できない状態だから、その重複を解消するのが第1正規系で行うこと。  
正直、この状態は試験ではまず出ない。対策するなら第2正規系と第3正規系の一番微妙な間をやるべし。  

第3正規系はマスターとしてまとまってる状態ではなかろうか。  
主キーで一意に決まるテーブルとしてそれぞれ分離された状態。  
少なくとも、業務でデータベースを設計するならここまでやらないと不十分だろう。  
データを参照する際はテーブルを結合しまくってようやくデータが出来上がるって状態にまで分離された状態。  

第1と第3がわかれば、第2もなんとなくわかってくるのでは？  
正直、第2正規系が一番微妙なのだが、「これ別のテーブルに分離できるよな？」ってのがあれば第2正規系状態といえるのではないだろうか。  
次にデータベースの問題をやるなら、そういう点に着目してやってみようかね。  

まぁ、上に行く程重複もなくなって、テーブルとして独立していくってイメージでいいんじゃないでしょうかね。  

第1正規形：レコードの繰り返し項目を別レコードへと分割する。  
第2正規形：テーブルの主キーに着目して、関数従属する非キー項目を見つける。  
第3正規形：テーブルの非キーに着目して、関数従属する項目を見つける。  

---

[うさぎでもわかる](https://www.momoyama-usagi.com/entry/info-database-seikika)  
[[DataBase]で行う正規化の手順についてわかりやすく解説します](https://rikulogger.com/db/nomalization/)
