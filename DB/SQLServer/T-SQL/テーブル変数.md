# テーブル変数

## 概要

テーブル変数は、変数としてテーブルを作成できる機能。  
変数の有効範囲はローカル変数と同様で、バッチ内のみ。  

作成したテーブル変数は、明示的に削除する方法はない。  
バッチ終了時に自動的に削除される。  

---

## 定義

DECLAREでの変数宣言時にデータ型へ「`table`」を指定する。  
後は、CREATE TABLEステートメントでの列定義と同様、テーブル定義が行える。  

``` sql
DECLARE @テーブル変数名 table
(
    列名1 データ型,
    列名2 データ型,
    …
)
```

テーブル変数へ値を代入するには、INSERTステートメントでサブクエリを利用する。  

``` sql
INSERT INTO @テーブル変数名
SELECT * FROM テーブル名 ~
```

---

## 例

ROW_NUMBERで取得した結果をテーブル変数「@t」へ格納して、一時テーブルの時と同じ結果を取得する。  

``` sql
DECLARE @t table
(
    rownum int,
    社員番号 int,
    氏名 char(50)
)

INSERT INTO @t
SELECT ROW_NUMBER() OVER (ORDER BY 入社日 DESC) AS rownum, * FROM 社員

SELECT * FROM @t
WHERE rownum BETWEEN 4 AND 6
```

---

## テーブル変数と一時テーブルの使い分け

テーブル変数は、一時テーブルと比べて次の制限事項がある。  

- SELECT INTO でテーブル変数を作成できない。  
- テーブル変数でインデックスを作成できない。  
- パラレル処理の対象とならない(複数CPUコアがある場合の並列処理)  
- 有効範囲がバッチ内のみ(一時テーブルは接続している間有効)  

このように、テーブル変数は、一時テーブルと比べて、利用が面倒なのと、パフォーマンス関連(インデックスを作成できない点とパラレル処理の対象とならない点)で一時テーブルよりも劣る。  
簡単な処理であれば、速度はほとんど変わらないが、クエリ結果に対してインデックスを作成してチューニングしたい場合には、テーブル変数を利用することができない。  
従って、テーブル変数を一時テーブルの置き換えとして利用しようと考えている場合は、置き換えることはせず、一時テーブルを利用することを勧める。  

---

## テーブル変数を配列のように利用する  

T-SQLでは、配列を扱える機能はないが、tableデータ型を利用すると、複数の値を格納できるので、配列と同じように利用することができる。  
