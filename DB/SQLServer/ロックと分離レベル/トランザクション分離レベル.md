# トランザクションの分離とIsolation Level

## 概要

トランザクションは1つずつ直列(Serial:シリアル)実行されるのであれば、データは矛盾のない状態に保たれる。  
しかし、実際には複数のユーザーが接続し、複数のトランザクションが並行して実行される。  

``` txt
直列実行(シリアル)    並列実行(パラレル)
↓A                   A      C
↓B                   ↓  B  |
↓C                   ↓  ↓ |
↓D                       ↓
```

このように並列実行されているトランザクションを直列実行されたときと同じように実行している状態が、トランザクションが分離(Isolation)された状態。  
トランザクションが分離された状態では、トランザクションが1つずつ直列実行された時と同じように、データの矛盾は発生しない。  

---

## トランザクション分離レベル

SQLの標準規格「ANSI SQL92」では、トランザクションの分離が満たされているかどうかを「一貫性水準」として、次の図の4つのIsolation Level(分離レベル)を定めている

``` txt
                 |       発生しうるデータの矛盾         |
Isolation Level  | dirty      | NonRepeat  | Phantom    |
-----------------+------------+------------+------------|
READ UNCOMMITTED | 発生する   | 発生する   | 発生する   | ↑Isolationは満たされない。データの矛盾あり
READ COMMITTED   | 発生しない | 発生する   | 発生する   | ｜
REPEATABLE READ  | 発生しない | 発生しない | 発生する   | ｜
SERIALIZABLE     | 発生しない | 発生しない | 発生しない | ↓完全なIsolationの実現。データの矛盾なし
```

データの一貫性が保たれるかどうか(データに矛盾が発生する可能性があるかどうか)で4つのレベルにわけ、複数のトランザクションが同時実行された場合に怒りえるデータの矛盾を3種類(ダーティーリード、ノンリピータブルリード、ファントムリード)を挙げている。  

分離レベルの実装はデータベース製品によって異なるが、**SQLServer、Oracle,DB2のデフォルト分離レベルは「Read Committed」**。  

※ADO.NetのSqlTransactionクラスのデフォルトはRead Committed  
※ADO.Net2.0以降のTransactionScopeクラスのデフォルトはSerializable  

---

## 分離レベルの変更

分離レベルを変更するには、ロックヒントと同様にテーブル名の後ろへ`WITH`句をつけて次のように指定する。  

``` sql
SELECT *
FROM TableName WITH(分離レベル名)
```

分離レベル名には次の4つを指定できる。  

- ReadUnCommitted (NOLOCKと指定しても可能)  
- ReadCommitted  
- RepeatableRead  
- Serializable (HOLDLOCKと指定しても可能)  

分離レベルはスペースなしで詰めて指定することに注意する。  

## 分離レベルをセッション単位で設定

分離レベルはセッション(接続)単位で設定することも可能。  
SETステートメントを使用する。  

``` sql
SET TRANSACTION ISOLATION LEVEL 分離レベル名
```

SETステートメントの場合は、ロックヒントの場合とは異なり、分離レベルをスペース付きで指定する必要がある。  

- Read UnCommitted  
- Read Committed  
- Repeatable Read  
- Serializable  

---

## ダーティーリードとRead UnCommitted

ダーティーリード(Dirty Read:不正読み取り)とは、コミットされていないデータを読み取れる現象のこと。  

分離レベルを`Read UnCommitted`へ変更した場合に発生する可能性がある現象。  
`Read Uncommitted`では排他ロックを無視してデータを読み取ることができる。(読み取り時のロック待ちが発生しない)  
読み取ったデータがロールバックされた場合には、データに矛盾が発生することになる。  
このように、未確定(UnCommitted)のデーtあを不正に読み取ることからダーティーリードと呼ばれている。  

``` sql
UPDATE A→B

SELECT -- A

ROLLBACK -- B
```

### Read UnCommittedはパフォーマンス向上がメリット

Read UnCommittedはダーティーリードが発生するからといって、利用価値のないレベルというわけではない。  
排他ロックを無視してデータを読み取れることはパフォーマンス上の大きなメリットとなる。  
ダーティーリードによるデータの矛盾はアプリケーションの種類の寄っては許容範囲内であったり、運用でカバー出来たり、アプリケーション側のちょっとした工夫(ロールバックされるとデータが変わる可能性があることを明記しておくなど)でカバーできることが多々ある。  
また、未確定のデータを読み取っても、それがコミットされてば正しいデータとなる。  
ロック待ちが原因のパフォーマンス低下に悩まされている場合は、Read UnCommittedを利用することで解決できるケースは多いので、多くの場面で役に立つ。  

Read UnCommittedは内部的には「共有ロックをかけない」という動作をすることで、排他ロックと競合しないようにし、排他ロックを無視してデータを読み取れるようにしている。  
WITH(NoLock)がRead UnCommittedと同じ動作なのは、NoLock(共有ロックをかけない)という意味。  

---

## ダーティリードの回避

ダーティリードはデフォルトの分離レベル`Read Committed`であれば回避可能。  
Read Committedでは、排他ロックのかかっているデータを参照することは出来ず、UnCommitted(未コミット)なデータを読み取ることはできない。(ダーティリードは発生しない。)  

データがコミットされるまでロック待ちになるため、ダーティリードは発生しない。  

Committed(確定された)データだけを読み取れるレベルということで、Read Committedと呼ばれている。  
Read Committedレベルでは、正確にはデータの読み取り時に共有ロックを掛けようとすることで、排他ロックにブロックされる。  
従って、利用状況モニターで確認したように、SELECTステートメントのロック待ちは、待機の種類が「`LCK_M_S`」で表示される。  

---

## 反復読み取り不可 : Non Repeatable Read

反復読み取り不可(Non Repeatable Read)は、デフォルトのRead Committedレベルでは発生する可能性があるデータの矛盾。  
この矛盾は一度読み取ったデータが他のトランザクションによって更新され、二度目に読み取ったときに異なるデータになっているというもの。  
文字通り、反復読み取りができない(1回目と2回目でデータが違う)という矛盾。  

反復読み取り不可の例には、予約システムの予約処理がある。  

---

## 反復読み取り不可の回避

反復読み取り不可を回避するには「`Repeatable Read`」(反復読み取り可能)という分離レベルを利用する。  
この分離レベルは、内部的には次のようにロックの動作を変更することで実現している。  

- 共有ロックをトランザクションが完了するまで保持  

---

## Repeatable Readの注意点

デッドロックが多発するという事態。  
Repeatable Readは、ダブルブッキングを防げるという意味では、利用価値がある分離レベルに見えるかもしれないが、デッドロックを発生させているという点に大きな落とし穴がある。  

---

## 更新ロックによる変換デッドロックの回避

Repeatable Readレベルによって発生する変換デッドロックを回避するには「更新ロック」(UpdateLock)を利用する。  

更新ロックは排他ロックと共有ロックの中間のような特徴を持つ。  
更新ロックは、更新ロックをブロック出来るという特徴を持つ。  

||共有ロック|更新ロック|排他ロック|
|:-:|:-:|:-:|:-:|
|共有ロック|○|○|×|
|更新ロック|○|×|×|
|排他ロック|×|×|×|

---

## 更新ロックの注意点

更新ロックは変換デッドロックもダブルブッキングも防ぐ事ができるため、最高の解決策のように感じるかもしれない。  
実際、ごく少人数のユーザーがデータを入力するシステムで、かつ同時更新が許されないようなシステム(会計システムなど)では重宝する機能。  
しかし、更新ロックは同時実行性が大幅に低下するという大きな代償がある。  

更新ロックは「誰かが更新するかもしれないから、念のためにブロックしておく」という悲観的な発想に基づいていることから「悲観的同時実行制御」とも呼ばれている。  

---

## ファントム読み取り : Phantom Read

---

## ファントム読み取りの回避

ファントム読み取りを回避できるのが、`Serializable`レベル。  
内部的には次のようなロックの動作を変更する事で実現している。  

- 共有ロックをトランザクションが完了するまで保持  
- 共有ロックを該当データだけでなく、その周囲のデータもロックする(範囲ロックをかける)  

---

## Serialiazableの問題点

デッドロックが多発すること。  

実際、Serializableレベルを利用する場面はほとんどない。  
ファントム読み取りを回避するには、アプリケーション側でファントムデータのチェックをしたり、重複値のINSERTの場合はUNIQUE制約を利用したり、運用でカバーしたりするようにする。  
また「更新ロック」や「楽観的同時実行制御」が利用できる場合はそちらを利用する。  
