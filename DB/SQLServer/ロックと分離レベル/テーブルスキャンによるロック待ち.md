# テーブルスキャンによるロック待ち

## 概要

以下のように「t1」テーブルがあるとする。  
a列、b列にインデックスは張られていないものとする。  

``` txt
「t1」テーブル

| a |  b  |
|---+-----|
|1  | BBB |
|2  | CCC |
|:  |  :  |
|7  | GGG |<- 排他ロック
|8  |  :  |   トランザクションX
|:  |  :  |   UPDATE t1 SET b='g' WHERE a=7
|20 | CCC |
|:  |  :  |

トランザクションY
SELECT * FROM t1 WHERE b = 'CCC'
b列をテーブルスキャン
```

1. トランザクションXを実行して[a=7]を排他ロックする。  
2. トランザクションYを実行して[b='CCC']のデータを参照する。  
3. SQLServerはインデックスがない場合、[b='CCC']という条件を満たすデータを探すために、テーブルスキャン(すべてのデータを先頭から順に最後のデータまで調べる)を実行する。  
4. トランザクションYが[a=7]に到達するが排他ロックされているため内部的にロック待ちが発生する。  

これがテーブルスキャンによるロック待ち。  

この現象はたった1つのロック(行単位のロック)によってテーブル全体がロックされているように見えるため、「ロックエスカレーション」が発生していると勘違いされることが多い。  

※排他ロック : 他のトランザクションからのあらゆるアクセスをブロックする。  

---

## 回避方法

SQLServer 2005から提供された「READ_COMMITTED_SNAPSHOT」「スナップショット分離レベル」機能を利用することで回避できる。  

この2つはOracleでの「読み取り一貫性」に相当する機能。  

---

## テーブルスキャンによるロック待ちの回避方法

1. 適切なインデックスを作成する  
2. テーブルスキャンをしなくて済むようにWHERE句の条件式を工夫する  
3. トランザクションをできる限り短くする  
4. Repeatable Read と Serializable 分離レベルを避ける
5. 更新ロック(UPDLOCK)をなるべく避け、楽観的な同時実行制御を実戦する。  
6. NOLOCKヒント(ダーティーリード)を利用する  

### 1.インデックスを作成する

WHERE句の条件式で利用している列へインデックスを作成する。  
概要で説明した例であれば、「b」列へインデックスを作成すれば、ロック待ちをしなくて済む。  
インデックスがある場合はデータをピンポイント(Index Seek)で取得できるため。  

![label](https://dhmacher.files.wordpress.com/2013/02/index-seek1.jpg)  

なお、インデックスを作成した場合にも、オプティマイザー(クエリの実行計画を判断する内部プログラム)によってインデックスが利用されないケースがある。  
この場合にはロック待ちが発生してしまうため、回避方法として次の2つがある。  

- FORCESEEKロックヒント(Index Seekへの強制変更)を利用する(SQLServer2008から提供された機能)  
- ロックをかけている側のトランザクションをできる限り短くする  

### 2.テーブルスキャンをしなくて済むようにWHERE句の条件式を工夫する

WHERE句の条件式の工夫は、アプリケーションのユーザーインターフェースを工夫することを意味する。  
よくある例として、デフォルトでは検索条件をほとんど設定せずに、「検索」ボタンをクリックすると大量のデータを取得してしまうというもの。  
この場合、テーブルスキャンが多発し、ロック待ちが発生する可能性が高くなる。  

つまり、デフォルトでは、大量のデータが取得されないように工夫する必要がある。  
できる限り絞り込んだ状態でデータを見せたり、大量のデータを取得する場合には、実行に時間がかかることを明治したり、ユーザーに絞り込んでデータを取得させるように促すようなアプリケーションの工夫を施す。  

---

## 読み取り一貫性

読み取り一貫性(READ_COMMITTED_SNAPSHOT または スナップショット分離レベル)は、排他のかかっているデータを読み取れるようにする機能。  
Oracleではお馴染みの模様。  

正確には「SELECTステートメントを発行した時点」または「トランザクションの開始時点」でのデータを読み取れることを保証する機能。  

![Alt text](https://bellsoft.jp/website/wp-content/uploads/2018/06/tran.jpg)
[SQL Server の読み取り一貫性とロック｜システム開発のブログ｜株式会社ベルソフト](https://bellsoft.jp/blog/system/detail_586)  

この機能はSQLServer2005から提供され、「READ_COMMITTED_SNAPSHOT」と「スナップショット分離レベル」の2種類がある。  

どんな状況でも利用するべき機能ではない。  
業務アプリケーションを構築する上で必須ではない。  
オーバーヘッドも存在する。  
現状のシステムに問題なければ利用しないほうが良い機能。  

因みにOracleでは読み取り一貫性機能をオフにすることができない。  

---

## READ_COMMITTED_SNAPSHOT

SELECTステートメントを発行した時点でのデータが読み取れることを保証する機能。  
Oracleのデフォルトの動作と同じ。  

排他ロックのかかっている更新中のデータ(未コミットのまだ確定していないデータ)を参照させないようにし、更新前のデータ(その時点での正しいデータ)を参照させることで一貫性を保つという動作。  
これにより、ダーティーリードが発生するのを回避している。  

更新前のデータは、tempdbデータベース内へ格納される。  
Oracleでは、更新前データの格納先にはUNDOセグメント(Oracle 8i以前はロールバックセグメント)が利用される。  

### READ_COMMITTED_SNAPSHOTの利用方法

デフォルトでは、READ_COMMITTED_SNAPSHOTを利用することはできない。  
次のように設定することで初めて利用できる。  

``` sql
ALTER DATABASE データベース名
SET READ_COMMITTED_SNAPSHOT ON
```

### READ_COMMITTED_SNAPSHOTの検証

1. テーブルとデータを用意する  

    ``` sql
    CREATE TABLE t1
    (
        a int,
        b NVARCHAR(20)
    )
    INSERT INTO t1 VALUES
        (1,"AAA"),
        (2,"BBB"),
        (3,"CCC"),
        (4,"DDD"),
    ```

2. データベースに対して`COMMITTED_SNAPSHOT`をONに設定する。  

    ``` sql
    ALTER TABLE テーブル名
    SET READ_COMMITTED_SNAPSHOT ON
    ```

3. [a=2]のデータを排他ロックする(COMMIT TRANを省略して、意図的に排他ロックをかけたままにする)

    ``` sql
    -- 1つ目の接続
    BEGIN TRAN
        UPDATE t1 SET b = 'xxx' WHERE a = 2
    ```

4. 「新しいクエリ」を作成し、[a=2]行を参照する。  

    ``` sql
    -- 2つ目の接続
    SELECT * FROM t1 WHERE a = 2
    --- 結果: 2 BBB
    ```

    ロック待ちにならず、データを参照できるはず。  
    取得できたデータは更新前のデータ"BBB"であるはず。  

5. 排他ロックをかけている側へ戻り、ROLLBACK TRANを実行する。  

    ``` sql
    -- 1つ目の接続
    BEGIN TRAN
        UPDATE t1 SET b = 'xxx' WHERE a = 2
    -- トランザクションをロールバックして排他ロックを解放
    ROLLBACK TRAN
    ```

6. ロールバックされた後、2つ目の接続側で参照したデータは"BBB"となる事を確認する(ダーティーリードは発生しない)  

    ``` sql
    -- 2つ目の接続
    SELECT * FROM t1 WHERE a = 2
    --- 結果: 2 BBB
    ```

このように、`READ_COMMITTED_SNAPSHOT`を利用すると、排他ロックにブロックされずにデータを参照できるようになる。  

---

## スナップショット分離レベル(Snapshot Isolation Level)

SQLServerのもう一つの読み取り一貫性機能。  
これは、トランザクションを開始した時点でのデータが読み取れることを保証する機能。  
OracleでのREAD_ONLYまたはSerializableトランザクションの動作とほぼ同じ。  

READ_COMMITTED_SNAPSHOTがステートメントレベルでの読み取り一貫性であったのに対し、スナップショット分離レベルは、トランザクションレベルでの読み取り一貫性となる。  

スナップショット分離レベルは、会計処理のように、トランザクションが長くなり、かつその間に他のトランザクションからの影響を受けたくないような場合に役に立つ機能。  

### スナップショット分離レベルの利用方法

デフォルトでは、スナップショット分離レベルも利用することはできない。  
次のようにデータベースに対して`ALLOW_SNAPSHOT_ISOLATION`をONに設定する。  

``` sql
ALTER DATABASE データベース名
SET ALLOW_SNAPSHOT_ISOLATION ON
```

また、SELECTステートメントを実行する側で、次のように分離レベルを`SNAPSHOT`へ変更することで、トランザクションレベルでの読み取り一貫性が保証される。  

``` sql
SET TRANSACTION ISOLATION LEVEL SNAPSHOT
```

### スナップショット分離レベルの検証

1. テーブルとデータを用意する  

    ``` sql
    CREATE TABLE t1
    (
        a int,
        b NVARCHAR(20)
    )
    INSERT INTO t1 VALUES
        (1,"AAA"),
        (2,"BBB"),
        (3,"CCC"),
        (4,"DDD"),
    ```

2. データベースに対してスナップショット分離レベルを有効に設定する。  

    ``` sql
    ALTER TABLE データベース名
    SET ALLOW_SNAPSHOT_ISOLATION ON
    ```

3. [a=2]のデータを排他ロックする(COMMIT TRANを省略して、意図的に排他ロックをかけたままにする)

    ``` sql
    -- 1つ目の接続
    BEGIN TRAN
        UPDATE t1 SET b = 'xxx' WHERE a = 2
    ```

4. 「新しいクエリ」を作成し、[a=2]行を参照する。  
   この時、SETステートメントでスナップショット分離レベルを有効化して、BEGIN TRANでトランザクションを開始する。  

    ``` sql
    -- 2つ目の接続
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT
    BEGIN TRAN
        -- 1回目のデータ参照
        SELECT * FROM t1 WHERE a = 2
        -- 結果 : 2 BBB
    ```

    ロック待ちは発生せず、データを参照できるはず。  
    また、SELECTされたデータは更新前のデータ("BBB")であることを確認する。  

5. 排他ロックをかけている側の接続に戻って、COMMIT TRANを実行する。  

    ``` sql
    -- 1つ目の接続
    BEGIN TRAN
        UPDATE t1 SET b = 'xxx' WHERE a = 2
    COMMIT TRAN

    SELECT * FROM t1
    -- 結果 : 2 xxx
    ```

    データは"xxx"となっている事が確認できるはず。  

6. コミット後、2つ目の接続側へ戻り、もう一度[a=2]行を参照する。  

    ``` sql
    -- 2つ目の接続
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT
    BEGIN TRAN
        -- 1回目のデータ参照
        SELECT * FROM t1 WHERE a = 2
        -- 結果 : 2 BBB
        
        -- 2回目のデータ参照
        SELECT * FROM t1 WHERE a = 2
        -- 結果 : 2 BBB
    ```

    データ"BBB"が返り、トランザクションを開始した時点でのデータを取得できたことを確認する。  
    このように、スナップショット分離レベルを利用した場合は、トランザクションレベルでの読み取り一貫性を実現することができる。  

7. 2つ目の接続でもCOMMIT TRANを実行して確定データを参照する。  

    ``` sql
    -- 2つ目の接続
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT
    BEGIN TRAN
        SELECT * FROM t1 WHERE a = 2

        -- 2回目のデータ参照
        SELECT * FROM t1 WHERE a = 2
    COMMIT TRAN

    -- 確定済みのデータを参照
    SELECT * FROM t1 WHERE a = 2
    -- 結果 : 2 xxx
    ```

    データが"xxx"となっている事を確認する。  

---

## 読み取り一貫性とスナップショット分離レベルの違い

![読み取り一貫性とスナップショット分離レベルの違い](Asset/%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A%E4%B8%80%E8%B2%AB%E6%80%A7%E3%81%A8%E3%82%B9%E3%83%8A%E3%83%83%E3%83%97%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%E5%88%86%E9%9B%A2%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E9%81%95%E3%81%84.jpg)

READ_COMMITTED_SNAPSHOTは、SELECTステートメントを発行した時点での確定されたデータを読み取り、スナップショット分離レベルは、トランザクション開始時点での確定済みデータを読み取る。  

トランザクションの途中でコミットされて確定したとしても、トランザクションの開始時点で確定されていないデータは更新前の値を返し、開始時点での正しいデータを一貫して返す。  

従って、スナップショット分離レベルは、会計処理のように、トランザクションが長くなり、かつその間に他のトランザクションからの影響を受けたくないような場合に役に立つ機能となる。  

---

## 読み取り一貫性のオーバーヘッド

READ_COMMITTED_SNAPSHOTとスナップショット分離レベルは、更新前のデータ(スナップショットデータ)を格納するために`tempdbデータベース`内の`Version Store`という領域を利用する。  

更新前データは、たとえ「列」単位の更新であったとしても、「行」単位で格納される。  

従って、行サイズが大きく、かつ更新の多いデータベースの場合は、`temodb`の利用頻度や肥大化に注意する必要がある。  

---

## tempdb(Version Store)の監視

「`db_tran_top_version_generators`」と「`dm_tran_version_store`」の2つの動的管理ビュー(DMV : Dynamic Management View)が役に立つ。  

※動的管理ビューはパフォーマンス監視のために用意されたシステムビュー  

---

## db_tran_top_version_generators

``` sql
-- データベース毎のStoreサイズの合計
SELECT * FROM sys.db_tran_top_version_generators
```

データベース毎のStoreサイズの合計(バイト単位)を確認することができる。  
`aggregated_record_length_in_bytes`がそれに当たる。  

これにより、読み取り一貫性機能によって、tempdbの領域をどの程度消費しているのかを確認できる。  

---

## db_tran_version_store

`aggregated_record_length_in_bytes`における動的管理ビューは、Version Store内の各Storeを1件ずつ確認できる。  

``` sql
-- Version Store内の各Storeを1件ずつ確認
SELECT * FROM sys.db_tran_version_store
```

`record_length_first_part_in_bytes` : 各Storeのサイズ  
`record_image_first_part` : 各Storeの生データ  

これにより、1件1件のスナップショットデータ(更新前データ)のサイズを確認できるため、どのデータがVersion Store領域をどの程度消費しているのかを調べる事ができる。  

---

## スナップショットデータの保持期間

スナップショットデータの保持期間は、READ_COMMITTED_SNAPSHOTとスナップショット分離レベルで異なる。  

![スナップショットデータの保持期間](Asset/%E3%82%B9%E3%83%8A%E3%83%83%E3%83%97%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E4%BF%9D%E6%8C%81%E6%9C%9F%E9%96%93.jpg)

READ_COMMITTED_SNAPSHOTは、更新側のトランザクションが完了すれば、更新前データは不要になるため破棄される。  
正確には、すぐには破棄されず、破棄可能マークがつけられ、1分ごとに内部動作している「ガベージコレクション」によって、破棄可能マークのつけられたデータが破棄される。  

スナップショット分離レベルの場合は、"読み取り側"のトランザクションが完了するまで、更新前データは破棄されない。  
もし破棄されると、トランザクション開始時点でのデータが削除されることになり、読み取り一貫性が実現できなくなってしまう。  

従って、READ_COMMITTED_SNAPSHOTよりも、スナップショット分離レベルのほうがスナップショットデータの保持期間が長くなり、tempdbへのオーバーヘッドが大きくなる。  

※読み取り一貫性は、どんな状況でも利用すべきというわけではないため、十分な検証とテストを行った上で利用すべき。  
特にスナップショットデータの格納先となるtempdbは、内部的なSortやHash処理等でボトルネックになりやすいデータベースであるため、注意が必要。  
ロック関連のパフォーマンスに問題がある場合は、インデックスチューニングを行うことで解決できるケースが非常に多いため、まずはインデックスから見直す事をお勧めする。  
