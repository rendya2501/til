# SQLServer関係メモ

[SQL Serverチートシート](https://qiita.com/esflat/items/7885e53737163eb955fe)  

---

## null許可のフィールドを追加→変更の保存が許可されていません

フィールドを追加する際にたまに発生するので備忘録として残しておく。  
発生原因としてはテーブルの監視履歴が削除されてしまうからだそうです。  

1. [ツール] メニューの [オプション] をクリックします。  
2. [オプション] ウィンドウのナビゲーション ウィンドウ で 、[デザイナー] をクリックします。  
3. [テーブルの再作成を必要とする変更の保存を防止する] チェックボックスをオンまたはオフにし 、[OK] をクリックします。  

[SQL Server カラム定義を変更すると「変更の保存が許可されていません」が表示された場合の対処法](https://nasunoblog.blogspot.com/2013/10/sql-server-column-edit-error.html)  

[変更の保存は、エラー メッセージで許可SSMS](https://docs.microsoft.com/ja-jp/troubleshoot/sql/ssms/error-when-you-save-table)  

---

## テーブルデザイナーにコメント列を追加する方法

あると便利といわれたのでまとめ。  
レジストリをいじらないと駄目です。  

[SSMS のテーブルデザイナの列をカスタマイズした](https://qiita.com/d01tsumath/items/906043d69f86a6a53cef)  
[SQL Server Management Studio のテーブルデザイナの列をカスタマイズする](https://blog.xin9le.net/entry/2018/06/17/165526)  

---

## SQL Server のRand関数を用いたテストデータの作成

[SQLで乱数を使ってテストデータを作る](https://nonbiri-dotnet.blogspot.com/2017/04/sql.html)

``` SQL
-- とりあえず5回ループして乱数を生成するサンプル
DECLARE @counter smallint
SET @counter = 0

WHILE @counter < 5
BEGIN
    SELECT rand() * 100
    SET @counter = @counter + 1
END
```

---

## FLOOR関数とCEILING関数

Y君から、「これ何したいかわかります？」って質問されたが、そもそも関数が何やるかわからなかったのでまとめる。  

``` SQL
    CEILING(FLOOR(金額 * 10) / 10)
```

- FLOOR : 床→切り下げ  
- CEILING : 天井→切り上げ  

なるほど。言葉の意味そのままなのね。  
因みにROUNDは四捨五入ね。

``` txt : 金額が「112.23」と来た場合
デフォ  →  112.23
*10     →  1122.3
FLOOR   →  1122  
/10     →  112.2 
CEILING →  113   
```

普通に112.23の地点でCEILING使えばよくね？ってなるよね。  
修正の履歴を見る限り、過去の修正を生かしつつ、辻褄を合わせるためにこうなったのだろうという結論で終結した。  

---

## Identityの発番テーブルで保存時に発番した値を取得する

`OUTPUT句`なるものがあるらしい。  
部長が知ってた。  

T-SQLに分類されるっぽいのでSQLServer独自の構文。  

INSERT、UPDATE、DELETE、MERGE ステートメントで影響を受けたレコードを取得することができる。  
それぞれで書き方が微妙に違う。  
実務では自動発番されたIDENTITYの値を取得するために使用していた。  

INSERTの場合はINTO句とVALUE句の間に `OUTPUT inserted.フィールド,inserted.フィールド,...`を記述することで指定した列の挿入した値を取得できる模様。  
SQLで使う場合はテーブル変数を用意してそれにINTOすることで複数の結果を取得可能。  

``` sql
-- テーブル変数を定義
DECLARE @StudentInserted TABLE (
   StudentID INT,
   FirstName VARCHAR(50),
   LastName VARCHAR(50)
);

-- INSERTとOUTPUTの実行
INSERT INTO Student
   (FirstName, LastName, Gender)
OUTPUT 
   inserted.StudentID, 
   inserted.FirstName, 
   inserted.LastName
INTO @StudentInserted (
   StudentID,
   FirstName,
   LastName
)
VALUES 
   ('Rin', 'Yokota', 'M'),
   ('Hina', 'Yokota', 'F');

-- 結果を表示
SELECT *
FROM @StudentInserted;
```

Dapperで使う場合はINTO句は必要なく、戻り値として受け取ることができる模様。  

``` C#
    // [SeqNo]という[Identity]フィールドがある[Table]
    var query = new StringBuilder()
        .AppendLine("INSERT INTO [Table] (")
        .AppendLine("   [Id],")
        .AppendLine("   [Name]")
        .AppendLine(")")
        .AppendLine("OUTPUT inserted.[SeqNo]")
        .AppendLine("VALUES (")
        .AppendLine("@Id,")
        .AppendLine("@Name")
        .AppendLine(")");
    // クエリ実行
    var identity = _DapperAction.GetFirstDataByQuery<long>(
        ConnectionTypes.SystemWithOutTransactionScope, 
        query.ToString(), 
        data
    );
```

[SQL Server - OUTPUT 句の使い方](https://sql55.com/query/sql-server-output-clause.php)  

OUTPUT句で出力する以外ではこういうものもあるらしい。  
`var id = rnWebConnection.QueryFirstOrDefault<long>("SELECT LAST_INSERT_ID()");`  

もしかしたら結果が1つだけなら変数受けすることもできるかもしれないと思ったが駄目だった。  

``` sql
DECLARE @Test INT
set @Test = (INSERT INTO [Table] (TestID,TestName) OUTPUT inserted.TestID VALUES (1,'Test'));
SELECT @Test;
```

---

## DISTINCTとワイルドカードの併用

DISTINCTとワイルドカード `*` を併用したら.NETFrameworkでは実行速度が遅くなるらしい  

---

## TOP 句 PERCENT

[SqlServerの SELECT TOP 100 PERCENT で作成したビューの並び順は『保証されない』](https://culage.hatenablog.com/entry/20170824/p1)  
[TOP 句 PERCENT](https://haradago.hatenadiary.org/entry/20180214/p1)  

TOPにPERCENT句を付けると上位N%のデータを取得することができる  

``` sql
select TOP 50 PERCENT * FROM TastTeble

--  100 : 90121件
--   50 : 45061件
--    1 :   902件
-- -100 : '-' 付近に不適切な構文があります。
-- 5000 : パーセント値は 0 から 100 までの値を指定してください。
```

### TOP 100 PERCENTをやる意味とは？

ビューを呼び出したときに最初からソートされているとありがたい。  
ビューを取得してから改めてOrderByする手間は省きたい。  
そういう訳で、それを実現するためのテクニックとして、この方法が用いられてきたみたいだが、Microsoft的には、この動作は意図した動作ではなかったので非推奨になったらしい。  
というわけで、今はほとんど意味がないんだとか。  

実務で使っていたのは、全てのデータを取得するメソッドで並び替えまで済ませ、そのあとで必要なフィールドだけを抽出する動作を実現したかったからだと思われる。  
完全なビューとして運用するわけではないので、この方法が有効だったのかもしれない。  
疑似的なビューとしてこの方法を用いた可能性がある。  

[Road to DBD](https://plaza.rakuten.co.jp/jamshid/diary/200805080000/)  
>Viewやテーブル関数にTOP 100 PERCENTを指定すると、ORDER BYが切れるようになるというのは、SQL Server 2000時代でもある意味Tipsとして通用していたと思うが、SQL Server 2005ではこれが使えなくなったのだった。  
>「TOP 100 PERCENTであれば、全件を返すわけだから、オプティマイザは並べ替えを行わない」という変更が行われた。  

[ビューのソートについて](https://oshiete.goo.ne.jp/qa/4420769.html)  
>ビューを単純に照会したときにORDER句を切らなくても希望する並び順でSELECTできれば、運用上は便利なことが多いです。  
>そのため、SQL Serverでは昔からTipsでTOP 100 PERCENTで並び替える方法が認識されていました。  
>（Tipsとある通り、普通はViewの外でOrder切ります）  
>ただし、SQL Server 2005になって、TOP 100 PERCENTは「並び替えの必要なし」とオプティマイザが判断するように仕様が変更されてしまいました。  
>そのため、SQL Server 2005ではTOP 100 PERCENT句をViewに切っても並び替えは起こりません。  
>それだけなら分かりやすいのですが、やはりこの技を使っていた人が多かったためでしょうか。  
>SP2の後の累積パッチ「SP2の累積プログラムその２」でこれを修正するモジュールが提供されています。  
>SP2には入っていないし、わざわざ当てる人も少ないと思うので、次のSP3が出たとして、それ当てた時からTOP 100 PERCENTが効くようになるでしょう。  
>ちなみにSQL Server 2008でも初期バージョンではTOP 100 PERCENTが効かず、累積パッチが提供されています。  
>ということで、そのようなビューの使い方は正しいアプローチではありませんが、SQL Serverの裏ワザの一つですと認識ください。  

---

## 移行におけるあれこれ

Aデータベースの動作が不安定なのでBデータベースを新しく立てて、そちらにデータを移動させることになった。  
デタッチしてmdfファイルを直接移動させて、アタッチする方式を取ろうとしたが、エラーが発生してうまく行かなかった。  
エラーの内容は以下の通り。  

``` txt
TITLEMicrosoft SQL Server Management Studio
------------------------------

データベース 'sample_database' の復元に失敗しました。 (Microsoft.SqlServer.Management.RelationalEngineTasks)

------------------------------
ADDITIONAL INFORMATION:

Transact-SQL ステートメントまたはバッチの実行中に例外が発生しました。 (Microsoft.SqlServer.SmoExtended)

------------------------------

データベース 'sample_database' は、オブジェクト 'sample_tabel' の一部または全体でデータ圧縮または vardecimal ストレージ形式が有効になっているため、このエディションの SQL Server では開けません。データ圧縮および vardecimal ストレージ形式がサポートされているのは、SQL Server Enterprise Edition だけです。
データベース 'sample_database' は、このエディションの SQL Server では起動できません。このデータベースには、パーティション関数 'sample_func' が含まれています。パーティション分割は SQL Server Enterprise Edition でしかサポートされません。
SQL Server の現在のエディションではデータベース機能の一部が使用できないため、データベース 'sample_database' を開くことができません。 (Microsoft SQL Server、エラー: 909)

ヘルプを表示するには https://docs.microsoft.com/sql/relational-databases/errors-events/mssqlserver-909-database-engine-error をクリック
```

[sqlserver error 909]  
このエラー自体は上位エディション(Enterprise Edition)から下位エディション()に移行した時に発生する現象な模様。  
しかし、`SELECT SERVERPROPERTY('Edition');`このクエリで確認してみると、AもBもStandard Editionであった。  

色々調べた結果、テーブルに圧縮の設定がされている場合に発生してしまう模様。  
調査クエリで確認したり、圧縮の設定を解除するクエリを流したり、直接テーブルの設定を変えたらうまく行った。  

DB単位で Enterprise Edition のどの機能を使用しているかを確認するクエリ

``` sql
select * from sys.dm_db_persisted_sku_features
```

データ圧縮されているオブジェクトのリストを表示するクエリ

``` sql
SELECT
    SCHEMA_NAME(sys.objects.schema_id) AS SchemaName
    ,OBJECT_NAME(sys.objects.object_id) AS ObjectName
    -- VarDecimalStorage 形式の圧縮があるかどうかを確認する
    ,OBJECTPROPERTY ( OBJECT_ID ( OBJECT_NAME(sys.objects.object_id) ), 'TableHasVarDecimalStorageFormat' )
    ,[rows]
    ,[data_compression_desc]
FROM sys.partitions
INNER JOIN sys.objects ON sys.partitions.object_id = sys.objects.object_id
WHERE data_compression > 0 AND SCHEMA_NAME(sys.objects.schema_id) != 'SYS'
ORDER BY SchemaName, ObjectName
```

データ圧縮オプションを「なし」にしてインデックスを再構築し、圧縮を無効にするクエリ。  

``` sql
ALTER INDEX ALL ON sample_table REBUILD WITH ( DATA_COMPRESSION = None );
```

上記クエリは1行ずつしか実行できないのでカーソル処理としたもの。  

``` sql
--カーソルの値を取得する変数宣言
DECLARE @ObjectName varchar(255)

--カーソル定義
DECLARE CUR_AAA CURSOR FOR
    SELECT OBJECT_NAME(sys.objects.object_id) AS ObjectName
    FROM sys.partitions
    INNER JOIN sys.objects ON sys.partitions.object_id = sys.objects.object_id
    WHERE data_compression > 0 AND SCHEMA_NAME(sys.objects.schema_id) != 'SYS'
    ORDER BY ObjectName

--カーソルオープン
OPEN CUR_AAA;

--最初の1行目を取得して変数へ値をセット
FETCH NEXT FROM CUR_AAA
INTO @ObjectName;

--データの行数分ループ処理を実行する
WHILE @@FETCH_STATUS = 0
BEGIN

    -- ========= ループ内の実際の処理 ここから===
    EXEC('ALTER INDEX ALL ON ' + @ObjectName + ' REBUILD WITH ( DATA_COMPRESSION = None );')
    -- ========= ループ内の実際の処理 ここまで===

    --次の行のデータを取得して変数へ値をセット
    FETCH NEXT FROM CUR_AAA
    INTO @ObjectName;
END

--カーソルを閉じる
CLOSE CUR_AAA;
DEALLOCATE CUR_AAA;
```

なんかのついでに拾ったクエリ。  
一応参考程度に残しておく。  

``` sql
SELECT s.[name]+'.'+o.[name] AS [object], i.[type_desc] COLLATE database_default+ISNULL(' '+i.[name], '') AS index_name,
       (CASE WHEN COUNT(DISTINCT p.partition_number)>1 THEN 'Is partitioned' ELSE '' END) AS [partitioned?],
       ISNULL(MIN(NULLIF(p.data_compression_desc, 'NONE'))+' compression', '') AS [compressed?],
       (CASE WHEN ISNULL(OBJECTPROPERTY(p.[object_id], 'TableHasVarDecimalStorageFormat'), 0)=0 THEN '' ELSE 'vardecimal' END) AS [vardecimal?]
FROM sys.partitions AS p
INNER JOIN sys.indexes AS i ON p.[object_id]=i.[object_id] AND p.index_id=i.index_id
INNER JOIN sys.objects AS o ON i.[object_id]=o.[object_id]
INNER JOIN sys.schemas AS s ON o.[schema_id]=s.[schema_id]
GROUP BY p.[object_id], s.[name], o.[name], i.index_id, i.[type_desc], i.[name]
ORDER BY s.[name], o.[name], i.index_id
```

[Microsoft SQL Server: エラー: 909 データベースを SQL Server 2008 の SQL Server Enterprise Edition から任意の下位エディションに移行中に発生する](http://www.thesqlpost.com/2012/06/microsoft-sql-server-error-909-while.html)  
[SQL Server 2008 R2 で新しい (ContosoRetailDW) を作成するときのエラー 909。エラー 909 を受け取り、](https://social.msdn.microsoft.com/Forums/en-US/0057feb1-2034-448c-a9ea-c66484b048ba/error-909-when-creating-new-contosoretaildw-on-sql-server-2008-r2-receiving-error-909?forum=sqlgetstarted)  
[Enterprise Edition の DB バックアップを Standard Edition にリストア](https://blog.engineer-memo.com/2014/12/24/enterprise-edition-%E3%81%AE-db-%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%82%92-standard-edition-%E3%81%AB%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2/)  

---

## FORMAT関数

FORMAT関数が使えるのは2012から。  
2008R2では分析ツール用のクエリでは使えるが、組み込み関数としては使えない。  

[SQLServerのFORMAT関数にハマったのでメモ (2008 R2では使えない)](https://devlights.hatenablog.com/entry/2015/03/09/143355)  

---

## テーブルを複製する方法

``` sql
SELECT * INTO コピー先テーブル名 FROM コピー元テーブル名
```

`コピー元テーブル名`は名前の指定だけあればよい。  
あらかじめテーブルを作成する必要は無し。  
実行するとテーブルもSQLServerが自動でテーブルも作成してくれます。  
※注：ただし、テーブルは規定の領域（なにも設定してなければPrimary）に作られるので、ファイルグループ管理は要注意。  

[[SQLServer]テーブルをまるっとコピーする方法](https://ameblo.jp/nature3298type-s/entry-10313449987.html)

---

## SQLServerのバージョンを確認する

単純に出力するクエリ

``` sql
PRINT @@VERSION;

-- 出力結果
-- Microsoft SQL Server 2016 (RTM) - 13.0.1601.5 (X64) 
--    Apr 29 2016 23:23:58 
--    Copyright (c) Microsoft Corporation
--    Standard Edition (64-bit) on Windows Server 2016 Standard 6.3 <X64> (Build 14393: ) (Hypervisor)
```

``` sql
SELECT
    CASE 
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '8%' THEN 'SQL2000'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '9%' THEN 'SQL2005'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '10.0%' THEN 'SQL2008'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '10.5%' THEN 'SQL2008 R2'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '11%' THEN 'SQL2012'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '12%' THEN 'SQL2014'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '13%' THEN 'SQL2016'
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '14%' THEN 'SQL2017' 
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '15%' THEN 'SQL2019' 
        WHEN CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) like '16%' THEN 'SQL2022' 
        ELSE 'unknown'
    END AS MajorVersion,
    SERVERPROPERTY('ProductLevel') AS ProductLevel,
    SERVERPROPERTY('Edition') AS Edition,
    SERVERPROPERTY('ProductVersion') AS ProductVersion


IF SERVERPROPERTY('ProductVersion') >= 11
    BEGIN
        PRINT 11;
    END
ELSE
    BEGIN
        PRINT 10;
    END
```

[How to tell what SQL Server versions you are running](https://www.mssqltips.com/sqlservertip/1140/how-to-tell-what-sql-server-version-you-are-running/)

---

## パフォーマンス改善

パフォーマンスによる影響  
・クエリの応答速度低下→コマンドタイムアウトの発生  
・CPU負荷の情報  

---

## 統計情報

これまで普通に使えていた SQL Server が急に遅くなった、夜間の更新処理に異常に時間がかかるようになった。  
といったとき、統計情報が古くなっていて実行プランが正しく選択されていないことががあります。  

統計情報を最新にすることで正しい実行プランが選択されるようになり、パフォーマンスが改善されることがあります。  

[SQL Serverで統計情報を更新する。UPDATE STATISTICSの使い方](https://www.fenet.jp/dotnet/column/database/sql/5389/)  
[統計情報を更新してクエリのパフォーマンスを改善する](https://www.projectgroup.info/tips/SQLServer/MSSQL_00000027.htm)  

---

## sp_updatestats

データベース単位で統計情報を更新するストアドプロシージャ。  

そのデータベースに存在する全てのインデックス、列 の統計情報を更新する。  
全部実行するので時間はかかる。  

・何を実行しても遅い場合  
・定期的に全部キレイにしたい場合  
・特定のクエリではなく全体的にクエリ パフォーマンスが低下している場合  
・どのテーブルのインデックス、列 の統計情報を更新すべきか明確に特定できていない場合  

等の場合において使用するとよい。  

``` sql
EXEC sp_updatestats
GO
```

[【保存版】クエリ パフォーマンスが著しく低下した場合の一時的な対処方法 (SQL Server/Azure SQL Database)](https://www.nobtak.com/entry/sqlp01)  
[統計情報を更新してクエリのパフォーマンスを改善する](https://www.projectgroup.info/tips/SQLServer/MSSQL_00000027.htm)  

---

## CONSTRAINT PRIMARY KEY CLUSTERED

CONSTRAINT句でPRIMARY KEYを設定する時、今までCLUSTERED句を書いて来なかったのだが、databaseProjectから自動生成されるクエリにはCLUSTERD句が書いてあった。  
CLUSTERD句がなくても動くことは知っていたのだが、この場合の動作はどのようになるのか調べた。  

公式でも、大抵の文献でも、CLUSTERED句はセットで記述されており、デフォルトの動作がどうなのかどこにも書いていなかったのだが、ようやくそれについて言及している記事を見つけた。  
書かなくても自動的にクラスター化インデックスになる模様。  
まぁ、書いておいて損はないだろう。  

>主キーは自動的にクラスタ化インデックスになるので、例示のCLUSTEREDはなくても動きます。  
>
>[SQL Serverチートシート](https://qiita.com/esflat/items/7885e53737163eb955fe)  

---

## MSDTC (Microsoft Distributed Transaction Cordinator)

>分散トランザクション (Distributed Transaction) は、複数サーバーにまたがったトランザクションのことで、この調整 (Coordinate) を行うための機能がMSDTCサービスです。  
>[SQLServer2016の教科書]  

TransactionScopeを使うとこの仕組みを使う模様。  
Linuxでは対応していないので、SQLServerをLinuxにもっていって、TransactionScopeを使うと死ぬ模様。  

---

## コマンドラインからSqlServerを使う

MySQLのようなグリッド表示の結果が欲しくて色々探した。  
とりあえずcliから実行する方法を探したら色々あったので、備忘録として残す。  

sqlcmd : 従来のツール。古い。使い勝手が悪い。  
mssql-cli : 新しいツール。python製。cliで使うならこれ一択。  

pythonをインストールしてpipからmssql-cliをインストールする。  
最新版をインストールするとバグるのでpyhonのバージョンは3.9のを使うこと。  

で、結局grid表示はできなかったので、使えなかった。  

[新しいコマンドラインツールの mssql-cli のクエリ実行方法のメモ](https://blog.engineer-memo.com/2017/12/24/%E6%96%B0%E3%81%97%E3%81%84%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%84%E3%83%BC%E3%83%AB%E3%81%AE-mssql-cli-%E3%81%AE%E3%82%AF%E3%82%A8%E3%83%AA%E5%AE%9F%E8%A1%8C%E6%96%B9/)  
[コマンドラインでSQL Serverを使う最低限のメモ](https://qiita.com/zaburo/items/6edf7c05c5d4f5e039eb)  

インストールはここを参考にする。  
[MSSQL-CLI: An Interactive Command Line SQL Server Query Tool](https://www.mytecbits.com/microsoft/sql-server/mssql-cli)  

`ImportError: cannot import name 'Iterable' from 'collections' in Python`というエラーが発生した。  
pythonのバージョンを3.9にしろという記事。  
[ImportError: cannot import name 'Iterable' from 'collections' in Python](https://stackoverflow.com/questions/72032032/importerror-cannot-import-name-iterable-from-collections-in-python)  

---

## SQLServer Linuxでの接続

Linux上のSQLServerにアクセスする場合は以下のようにアクセスすればよい。  
`Server=localhost;Database=myDatabase;User id=myUserName;Password=myPassword;`  

以下、Linux上で動作しているSQLServerにアクセスしようとして色々あったのでまとめる。  
結果的にLinuxなのにWindows認証しようとしてエラーとなっていた。  

■**connection string is not valid sql server**  

こんな感じのWindow認証でログインしようとして発生した。  
`"Server=.\\SQLEXPRESS; Database=<db_name>; Integrated Security=True"`  

SQLServerでWindows認証が使えるはずないので当然と言えば当然。  
Windows認証 = WindowではローカルのSQLServerにアクセス → Linux上の(ローカルの)SQLServerにアクセス  
という理論でやったが、Localにアクセスなら素直に`localhost` or `127.0.0.1`だった。  

>Linuxは名前付きパイプの概念が違う。  
>また、統合セキュリティは、Active Directory / NTML Authorizationに関連しているため、Linuxでは動作しません（少なくとも未設定では、Kerberos認証はサポートされています）。  
>そのため、通常の標準的なユーザー名認証の接続文字列を使用します。  
>`Server=localhost;Database=myDatabase;User id=myUserName;Password=myPassword;`  
[Invalid SQL Server Connection String on Linux Entity Framework Core](https://stackoverflow.com/questions/55454878/invalid-sql-server-connection-string-on-linux-entity-framework-core)  

■**System.Data.SqlClient.SqlException: 'System.Net.Security.Native assembly:\<unknown assembly> type:\<unknown type> member:(null)**

`System.Net.Security`とあるので、セキュリティに関することなのは分かった。  
この時まだWindows認証で頑張っていたので、`Integrated Security`がセキュリティに関するオプションであることは明白だったので、消したらエラーも消えた。  
リンク先の人も消したら出てこなくなったと言っている。  

[System.Data.SqlClient.SqlException: 'System.Net.Security.Native assembly:\<unknown assembly> type:\<unknown type> member:(null)](https://learn.microsoft.com/en-us/answers/questions/979587/systemdatasqlclientsqlexception-39systemnetsecurit.html)  

---

## テーブルの存在確認

OBJECT_ID関数  

``` sql
IF OBJECT_ID (N'テーブル名', N'U') IS NOT NULL  
    --テーブルが見つかったときの処理
ELSE
    --テーブルが見つからなかったときの処理
```

2016以降のバージョンでは命令に繋げて記述可能  

``` sql
DROP TABLE IF EXISTS テーブル名
```

[SQLServer テーブルが存在していたらdropしてcreateする方法](https://note.mokuzine.net/sqlserver-if-exist-table/)  
[【SQL Server】テーブルの存在チェックするやり方を解説します](https://www.tairax.com/entry/Microsoft-SQL-Server/Check-existence-of-table)  

---

## SQLを止める方法

GOTOするかTHROWする。  
RETURNはストアドでしか使えない。  

検索文字列 : sqlserver t-sql 途中終了  

[T-SQL STOP or ABORT command in SQL Server](https://stackoverflow.com/questions/2028072/t-sql-stop-or-abort-command-in-sql-server)  
