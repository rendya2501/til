# エラー

---

## 基本

``` sql
BEGIN TRY
…
END TRY

BEGIN CATCH
…
END CATCH
```

トランザクションにおける制約違反エラーが発生した場合にも、トランザクションをロールバックさせる事ができる。  

TRY CATCHを利用して例外処理を行っている場合は、エラーはアプリケーションには通達されず、CATCH部の処理のみが実行される。
例外処理を行っていない場合は、エラーはアプリケーションにそのまま通達される。  
従って、TRY CATCHしただけではアプリケーション側は正常に終了したのか、失敗したのか判断できない。  
そのための手段として「THROWによるエラーの再スロー」または「ユーザー定義(RAISEERROR)エラーによる再スロー」がある。  

---

## THROW

SQLServer 2012 から提供されたステートメント。  
CATCH部でエラーを再スローすることができる。  

``` sql
SET XACT_ABORT ON
BEGIN TRY
    BEGIN TRANSACTION

    -- ===========================
    -- 処理をここに記述
    -- ===========================

    COMMIT TRANSACTION
END TRY

BEGIN CATCH
    THROW
    ROLLBACK TRANSACTION
END CATCH
SET XACT_ABORT OFF
```

CATHC部でTHROWと記述することで、再度同じエラーを発生させる事ができる。  
しかし、制約違反エラーの場合にはロールバックが行われないため(THROWは全く同じエラーの再発生を行うだけ)、SET XACT_ABORT オプションをONへ設定するようにする。  
これを設定しないとロールバックもコミットもされない未完了のトランザクションが残ってしまう。  

``` sql
THROW [error_number], [error_message], [state];
```

例:「Error!!!」 というメッセージでエラーを起こす  

``` sql
THROW 50000, 'Error!!!', 1;
```

---

## RAISERROR

SQLServer 2008 R2以前のバージョンを利用している場合はこちらを使う必要がある。  

``` sql
BEGIN TRY  
    BEGIN TRANSACTION

    -- ===========================
    -- 処理をここに記述
    -- ===========================

    COMMIT TRANSACTION
END TRY  

BEGIN CATCH  
    DECLARE @errMsg   nvarchar(1000)
    SELECT errMsg = 'エラー番号:' + CONVERT(varchar,ERROR_NUMBER()) + '、エラーメッセージ:' + ERROR_MESSAGE()
    
    RAISERROR (@ErrorMessage, 16, 1)  
    ROLLBACK TRAN
END CATCH
```

重大度レベルは「16」がユーザー定義用に空いているので、これを利用するようにする。  
第3引数の状態は、同じエラーでも状態を分けて区別したい場合に利用する。  
通常は1としておき、その他は2や3など他の状態を与えるようにすると良い。  
WITH LOGを記述した場合は、Windowsのイベントログ(アプリケーションログ)へ記録できるようになる。  
デフォルトは、WITH LOGが省略された状態であるため、イベントログへの記録は行わない。  
エラー番号は「50000」が自動的に割り当てられる。  

``` sql
RAISERROR ('エラーメッセージ',重大度レベル,状態);
```

例:「Error!!!」 というメッセージでエラーを起す  

``` sql
RAISERROR ('Error!!!', 16, 1);
-- メッセージ 50000、レベル 16、状態 1、行 1
-- Error!!!
```

---

## エラーメッセージの取得

TRY~CATCHでは`ERROR_`で始まるシステム関数を使ってエラーに関する周辺情報を取得する事ができる。

``` txt
関数名            | 役割
------------------+-------------------------------
ERROR_NUMBER()    | エラー番号
ERROR_MESSAGE()   | エラーメッセージの全文
ERROR_SEVERITY()  | エラーの重大度
ERROR_STATE()     | エラー状態番号
ERROR_LINE()      | エラーが発生した行番号
ERROR_PROCEDURE() | エラーが発生したストアドプロシージャまたはトリガーの名前
```

---

## アプリケーション側でのエラーの取得

アプリケーション側では`SqlException`クラスを指定してSQLServer関連のエラーをキャッチするようにする。  

``` cs
using System.Data.SqlClient;
using System.Data;

void Execute(){
    using (var cn = new SqlConnection("接続文字列"))
    {
        using (var cmd = new SqlCommand("SQL",cn))
        {
            try 
            {
                cn.Open();
                cmd.ExecuteNonQuery();
            } 
            catch(SqlException ex) 
            {
                MessageBox.Show(ex.Message);
            }
            finally
            {
                cn.Close();
            }
        }
    }
}
```

---

## TRY CATCHでROLLBACKを記述しなかった場合

``` sql
BEGIN TRY
    BEGIN TRAN
    …
    COMMIT TRAN
END TRY

BEGIN CATCH
    -- ROLLBACK を記述しない
END CATCH
```

トランザクションがコミットもロールバックもされないので、トランザクションが完了していない状態(トランザクション中)が残ってしまう。  
COMMITまたはROLLBACKが実行されるか、接続が切られるまでトランザクション中の状態が続く。  

---

## キャッチできないエラー

CATCH部では、エラーの重大度レベルが10以下のエラーと20以上のエラーのうち、再接続が不可となる深刻度の高いエラー(ハードウェア的な障害発生時等の致命的なエラー)はキャッチすることができない。  
重大度レベルが10以下のエラーは重大なエラーではなく、単なる情報メッセージとして分類される。  

---

## SQLServer 2000のときの例外処理

TRY CATCHはSQLServer 2005から提供された機能。  
2000時代では、1つ1つのステートメントごとにエラー処理を記述する必要があった。  
インラインでのエラー処理は、直前のエラー番号を取得できる`@@ERROR`というシステム関数を使って記述していた。  

``` sql
BEGIN TRAN
    INSERT INTO t VALUES(1,777)
        IF @@ERROR <> 0
            BEGIN
                ROLLBACK TRAN
                RETURN
            END
    INSERT INTO t VALUES(4,777)
        IF @@ERROR <> 0
            BEGIN
                ROLLBACK TRAN
                RETURN
            END
COMMIT TRAN
```

`@@ERROR`関数は、直前のステートメントが成功した場合には`0`が格納されるため、IF文を使って0か否かで条件分岐することでエラーが発生したか銅貨をチェックできる。  

RETURNを記述していない場合、次の行がそのまま実行されてしまうので必要だった。  

---

## 意図的にエラーを起こす方法

発生させるだけならこれで十分。

``` sql
SELECT 1/0
```

---

## カーソル処理に置けるTryCatch

[複数のカーソルを開く方法 -ヘッダーと明細で複数のカーソルが必要な場合の記述方法- | SQL Server](https://itblogdsi.blog.fc2.com/blog-entry-315.html)  
[トランザクション処理をさらっとマスターしよう](https://atmarkit.itmedia.co.jp/ait/articles/0803/24/news138_3.html)  

---

[SQL Server で意図的にエラーを起こす](https://sql55.com/query/raise-error-exception.php)

[Best practices for committing a transaction in SQL Server where TRY CATCH is used](https://dba.stackexchange.com/questions/233079/best-practices-for-committing-a-transaction-in-sql-server-where-try-catch-is-use)  

Sqlserver TRYCATCH ROLLBACK
[エラー発生時のトランザクションのロールバック - SET XACT_ABORT ON　と TRY...CATCH](https://sql55.com/column/rollback-transaction-set-xact-abort.php)  

[トランザクション処理をさらっとマスターしよう](https://atmarkit.itmedia.co.jp/ait/articles/0803/24/news138_2.html)  
[SQLServerのストアドプロシージャーで例外をキャッチする方法](https://it-engineer-info.com/database/excption-try-catch)  
[SQLServerでTRY-CATCHしちゃうと呼び出し側でエラー判別しにくい](https://qiita.com/ryo_naka/items/2e79f8dcf9c24f1b7269)  
[TRY CATCH ROLLBACKパターンを含むネストされたストアドプロシージャ](https://www.web-dev-qa-db-ja.com/ja/sql-server-2005/try-catch-rollback%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%82%92%E5%90%AB%E3%82%80%E3%83%8D%E3%82%B9%E3%83%88%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B9%E3%83%88%E3%82%A2%E3%83%89%E3%83%97%E3%83%AD%E3%82%B7%E3%83%BC%E3%82%B8%E3%83%A3/968296485/)  
