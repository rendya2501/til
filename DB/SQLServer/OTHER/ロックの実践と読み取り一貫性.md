# ロックの実践と読み取り一貫性

## テーブルスキャンによるロック待ち

以下のように「t1」テーブルがあるとする。  
a列、b列にインデックスは張られていないものとする。  

``` txt
「t1」テーブル

| a |  b  |
|---+-----|
|1  | BBB |
|2  | CCC |
|:  |  :  |
|7  | GGG |<- 排他ロック
|8  |  :  |   トランザクションX
|:  |  :  |   UPDATE t1 SET b='g' WHERE a=7
|20 | CCC |
|:  |  :  |

トランザクションY
SELECT * FROM t1 WHERE b = 'CCC'
b列をテーブルスキャン
```

1. トランザクションXを実行して[a=7]を排他ロックする。  
2. トランザクションYを実行して[b='CCC']のデータを参照する。  
3. SQLServerはインデックスがない場合、[b='CCC']という条件を満たすデータを探すために、テーブルスキャン(すべてのデータを先頭から順に最後のデータまで調べる)を実行する。  
4. トランザクションYが[a=7]に到達するが排他ロックされているため内部的にロック待ちが発生する。  

これがテーブルスキャンによるロック待ち。  
この現象はたった1つのロック(行単位のロック)によってテーブル全体がロックされているように見えるため、「ロックエスカレーション」が発生していると勘違いされることが多い。  

※排他ロック : 他のトランザクションからのあらゆるアクセスをブロックする。  
