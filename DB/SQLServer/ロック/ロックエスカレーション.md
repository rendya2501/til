# ロックエスカレーション

## 概要

行単位のロックは、同時実行性は高まるが、大量の行が更新される場合には、ロックの数が膨大になってしまう。  
SQLServerは、行単位やページ単位など、小さい粒度のロックが大量に発生し、SQLServer自身に負荷が高いと認識したときには、必要に応じてロックの粒度を拡大(エスカレート)する。  
これは、**ロックエスカレーション**と呼ばれている。  

例えば、テーブルデータが100万件あり、そのうちの90万件に行ロックがかかっているとする。  
この時、それらのロックをテーブル単位のロックへエスカレートできるのであれば、ロックは1つで済む。  

ロックがエスカレートされるかどうかは、同時実行されているトランザクションや、利用できるメモリ量に依存する。  

---

## ロックエスカレーションの監視

ロックエスカレーションが発生したかどうかは、プロファイラーの「`Lock Escalation`」イベントまたはシステムモニターツールの「`Table Lock Escalation/sec`」カウンターで調べることができる。  

---

## Oracleと同じように動作させたい場合

Oracleでは、ロックエスカレーション機能が実装されていないため、大量のデータをロックする場合にも、(デフォルトでは)行単位のロックが大量に取得される。  
SQLServerでも「`ロックエスカレーションの無効化`」を設定して、ロックヒントへ「`ROWLOCK`」を指定すれば、Oracleのデフォルトと同じように動作させることが可能になる。  

---

## ロックエスカレーションの無効化

ALTER TABLEステートメントを使ってテーブル単位で無効化を設定できる。  
2008から有効。  

``` sql
ALTER TABLE テーブル名
SET (LOCK_ESCALATION = DISABLE)
```

※ 2005以前のバージョンではトレースフラグ「1211」を設定する事でSQLServer全体でロックエスカレーションを禁止していた。

---

## ロックエスカレーションは悪ではない

データベースエンジニアの中には、ロックエスカレーションの本質を理解せずに、「ロックエスカレーションが悪さをして性能が出ない」と早計に考える人もいる。  

あくまでも、ロックエスカレーションは大量のロック獲得のオーバーヘッドを軽減させることができる"性能向上"のための機能。  
NOLOCKヒントを利用したり、適切なインデックスを作成していれば、ロックエスカレーションに悩まされることはない。  
