# トランザクション

## 基本

トランザクションは、データベースシステムにおける処理の単位。  
トランザクションの完了はコミット。  
トランザクションの取り消しはロールバック。  

SQLServerでは次の2つをトランザクションとして扱う。  

- UPDATE/INSERT/DELETEなどのデータ更新系のステートメント  
- BEGIN TRANSACTION から COMMIT TRANSACTION で挟まれた複数のステートメント  

■ 基本形  

``` sql
BEGIN TRANSACTION
COMMIT TRANSACTION
ROLLBACK TRANSACTION
```

■ 省略形  

``` sql
BEGIN TRAN
COMMIT
ROLLBACK
```

`TRANSACTION`は`TRAN`と省略可能。  

`COMMIT TRAN`は`TRAN`を省略して`COMMIT`と記述可能。  
`ROLLBACK TRAN`も`ROLLBACK`と記述可能。  
`BEGIN TRAN`の`TRAN`は省略不可。  

---

## 明示的 vs 暗黙的トランザクション

SQLServerはBEGIN TRANSACTIONステートメントによる明示的な開始を宣言する「明示的なトランザクション」。  
OracleやDB2のように、自動的にトランザクションが開始されるトランザクションは「暗黙的なトランザクション」(Implicit Transaction)と呼ばれる。  

SQLServerで暗黙的なトランザクションとして動作させる場合、次のSETステートメントを実行する。  

`SET IMPLICIT_TRANSACTIONS ON`  

この設定(暗黙的なトランザクションが有効な状態)は、SQLServerに接続している間、または設定をOFFへ変更するまで続く。  

---

## ネストしたトランザクション

トランザクションは、トランザクションの中でさらにトランザクションを定義することも可能。  
ただし、この場合はネストしたトランザクション側でROLLBACK TRANが実行されると、当該トランザクションだけではなく、トランザクション全体がロールバックされてしまう。  

``` sql
BEGIN TRAN
    -- do something
    BEGIN TRAN
        -- do something
    ROLLBACK TRAN -- ←ROLLBACKが実行されるとトランザクション全体がロールバックされる。
COMMIT TRAN
```

---

## ロールバックされない処理

トランザクションは不慮の障害(停電やCPU障害、メモリ障害など)が発生した場合にロールバックを行ってくれるが、制約違反エラー等のステートメントエラーが発生した場合には、ロールバックを行ってくれない。  

`SET XACT_ABORT ON`を追加するか、例外処理を追加する。  

---

## SET XACT_ABORT ON

ステートメントエラー時のトランザクションのロールバックを有効化するオプション。  
規定ではOFFになっている。  
ONにした後はOFFを実行するか、接続が切れるまで有効。  

XACTはTransactionの略。  
Abortは「中止」「中断」の意味。  

``` sql
SET XACT_ABORT ON
BEGIN TRAN
    INSERT INTO t VALUES(1,111)
    INSERT INTO t VALUES(1,111)-- 重複値の追加。制約違反エラー
COMMIT TRAN
SET XACT_ABORT OFF
```

---

## TransactionはTryの前で行うべきか後に行うべきか

昔、Tryの前にTransactionを実行してエラーとなり、トランザクションが開いたままになった記憶がある。  
教科書やほとんどの例ではTry Catchの内部でBegin Tranしている。  
では、Tryの前にBegin Tranする事は何がいけないのか調べた。  
全然そんな文献に当たらない。  

でもって実際に実行してみたが、特にトランザクションが開きっぱなしになるような事もない。  
どちらでもいいのだろうか。  

``` sql
BEGIN TRANSACTION

BEGIN TRY
    SELECT 1/0
    COMMIT TRANSACTION
END TRY

BEGIN CATCH
    SELECT
        ERROR_NUMBER() AS ErrorNumber,
        ERROR_SEVERITY() AS ErrorSeverity,
        ERROR_STATE() AS ErrorState,
        ERROR_PROCEDURE() AS ErrorProcedure,
        ERROR_LINE() AS ErrorLine,
        ERROR_MESSAGE() AS ErrorMessage

    ROLLBACK TRANSACTION
    PRINT 'Error detected, all changes reversed.'
END CATCH
```

[開発備忘録＆ふと思ったこと](https://memo.itsysgroup.com/?p=1359)  
こちらのサイトでも同じようなことをしているが、やはり問題なくロールバックされる模様。  
この書き方で駄目だったのは別の要因であって、書き方の順番ではなかった？  
普通に考えれば、先にトランザクションを開始してからエラーキャッチを行うか、エラーキャッチを行った後にトランザクションを開始するかの違いでしかなく、これくらい小さなバッチではトランザクションを開始した時点でバッチ全てがトランザクションの対象になるから、順番なんてあまり関係ないのだろうか。  
多分そうだと思う。  

[TSQL Try / Catch within Transaction or vice versa?](https://stackoverflow.com/questions/23056973/tsql-try-catch-within-transaction-or-vice-versa)  

---

## MSDTC (Microsoft Distributed Transaction Cordinator)

>分散トランザクション (Distributed Transaction) は、複数サーバーにまたがったトランザクションのことで、この調整 (Coordinate) を行うための機能がMSDTCサービスです。  
>[SQLServer2016の教科書]  

TransactionScopeを使うとこの仕組みを使う模様。  
Linuxでは対応していないので、SQLServerをLinuxにもっていって、TransactionScopeを使うと死ぬ模様。  

---

## トランザクションの肥大化

[トランザクションログ肥大化の対処方法 (log_reuse_wait_desc : LOG_BACKUP) [SQL Server]](https://www.nobtak.com/entry/tlogs2)  
[【INDEX】SQL Server トランザクションログ肥大化 (原因／対処方法)](https://www.nobtak.com/tlogidx#2-%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%AD%E3%82%B0%E3%82%92%E8%82%A5%E5%A4%A7%E5%8C%96%E3%81%95%E3%81%9B%E3%81%A6%E3%81%84%E3%82%8B%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AE%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95)  
[トランザクションログを肥大化させているクエリの特定方法 [SQL Server]](https://www.nobtak.com/entry/tlogs0)  

---

## DROP TABLEやTRUNCATE TABLEはロールバック可能か？

SQLServerではロールバック可能であることを確認した。  
他はDBによる模様。  
ロールバック不可能なDBに関してはdrop tableやtruncate等のDDL(テーブル構造)命令は、RollBackが利かないらしい。  

以下のクエリをコピペして実行するだけで検証可能。  

``` sql
DROP TABLE IF EXISTS employees;
CREATE TABLE employees(dept_id int,name varchar(32));
INSERT INTO employees(dept_id,name) VALUES(1,'田中');
INSERT INTO employees(dept_id,name) VALUES(2,'玉木');
INSERT INTO employees(dept_id,name) VALUES(3,'鈴木');
GO

BEGIN TRY
    BEGIN TRANSACTION

    DROP TABLE employees;
    -- TRUNCATE TABLE employees;
    SELECT 1/0

    COMMIT TRAN
END TRY

BEGIN CATCH
    THROW
    ROLLBACK TRAN
END CATCH
GO

select * from employees
```
