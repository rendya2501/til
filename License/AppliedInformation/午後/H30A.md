# 平成30年秋期

---

## セキュリティ インターネットサービス向けサーバのセキュリティ対策

まぁ、セキュリティなんてこんなものでしょ。  
本番でもこれくらいサクサクとければいいんだけどねぇ。  
12分で終わったら相当なアドバンテージが取れる。  

・FWを設定する場所  
・最初からセキュリティの専門家を参加させるのは、ダメな暗号化通信を最初から使わせないため的な  

``` txt 12分 11/11
ウ
キ
診3

エ
カ
FW
Webサーバ
SQLインジェクション

イ
ウ
脆弱な暗号化通信を使うリスクを排除することができる 0%
危殆化していない暗号化通信方式を採用するため
→まぁ正解みたいなモノだろう。

---

[1]
UDPスキャン,セッション管理については11.セキュリティにまとめた。
最初セッション管理ではなく、ログ管理に仕様としたけど、Webアプリケーションならセッション管理できないとやばいよなと思ってこっちにした。


[2][2]
「各サーバで稼働するサービスへのアクセス制限は，ファイアウォール及び各サーバのOSがもつFW機能の両方で実施することになっている」と説明されていることに注目します。"脆2"はWebサーバで提供されるサービス(DBMS)の脆弱性なので、ファイアウォール及びWebサーバのOSがもつFW機能の両方でアクセス制限を施すことになります。

→
ちゃんと文中に書いてあった。

[3]
設問では解答に当たり「"脆3"で発見された脆弱性への対策として」という条件があるので、まず"脆3"の内容について確認します。
"脆3"の脆弱性とは「脆弱な暗号化方式が使用できてしまう設定であった」ことであり、表4では、この発見された脆弱性に対して実施すべき対策(案)として「Webサーバのソフトウェアの設定を変更して，脆弱な暗号化方式を使用禁止にする。」という方法が提案されています。
つまり、ソフトウェアの企画・設計段階からセキュリティの専門家を参加させる狙いとして、脆弱な暗号化方式の使用に関連することを答えるのが妥当であると判断できます。

市販ソフトウェアでは、更新により強固な暗号化方式へのアップデートが行われるのが通常ですが、委託開発する自社ソフトウェアの場合には、このような更新は行われず、委託先企業のセキュア設計のレベルによっては脆弱な暗号化方式（近い将来に危殆化が予測されているものも含む）を採用することがないとは言えません。一度開発されたソフトウェアは中長期的にわたり使用されますから、将来的な展望や用途及びリスクを考慮した適切な暗号化方式を選択するために、セキュリティの専門家の意見を取り入れることは重要です。

したがって、"脆3"の対策として企画・設計段階からセキュリティの専門家を参加させる狙いは、「危殆化していない暗号化通信方式を採用するため」が適切です。

∴危殆化していない暗号化通信方式を採用するため
```

---

## プログラミング ウェーブレット木

難しかったけど、点数をとるって目的を達成するだけなら案外とれたほうではなかろうか。  
この問題やっててわかったことは、ややこしい日本語を読んでいる時どこか諦めてることですかね。  
理解を放棄しそうになってる。  
だから、読んでもわかんないって感じになるんだ。  
そういう時は、いったん離れて全体を見た後で読み返したりする必要があるのかも。  
時間に追われるとこういう点も顕著になってくるのだろう。  

シフト演算と計算量の確認もしっかり行う。  

``` txt : 30分 7/10
10001
TGGGT
5

d × DEPTH + d
1 × r
0
count

σ
N
σ*log2(σ) × Nlog2(σ)

---
〔エ，オについて〕
図3「関数rankのプログラム」の7行目のコメント行に「rに対応するビット列の左からd番目のビット位置のビットの値をbに格納」と書かれています。8行目から10行目は、この処理を行っている箇所です。

あるビット列から特定の位置のビットを取り出す場合は、以下の手順で処理を行います。
取り出したい位置のビットを 1、それ以外の位置のビットを 0 としたビット列を用意する
対象文字のビット列と、1.で用意したビット列の論理積(AND)を求める
2.で求めた論理積を右にビットシフトして、取り出したい位置のビットを取得する
例として、ビット列"11010"の左から2番目のビットを取り出したい場合を考えます。手順1で"01000"を用意します。これは、1を左に3ビットシフトした値です。手順2で"11010"と"01000"の論理積"01000"を求めます。手順3で01000を右に3ビットシフトすると、元のビット列の左から2番目のビットである「1」が得られます。
pm03_7.gif/image-size:386×247
この手順1がプログラムの8行目、手順2が図3の9行目、手順3が図3の10行目に対応しています。

また、d はプログラムの3行目と22行目の記述から、符号中の左からのビット位置を保持する変数であり、whileループを繰り返す（木構造を下がる）ごとに1、2、3、…と1ずつ増えていくことがわかります。

エは、手順1のビット列を用意するために「1を何ビット左にシフトすれば良いか」と考えます。具体例を挙げて、プログラムに落とし込む手順を踏むと、
ビット列の長さが5、左から2番目を取り出す場合
用意するビット列は"01000"なので、1を左に3ビットシフトする
ビット列の長さが5、左から3番目を取り出す場合
用意するビット列は"00100"なので、1を左に2ビットシフトする
ビット列の長さが6、左から3番目を取り出す場合
用意するビット列は"001000"なので、1を左に3ビットシフトする
ビット列の長さが6、左から2番目を取り出す場合
用意するビット列は"010000"なので、1を左に4ビットシフトする
というように、左にシフト（及び手順3で右にビットシフト）させる大きさは「符号のビット数 - 取り出したいビット位置」で求められることがわかります。各文字の符号化に必要な最小のビット数は、大域変数 DEPTH に、取り出す位置は前述の通り変数 d に格納されているので、エに入る式は DEPTH - d が適切です。

オは、手順2に該当し、プログラムの8行目(手順1に相当)で作成したマスクビット列 x と論理積を求めるものですので、取り出し対象のビット列である r が入ります。

∴エ＝DEPTH - d
　オ＝r

〔「カ」について〕
図3の10行目のコメントに「bは0か1の値」と書かれているので、カには0か1のどちらかが入ります。また、図3の17行目から、この条件式を満たす場合の処理は、「nodep ← nodep.left」であることがわかります。nodep.left は、左の子ノードへのポインタであり、次回のwhileループで左の子ノードを検索対象とする処理です。本問のウェーブレット木では、ある文字の指定位置から取り出したビットが 0 の場合には左の子ノードに、1 の場合には右の子ノードに振り分けるので、出現回数を数える対象となっている文字を格納する葉に行き着くためには、bが0の場合には左の子ノードへ、bが1の場合には右の子ノードへ進まなければなりません。よってカには 0 が入ります。

∴カ＝0

〔キについて〕
図3の4行目から n は検索対象の文字列(キー値)の長さであることがわかります。このことから、プログラムの21行目は n の更新をする処理であり、キには次の検索対象の文字列の長さが入ることがわかります。次の検索対象となる文字列とは、現在のノードに振り分けられた文字列のうち、次にたどる(左又は右の)子ノードに振り分けられる文字列です。
次の検索対象となる子ノードの文字列長は、11行目から15行目の処理で求めています。具体的には、現在のノードのキー値の各ビットと b を比較して、一致する場合に変数 count を増やしています。何をしているかというと、出現回数を数える対象となっている文字と同じ子ノードに振り分けられる文字数を数えているのです。
pm03_8.gif/image-size:432×157
変数 count に次回の検索対象となる文字列の長さが格納されているので、次のwhileループが始まる前に n を count で更新することになります。よってキには count が入ります。

∴キ＝count

→
エ、オの記述を見る限り、シフトして戻すのはわかったけど、どうしてそうする必要があるのか理解できなかったんだよな。
rが単純なビット列でそこから何番目の値を取得するのかって前提を解読できればなるほどねってなる問題だった。
これは中々どうしてだな。
整数(0~σ-1)に変換したものって文言に惑わされてしまった感がある。


〔クについて〕
ウェーブレット木の構築は、各文字ごとにルートから葉までのノードで操作を行います。ルートから葉までにたどるノードの数は、ウェーブレット木の深さと等しくなります。文字の種類の個数をσとすると、ウェーブレット木の深さは log2(σ) となるので、クには σ が入ります。

∴ク＝σ

〔ケについて〕
各ノードでの操作に掛かる定数時間を考えます。プログラムを見ると、各ノードにはwhileループの中に記述された処理が1回だけ行われます。この中には、キー値全てを走査するfor文が1つ含まれているため、各ノードに対する計算量は O(N) (線形時間：データ量の分だけ時間を要する)になります。

∴ケ＝N

〔コについて〕
ウェーブレット木全体のキー値の長さの総和は、「深さごとのキー値の長さの和×深さ」で求めることができます。

まず、深さごとのキー値の長さの和について考えます。
本問の図1を見てみると、深さ0のノード(根)のキー値は「0101010110」であり、長さは 10(＝N) です。深さ1のノードのキー値の長さは、いずれも 5 です。
pm03_9.gif/image-size:447×93
ノードの深さごとのキー値は、根のキー値が分割されたものですから、ノードの深さごとのキー値の長さの和は、常に 10、すなわち N になります。

次に、ウェーブレット木の深さを求めます。これはクで求めたとおり、log2(σ)です。

以上より、
深さごとのキー値の長さの和：N
ウェーブレット木の深さ:log2(σ)
ですから、ウェーブレット木全体のキー値の長さの総和は Nlog2(σ) になります。

∴コ＝Nlog2(σ)

→
計算量とlogが出てきて思考停止したが、よく見てみれば、大したことはしていない。
もう一度問題をやり直してみれば頭の中で理論を説明できるだろう。

```

---

## ネットワーク Webシステムの負荷分散と不具合対応

LPIC合格したよなぁ？って感じです。  
nslookupと書こうとしてnetstatとはな。  

すぐに終わったけど、ミスリードしてた。  
IPの問題は大丈夫だったけど他がダメですね。  

``` txt : 18分 4/7
172.16.10.5
172.16.10.12

netstat × dig or nslookup
TCPポートを確保できず接続待ち状態が続きタイムアウトする 0%
→WebサーバからDBサーバへのアクセスがエラーとなった
タイムアウトエラーになる確率が低下する 0%
→Webサーバー1～3で再利用できるTCPポート数を増やせること

ア
LBによる送信元アドレス書き換え機能 100%
他)送信元のIPアドレスはLBのものになるから

---

[2]
問題をよく見てみれば、どのようなエラーが発生していると考えられるか？なので、何が原因か？と答えるのは全然違うように思われる。
もっとよく見れば、普通にこたえられる問題だっただけに非常におしい。


[2][2]
不具合の直前に販売管理機能のプログラムをバージョンアップしているので、Webサーバ上で動作するプログラム上の問題であることが想定できます。

表1の記載内容を見ると、pingでの疎通確認、名前解決が正常である一方、項番4には「エラーが表示されたときのWebサーバとPC間におけるHTTP通信メッセージそのものが存在しなかった」とあり、Webサーバが要求を受信してから応答を送信するまでの間にエラーが発生している確率が高いと考えられます。HTTP応答が返ってこない場合、Webブラウザではタイムアウトエラーを表示します。
さらに、項番6に「WebサーバからDBサーバへのアクセスエラーメッセージがあった」と記載されていることから、WebサーバからDBサーバへのアクセス時にエラーの原因となる不具合が生じていると判断するのが妥当です。

∴WebサーバからDBサーバへのアクセスがエラーとなった


[2][3]
表1の項番6では「TCPポートが確保できない」エラーが記録されており、DBサーバのTCPポートが枯渇してしまっていることがアクセスできない原因であることがわかります。

TIME_WAIT状態とは、TCP通信のシーケンスにおける遷移状態の1つで、本文中に「TCPコネクションが閉じるまでの猶予状態である」と説明されているように接続終了待ちの状態を示します。TIME_WAIT状態のタイムアウト値を短縮することで、使用済みのTCPポートを以前より早く解放するようになります。TCPポートが解放されるまでの時間が短くなれば、他の通信がそのポートを再利用することが可能となります。これにより、Webサーバ1～3で再利用できるTCPポート数が増える改善効果を望めます。

∴Webサーバ1～3で再利用できるTCPポート数を増やせること


```

---

## データベース 入室管理システムの設計

難しかった。  
この年のデータベースは難しい模様。  
スレッドもあれている。  

``` txt : 30分 7/9
## 1
グラフは答えを覚えていたので正解ではあるが、なぜそうなのか説明出来ないので不正解みたいなものだろう。
→
意外と単純なもので、主キーと外部キーを見比べれば一目瞭然だった。
ユースケースから考えると難しいけど、単純にE-R図上で考えてみれば1対多になる可能性があるかどうかで判断できるから、素直にそれだけでよかった。


## 2
ここは特に何もないかな。
主キーといわれてこれ以外は考えられないし。


## 3
TRUE,FALSEを返す文はCOUNTだけでよかったか。
最初はそう書いたのだが、WHEREの意味がよくわからなかったので、CASEまで書いたけどダメだった。
深読みして失敗したパターンってやつだな。

→
図2のSQL文では、ROOMスキーマの入室許可表から「社員IDと室IDが指定のものであり、今日が入室許可期間内である」という条件のレコードを抽出します。
この条件を満たすレコードが存在する（つまり、レコードが1つ以上）ということは本日の入室が許可されていて、条件を満たさない（つまり、レコードがない）ということは本日の入室が許可されていないということです。

aにレコードの個数を数える関数を入れれば、本文で説明されている結果、すなわち前者に1以上を後者に0を返すことができます。したがって、aには「COUNT(*)」が当てはまります。
→
AND 入出許可開始 <= :今日 AND 入出許可終了 >= :今日
時間ではなく、日で考える。
2日部屋を予約したのなら？終了は今日より後に無くてはならないし、許可は少なくとも今日からでないといけない。
だからちゃんと有効範囲内に入っている事がわかる。
ここまで読むことが出来なかった。
しかも、問題文にはちゃんと「可の場合は1以上」って記述があるので、なおさらCOUNTでよかった。


## 4
GRANT文なんて使ったことはなかったが、ONやTOの前置詞の意味が分かれば、自ずと答えは決まってくる。
許可する命令をビューに与え、それをユーザーに付けるというイメージかな。
GRANT 許可する命令 ON 付与するビュー TO 付与するユーザー
`GRANT <権限> ON <表名> TO <ユーザ名>`  

HRかROOMか。
ここ毎回ROOMにしようとしてしまうのだけど、何故だろうか。
→
〔各社内システムのRDBMSユーザ〕には「社内システムごとにデータベース管理者(以下，DBAという)が存在する。
DBAは表の所有者であり，他のユーザに対して，自分が所有する表へのアクセス権限を付与することができる。」とあります。
前述したようにビュー表"入室管理用社員"の属するスキーマは「HR」ですから、アクセス権限の付与は人事システムのDBA用ユーザが実行します。
表4より、人事システムのDBA用ユーザ名は「HR_DBA」とわかります。
→
直前の問題がROOM_APに対して権限を付与しているから、ならROOM_DBAから付与されるのが筋だよなって勘違いしてしまうからだろうか。


## 5
ここは是非とも正解しておきたかった。
やりたいことはわかったけど、それをクエリに落とし込めなかった感じ。
間に組織を挟んで考えれば簡単だった。

→
図5のSQL文によると、ビュー表"入室管理用社員"の各列の対応は次のようになります。
社員ID：社員表（T1）の社員ID列
氏名：社員表（T1）の氏名列
勤務区分：社員表（T1）の勤務区分列
組織長氏名：社員表（T2）の氏名列
ある社員の組織長の氏名を得るためには、その社員の「社員ID→所属する組織の組織ID→その組織の組織長の社員ID→組織長の氏名」の順に参照すればよいと考えられます。
それをSQL文で実現するには、

「社員ID、所属組織ID、氏名、勤務区分をもつ社員表(T1)」と「組織ID、組織長の社員IDをもつ組織表(T3)」を(所属)組織IDで結合する。
　 →WHERE句に「T1.所属組織ID = T3.組織ID」を記述する。

「組織長の社員IDをもつ組織表(T3)」と「社員ID、氏名をもつ社員表(T2)」を(組織長の)社員IDで結合する。
　 →WHERE句に「T3.組織長の社員ID = T2.社員ID」を記述する。

といった手続きを行います。
```

---

## 組み込みシステム カードを使用した電子扉システムの設計

プリエンプション  
優先度に関する問題  

ほぼ全問正解。  
間違えたのは適切な字句を入れなさいってところをキーワードでしか答えなかったから。  
でも、内容的には100％正解だったので、まぁってかんじ。  
問題文をちゃんと読みましょう。  

30分かかってしまった。最後の問題で時間がかかった。  
フローに置けるバグを見つける問題でちょっとしたパズルになっている。  
それに嵌った。  
30分ちょうどでわかって正解した感じ。  

``` txt : 回答 30分 7/8
## メモ


## 1
a カード識別コード
b 扉識別コード


## 2
c エラー音 × エラー音を発生する
d オ
e カ
f 閉扉
g タイマ満了


## 3 100%
t1秒経過して開錠処理が開始されてから１秒以内に扉を開ける
→
「①施錠する」処理中に扉を開き、そのままt2秒経過したとき
```

---

## 情報システム開発 継続的インテグレーション

問題を覚えていたのでスラスラ解けた。  
1つナチュラルに間違った奴があるので、それだけ復習すれば後は十分かな。  
最後の問題に関しては言いたいことはわかっていた。  
表現の問題として片付けたい。部分点をもらえる自信はある。  

``` txt : 20分 7/9 実質8
イ
エ
オ

リグレッションテスト
エ × ア

false

エ
異常が発生した場合、担当したチームにのみメールが送信されるようにする 0%
他)各アプリケーションの担当チームだけにメールするようにする
ビルドと単体テスト間のフォークとジョインを廃止してそれぞれ単体テストまで流す 0%
→各アプリケーションのビルド終了後、待ち合わせせず単体テストに移る

---

[2]
"既存機能に対するテスト"では、機能変更・機能追加された部分だけでなく、追加・変更された機能とは直接関係ない部分も含めて網羅的に再テストを実施します。
当然ですが、アプリケーションの規模が大きくなれば、それだけテストしなければいけない部分も増えるため、テストケース数は増加します。
アプリケーションの規模はステップ数で表されますから、"既存機能に対するテスト"のテストケース数は、アプリケーションのステップ数と密接な関連があります。

ステップ数に対するテストケース数をテスト密度といいます。
テスト密度は、テストケース数を設定する際の参考値や、テストの十分性評価等に使用できます。
IPAの「ソフトウェア開発データ白書」等の資料では、テスト密度の統計が公表されているため、初めてCIツールを導入する場合でも、これらを参考にテストケースの数が妥当であるかどうかを評価することができます。

したがって、テストケース数の妥当性を評価するために考慮すべき値は、アプリケーションのステップ数になります。
他の選択肢は、追加・変更された部分の大きさと関連する値ばかりなので誤りです。

∴ア：アプリケーションのステップ数

```
