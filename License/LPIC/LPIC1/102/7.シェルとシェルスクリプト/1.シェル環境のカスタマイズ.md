# シェル環境のカスタマイズ

---

## aliasコマンド

エイリアスを設定するコマンド。  
コマンドの別名を定義したり、コマンドとそのオプションをまとめて1つの新しいコマンドとして実行できる。  

単一引用符で括っているのは、コマンドとオプションの間のスペースがシェルによって解釈されないようにするため。  
本来のコマンド名と同じエイリアスを定義した場合、エイリアス側が実行される。  
本来のコマンドを実行したい場合は頭に`\` or `バックスラッシュ`を付けて実行するか、パス付きで実行する。  
→`\ls` or `/bin/ls`  

``` txt
alias
登録されている全てのエイリアスが表示される。

alias [エイリアス名='コマンド']
エイリアスを登録する。
既に登録されている別名と同じ別名で再定義した場合、上書きされる。  
通常の場合はシングルクオート。
コマンドが2語以上になる場合は、シングルクォート（'）もしくはダブルクォート（"）で括る。  
```

`ls`と入力した時に`ls -l`コマンドが実行されるようにする。  
`alias ls = 'ls -l'`  

`ls -l`コマンドの実行結果を`less`コマンドで表示するエイリアス`lsless`を定義する。  
`alias lsless = 'ls -l | less'`

---

## unaliasコマンド

設定したエイリアスを削除するコマンド  

``` txt
unalias [オプション] 別名

オプション
-a :: 現在の登録内容を全て削除する。
```

上で定義した`lsless`コマンドを解除する。  
`unalias lsless`  

---

## functionコマンド

bashシェル上で利用できる独自のシェル関数を定義するためのコマンド。  
複雑なコマンドの組み合わせや条件分岐を行う場合等に使用する。  
単純なコマンドの組み合わせはエイリアスだが、それでは対応出来ない場合にfunctionを定義する。  

シェル関数はシェルスクリプトとは異なり、現在のシェルで動作します。  
例えば、シェル関数内でexitした場合、現在のシェルが終了します。  
シェルスクリプトを実行した場合は新たなシェル（サブシェル）を生成し、そのサブシェル上でシェルスクリプトは動作しますので、  
シェルスクリプト内でexitした場合はサブシェルが終了し、現在のシェルに戻ります。  

※関数が利用できるのは、その関数を定義したシェル内のみ。  
※bashはシェル変数とシェル関数を区別しないため、シェル関数はsetコマンドでも確認できる＆競合しないようにする必要がある。  
※定義済みの関数は「declare -f」コマンドで確認できる。  

``` txt
※1
function シェル関数名() { コマンド; }

※2
function
関数名()
{
    コマンド
}

※1の書式では「{」と「}」の間にはスペースが必要。  
※2の書式ではコマンドの後ろの「;」は不要。  

コマンド中には、関数の実行時に指定した引数を設定することもできます。実行時に指定した順に$1、$2 ... とすることで、引数の値を参照します。
```

例)指定したディレクトリの中にあるリンクファイルのみをリスト表示するlslink関数を定義する。  
`function lslink() { ls -l $1 | grep '^1' }`  
→  
1番目の引数は$1と表す。  
シンボリックリンクは行頭のファイル種別記号が「l」になるので、行頭のlを検索する。  

例）2つの引数を逆に表示するシェル関数reverseを作成する場合  
function reverse() { echo $2 $1; }

``` bash : 実行例
reverse a b
b a
```

---

## unsetコマンド

定義したシェル関数を削除するコマンド。  

``` txt
unset シェル関数名
```

シェル関数[lsmo]の削除  
`unset lsmo`  

---

## declareコマンド

変数を宣言するコマンド。  
定義済み変数や関数の定義内容も表示する。  
declare : 宣言する。  

``` txt
declare [オプション] [名前]
declare [オプション] [名前=値]

オプション
-f :: 現在定義されているシェル関数を全て表示する。
-F :: 現在定義されている関数名を全て表示する。
-p :: 現在定義されている変数を全て表示する。
-P :: 現在定義されている変数名を全て表示する。
```

---

## setコマンド

シェルの設定を確認、変更するコマンド。  
101の時は環境変数を確認するためのコマンドとして認識していた物。  

引数なしで実行した場合、表示できるもの :: 環境変数、シェル変数、シェル関数  
オプションの有効は「-」、オプションの無効は「+」。直観的な認識と逆なので注意。  

``` txt
set [-o][+o] [オプション]

-o :: オプション有効
+o :: オプション無効
シェルのオプションの設定状態を確認する :: 「set -o」

オプション
allexport :: 作成・変更した変数を自動的にエクスポートする。
emacs     :: emacs風のキーバインドにする。
ignoreeof :: Ctrl + Dによってログアウトしないようにする。
noclobber :: 出力リダイレクトによる上書きを禁止する。
noglob    :: メタキャラクタを使ったファイル名展開を無効にする。
             ワイルドカードによる展開(*や?)が無効になる。
noexec    :: シェルスクリプトを読み込むが、実行はせずに構文エラーのみを確認(検査)する。
             構文エラーはディスプレイに標準出力され、構文エラーがない場合もシェルスクリプトは実行されません。
             このオプションは対話的シェルでは無視されます。
vi        :: vi風のキーバインドにする。

※noclobberとnoglobが毎回わからない。
```

---

## envコマンド

設定されている環境変数の値を一時的に指定された値に変更してコマンド実行するコマンド。  
環境変数も表示できる。  

``` txt
env [オプション] [環境変数名=値] [コマンド]

オプション
-i               :: 何も環境変数が設定されていない状態にする。
-u 環境変数名    :: 環境変数を一時的に削除する。
環境変数名=値    :: 環境変数の値を一時的に指定された値に変更する。
(オプションなし) :: 全ての環境変数を表示する。
```

何も環境変数が設定されていない状態で、「sample.sh」というコマンド（スクリプト）を実行する。  
`env -i ./sample.sh`  
こうすることで、シェルを実行するときに、余計な環境変数に影響されることがなくなるのだろう。  

「TEST_A」という環境変数を一時的に「999」に変更して、「sample.sh」というコマンド（スクリプト）を実行  
`env TEST_A=999 ./sample.sh`  

---

## printenvコマンド

指定した環境変数のみを表示するコマンド。  
未指定の場合、全ての環境変数を表示する。  

---

## 環境変数早見表

``` txt
set        :: 全てのシェル変数、シェル関数、環境変数  
env        :: 環境変数  
printenv   :: 環境変数  
declare -f :: シェル関数
```

---

## bashの設定ファイル

シェルを起動するたびに環境変数やエイリアス、関数などを定義するのは非効率なので、それらの定義を自動的に行うための設定ファイルが用意されている。  

``` txt
適用範囲   | ファイル         | 読込ﾀｲﾐﾝｸﾞ   | 主な設定内容
全ユーザー | /etc/bash.bashrc | bash起動時   | Debian系。bash起動時に実行させたい処理(エイリアスなど)
           | /etc/bashrc      |     〃       | RedHat系。bash起動時に実行させたい処理(エイリアスなど)
           | /etc/profile     | ログイン時   | 環境変数、利用環境にかかわるもの
各ユーザー | ~/.bash_profile  |     〃       | 環境変数などユーザー環境に関わるもの
           | ~/.bash_login    |     〃       | ~/.bash_profileがない場合の読み込み次候補。内容は~/.bash_profileと同じ。
           | ~/.profile       |     〃       |  ~/.bash_profileも~/.bash_loginもない場合の読み込み次候補。内容は~./bash_profileと同じ。
           | ~/.bashrc        | bash起動時   | bash起動時に実行させたい処理(エイリアスなど)
           | ~/.bash_logout   | ログアウト時 | ログアウト時に実行させたい処理を記述する。


■ /etc/bash.bashrcファイル
Debian系。全ユーザー。  
bash起動時に実行させたい処理(エイリアス等)を記述するファイル。  

■ /etc/bashrcファイル
RedHat系。全ユーザー。  
bash起動時に実行させたい処理(エイリアス等)を記述するファイル。  

■ /etc/profileファイル
システムを利用する全てのユーザーが、ログイン後すぐに必要となる基本的な環境変数を設定するファイル。  

■ ~/.bash_profileファイル
ユーザー独自の設定が格納されたファイル。ログインした場合、2番目に読みこまれる。  

■ ~/.bashrcファイル
対話型シェルが起動されるたびに実行される。  
システムを利用する全ユーザーに対する設定は/etc/bashrcに記述し、~/.bashrcから呼び出すようになっている。  
ログインシェルとしてbashが起動した際に、読みこむ設定がない場合は読みこまれない。  
その設定は`~/.bash_profile`に記述されているらしい。  

■ ~/.profileファイル
Bashあるいはshが読み取って実行するファイル。  
記述内容はシェル構文に従う。  
ファイルに読み取り権は必要。実行権は不必要。  
ホームディレクトリにあるので、rootユーザーは関係ない。  
ユーザーにのみファイルの読み取り件を付ける必要がある。→ない。  

■~/.bash_logoutファイル
bashログアウト時に実行させたい処理を記述するファイル。画面をクリアする clear コマンドなどを記述する。  
```

---

## ログインシェルと非ログインシェル(対話型シェル)

bashは起動のされ方によって扱いが変わります。  

・ログインシェル  
`/etc/passwd`に設定され、ユーザーのログイン時に最初に起動されるシェル。  
このシェルが終了するとログアウトされる。  

・非ログインシェル(対話型シェル)  
ログインシェルから別のプロセスとして起動するシェル。  
ユーザーがログインした後に、ターミナルエミュレーターを開くことで起動するシェルを実行したり、コマンドラインから直接起動したシェル。  
（例：直接/bin/bashを実行する）  

---

## 読み込み順

ログインシェルとしてbashが起動すると、環境変数の設定などユーザー環境にかかわるものが記述されている全ユーザー共通、また、各ユーザー個別の環境設定ファイルを読み込みます。  
これらのファイルはシェル上で実行できるコマンドが記述されたシェルスクリプトです。  

これらの設定ファイルはsourceコマンド（指定したシェルスクリプトを読み込み、現在のシェルで実行する）によって実行されており、  
ファイルに読み取り権とファイルが存在するディレクトリに検索権（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼ぶ）があれば実行可能です。  

``` txt : 読み込み順
■ bashをログインシェルとして起動した場合の読み込み順  
1. /etc/profile     ← 絶対
2. /etc/bash.bashrc ← Debian系の場合、読み込む
3. ~/.bash_profile  ← 存在したら読み込む
4. ~/.bash_login    ← ~/.bash_profileが存在しないで、~/.bash_loginが存在したら読み込む
5. ~/.profile       ← ~/.bash_proflieも~/.bash_loginも存在しないで、~/.profileが存在したら読み込む
6. ~/.bashrc        ← ~/.bash_proflieと~/.bash_loginと~/.profileのどれかが存在して、かつ読み込む設定があれば読み込む
7. /etc/bashrc      ← ~/.bashrcを読み込んで、更に/etc/bashrcを読み込む設定があれば読み込む

■ bashを非ログインシェル(対話型シェル)として起動した場合の読み込み順  
1. /etc/bash.bashrc ← Debian系の場合、読み込む
2. ~/.bashrc        ← 絶対
3. /etc/bashrc      ← 読み込む設定があれば読み込む
```

---

## おまけ : .bashrc とか .npmrc とかの「RC」って何？

[.bashrc とか .npmrc とかの「RC」って何？](https://neos21.net/blog/2017/02/15-02.html)  
>.bashrc とか .npmrc とかの「RC」とは、Run Commands の略。  
>どうも Run Control とか Resource Control の略、というのは誤りらしく、  
>Wikipedia やジャーゴンファイルでは、Run Commands が RunCom と略され、最終的に rc となったとされている。  

---

## おまけ : 代表的な環境変数

``` txt
HISTFILE     :: コマンド履歴保存ファイルのパス
HISTSIZE     :: 現在のシェルでコマンド履歴の保存数
HISTFILESIZE :: コマンド履歴保存ファイルへの履歴保存数
HOSTNAME     :: ホスト名
HOME         :: ログインしているユーザーのホームディレクトリ
LANG         :: ロケール(言語設定)
PATH         :: コマンドやプログラムを検索するディレクトリのリスト
PWD          :: カレントディレクトリパス
USER         :: ログインしているユーザー
```

echoコマンドを使用して環境変数の値を確認するには、変数の先頭に「$」をつけたものを引数に指定します。  
