
# シェルスクリプト

スクリプト(特定の処理を行うために作成したプログラム)をシェルプログラムで記述したもの。  
bashシェルを始め、シェルにはスクリプト言語によるプログラミング機能が備わっている。  
一連のコマンドライン作業を自動化する事ができる。  

バイナリ形式のコマンドは実行権のみで実行できるが、シェルスクリプトの場合は読み込み権限もないと実行できない。  
なお、シェルスクリプトの場合は`bash sample.sh`のようにしてシェルの引数として指定すれば、実行権がなくても読み込み権さえあれば実行できる。  

原則、スクリプトファイルの1行目にはそのシェルスクリプトがどのインタープリタ（シェル）で実行されるかを記述します。  
この「#!」は「シバン」または「シェバング」（shebang）と呼ばれるもので、「#!」が記述された行のことを「シバン（シェバング）行」ということもあります。  
ここに記述されたインタープリタは、次の行からのスクリプトを解釈して実行します。  

``` txt
書式：#!インタープリタ
```

以下はスクリプトをbashシェルで実行する場合の例です。  

``` txt
$ cat hoge.sh
#!/bin/bash
echo "Hello Ping-t Users."
```

シェルスクリプトを実行するには主に以下の方法があります。  

・sourceコマンドを使用  
指定したシェルスクリプトを読み込み、現在のシェルで実行するコマンドです。  
シェルスクリプトに実行権が無い場合でも実行できます。  
ただし、実行するシェルスクリプトに読み取り権と、シェルスクリプトが存在するディレクトリに検索権が必要です。  
（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼びます）  
なお、sourceコマンドは「.(ドット)」で代用できます。  

``` txt
$ source hoge.sh
または
$ . hoge.sh
```

・sh、bashコマンドを使用  
シェルを起動してシェルスクリプトを実行するコマンドです。  
sourceコマンドと同様に、シェルスクリプトに実行権が無い場合でも実行できます。  
ただし、実行するシェルスクリプトに読み取り権と、シェルスクリプトが存在するディレクトリに検索権が必要です。  
（ディレクトリに設定されたパーミッション「x」 は実行権ではなく検索権と呼びます）  

``` txt
$ sh hoge.sh
または
$ bash hoge.sh
```

・コマンドとして実行  
シェルスクリプトに実行権がある場合、シェルスクリプトはコマンドのように実行できます。  
ただし、パスが通っていない場合は、絶対パスまたは相対パスでシェルスクリプトを指定する必要があります。  
またこの場合、シェルスクリプトはサブシェル内で実行されます。  
サブシェルとは現在のシェルから新たに生成されたシェルのことです。  

``` txt
$ /home/test/hoge.sh （絶対パスで指定）
または
$ ./hoge.sh （「/home/test」ディレクトリから相対パスで指定）
または
$ hoge.sh （パスが通っている場合）

$ ./hoge.sh （相対パスで指定した場合）
Hello Ping-t Users.
```

---

## シェルスクリプトの実行方法

1. bashコマンドを使う。  
   `bash testing.sh`  
2. soueceコマンドを使う。  
   `source testing.sh`  
3. スクリプトファイルの前に省略記号「.」を入力して実行する。  
   `. testing.sh`  
4. ファイルに実行権を付与してファイル名を指定して実行する。  
   `chmod a+x test.sh`  
   `./testing.sh`  

4番目に関して  
カレントディレクトリにあるスクリプトを実行するために「./」を付ける必要があるのは、  
そのディレクトリにパスが通っていない(変数PATHにそのディレクトリが含まれていない)場合。  
パスの通っているディレクトリ内にあるスクリプトファイルは「./」を付けなくても実行できる。  
変数PATHに「.」を追加する事はセキュリティ上のリスクをはらむらしい。  

`実行権`がないシェルスクリプトを実行するには、`source`コマンドを使用する。  
但し`source`コマンドを実行するには、シェルスクリプトに`読み取り権`と、シェルスクリプトが存在するディレクトリに`検索権`が必要。  
`source`コマンドは「.(ドット)」で代用できる。  

設定を即座に反映させるには、現在のシェルでスクリプトを実行できるsourceコマンドを使用します。  

---

## コマンド置換

bashにはコマンドの実行結果を文字列として扱う「コマンド置換」機能があります。  
コマンド置換は次の書式で実行します。  

・`実行コマンド`（バッククォート、日本語キーボードではSHIFT+@）  
・$(実行コマンド)  

`$echo $HOSTNAME`  
→`testserver.localdomain`  
`$ echo $(echo $HOSTNAME)`  
→`testserver.localdomain`  

---

## sourceコマンド

sourceコマンドからシェルスクリプトを実行すると、現在のシェルで直接シェルスクリプトを実行します。  
シェルの環境設定をシェルスクリプトで行う場合に使われます。  
sourceコマンドは「.（ドット）」でも代用されます。  

ファイルに書かれたコマンドを現在のシェルで実行する事を指示するコマンド。  
主にシェルの設定を反映させる際に使用する。  

sourceコマンドはシェルに組み込まれたビルトインコマンドで、bashやtcsh,zshに共通して使用できる。  
sourceコマンド（または「.（ドット）」）はスクリプトの実行権限がなくても実行できます。  

``` txt
source ファイル [ファイル実行時の引数]
or
. ファイル [ファイル実行時の引数]

オプションはない。
```

bash ファイル名  
ファイル名  

で実行した場合はbashの子プロセスが立ちあがり、  

---

## execコマンド

子プロセスを生成するのではなく、現行プロセスを引数で指定したコマンドに入れ替えて実行するコマンド。  
bashの組み込みコマンド。  
指定したコマンドを既存のジョブ(シェルとプロセス)と置き換えて実行するコマンドとも言えるらしい。  

---

## シェルスクリプトの特殊変数

シェル変数とも言うらしい。  

``` txt
$0  :: シェルスクリプトファイル名  
$1  :: 1番目の引数。※ 2番目の引数の場合は $2 と指定する。  
$$  :: 現在のシェルのプロセス番号。      $$
$#  :: コマンドラインに与えられた引数の数  
$?  :: シェルが最後に実行したコマンドの終了ステータス(0 = 正常終了、1 = 異常終了、それ以外はエラー)  
$@  :: 全ての引数 ( 区切りはスペース )  
$*  :: 全ての引数 ( 区切りは環境変数IFSで指定したもの )  
```

シェルスクリプトの実行後 `echo $?` と実行して 0 が帰ってくるならスクリプトが正常終了したことが分かる。  
bashのプロンプトで`echo $$`を実行した場合のプロセスIDはシェル自身のプロセスIDが格納される。  

10番目以降の引数を参照する時は\${10}のように「{}」で囲う必要があります。  
「{}」を使用しないとシェルは「\$1 + "0"」のように誤った解釈をします。  
そのため、\$10および\$11はそれぞれ「a0」と「a1」のように表示されます（aは1番目の引数）。  

---

## if文

``` sh
if 条件式
then
    実行文1
else
    実行文2
fi
```

---

## case文

``` sh
case 式 in
    値1)
        実行文1 ;;
    値2)
        実行文2 ;;
    ~~~
esac
```

case式はforeachでないくせに[in]であることに注意。  
実行文の最後は[;]ではなく[;;]であることに注意。  
最後はcaseの反対文字(esac)になるタイプであることに注意。  

---

## for文

``` sh
for 変数名 in 変数に代入する値のリスト
do
    実行文
done
```

---

## while文

``` sh
while 条件文
do
    実行文
done
```

``` sh
while read USERNAME
do
    useradd $USERNAME
    echo $USERNAME | passwd --stdin $USERNAME
done < $1
```

---

## readコマンド

ユーザーからの入力値を受け取り、変数に格納してそれを次の処理で使用したい場合に使用するコマンド。  
キーボードからの入力を受け付けて、それを後の処理でも使いまわすという性質上、シェルスクリプトで使われるコマンド。  

``` txt
read [オプション] 変数名
```

``` sh
echo -n " あなたのお名前は? "
read yourname
echo " こんにちは、$yourname さん "
```

``` sh
read a b c <<END
1 2 3 4 5 6
END
```

格納変数は複数定義可能。  
上記例の場合、a=1,b=2,C=3 4 5 6 となる。  
そういう仕様らしい。  

---

## testコマンド

条件分岐が行われる条件式の真偽を判断して、その結果を返すコマンド。  
条件が満たされた場合は真(0)、満たされない場合は偽(1)を返す。  
エラーの場合、0や1ではない何かが返される模様。  
主にシェルスクリプト内部で使用する。  

``` txt
test 条件式
or
[ 条件式 ]
※「[]」はtestコマンドと同じコマンド。「[」の後ろと「]」の前にはスペースが必要

[ファイルの形式に関する条件式]
-d ディレクトリ名  :: 指定したディレクトリがあれば真
-f ファイル名      :: 指定したファイルが通常ファイルであり、存在すれば真
-s ファイル        :: 指定したファイルのサイズが0より大きいファイルであれば真
-L ファイル        :: 指定したファイルがシンボリックリンクであるファイルであれば真

[ファイルの権限に関する条件式]
-r ファイル :: 指定したファイルが存在して、かつ読み込み可能であれば真
-w ファイル :: 指定したファイルが存在して、かつ書き込み可能であれば真
-x ファイル :: 指定したファイルが存在して、かつ実行可能であれば真

[ファイルの特性に関する条件式]
-e ファイル             :: 指定したファイルが存在すれば真。ファイルでもディレクトリでも真となる。
ファイル1 -nt ファイル2 :: 指定したファイル1が指定したファイル2よりも修正時刻が正しければ真(newer than)
ファイル1 -ot ファイル2 :: 指定したファイル1が指定したファイル2よりも修正時刻が古ければ真(older then)

[文字列に関する条件式]
-n 文字列          :: 文字列の長さが0より大きければ真
-z 文字列          :: 文字列の長さが0であれば真
文字列1 = 文字列2  :: 文字列1と文字列2が等しければ真
文字列1 != 文字列2 :: 文字列1と文字列2が等しくなければ真

[数値に関する条件式]
数値1 -eq 数値2 :: 数値1と数値2が等しければ真
数値1 -ne 数値2 :: 数値1と数値2が等しくなければ真
数値1 -ge 数値2 :: 数値1が数値2よりも大きい、または等しければ真
数値1 -gt 数値2 :: 数値1が数値2よりも大きければ真
数値1 -le 数値2 :: 数値1が数値2よりも小さい、または等しければ真
数値1 -lt 数値2 :: 数値1が数値2よりも小さければ真

[論理結合に関する条件式]
!条件          :: 条件式が偽であれば真
条件1 -a 条件2 :: 条件1と条件2の両方の条件式が真であれば真
条件1 -o 条件2 :: 条件1と条件2のどちらかの条件式が真であれば真
```

---

## seqコマンド

連続した数値を自動的に生成するコマンド。  
主にシェルスクリプトで使用する。  

``` txt
seq 開始する数値 終了する数値
seq 終了する数値(1から開始)
seq 開始する数値 増加する値 終了する数値

※スペースで区切る。「-」などの記号は不要。
※seqコマンドの代わりに「{1..5}」のように範囲を指定してもOK
```

1,2,3,4,5をforで出力する。  
→  
`seq 1 5` or `seq 5` or `seq 1 1 5`  

`seq 1-5` or `seq 1 to 5`は間違いだから注意ね。  

---

## 制御演算子

`&&` :: command1が成功した場合のみcommand2を実行する。  
`||` :: command1が失敗した場合のみcommand2を実行する。  
`;` :: コマンドを続けて実行する。  

制御演算子との間にスペースは無くて良い模様。  

command1を実行し、続けてcommand2を実行させたい。ただし、command1が失敗した場合はcommand2を実行しないこととする。下線部にあてはまる語句は次のうちどれか。  
→  
&&  
