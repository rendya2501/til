# シェル、スクリプト問題

---

## 1 ○

ユーザーのホームディレクトリ直下のファイルで、bashシェル環境のカスタマイズに使用されるものはどれか？1つ。  

→  
D. .bashrcと.bash_profile  

bash.confなるものはなかったはず。  
後、隠しファイルなので「.」は必須。  

---

## 2 ○

bashをログインシェルとする全てのユーザーが共通して使用可能な変数と値を設定する場合に適切なものはどれか？1ツ。  

→  
B. /etc/profile  

小豆本の時もそうだったけど、読んで字のごとくだから、選択肢として出された場合にはすぐに応えられる。  

---

## 3 ○

bashをログインシェルとするユーザーがログインすると、どの順番で設定ファイルを読み取りますか？1つ。  

→  

順番の問題からは逃れられないか。  
だからこそ、あそこまで一生懸命説明してるんだろうけど。  
実質Bしか無くないか？  
最初にetcを読んだ後に、ホームディレクトリの3ファイルを読み取るって話だった気がするが？  

B. /etc/profile -> .bash_profile -> .bash_login -> .profile  

---

## 4 △

~/.bash_profileの説明で正しいものはどれか？2つ。  

→  
よくわからないけど、BとCで。  
当たった。△にしておこう。

→  
~/.bash_profileはbashが読み取って実行するファイルなので読み取り件が必要だが、実行権は必要ない。  
~/.bash_profileはユーザーが自分の閑居うをカスタマイズするためのファイルでもあるので、ユーザーの読み書き権限が設定されている。  

---

## 5

コマンドcmdの実行結果をシェル変数varに格納するコマンドラインはどれか？2つ。  

→  
いやー、わからんな。  
シングルだか、ダブルだかで結果が変わったのは覚えているが。  
シングルは完璧に文字列として扱う。  
ダブルはコマンド部分はコマンドとして実行するって話だっけか？  
バッククオートは忘れた。  

BとDで。  
BとC出した。意外といい線行ってた。  

→  

コマンドの実行結果をシェル変数に代入する方法  
1.コマンドを`$()`で囲んで、その結果をシェル変数に代入する。  
2.コマンドをバッククオート「`」で囲んでその結果をシェル変数に代入する。  

バッククオートで囲めばコマンドは実行される。  
ダブルクォートも基本的には文字列だが、シングルとは別のルールがあった気がする。  

---

## 6 ×

一連の処理を子シェルではなく、現在のシェルの中で実行したい場合、適切なものを1つ選択せよ。  

→  
execがあればそれだが、ない。  
functionとdeclareは明らかに違う。  
`$bash プログラム名`はありそうではあるが、確信が持てない。  

Bにしてみるか。  

Cだった。  
あー。よく問題を読んでみれば、一連の処理って書いてあるな。関数として定義して実行するって意味ならfunctionしかないわな。  

`$bash 処理プログラム名` or 1行目に`#! /bin/bash`と記述したシェルスクリプトをコマンドとして実行した場合でも普通に実行できるらしい。  
しかし、解釈実行するので、子シェルを新たに生成する。  

---

## 7 ○

実行すると"Hello"と表示する関数func1を定義したい。1つ。  

→  
A . `function func1() { echo Hello; }`

---

## 8 ×

現在実行中のシェルのシェル変数VALをサブプロセス(子プロセス)から参照できるようにするコマンドはどれか？1つ  

→  
B. `set $VAL`  

やベーわ。  
あぁ？そういう解釈？シェル変数を環境変数にすることで、サブプロセスから参照できるようになる理論。  
exportコマンドの引数に指定するシェル変数の先頭には`$`は付かない。覚えとけ。  

---

## 9 ○

シェル内のすべてのシェル変数と環境変数及び関数を表示するにはどうしたらいいか。3文字のコマンド  

→  
set?

おー、当たった。  
declareコマンドでも表示できるらしい。  
それは盲点だった。  

---

## 10 ○

aliasの目的として適切なものはどれか？1つ。  

→  
A. 入力するコマンドラインを短くするため  

当たり前体操  

---

## 11 ○

lsのaliasを一時的に解除して実行する方法は次のうちどれか？1つ。  

→  
A. \ls  

後はフルパスを指定する  

---

## 12 ○

bashのプロンプトで次のコマンドを実行すると何が表示されるか？1つ。  
`echo $$`

→  
プロセスIDなのは覚えているのだが、何のプロセスIDなのかあいまいだ。  
シェルスクリプトにおいて使われる特殊な変数で、スクリプトのプロセスIDならば、これを実行したbash自身のプロセスIDということにはならないか？  

当たった。

---

## 13 ○

コマンドが正常終了したときに返す値  

→  
0  

逆なんだよね。1が失敗。0が成功。  

→
POSIX(Portable Operating System Interface)ではコマンド成功の場合は0を返し、失敗の場合は0以外を返すと定められている。  

---

## 14 ○

標準的なシェルスクリプトの1行目にはどのようにかかれているか？1つ。

→  
B. `#!/bin/sh`  

解説を読んでいる時に何回か目に入ったので正解した。  
それだけ。  

→  
シェルスクリプトではファイルの1行目は`#!`で始まり、その後にプログラムを解釈実行するインタープリターのパスを書く。  
これをシバン(shebang)と呼ぶ。  

Bourneシェル :: `#!/bin/sh`  
bash :: `#!/bin/bash`  
perl :: `#!/usr/bin/perl`  
python :: `#!/usr/bin/python`  

---

## 15 ○

シェルスクリプトの1行目には`#!`の次にバイナリコマンドのフルパスが書いてあります。  
このバイナリコマンドはどのような役割をしていますか？1つ。  

→  
A. スクリプトを解釈して実行する。  

すぐに上に答え書いてありますやん。  

起動の仕方いかんによって解釈が違う。
全部やり終わってからまとめたい。  

例1 `$ hello.sh`  
1.bashがインタープリター指定のを読み取りを行う。  
2.インタープリターを起動。新しいbashが起動される。  
3.新しく起動したbashがスクリプトの実行を行う。  

シェルスクリプト1行目のインタープリターの解釈を行う。

例2 `$ bash hello.sh`  
1.インタープリターはbashであることを指定している。
2.bashがbashを起動。  
3.起動されたbashがスクリプトを実行。  

シェルスクリプト1行目のインタープリターの解釈を行わない。

例3 `. hello.sh`  
1.bashがシェル自身の内部でスクリプトを実行。  

シェルスクリプト1行目のインタープリターの解釈を行わない。

---

## 16 ×

一般ユーザーが自分のホームディレクトリ下に作成したシェルスクリプトをコマンドとして実行するために最小限必要なパーミッションはどれ？1つ。  

→  
×D. --x  
○B. r-x  

読み取り県も必要なのか。  

→  
バイナリ形式のコマンドは実行権のみで実行できるが、シェルスクリプトの場合は読み込み権限もないと実行できない。  
なお、シェルスクリプトの場合は`bash sample.sh`のようにしてシェルの引数として指定すれば、実行権がなくても読み込み権さえあれば実行できる。  

---

## 17 ○

次のシェルスクリプト`script-args.bash`を`./script-args.bash a b c`として実行したときに表示される結果はどれか？1つ。  

``` sh : script-args.bash
#!/bin/bash
echo $0 $1 $2
```

→  
A. `./script-args.bash a b`  

$0はファイル名。  
$1から引数。  

---

## 18 ○  

次のシェルスクリプトは、実行ユーザーのホームディレクトリの下に.bashrcがあるかどうかを調べて、存在すれば`~/.bashrc exists!`と表示するプログラムです。  
下線部の制御分を記述せよ。  

``` sh
if [ -f ~/.bashrc ]; then
    echo '~/.bashrc exists!'
_______
```

→  
`fi`では？  
当たったー。ifとcaseは逆に書くというふざけた構文だったのは速攻で覚えた。  

testコマンドは`[];`で置き換え可能。  

test構文 :: `text 条件式`  
「[」構文 :: `[ 条件式 ]`  

---

## 19 ○

testコマンドで2つの値の比較に用いる比較演算子はどれか？2つ。  

→
C. -lt  
D. -eq  

数値に関してはlaravelのあれみたいにless than, grater than構文である。  
文字列は=か!=か。  

---

## 20 ×

次のようなファイル`/dev/sda1`とシェルスクリプトmyprogがあります。  
`./myprog /dev/sda1`を実行するとどのように表示されるか？1つ。  

``` sh : /dev/dsa1
$ls -l /dev/sda1
brw-rw---- 1 root disk 8, 1 6月 13 00:30 2019 /dev/sda1
```

``` sh : myprog
#!/bin/bash
if test -d $1; then
    echo "-d is true";exit
elif test -f $1; then
    echo "-f is true";exit
elif test -e $1; then
    echo "-e is true";exit
fi
```

→  
B. 「-f is true」と表示される。  

-f って指定したファイルが存在したらって意味ではなかったか？
-d がディレクトリ。-rは読み取り権限があるかどうかだった気がする。  
-eってなんだ？  

ダメでした。正解はC. -eだそうで。  

→  
-e :: ファイルが存在すれば真  
-d :: ファイルが存在し、ディレクトリファイルなら真  
-f :: ファイルが存在し、通常ファイルなら真  

/dev/sda1はブロックデバイスファイルなので-eが正解なんだと。  
ブロックデバイスファイルってなんやねん。  

### ブロックデバイスファイル  

前提としてデバイスファイルである事。  
アクセス時に文字単位ではなく、ブロック単位でデータを転送するものを「ブロックデバイス」と呼ぶ。  
ハードディスクドライブやUSB,CR-ROM,メモリ領域などのデバイスファイルはこのように呼ばれるらしい。  

というわけで、通常ファイルではないので、-fは無効。  
-dはディレクトリなので関係ない。-eでそのファイルが存在すればって判定に落ち着くってわけか。  

---

## 21 ○

次のシェルスクリプトの中で、___の部分に必要なものを記述せよ。  

``` sh
#! /bin/sh
for i in 1 2 3 4 5
_______
    echo $1
done
```

→  
`do`では？  

あったたー。  
ここら辺は大丈夫そうだな。  

``` sh : for構文
for シェル変数 in 値のリスト
do
    コマンド
done
```

---

## 22 ○

以下のコマンドによる処理はどのような出力を生成するか？1つ。  

``` sh
n=1
while [ $n -le 5 ]
do
    echo -n $n
    let "n=n+1"
done
```

→  
-nの意味がわからないけど、普通に考えれば5回ループして表示するからAで。  

あたった。  

echo の -n は改行を出力しないオプションらしい。  
letコマンドは与えられた引数を計算式として評価するコマンドらしい。  

---

## 23 ×

次のシェルスクリプトを実行したとき、シェル変数a,b,cにはどのような値が格納されるか？1つ。  

``` sh
read a b c << END
1 2 3 4 5 6
END
```

→  
B.a = 1 ,b = 2, c = 3  
ハズレ。  

A. a=1,b=2,c=3 4 5 6  
が正解だそうです。

ヒアドキュメント  
`コマンド << 終了文字` :: 終了文字が現れるまで標準入力へ送る  

``` bash
echo 'hoge'
echo 'fuga'
echo 'piyo'
```

``` bash
cat << EOS
hoge
fuga
piyo
EOS
```

つまり、readコマンドに1,2,3,4,5,6を連続して送ってる状態というわけか。  
そのうえで、シェル変数の格納の仕様として、最後に全て格納されるらしい。  

---

## 24 ○

`seq 10`を実行するとどうなるか？1つ。  

→  
D. 1ずつ増分して1から10まで表示する。  

これは問題ない。  

---

## 25 ○

bashスクリプトの中でコマンドが正常終了したことを確認したい場合、適切な方法はどれか？1つ。  

→  
C.正常終了値0を確認  

確か$!だっけ？  
$?でした。  

---
