# 12.セキュリティ

- ホストレベルのセキュリティ  
- ユーザーに対するセキュリティ管理  
- OpenSSH  
- GnuPGによる暗号化  
- その必要なコマンド  

``` txt : ホストレベルのセキュリティ
・スーパーサーバー :: サーバープログラムを管理するプログラム。
・xinetd           :: スーパーサーバデーモン。ネットワークからのリクエストを受け付けるデーモン。  
・inetd            :: xinetdの前身。TCP Wrapper必須。
・/etc/xinetd.conf :: xintedの全体的な設定を行うファイル。  
・/etc/xinted.d/   :: xinetdのサービスごとの設定ファイルを格納するディレクトリ。  
・socketユニット   :: systemdの動作するシステムで、スーパーサーバのように特定のサービス宛のネットワーク接続を監視する事ができるユニット。
・TCP Wrapper      :: システムに常駐する、外部からのTCP/IP接続のアクセス制御を行うプログラム。ホストのセキュリティ対策の基本となる。
・tcpd             :: TCP Wrapperのデーモン。
・/etc/hosts.allow :: TCPラッパーでアクセスを許可するホストを記述するファイル。
・/etc/hosts.deny  :: TCPラッパーでアクセスを拒否するホストを記述するファイル。
※「/etc/hosts.allow」と「/etc/hosts.deny」の変更は直ちに反映される。該当サービスへの新たなアクセスから適用される。既存の接続は切断出来ない。
・lsof             :: ファイルシステムやポートなど、システムのリソースを使用しているプロセスの情報を表示できるコマンド。
・nmap             :: ポートスキャンをするコマンド。
・fuser            :: システムの特定のリソースを使用中のプロセスを検索し、強制終了することのできるコマンド。

※/etc/init.d/ :: SysVinitの動作するシステムにおいて各種サービスの起動スクリプトを置くディレクトリ。
```

``` txt : ユーザーに対するセキュリティ管理
・/etc/nologin :: rootユーザ以外のユーザのログインを禁止するファイル。
・/etc/sudoers :: sudoコマンドの設定を行うファイル。
・/etc/shadow  :: シャドウパスワードやパスワードの有効期限に関する情報が記載されるファイル。
・chage        :: パスワードの有効期限の設定に特化したコマンド。詳細な設定や表示が可能。操作は「/etc/shadow」ファイルに反映される。
・passwd       :: ユーザーのパスワードを変更するコマンド。
・usermod      :: 既存のユーザーアカウントを変更するコマンド。
・su           :: 一時的に別のユーザーになるコマンド。
・sudo         :: 別のユーザーの権限でプログラムを実行するためのコマンド。
・visudo       :: /etc/sudoersを編集するコマンド。sudoコマンドの利用設定をするコマンド。
・ulimit       :: ユーザやシェルが利用できるリソースの制限を設定したり表示できるコマンド。
```

``` txt : OpenSSH
・SSH                      :: 暗号や認証の技術を利用して、安全にリモートコンピュータと通信するためのプロトコル。
・sshd                     :: SSHサーバーの機能を提供するデーモン。

SSHサーバー側の設定ファイル。
・/etc/ssh/sshd_config     :: sshの設定ファイル。
・/etc/ssh/ssh_host_rsa_key :: サーバーの秘密鍵ファイル。
・/etc/ssh/ssh_host_rsa_key.pub :: サーバーの公開鍵ファイル。
・~/.ssh/authorized_keys   :: ユーザーの公開鍵を登録しておくファイル。

SSHクライアント側の設定ファイル。
・/etc/ssh/ssh_config      :: sshの設定ファイル。
・/etc/ssh/ssh_known_hosts :: ローカルシステムの全ユーザーが利用するsshサーバーの公開鍵を格納するファイル。
・~/.ssh/id_rsa            :: ssh-keygenコマンドで生成された秘密鍵ファイル。
・~/.ssh/id_rsa.pub        :: ssh-keygenコマンドで生成された公開鍵ファイル。
・~/.ssh/known_hosts       :: サーバの公開鍵を登録しておくファイル。
・~/.ssh/config            :: SSH接続情報を格納するファイル。

・SSH認証                  :: クライアントがSSHでサーバへログインする際に行う一連の認証。(ホスト認証の後、ユーザー認証を行う)
・ホスト認証               :: クライアントがサーバーの正当性を確認するための認証。
・ユーザー認証             :: SSHクライアントで接続してくるユーザが正当なユーザかどうかを確認するための認証。
・共通鍵暗号方式           :: 暗号化と復号に共通の鍵を用いる方式。
・公開鍵暗号方式           :: 暗号化と復号は公開鍵と秘密鍵のペアによって行う方式。
・ssh                      :: SSHを使ってリモートホストにログインするためのコマンド。
・ssh-keygen               :: 公開鍵と秘密鍵の鍵ペアを作成するコマンド。
・scp                      :: SSHの仕組みを使い、ホスト間で安全にファイルをコピーするコマンド。
・ssh-agent                :: メモリ上に秘密鍵を保管しておく認証エージェント。及びそのコマンド。
※バックグラウンドで動作する。ssh-agentによって起動されたシェルでssh-addやsshコマンドを実行する。
※環境変数SSH_AUTH_SOCKとSSH_AGENT_PIDを利用する。
※ssh-agentはSSHサーバーと通信は行わない。ローカルプロセスであるsshとssh-addコマンドと通信する。
・ssh-add                  :: 認証エージェントであるssh-agentに秘密鍵を登録するコマンド。
・ﾎﾟｰﾄﾌｫﾜｰﾃﾞｨﾝｸﾞ           :: あるポートに送られてきたTCPパケットをSSHを使った安全な通信路を経由して、リモートホストの任意のポートに転送すること。
                              SSHクライアント to SSHサーバー  
・ﾘﾊﾞｰｽﾎﾟｰﾄﾌｫﾜｰﾃﾞｨﾝｸﾞ      :: SSHサーバが転送用ポートを用意し、SSHクライアントの指定されたポートに転送すること。
                              SSHサーバー to SSHクライアント
・X11ﾎﾟｰﾄﾌｫﾜｰﾃﾞｨﾝｸﾞ        :: ポートフォワーディングの機能を使って、ネットワークを介したXサーバ・クライアントの通信を暗号化し、接続を簡略化すること。
                              SSHサーバー to SSHクライアント with X11  
```

``` txt : GnuPGによる暗号化
・GnuPG     :: 公開鍵暗号方式を使って、ファイルの暗号化や復号をしたり、電子署名をしたりすることができるオープンソースソフトウェア。
・gpg-agent :: GnuPGにおいて秘密鍵を管理し、パスフレーズによる認証状態を一定期間キャッシュするデーモンプログラム。
・gpg       :: GnuPGを使ってファイルの暗号化や復号を行うコマンド。
・~/.gnupg/ :: GnuPGに関連するファイルの置かれるディレクトリ。
```

``` txt :その必要なコマンド
・/var/log/wtmp :: ユーザのログイン/ログアウト情報が記録されているバイナリファイル。
・/var/run/utmp :: ログイン中のユーザの情報が格納されているバイナリファイル。  
・last          :: 「/var/log/wtmp」ファイルを参照し、最近ログインしたユーザの一覧を表示するコマンド。
・w             :: 現在、システムに誰がログインしていて、何を実行しているのかを表示するコマンド。
・who           :: システムに誰がログインしているかを表示するコマンド。  
```

---

## ホストレベルのセキュリティ

### スーパーサーバー

サーバープログラムを管理するプログラム。  
必要な時だけ個々のサーバープログラムを起動する。  
→メモリなどのシステムリソースを効率的に使うことが出来る。  

即応性が求められるサービスはそのサービス自体で監視すべき(スタンドアロン)  
Webサーバー,メールサーバ,etc...  

FTP,Telnetなど、頻度が高くないものはスーパーサーバー経由での接続に適している。  

代表的なスーパーサーバー  
inted,xinted  

「inetd」や「xinetd」はスーパーサーバと呼ばれ、登録された利用頻度の低いサービスを監視し、リクエストが来た場合にだけ、該当のサービスを実行します。  
これにより利用頻度の低いサービス（例えばTELNETやFTPなど）をシステムにデーモンとして常駐させる必要が無くなり、メモリやCPU等のリソースの消費を抑えられます。  
なお、利用頻度の高いサービス（HTTPなど）は、スーパーサーバを経由せず、システムにデーモンを常駐させておいた方が効率的です。  

### xinetd

ネットワークからのリクエストを受け付けるデーモン。  

「xinetd」は「inetd」より新しいスーパーサーバで、サービス毎に詳細な設定が可能です。  
xinetdの全体的な設定は「/etc/xinetd.conf」ファイルで行い、各サービスの個別設定は「/etc/xinetd.d/」ディレクトリ内の設定ファイルで行います。  

「xinetd」のアクセス制御は、「/etc/xinetd.d/」内の個別ファイルで行う方法（xinetdのみ）と、TCPラッパーを併用する方法があります。  
※xinetdの前身であるスーパーサーバinetdはアクセス制御を行う際、TCPラッパーを利用します。TCPラッパーは「tcpd」というデーモン名で起動しています。  

xinetdが監視しているサービスにアクセスがあると、xinetdはtcpdにその制御を渡します。  

<https://www.express.nec.co.jp/linux/distributions/knowledge/network/xinetd.html>  
xinetd は、単体で inetd + TCP wrapper(tcpd) の機能を持っているだけでなく、よりきめ細かで自由度の高い設定を行なうことができる。  

xinetdによるアクセス制御は以下のルールで判定されます  
・only_fromもno_accessも設定されていない場合、サービスへのアクセスは全て許可  
・only_fromだけが設定されている場合、指定されたアクセス元しかサービスへアクセス出来ない  
・no_accessだけが設定されている場合、指定されたアクセス元はサービスへアクセス出来ない  
・only_fromとno_accessが同時に指定された場合、より厳密にマッチするほうに従う  

例えばonly_fromとno_accessが以下のように設定されている場合、192.168.10.10からはサービスへのアクセスが出来ません。

``` txt
service example1
{
    only_from = 192.168.10.0/24
    no_access = 192.168.10.0/25
}
```

逆に、以下の設定では192.168.10.10からはサービスにアクセスできます。

``` txt
service example2
{
    only_from = 192.168.10.0/25
    no_access = 192.168.10.0/24
}

※inetdからxinetdに変更した場合、伴って編集を検討する必要のあるファイルは[/etc/xinetd.conf]  

```

### /etc/xinetd.confファイル

xintedの全体的な設定を行うファイル  
各サービスの個別設定ファイルを配置するディレクトリは、「/etc/xinetd.conf」の「includedir」で指定します。  

``` txt : xinetdの主な設定項目
bind or interface :: サービスを提供するインターフェースのIPアドレス
disable           :: サービスの有効/無効 (yes:無効化 no:有効化)
instances         :: サーバープログラムの最大起動プロセス数
log_type          :: ログの記録先指定。サービスが出力するログをsyslogや指定したファイルに出力する。出力先ファイルは絶対パスで指定する。
no_acccess        :: サービスへの接続を拒否する接続元
only_from         :: サービスへの接続を許可する接続元
server            :: サーバープログラム(デーモン)へのフルパス
server_args       :: サーバープログラム(デーモン)に渡す引数
socket_type       :: 通信のタイプ(TCP:stream , UDP:dgram)。サービスの接続タイプ。
user              :: サーバープログラムを起動するユーザー
wait              :: サーバープログラムへの接続処理を待ち合わせるかの設定。
                     サーバープログラムがマルチスレッドであり、1プロセスで同時に複数処理できる場合はno。
                     シングルスレッドで処理が完了し、サーバープログラムが終了するまで接続処理を待ち合わせる必要がある場合はyesとする。
log_on_failure    :: 接続を拒否した時にログに記録する内容
nice              :: 実行優先度
access_time       :: アクセスを許可する時間帯

※instances未指定の場合
UNLIMITED（無制限）となり、サーバリソースが枯渇する恐れがありますので、適度な上限値を設定するのが運用上好ましいです。

※log_typeでsyslogに出力する場合
以下のように設定する。プライオリティは省略可能です。省略した場合はINFOレベルとして出力されます。
log_type = SYSLOG ファシリティ [ プライオリティ ]

※disableなどの有効、無効の指定は「yes」「no」で行う。
```

``` txt : /etc/xinetd.confファイルを表示
cat /etc/xinetd.conf
defaults
{
    instances = 60
    log_type  = SYSLOG deamon
}
includedir = /etc/xinetd.d
```

``` txt : どういう経緯で書いたやつだっけか？
/etc/services
23 telnet
ポート番号→サービス名

/etc/xinetd.conf
telnet in.telnetd
サービス名→デーモン名
```

### /etc/xinted.d/ディレクトリ

xinetdのサービスごとの設定ファイルを格納するディレクトリ  
ファイル名はサービス名に当たる。  

設定ファイルの変更を行った場合は「/etc/init.d/xinetd restart」などでxinetdの再起動を行って変更を反映させる必要があります。  

``` txt : /etc/xinetd.d/time-streamの例  
service time
{
    disable = no
    id = time-stream
    type = INTERNAL
    wait = no
    socket_type = stream
    only_from = 172.16.0.1
```

問題)  
xinetdで管理させたい独自サービスの設定ファイルを作成した。以下のA、Bに当てはまる正しい組み合わせはどれか  

``` txt
service myservice
{
    (A) = /usr/local/bin/myservice
    (B) = -debug
    user = root
    socket_type = stream
    wait = yes
}
```

起動するサービスはどれもサーバーとして機能するプログラムばかりなので、サーバーでよい。  

A : server  
B : server_args  

### socketユニット

systemdの動作するシステムでは、特定のサービス宛のネットワーク接続を監視する「socketユニット」がスーパーサーバの代わりに使えます。  
socketユニットの定義ファイルでは待ち受けるIPアドレスとポート番号を指定し、接続があったら対応するserviceユニットを起動してリクエストに応答します。  

以下はSSHサーバ（sshd）でsocketユニットを使用する例です。  

``` txt : CentOS 7のsshd（TCPポート22番）用のユニット定義ファイル
cat /usr/lib/systemd/system/sshd.socket
[Unit]
Description=OpenSSH Server Socket ←このsocketユニットの説明
Documentation=man:sshd(8) man:sshd_config(5)
Conflicts=sshd.service ←競合する関係のサービス

[Socket]
ListenStream=22 ←接続を待ち受けるTCPのポート
Accept=yes      ←着信したコネクション毎にサービスプロセスを起動

[Install]
WantedBy=sokets.target ←自動起動で関連付けられるターゲット
```

1.デフォルトではsshd.serviceが常時起動しているので、socketユニットを使用するためにsshd.serviceを停止します。  
`# systemctl stop sshd.service`  

2.sshd.socketを起動します。  
`# systemctl start sshd.socket`  

3.他のPCからSSHサーバに接続すると、その接続に対するserviceユニットが起動します。  

``` txt
# systemctl list_units | grep sshd ←sshdに関するユニットの一覧を表示する。
sshd@0-192.168.0.100:22-192.168.0.9:54940.service loaded active running   OpenSSH per-connection server daemon(192.168.0.9:54940)
system-sshd.slice                                 loaded active active    systemd-sshd.slice
sshd.socket                                       loaded active listening OpenSSH Server Socket
```

### TCP Wrapper

システムに常駐する、外部からのTCP/IP接続のアクセス制御を行うプログラム。  
スーパーサーバinetdやxinetdはアクセス制御を行う際、TCPラッパーを利用します。  
TCPラッパーは「tcpd」というデーモン名(常駐プログラム名)で起動しています。  
サービス要求を受け取った後、設定に基づいてチェックを行い、接続が許可された場合はそれぞれのサーバープログラムに処理を引き渡す。  

``` txt
デーモン   設定ファイル
inetd   :: /etc/inetd.conf
xinetd  :: /etc/xinetd.conf

アクセス制御
・TCPラッパー
/etc/hosts.allow
/etc/hosts.deny
・xinetdのみ
/etc/xinetd.dの個別設定ファイル
```

xinetdが監視しているサービスにアクセスがあると、xinetdはtcpdにその制御を渡します。  
tcpdは「/etc/hosts.allow」と「/etc/hosts.deny」ファイルを調べ、アクセスを許可するかどうか判断します。  
許可する場合にのみ、対象のサービスを起動して制御を渡します。  

TCPラッパー（tcpd)の制御ファイルは以下の順で評価されます。  
1.「/etc/hosts.allow」に記載されているホストは許可。  
2.「/etc/hosts.allow」に記載されていなければ、「/etc/hosts.deny」を参照し、記載されているホストは拒否。  
3.両方のファイルに記載の無いホストは全て許可。  

両方のファイルに記載が無いホストは全て許可されてしまうため、通常は「/etc/hosts.deny」に「ALL:ALL」と記載（全てのサービスとホストを拒否）しておき、  
許可したいサービスとホストだけ、「/etc/hosts.allow」に記載しておくという運用を行います。  

※先にチェックされるのはhosts.allow  
※hosts.denyで拒否されていない対象ホストは、全て許可される  
※「/etc/hosts.allow」と「/etc/hosts.deny」を変更すると直ちに反映され、該当サービスへの新たなアクセスから適用されます。  

``` txt : 制御ファイルの表示例
書式
サービス名:対象ホスト

#cat /etc/hosts.allow
ALL : 127.0.0.1
sshd : ALL

#cat /etc/hosts.deny
ALL : ALL
```

### lsofコマンド

特定のポートを使用しているプロセスなど、ローカルホストの様々なプロセス情報を表示させることができます。  
プロセスによってオープンされているファイルの一覧を表示するコマンド  
引数にファイル名をした場合、そのファイルをオープンしているプロセスを表示する。  

``` txt
lsof [オプション] [ファイル名]

オプション
-i            :: オープンしているポートとプロセスを表示する。
-i:ポート番号 :: 指定のポートをオープンしているプロセスを表示する。
-i:サービス名 :: 指定のサービスをオープンしているプロセスを表示する。
-p プロセスID :: 指定したプロセスがオープンしているファイルを表示する。
-P            :: ポート番号をサービス名に変換せず、数値のままで表示する。
```

ポート22番(ssh)を使用しているプロセスを表示する。  
`lsof -i:22`  

### nmapコマンド

ポートスキャンをするコマンド  

指定したホストの開いているポートをネットワーク経由で確認（ポートスキャン）する事ができます。  
ホストにログインせずに、外部からアクセス可能なポートを調査します。  

選択肢の「netstat」や「lsof」コマンドでも空いているポートは確認できますが、これらで表示できるのはローカルホストの情報です。  
「nmap」コマンドはリモートホストの情報も確認できます。  
「nmap localhost」とすればローカルホストのポートスキャンも可能です。  

なお、自身の管理下にない外部サーバに対して、むやみにポートスキャンをしてはいけません。  
攻撃準備とみなされる可能性があります。  

``` txt
nmap 対象ホスト
```

使用例  
`nmap www.emxample.com`  

### fuserコマンド

システムの特定のリソースを使用中のプロセスを検索し、強制終了することのできるコマンド  

``` txt
fuser [オプション] 検索対象

-k :: プロセスにSIGKILLを送信(kill)。送りたいシグナルを指定するには-kではなく「-シグナル名」とする。
-m :: マウントされたファイルシステムを指定(mount)
-n :: 検索する領域(名前空間)を指定(namespace)
      ・file(ファイル名:デフォルト)
      ・udp(UDPポート番号)
      ・tcp(TCPポート番号)
      が指定できる。
-u :: 検索結果にユーザー名を追加(user)
-v :: 詳細な情報を表示(verbose)
```

tcpポート8080番を使用しているプロセスを検索する。  
`fuser -n tcp 8080`  

リソースを使用中のプロセスの実行ユーザーを特定したい  
`fuser -v` or `fuser -u`  
→  
-vは詳細情報にユーザー名が表示される。  
-uはそれ自体がユーザー名を表示するオプション。  

/mntにアクセスしているプロセスを検索  
`fuser -muv /mnt`  

/mntにアクセスしているプロセスを強制終了  
`fuser -m /mnt -k`  

不正プログラムによって、外部からTCPの65432ポートに接続可能になっている。不正プログラムのプロセスIDの確認とプロセスの強制終了を同時に行いたい。  
`fuser -k -n tcp 65432`  
→  
`fuser -k tcp 65432`  
-nオプションを指定しないと、指定した検索対象をファイルとみなすため、誤りです。

不正プログラムによって、キー操作が/tmp/.keylogに書き込まれていることがわかった。  
書き込みをしているプログラムのプロセスID、実行ユーザー情報の確認とプロセスの強制終了を同時に行いたい。  
`fuser -uk /tmp/.keylog`  

### SUID/SGIDの確認

SUIDやSGIDが設定されていると、一般ユーザーでもroot権限でファイルを実行できる場合があります。  
root権限を不正に操作されるとセキュリティ上問題があります。  
そこで、システムの管理者は、ファイルを検索する「find」コマンドに「-perm」オプションを付けて、SUID/SGIDが設定されたファイルを検索し、普段から把握するように努めます。  

``` txt : findコマンドの書式
find [検索場所] -perm -[モード]
[モード]で指定されている許可属性ビットのすべてが、ファイルでも立っていたら真

find [検索場所] -perm +[モード]
[モード]で指定されている許可属性ビットのどれか一つが、ファイルでも立っていたら真


・SUIDが設定されたモードを数字表現で表すと「4000」、記号表現は「u+s」
・SGIDが設定されたモードを数字表現で表すと「2000」、記号表現は「g+s」
・「-uid」で所有権を持つユーザIDを、「-gid」で所有権を持つグループIDを指定して検索できます。
・rootユーザはユーザID、グループIDともに「0」です。

・rootのファイルを探す :: [-uid 0] or [-user root]
・SUID(Set UID)ビットが立っているかどうか :: [-perm /4000] or [-perm -4000]
-permの後に[/]で始まる値を指定した場合、[/]以降のいずれかのビットが立っているファイルを探す。
-permの後に[-]で始まる値を指定した場合、[-]以降の全てのビットが立っているファイルを探す。
[-perm 4000]の場合、指定したパーミッション4000とすべてのビットが同じファイルを探す。
(例えば、パーミッション4755のファイルは検索対象にならない)


■SUIDとSGIDの両方が設定されたファイルの検索
find / -perm -6000

SUID「4000」の4をビットに直すと100、SGID「2000」の2をビットにすると010。
これらのビットが立っているファイルが検索対象ですので、110、つまり先頭の数字が6の「6000」が正解となります。
SUID、SGIDの「両方が設定された」ですので、モードの前は「-」を指定します。


■ルートグループの所有権を持ち、かつSGIDが設定されたファイルやディレクトリの検索
find / -perm -2000 -gid 0
find / -perm -g+s -gid 0


■シンボリックリンクを検索
findコマンドの検索式に「-type l」を指定する事でシンボリックリンクを検索できる。

findコマンドの検索式に「-type ファイルの種類」を指定するとファイルの種類で検索できます。

同じ「ファイルの実体」に対して複数の名前でアクセスできるシンボリックリンクは便利な機能ですが、
一般ユーザがアクセス権限の無いファイルや存在しないファイルへのリンクを作成できるので、悪用されないようセキュリティ上注意が必要です。
```

SUIDが設定されているファイルを検索するコマンド  
`find / -perm -u+s -ls`  

セキュリティ上、ルートユーザの所有権を持ち、かつSUIDが設定されたファイルを検索。  
`find / -perm -u+s -uid 0`  
`find / -perm -4000 -uid 0`  

---

## ユーザーに対するセキュリティ管理

### chageコマンド

「chage」はパスワードの有効期限の設定に特化したコマンド（CHange password AGEの略）で、詳細な設定やその表示が可能です。  
なお、パスワードの有効期限に関する情報は「/etc/shadow」ファイルに保存されます。  

ユーザーのパスワードの有効期限を表示・変更するコマンド。  
引数を設定しないで実行した場合、対話モードになる。  
9.管理タスクのパスワードに置ける問題でも頻出。  

cha'n'geではなく、chageであることに注意。  
CHange password AGEの略 らしい。  

``` txt
chage [オプション] [ユーザー名]

-l :: アカウントとパスワードの失効日の情報を表示。(ls)
      一般ユーザーでも使用可能。
-d :: パスワードの最終更新日を設定。YYYY-MM-DDの形式もしくは1970年1月1日からの日数で指定する。
-m :: パスワード変更間隔の最短日数を設定。(minimum)
      (パスワードを変更できるようになる日数)
-M :: パスワードを変更なしで使用できる最長日数を設定。(Max)
      (何日毎に必ずパスワードを変更させるか)
-W :: パスワードの変更期限の何日前から警告を出すかを指定。(Warning)
      (有効期限の何日前から警告を行うか)
-I :: パスワードの変更期限を過ぎてからアカウントが使用できなくなるまでの失効日数。(Inactive)
      パスワードの有効期限切れ後にアカウントがロックされるまでの日数を指定。
      有効期限が切れてからパスワードが実際にロックされるまでの猶予期間を指定できます。
      「0」を指定すれば、期限切れと同時にパスワードがロックされます。
-E :: アカウントの失効日を設定。(YYYY-MM-DD形式)(Expire:期限切れ)

※-lオプション以外はrootユーザしか実行できません。
```

ユーザーryoのパスワードの有効期限を60日に設定する。  
`chage -M 60 ryo`  

期限を過ぎてから無効になるまでにパスワードを変更できる期間を30日に設定する。  
`chage -I 30 ryo`  

ユーザ「user1」のパスワードをいつでも変更できるようにしたい。  
`chage -m 0 user1`  
→  
-mはパスワードを変更できるようになる日数の設定なので、0にする事で即変更できるようになる。  

短期のアルバイト社員「user1」のユーザーアカウントを、2010年4月20日までの期限付きにしたい  
`chage -E 2010-04-20 user1`  

アカウント「user1」のパスワードを設定してから、最長でも90日ごとには強制的にパスワードを変更させたい  
`chage -M 90 user1`  

### パスワードの有効期限に関する設定が可能なコマンド

・chage  
・passwd  
・usermod  

中でも「chage」はパスワードの有効期限の設定に特化したコマンド（CHange password AGEの略）で、詳細な設定やその表示が可能です。  
なお、パスワードの有効期限に関する情報は「/etc/shadow」ファイルに保存されます。  

passwdはユーザーのパスワードを変更するのがメインのコマンド。  
パスワードのロックや最長日数、失効までの猶予期間の設定はできるが、問題文にある有効期限の確認や設定は出来ない。  

chageはパスワードの変更は出来ないが、有効期限の確認や設定等の細かな設定ができるコマンド。  
問題文中に有効期限というフレーズがあれば間違いなくこちら。  

「passwd」コマンドでパスワードの最長有効日数を10日にする場合は「passwd -x 10 user1」とします。  
「usermod」コマンドにはこれを実現するオプションは存在しませんが、  
アカウントの有効期限やパスワードの使用期限が切れてからアカウントを永久に使用不能になるまでの日数を設定できますので、正解の1つとなります。  

### /etc/nologinファイル

「/etc/nologin」ファイルが存在すると、rootユーザのみログインが許可されます。  
rootユーザ以外の、一般ユーザによるログインを禁止するときに作成します。  
一般ユーザアカウントは必要だけれど、ログインはさせたくない場合などに使用します。  

「touch」は空ファイルを作成するコマンドです（書式：touch [ファイル名]）。  

ユーザーのログインを禁止するファイル  
これが存在するだけでルートユーザー以外のログインは出来なくなる。  
中身は空でもよい。
記述した場合は、その内容が一般ユーザーがログインしようとしたときに表示される。  

### suコマンド

su（Switch User）コマンドを使うと、ログイン中に別のユーザーに切り替わる事ができます。  

suコマンドには以下の特徴があります。  
・引数に「-」をつけると、切り替わる先のユーザの環境変数を使用する  
・ユーザー名を指定しない場合、rootユーザへ切り替わる  
・ユーザを切り替える時に求められるパスワードは、切り替わる先のユーザのパスワード  
・但し、rootユーザから別のユーザに切り替わる時はパスワードは要求されない  

一時的に別のユーザーになるコマンド  
別の実行ユーザーIDと実行グループIDを持つ新たなシェルを起動するコマンド  

``` txt
su [オプション] [-] ユーザー名

-あり :: 直接ログインしたときと同様の動作を行う。
カレントディレクトリは新しいユーザーのホームディレクトリとなる。
環境変数が全て初期化される。

-なし :: 現在の環境をそのままにしてユーザーだけを切り替える。  
```

### sudoコマンド

[superuser do] or [substitute user do]  
substitute : 代わりの  

別のユーザーの権限でプログラムを実行するためのコマンド。  
大抵はrootユーザーとして実行する場合に使われる。  
実質、一般ユーザが管理者権限でコマンドを実行する為のコマンド  
一般ユーザでも、管理者から実行権限を委譲されたコマンドであれば実行できます。  

・自身に委譲されているコマンドは「sudo -l」で確認できます。  
・sudoコマンドを実行するとパスワードの入力を求められますが、rootのパスワードではなく、ユーザー自身のパスワードを入力します。  
・権限委譲の設定は「visudo」コマンドで「/etc/sudoers」ファイルを編集することで行います。  

``` txt
sudo [オプション] [-u ユーザー名] コマンド

オプション
-l :: 自身に許可されているコマンドを表示する
-i :: 変更先ユーザーでシェルを起動する(ログイン時の処理を行う)
-s :: 変更先ユーザーでシェルを起動する

-u ユーザー :: rootではなく指定したユーザーでコマンドを実行する
ユーザー名を省略するとrootユーザーで実行する。
```

### visudoコマンド

sudoコマンドの利用設定をするコマンド。  
「/etc/sudoers」ファイルを編集する。  
rootユーザーのみ実行可能。  

### /etc/sudoersファイル

sudoコマンドを実行できるユーザーの設定を行うファイル。  
sudoコマンド実行時、sudoコマンドはこのファイルを参照してユーザーが実行権限を持っているかどうか判定を行う。  
visudoコマンドで編集する。  
エディターで直接、このファイルを開いてはいけないらしい。  

``` txt
書式
権限を委譲するユーザ名 ホスト名=(実行ユーザー名) [NOPASSWD:]委譲するコマンド

ユーザー名     :: コマンドの実行を許可するユーザー名かグループ名、もしくはALL
ホスト名       :: 実行を許可するホスト名か、IPアドレス、もしくはALL
実行ユーザー名 :: コマンド実行時のユーザー名(省略時はroot)、もしくはALL
コマンド       :: 実行を許可するコマンドのパス、もしくはALL
NOPASSWD:      :: 指定すると、コマンド実行時にパスワードを問われない

移譲するコマンドを複数していする場合は「,(カンマ)」で区切る。
```

studentユーザーのみshutdownコマンドが実行できるように設定する  
`student ALL=(ALL) /sbin/shutdown`  

studentユーザーに対し、全てのroot権限が必要なコマンドの実行を許可する。  
`student ALL=(ALL) ALL`  

wheelグループに対し、全てのroot権限が必要なコマンドをパスワードなしで実行できるようにする。  
`%wheel ALL=(ALL) NOPASSWD:ALL`

### ulimitコマンド

ユーザやシェルが利用できるリソースの制限を設定したり表示するコマンド  
アプリケーションのエラー発生時に生成されるcoreファイルの最大サイズやシェルが使用できる最大メモリ量など、使用するリソースを制限できる。  

``` txt
ulimit [オプション] [制限値]

-a         :: 現在の全ての設定を表示(all)
-c サイズ  :: コアダンプで生成されるcoreファイルの最大サイズ(単位はブロック)を制限(core)
-f サイズ  :: シェルが生成できるファイルの最大サイズをブロック単位で指定する(file)
-n 数      :: オープンできるファイル(ファイル記述子)の最大個数を制限
-u ﾌﾟﾛｾｽ数 :: 1人のユーザーが利用できる最大プロセス数を指定する(user process)
-v サイズ  :: シェルが利用できる仮想メモリの最大サイズ(単位はキロバイト)を制限(virtual memory)

※コアファイル
プログラムが異常終了した時にプログラムが使用していたメモリ情報をファイルに書きだしたものです。
主にデバッグのために使用しますが、一般ユーザーが通常使用するものではなく、
またプログラムによっては多くのメモリを使用するためコアファイルが巨大になることがあります。
そのため、ファイルシステムの容量を食いつぶさないようにコアファイルのサイズを制限することが一般的です。
```

---

## OpenSSH

オープンソースのSSH実装のソフトウェア。  
SSHプロトコルを利用するためのソフトウェア。  
SSHサーバーおよびSSHクライアントを含む。  
SSHを利用するために、現在世界で最も使われているSSH実装。  

[インフラエンジニアじゃなくても押さえておきたいSSHの基礎知識](https://qiita.com/tag1216/items/5d06bad7468f731f590e)  

### SSH(Secure Shell)

暗号や認証の技術を利用して、安全にリモートコンピュータと通信するためのプロトコル。  
公開鍵認証や通信の暗号化といった点でTELNET(ポート23)よりセキュリティが強固です。  
※外部サーバを管理する場合、通信の内容が平文である（暗号化されていない）TELNET(ポート23)はできる限り使うべきではない。  

``` txt
ポート番号 :: 22
SSHサーバーの機能を提供するデーモン :: sshd

SSHに関する主なファイル
             | SSHクライアント     | SSHサーバー(sshd)
設定ファイル | /etc/ssh/ssh_config | /etc/ssh/sshd_config
秘密鍵       | ~/.ssh/id_rsa       | /etc/ssh/ssh_host_rsa_key
公開鍵       | ~/.ssh/id_rsa.pub   | /etc/ssh/ssh_host_rsa_key.pub
認証鍵リスト | ~/.ssh/known_hosts  | ~/.ssh/authorized_keys

①ホスト認証時に登録
サーバー公開鍵 : /etc/ssh/ssh_host_rsa_key.pub → クライアント認証鍵リスト : ~/.ssh/known_hosts
②ユーザー認証時に登録
クライアント公開鍵 : ~/.ssh/id_rsa.pub → サーバー認証鍵リスト : ~/.ssh/authorized_keys

※ユーザー側のファイル名「id_<鍵の種類>」「id_<鍵の種類>.pub」
※サーバー側のファイル名「ssh_host_<鍵の種類>_key」「ssh_host_<鍵の種類>_key.pub」

※クライアント側の設定ファイル「/etc/ssh/ssh_config」に設定した内容はシステム全体（全ユーザ）に適用されます。
※ユーザが個別に設定したい場合は「~/.ssh/config」を使用します。
```

### /etc/ssh/sshd_config  

sshdの設定ファイル  
[OpenSSH (sshd) のデフォルト値](https://qiita.com/bezeklik/items/b728ea2de4924f89a787)  
めっちゃたくさんある。  

``` txt : sshdの主なディレクティブ  
Port                   :: 待機ポート番号
Protocol               :: プロトコルバージョン
PermitRootLogin        :: rootログインを許可するかどうか(デフォルトはyes:許可。no:不許可が推奨)
                          セキュリティ上の理由から、rootユーザでのSSHログインは禁止する事が一般的に推奨されます。
PubkeyAuthentication   :: 公開鍵認証(プロトコルバージョン2)
AuthorizedKeysFile     :: ユーザー認証の公開鍵格納ファイル名
PasswordAuthentication :: パスワード認証
X11Forwarding          :: X11ポートフォワーディングを許可するかどうか

例)
Port 22
Protocol 2
PermitRootLogin yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PasswordAuthentication yes
```

### /etc/ssh/ssh_known_hostsファイル

ローカルシステムの全ユーザーが利用するsshサーバーの公開鍵を格納するファイル。  
そのsshサーバーはローカルシステムの全ユーザーにとって正当と認めるサーバーになる。  

### sshコマンド

SSHを使ってリモートホストにログインするためのコマンド  

``` txt
ssh [オプション] [[ログインユーザー@]ホスト名]

-p ポート番号 :: ポート番号を指定する。「-o Port = ポート番号」 or 「-o "Port ポート番号"」 でも指定可能。
-l ユーザー名 :: 接続するユーザーを指定する。(本オプションと[ユーザー名@]のどちらも省略された場合は現在のユーザー名を使用)
-i ファイル名 :: 秘密鍵ファイルを指定する。「-o IdentityFile=秘密鍵ファイル」でも指定可能。
-o            :: ssh_configで設定できるオプションの指定。「-o ディレクティブ=値」の方式で指定する。
-f            :: コマンドを実行する際にsshをバックグラウンドにする(Xアプリケーションを実行する際に使用)
-N            :: リモートコマンドを無効にする。転送のみを指示する。
-2            :: SSHのバージョン2を使用する。
-L            :: 指定されたローカル (クライアント) ホスト上のポートが、指定されたリモート側のホストおよびポートに転送されることを指定します。
                 -Lは「Local port forwarding」のためのオプションです。詳しくはポートフォワーディングを参照。
-X            :: DISPLAY環境変数が自動で設定される。詳しくはX11ポートフォワーディングを参照。
```

sv1.lpic.jpにSSHで接続する。  
`ssh sv1.lpic.jp`  

studentユーザーとしてsv1.lpic.jpにSSHで接続する。  
`ssh student@sv1.lpic.jp`  

ポート番号22番、アイデンティティファイル~/.ssh/id_dsa、プロトコルバージョン2、ログインユーザーyukoでsshサーバーにログインする。  
`ssh -p 22 -i ~/.ssh/id_dsa -2 -l yuko examserver`  

接続時にユーザー名を指定する方法  
・「ユーザ名@ホスト名」の形式で接続先ホストを指定する  
・「-l ユーザ名」オプションを指定する  
・「-o User=ユーザ名」オプションを指定する  
→  
sshでの接続ユーザを指定するには、ホスト名の前にユーザ名を@でつなげる、「-l ユーザ名」オプションで指定する、  
ssh_configで接続先ホストのエントリで「User ユーザ名」を設定する方法があります。  
ssh_configの設定値はsshコマンドに直接「-o オプション名」を指定しても有効になります。  

sshコマンドのオプションで、公開鍵方式のユーザ認証に使用する秘密鍵のファイルを指定する方法  
・「-i 秘密鍵ファイル」オプションを指定する。  
・「-o IdentityFile=秘密鍵ファイル」オプションを指定する。  
→  
sshコマンドで接続時に秘密鍵ファイルを指定しないと「~/.ssh」配下の秘密鍵がユーザ認証で使用されます。  
「~/.ssh」以外の場所にある秘密鍵を認証で使用したい場合は、「-i 秘密鍵ファイル」で指定するか、  
ssh_configで接続先ホストのエントリで「IdentityFile 秘密鍵ファイル」を設定します。  
ssh_configの設定値はsshコマンドに直接「-o オプション名」を指定しても有効になります。  

### SSH認証

クライアントがSSHでサーバへログインする際、ホスト認証（接続先のSSHサーバが正しいホストかどうかを確認する）とユーザ認証（SSHクライアントで接続してくるユーザが正当なユーザかどうかを確認する）が行われます。  

ホスト認証の後、ユーザー認証を行う。  
接続先がなりすましだった場合、警告が出る。  
ユーザーが接続先の正当性を確認するための認証がホスト認証というわけ。  

### ホスト認証（認証方式：公開鍵方式）

ホスト認証は、SSHクライアントが接続先のリモートホスト（SSHサーバ）が正しいホストかどうかを確認する（なりすましを防ぐ）ために行います。  
クライアントからの接続時に、リモートホストは自身の公開鍵をSSHクライアントに送信します。  
SSHクライアントは受け取った公開鍵と、SSHクライアントの「~/.ssh/known_hosts」ファイルに格納されているSSHサーバの公開鍵を比べることで正しいホストかどうかを確認します。  

初めて接続する際はSSHクライアントの「~/.ssh/known_hosts」ファイルにSSHサーバの公開鍵が格納されていないため、サーバの公開鍵を登録するかどうか問われます。  
「yes」と入力すると「~/.ssh/known_hosts」に登録されます。2回目以降は問われません。  

※クライアントがサーバーの正当性を確認するための認証。  
※サーバの公開鍵をクライアントの「~/.ssh/known_hosts」に登録しておく。  
※クライアントは登録した公開鍵とサーバの公開鍵が一致したらログインする。  
※接続したサーバの公開鍵が異なる場合、メッセージが表示されてログインできない。  

``` txt
ホスト認証流れ  
①クライアントからサーバにSSH接続する  
②サーバは自身の公開鍵をSSHクライアントに送信する  
③クライアントは、受け取った公開鍵とSSHクライアントの「~/.ssh/known_hosts」ファイルに格納されているSSHサーバの公開鍵が一致したらログインする。  
  一致しなければログインしない。  

SSHクライアント                    SSHサーバー
①SSH接続 →→→→→→→→→→→→
                                ← ②サーバーの公開鍵(認証鍵)を送付
③登録されている公開鍵と
サーバーの公開鍵は一致するか？
↓OK
正しいホストと判定し、ログインする。
ユーザー認証へ
```

### ユーザ認証（ID/パスワード方式、もしくは公開鍵方式）  

ユーザ認証は、SSHクライアントで接続してくるユーザが正当なユーザかどうかを確認するために行います。  
ユーザ認証には、ローカルでのログインと同様のID/パスワード方式と公開鍵方式の2種類があります。  
公開鍵方式を使用する場合は一対の公開鍵と秘密鍵を作成する必要があります。  
作成したユーザ公開鍵をサーバに登録しておき、サーバがSSH接続を受け付けた際、サーバは登録されている公開鍵とユーザの秘密鍵のペアが一致するかどうかを確認します。  
一致しなければログインさせません。これによりID/パスワード方式よりもセキュリティ上強固なユーザ認証を実現します。  

ユーザ認証で公開鍵方式を使う場合、「ssh-keygen」コマンドで公開鍵/秘密鍵のペアを作成し、  
そのうち公開鍵「~/.ssh/id_rsa.pub」（デフォルト）をサーバの認証鍵リスト「~/.ssh/authorized_keys」に登録しておきます。  

※サーバーが接続してくるクライアントに対して行う認証。  
※ユーザの公開鍵をサーバの「~/.ssh/authorized_keys」に登録しておく  
※サーバは登録した公開鍵とユーザの秘密鍵のペアが一致したらログインさせる  

事前の準備  
①公開鍵と秘密鍵のペアを作成  
SSH接続するユーザごとに「ssh-keygen」コマンドを使用して公開鍵と秘密鍵のペアを作成する。  
鍵の作成時には任意のパスフレーズを入力する。  
※秘密鍵が流出した場合でも、パスフレーズを入力しないとその秘密鍵を使用することはできません。  
②ユーザの公開鍵をサーバの「~/.ssh/authorized_keys」ファイルに登録しておく  

``` txt
ユーザー認証の流れ  
①ユーザーの公開鍵を利用できるか問い合わせる。  
②サーバーが利用できると返す。  
③ユーザーの秘密鍵で署名を作る。  
④データと署名をサーバーに送る。  
⑤ユーザーの公開鍵で署名を検証。  
⑥署名が合っていればログインを許可。  

SSHクライアント                                     SSHサーバー
①ユーザーの公開鍵を利用できるか問い合わせる。  →  
                                                ←  ②サーバーが利用できると返す。
③ユーザーの秘密鍵で署名を作る。
④データと署名をサーバーに送る。→→→→→→→→→
                                                    ⑤ユーザーの公開鍵で署名を検証。
                                                    ⑥署名が合っていればログインを許可。
```

### 共通鍵暗号方式(共通鍵認証)

暗号化と復号に共通の鍵を用います。  
処理が早く簡単ですが、複数の相手に同じ共通鍵を使用すると他の人のデータも復号できてしまうので、データを送信する相手ごとに鍵を作成した方がよいでしょう。  

``` txt
受信者                             送信者A,B,C
①共通鍵のペアの作成 * 送信者分
②共通鍵を渡す                  →
                                ← ③受け取った共通鍵で暗号化し送信
④共通鍵で復号
```

### 公開鍵暗号方式(公開鍵認証)

共通鍵暗号方式では送信者と受信者で共通の鍵を使用するため、安全な鍵の受け渡しが重要でした。  
これに対して公開鍵暗号方式は、自分だけの鍵（秘密鍵）と、誰でも参照可能な鍵（公開鍵）を使用することで共通鍵暗号方式の問題点を回避しています。  
公開鍵暗号方式では、公開鍵を使って暗号化したものをペアとなる秘密鍵で復号します。  
送信者は暗号化ファイルを送りたい相手の公開鍵でファイルを暗号化して相手に送ります。  
暗号化ファイルを受け取った受信者は、自身の秘密鍵で復号を行います。  
正しい鍵ペアの場合のみ復号できますので、送信者も受信者も安全にデータの受け渡しができます。  
また、送信者が自身の「秘密鍵」を使ってデータに「署名」を行うこともできます。  
署名されたデータを受信した相手は送信者の公開鍵を使って署名の「検証」を行い、正当な相手からの改ざんされていないデータであることを確認できます。  

``` txt
受信者                                送信者A,B,C
①暗号化用の「公開鍵」、
  復号用の「秘密鍵」のペアを生成。
②公開鍵を渡す                     →
                                   ← ③受け取った公開鍵で暗号化し送信
④秘密鍵で復号
```

- 公開鍵暗号方式は非対称暗号方式とも呼ばれる。  
- 暗号化と復号の鍵が異なる方式。  
- 秘密鍵を乱数で生成し、秘密鍵から大きな2つの素数の積や離散対数により公開鍵を生成する。  
- 秘密鍵と公開鍵は1対1対応。  
- 秘密鍵から公開鍵が計算されるが、その逆の演算は実質不可能(宇宙が出来上がるまでの時間を掛ければ出来なくはないが、計算時間に対して割に合わな過ぎる)  
- データ送信側は受信側から事前に取得してある公開鍵でデータを暗号化して受信側に送り、受信側は自分の秘密鍵でデータを復号する。  
- 公開鍵認証では、被認証側が自分の秘密鍵で認証データを作成して認証側に送り、認証側では被認証側の公開鍵で認証データを検証する。  

### ssh-keygenコマンド

公開鍵と秘密鍵の鍵ペアを作成するコマンド  

鍵を作成する際、パスフレーズの入力が求められますが、これを忘れてしまった場合、**パスフレーズを表示、削除するコマンドやオプションは存在しません**。  
再度「ssh-keygen」コマンドでキーを作成し、その際にパスフレーズを入力し直します。  
その場合は、新たに作成された秘密鍵とペアの公開鍵をサーバに登録する作業もやり直す必要があります。  

※パスフレーズ  
秘密鍵を利用する際の認証用文字列。  
秘密鍵を暗号化してファイルに格納するために秘密鍵の作成時に設定する文字列。  
秘密鍵をファイルから取り出すときに同じパスフレーズを入力して復号する。  

``` txt
ssh-keygen [オプション]

-t キータイプ :: 
-p            :: 
-f ファイル名 ::
-R ホスト名   :: 
-b ビット長   ::

-tオプションで生成できる暗号方式と鍵のデフォルトのファイル名
                   SSHｸﾗｲｱﾝﾄ        SSHサーバー
                   ~/.ssh/配下      /etc/ssh/配下
rsa     | 秘密鍵 | id_rsa         | ssh_host_rsa_key
        | 公開鍵 | id_rsa.pub     | ssh_host_rsa_key.pub
dsa     | 秘密鍵 | id_dsa         | ssh_host_dsa_key
        | 公開鍵 | id_dsa.pub     | ssh_host_dsa_key.pub
ecdsa   | 秘密鍵 | id_ecdsa       | ssh_host_ecdsa_key
        | 公開鍵 | id_ecdsa.pub   | ssh_host_ecdsa_key.pub
ed25519 | 秘密鍵 | id_ed25519     | ssh_host_ed25519_key
        | 公開鍵 | id_ed25519.pub | ssh_host_ed25519_key.pub

※rsaがデフォルト
```

DSAで鍵ペアを作成
`ssh-keygen -t dsa`

### ~/.ssh/内のファイル

``` txt
・~/.ssh/authorized_keys :: 接続を許可する公開鍵を登録しておくサーバー側のファイル。
・~/.ssh/config          :: SSH接続情報を格納したファイル。
・~/.ssh/id_rsa          :: ssh-keygenコマンドで生成された秘密鍵ファイル。
・~/.ssh/id_rsa.pub      :: ssh-keygenコマンドで生成された公開鍵ファイル。
・~/.ssh/known_hosts     :: 過去に接続したことがあるサーバーの情報。クライアント側のファイル。
```

### ~/.ssh/authorized_keys  

接続を許可する公開鍵を登録しておくサーバー側のファイル。  
①接続先リモートホストのホームディレクトリ内に「.ssh」ディレクトリを作成。  
②その中にauthorized_keysファイルを作成して、そこに公開鍵をコピーして登録する。  

### ~/.ssh/config

SSH接続情報を格納したファイル。  
sshコマンドを使うとき、ここに記述した設定が反映されるので、毎回面倒な接続情報書かなくて済むようになったりする。  
接続時に使うので、クライアント側に配置するファイルだと思われる。  

<https://blog-and-destroy.com/20409>  
<https://qiita.com/0084ken/items/2e4e9ae44ec5e01328f1>  
SSH系の記事が豊富過ぎてまとめるのが大変だ。  

``` txt : 主な設定項目
Host         :: sshコマンド等で指定するホスト名。
HostName     :: 実際の接続ホストのアドレス。IPアドレスや/etc/hostsに指定したホスト名等を指定する。  
                これがあるとホスト名を省略できる。  
User         :: ユーザー名。これがあるとユーザー名を省略できる。  
Port         :: ポート番号。これがあると 「-p ポート番号」 って書かなくてよくなる。  
IdentityFile :: 秘密鍵ファイル。これがあると 「ssh -i 秘密鍵ファイルのパス」 って書かなくてよくなる。  

例)
Host 接続コマンド名（任意の名前）
    HostName ホスト名
    User ユーザー名
    IdentityFile ~/.ssh/秘密鍵のファイル名
    Port ポート番号

ssh 接続コマンド名
を利用した接続が可能になる。  
```

### ~/.ssh/id_rsa

ssh-keygenで生成した秘密鍵。  

### ~/.ssh/id_rsa.pub

ssh-keygenで生成した公開鍵。  

### ~/.ssh/known_hosts

過去に接続したことがあるサーバーの情報。  
クライアント側に保存される。  
内容は**ホスト名、IPアドレス、公開鍵**  

### scpコマンド

SSHの仕組みを使い、ホスト間で安全にファイルをコピーするコマンド  

``` txt
ローカルホストにあるファイルをリモートホストにコピーする場合の書式
scp コピー元ファイル名 [ユーザー名@]コピー先ホスト:[コピー先ファイル名]

リモートホストにあるファイルをローカルホストにコピーする場合
scp [ユーザー名@]コピー元ホスト:コピー元ファイル コピー先ファイル名

オプション
-p            :: パーミッションなどを保持したままコピーする
-r            :: ディレクトリ内を再帰的にコピーする
-P ポート番号 :: ポート番号を指定する
```

ローカルホストの/etc/hostsをリモートホストsv3.example.jpの/tmp以下にコピーする。  
`scp /etc/hosts sv3.example.jp:/tmp`  

リモートホストsv3.example.jpの/etc/hostsをカレントディレクトリにコピーする。  
`scp sv3.example.jp:/etc/hosts .`

リモートホストsv3.example.jpのfredユーザーのホームディレクトリに、ローカルホストのdata.txtファイルをコピーする。  
`scp data.txt fred@sv3.example.jp:`  

### ssh-agent

「ssh-agent」はメモリ上に秘密鍵を保管しておく認証エージェントです。  

ざっくりまとめ  
・バッググラウンドで動作する。  
・クライアント側で稼働するデーモン。  
・ssh-agentによって起動されたシェル内で認証エージェントとして機能する。  
・起動する度に「ssh-add」コマンドで秘密鍵とパスフレーズを登録しないといけない。  
・秘密鍵とパスフレーズはメモリ上にキャッシュされる。  
・一度起動すると「ssh-agent -k」でssh-agentをkillするまでバックグラウンドで動作し続ける。  
・SSH接続を終了しても停止しない。  
・環境変数SSH_AUTH_SOCKとSSH_AGENT_PIDを利用する。  
・SSHサーバーとは通信しない。ローカルプロセスであるssh及びssh-addと通信する。  

「ssh-keygen」コマンドでキーペアを作成する際にパスフレーズを設定している場合、その秘密鍵を使用する際には毎回パスフレーズの入力が求められます。  
パスフレーズ付きの秘密鍵を使ってSSH接続する際に毎回パスフレーズを入力しないで済むようにするには、「ssh-agent」を使用します。  

ssh-agent起動直後は鍵情報が登録されていませんので、「ssh-add」コマンドで秘密鍵とペアになるパスフレーズを入力して鍵情報を登録します。  
これ以降は登録した秘密鍵を使用したSSH接続時にパスフレーズの入力が求められなくなります。  

「ssh-agent bash」コマンドでssh-agentはbashを起動し、バックグラウンドで動作します。  
ssh-agentによって起動されたシェル内で子プロセスとしてssh-addやsshコマンドを実行すると、これらの認証エージェントとしてssh-agentが機能します。  

指定した文字列を評価後に連結して実行させるevalコマンドでssh-agentを起動することも可能です。  
この場合、現在のシェルでssh-agentが動作します。  

``` txt
#eval `ssh-agent`
Agent pid 23977 ←現在のシェルでssh-agentが動作する。
```

[ssh-agentを使って公開鍵認証方式のsshパスワード入力を省略する方法](https://www.server-memo.net/server-setting/ssh/ssh-agent.html)  
>公開鍵認証方式による認証を行っているSSHサーバーへ接続する際、秘密鍵に設定されているパスフレーズの入力を代わりにやってくれるプログラム。  

パスフレーズの入力回数を減らしてくれるという便利なプログラムだが、ちょっと使いづらい仕様もあったりする。  

- ssh-agentを起動したシェル内のみ有効  
  ログアウトしたりシェルを変更すると使えなくなりssh-agentの再実行が必要  
- ssh-addで秘密鍵とパスフレーズの登録が必要  
  ssh-agentを起動するたびに登録が必要  
- ssh-agentが自動終了しない  
  ログアウトしたりシェルを変更してもssh-agentは自動終了しないため、新しいシェルでssh-agentを起動すると多重起動が発生してしまう  

ssh-agent利用のためには、子プロセスとしてbashシェルを起動する必要がある。  
`ssh-agent bash`  

秘密鍵を登録する。  
`ssh-add`  

秘密鍵の登録確認。  
`ssh-add -l`  

### ssh-addコマンド

認証エージェントであるssh-agentに秘密鍵を登録するコマンド。  

「ssh-keygen」コマンドで鍵を作成する際、パスフレーズの入力が求められます。  
SSHサーバへ公開鍵認証方式で接続する際には秘密鍵へのアクセスが必要となるため、毎回パスフレーズの入力が必要になります。  
SSH接続時にパスフレーズを聞かれないようにする為には「ssh-agent」コマンドを使用します。これはメモリ上に秘密鍵を保管しておく認証エージェントです。  
ただ、最初は認証エージェントに認証鍵が登録されていませんので、「ssh-add」コマンドを実行し、1度だけパスフレーズを入力して秘密鍵を登録します。  
これ以降、SSH接続時にパスフレーズの入力が求められなくなります。  

### ポートフォワーディング

SSHクライアント to SSHサーバー  

SSHポート転送(ポートフォワーディング)とは、あるポートに送られてきたTCPパケットをSSHを使った安全な通信路を経由して、リモートホストの任意のポートに転送すること。  
POP3やFTPなど、暗号化されていないプロトコルを使った通信の安全性を高めることが出来る。  

SSHには、他の通信を自身の作成する暗号化コネクション内に流す機能があります。  
この機能はポートフォワーディングによって実現されています。  
ポートフォワーディングとは、あるポートで受け取った通信を別のポートに転送する処理のことです。  

-Lは「Local port forwarding」のためのオプションです。  

``` txt
ping-tバージョン
ssh -L 転送対象ポート番号:SSHサーバーから見た接続先アドレス:SSHサーバーからの接続先ポート番号 [SSH接続ユーザー名@]SSHサーバーアドレス

例)ローカルのポート8000への接続は、SSHサーバー自身(localhost)のポート80(Webサーバー)へ転送する。
ssh -L 8000:localhost:80 user@ssh-server


白本か小豆本バージョン
ssh -L [ローカルポート]:[リモートホスト]:[リモートポート] [リモートホストのユーザー名]@[リモートホスト]

例)ローカルホストの10110版ポートに接続すると、リモートホストpop.example.netの110番ポートに接続する。  
ssh -f -N -L 10110:pop.example.net:110 student@pop.example.net
```

``` txt : SSHポートフォワーディング例

 外部Webサーバー               SSHサーバー                   SSHクライアント
(www.example.com)①
        ↑                                   SSH暗号化接続                                     Webブラウザ
        ↑←←←←←←←←←← SSHサーバー ←←←←←←←←  SSHクライアント ポート 8080 ← ① ポートフォワードlocalhost:8080にアクセスした場合
                                   ↓                                        ポート10080 ← ② ポートフォワードlocalhost:10080にアクセスした場合
                               Webサーバー②
                                                                            Webサーバー  ← ③ポートフォワードしない場合のlocalhost:8080アクセス

Webブラウザで「http://localhost」に接続すると、自身の内部で動作するWebサーバにアクセスしに行きます③。
ここで、SSHサーバへの接続に以下の2つのポートフォワーディング設定を行います。
・ローカルのポート8080への接続を、外部Webサーバ（www.example.com）のポート80へ転送する①
ssh -L 8080:www.example.com:80 user@ssh-server

・ローカルのポート10080への接続は、SSHサーバ自身（localhost）のポート80（Webサーバ）へ転送する②
ssh -L 10080:localhost:80 user@ssh-server

次にWebブラウザでの接続先を変更すると、アクセス先が変更されます。
・接続先「http://localhost:8080」 → 外部Webサーバへ接続
・接続先「http://localhost:10080」→ SSHサーバ内のWebサーバへ接続

このように、SSHがポートを用意して通信を中継することをSSHポートフォワーディングといいます。
また、SSHの暗号化接続内を通ることで、SSHサーバ・クライアント間でのHTTP通信は外部から内容を盗み見ることができなくなります。
こういった特性から、SSHポートフォワーディングのことを「SSHトンネリング」と呼ぶこともあります。
そのため、SSHポートフォワーディング設定を行うことを俗に「トンネルを掘る」ということもあります。
```

### リモートポートフォワーディング

SSHサーバー to SSHクライアント  

逆向きの「Remote port forwarding」もあります。  
この場合はSSHサーバが転送用ポートを用意し、SSHクライアントの指定されたポートに転送します。  

``` txt : イメージ
以下の例では、「SSHサーバのポート8080へのアクセスは、SSHクライアントのポート80（Webサーバ）へ転送」されます。

外部サーバー    SSHサーバー                  SSHクライアント
    →→→→→  ポート8080
                    ↓      SSH暗号化接続
                SSHサーバ →→→→→→→→→ SSHクライアント
                                                 ↓
                                             Webサーバー
```

リモートポートフォワーディングはSSHクライアント上でsshコマンドを以下の書式で実行します。  
-Rは「Remote port forwarding」のためのオプションです。  

``` txt
ssh -R 転送対象ポート番号:SSHクライアントから見た接続先アドレス:SSHクライアントからの接続先ポート番号 [SSH接続ユーザー名@]SSHサーバアドレス

例)SSHサーバのポート8080へのアクセスは、SSHクライアントのポート80（Webサーバ）へ転送する
ssh -R 8080:localhost:80 user@ssh-server
```

### X11ポートフォワーディング

SSHサーバー to SSHクライアント with X11  

ポートフォワーディングをネットワークを介したXサーバ・クライアントの通信に特化し、通信の暗号化、設定作業を簡略化できるX11フォワーディングがあります。  
Xサーバ・クライアント間の通信は暗号化されていないため、入力したキー情報など盗み見られる恐れがあります。  
X11フォワーディングを使うことで、ローカルのXサーバとリモートのXクライアントで安全に通信を行うことができます。  

X11ポート転送を有効にするためにはSSHサーバの設定ファイル`/etc/ssh/sshd_config`で「X11Forwarding yes」となっている必要がある。  

``` txt : イメージ
SSHサーバー                    SSHクライアント

               SSH暗号化接続
SSHサーバー  →→→→→→→→  SSHクライアント
     ↑                           ↓
Xクライアント                  Xサーバー  → 画面表示
```

X11フォワーディングはSSHクライアント上でsshコマンドを以下の書式で実行します。  

``` txt
書式
ssh -X [SSH接続ユーザー名@]SSHサーバアドレス [Xクライアントコマンド]
```

このコマンドにより、SSHサーバ上のXクライアントが、SSHクライアントのXサーバ画面上に表示されます。  
なお、-Xオプションを付けてssh接続すると、Xクライアントの表示用にDISPLAY環境変数が自動で設定されます。  
そのため、-Xオプション付きで接続したsshセッションでは、起動したXクライアントはすべてSSHクライアント（ローカル）側のXサーバに表示されます。  

---

## GnuPGによる暗号化

### GnuPG(GNU Privacy Guard)

GnuPG（GNU Privacy Guard）は暗号化プログラム。  
共通鍵暗号方式や公開鍵暗号方式に対応しています。  
ファイルの暗号化や復号を行うにはgpgコマンドを使用します。  

公開鍵暗号方式を使って、ファイルの暗号化や復号をしたり、電子署名をしたりすることができるオープンソースソフトウェア。  
公開鍵暗号PGP(Pretty Good Privacy)の標準仕様であるOpenPGPのGNUによる実装であり、暗号化と署名を行うツール。  

### gpg-agent

gpg-agentは、GnuPG（GPG）という暗号化プログラムにおいて秘密鍵を管理し、パスフレーズによる認証状態を一定期間キャッシュするデーモンプログラムです。  
SSHにおけるssh-agentと同様です。  

### gpgコマンド

GnuPGを使ってファイルの暗号化や復号を行うコマンド。  

``` txt
gpg [オプション]

オプション
--gen--key        :: 公開鍵暗号方式の鍵ペアを生成する。「~/.gnupg/」ディレクトリの下に、作成される。
--export          :: 公開鍵をエクスポートする。
--import          :: 公開鍵をインポートする。
--list-keys       :: 公開鍵を一覧表示する。
--sign            :: ファイルに署名する。
--verify          :: ファイルの署名を検証する。verify:確認
-e ファイル名     :: 暗号化データを受け取る側の公開鍵を使用してファイルを暗号化する。
-o ファイル名     :: 出力ファイル名を指定する。
-r メールアドレス :: 暗号化に使用する公開鍵の持ち主のメールアドレスを指定する。

※復号する場合はそのままファイル名を指定する。オプションはいらない。
```

公開鍵と秘密鍵の鍵ペアを生成するコマンド  
`gpg --full-generate-key` or `gpg --gen-key`  
鍵は`~/.gnupg`ディレクトリに作成される。  

失効証明書の作成  
`gpg -o 執行証明書ファイル名 --gen-revoke メールアドレス`  
失効証明書はパスフレーズが漏れてしまったり、忘れてしまった際に鍵を無効化するために必要。  

失効証明書を使い鍵を無効化するコマンド  
`gpg --import revoke.asc`  

共通鍵を使ったファイルの暗号化  
`gpg -c ファイル名`  
例 : secret.txtファイルを暗号化  
`gpg -c secret.txt`  

公開鍵を使ったファイルの暗号化  
`gpg -c ファイル名`  

公開鍵のエクスポート  
`gpg -o 出力ファイル名 -a --export 自分のメールアドレス`  

公開鍵のインポート  
`gpg --import pubkey`  
→
公開鍵暗号方式では、公開鍵を使って暗号化したものをペアの秘密鍵で復号します。  
このため暗号化ファイルを送りたい相手から事前に公開鍵をファイル形式で受け取り、インポート（--importオプション）しておきます。  

鍵に署名を行うコマンド  
`gpg --sign-key メールアドレス`
公開鍵が信頼できる場合に行う。署名を行わないと毎回警告が表示される。  

ファイルの暗号化  
`gpg -e -a -r 送り先のメールアドレス 暗号化するファイル名`  
例 : 受信者ID yuko@mylpic.com,送信データファイルsecret-document.txt  
`gpg --encrypt --recipient yuko@mylpic.com secret-document.txt`  
受信は○○です。暗号化するファイルはこれです。この組み合わせで暗号化します。  

送られてきた暗号化ファイル「hogehoge.txt.gpg」を自分の秘密鍵を使用して復号したい。
`gpg hogehoge.txt.asc`  
→  
復号する場合はそのままファイル名を指定する。オプションはいらない。

ファイルの署名  
`gpg -o sample.sig --sign gpg.log`  

鍵の管理に関するタスクを対話モードで実行する場合のコマンド  
`gpg --edit-key`  

メールアドレス「user1@ping-t.com」のユーザから受け取った公開鍵を使ってファイル「hogehoge.txt」を暗号化します。  
`gpg -e -r user1@ping-t.com hogehoge.txt`  

### ~/.gnupg/ ディレクトリ

GnuPGに関連するファイルの置かれるディレクトリ。  

「--gen-key」オプションを使用すると、「~/.gnupg/」ディレクトリの下に、  
公開鍵暗号方式の公開鍵のキーリング（pubring.gpg）秘密鍵のキーリング（secring.gpg）が作成されます。  
キーリングとは公開鍵や秘密鍵を保管しておく鍵用のファイルのことです。  

公開鍵キーリング :: ~/.gnupg/pubring.gpg  
秘密鍵キーリング :: ~/.gnupg/secring.gpg  

### GnuPGを使った公開鍵暗号化方式を用いたファイルのやり取り

■公開鍵暗号方式の鍵ペアを作成  
暗号化データを受け取る側で、公開鍵と秘密鍵の鍵ペアを作成します。  
他者に公開できる公開鍵で暗号化されたファイルは、その公開鍵のペアとなる秘密鍵でしか復号できません。  
そのため、秘密鍵は作成したユーザのみが管理し他者にもれないようにします。  

例）server1のuser1が鍵ペアを作成する  
`gpg --gen-key`  

「gpg --gen-key」コマンド実行時に下図のようなパスフレーズを入力するダイアログを表示させるために、  
pinentry-curses（パスフレーズ入力ダイアログのコレクション）をインストールしておく必要があります。  

・gpg-agent  
gpg-agentというデーモンプログラムが、秘密鍵を管理し、パスフレーズによる認証状態を一定期間キャッシュします。  

■公開鍵のエクスポート  
暗号化に使用する公開鍵を通信相手に渡すため、公開鍵をファイルに出力します。  

例）user1がメールアドレス「user1@ping-t.com」を用いる公開鍵を「pubkey」というファイル名でエクスポートする  
`gpg -o pubkey --export user1@ping-t.com`  

エクスポートされた「pubkey」ファイルは通信相手（暗号化データを送る側）に送っておきます。  
`scp pubkey user2@server2:~/pubkey`  

■公開鍵のインポート  
暗号化データを送る側で、エクスポートされた公開鍵をインポートします。  

例）server2のuser2が、server1のuser1から受け取った公開鍵「pubkey」ファイルをインポートする  
`gpg --import pubkey`

■ファイルの暗号化  
暗号化データを送る側で、受け取った公開鍵を使ってファイルを暗号化します。  

例）user1から受け取った公開鍵を使ってファイル「hogehoge.txt」を暗号化する  
`gpg -e -r user1@ping-t.com hogehoge.txt`

暗号化したファイル「hogehoge.txt.gpg」はserver1のuser1に送っておきます。  

■ファイルの復号  
暗号化データを受け取る側で、送られてきた暗号化ファイルを自分の秘密鍵を使用して復号します。  

例）server2のuser2から送られてきた暗号化ファイル「hogehoge.txt.gpg」を復号する  
`gpg hogehoge.txt.gpg`

■ファイルの署名  
秘密鍵を使用してファイルに署名することで、ファイルの作成者が本人かどうかやファイルが改ざんされていないかどうかを確認できます。  

例）「hogehoge2.txt」ファイルに署名する  
`gpg --sign hogehoge2.txt`

「hogehoge2.txt.gpg」というバイナリファイルが作成されます。  

例）「hogehoge2.txt.gpg」ファイルの署名を検証する  
`gpg --verify hogehoge2.txt.gpg`  

---

## その必要なコマンド

### lastコマンド  

「/var/log/wtmp」ファイルを参照し、最近ログインしたユーザの一覧を表示するコマンド。  
「/var/log/wtmp」はユーザのログイン/ログアウト情報が記録されているバイナリファイルです。  

システムのログイン履歴を一覧表示するコマンド  
ログイン記録`/var/log/wtmp`を参照して、ログイン履歴を表示する。  

last :: 過去、最後  
lust :: 強い欲望、切望、渇望、色欲、肉欲  

``` txt
last [オプション][ユーザー名][端末番号]

オプションたくさんあるけど、今はいいです。
必要になったらまとめます。
```

### wコマンド

現在、システムに誰がログインしていて、何を実行しているのかを表示するコマンド。
`/var/log/wtmp`および`/proc`の情報を参照して表示する。  
`/var/run/utmp`ファイルも参照する模様。  

「/var/log/wtmp」はユーザのログイン/ログアウト情報が記録されているバイナリファイルです。  
「/var/run/utmp」ファイルはログイン中のユーザの情報が格納されているバイナリファイルです。  

「w」コマンドは、「who」コマンドの情報にプラスして、システムの情報やユーザが何をしているのか、まで表示します。  

``` txt
w [オプション][ユーザー名]

-h :: ヘッダーを表示しない
-u :: 現在のプロセス時間とCPU時間を計算する際に、ログイン名と現在のユーザー名の違いを無視する
-s :: 短く表示する
-f :: リモートホスト名を表示しない
```

### whoコマンド

システムに誰がログインしているかを表示するコマンド。  
`/var/run/utmp`ファイルを参照して表示する。  
「/var/run/utmp」ファイルはログイン中のユーザの情報が格納されているバイナリファイルです。  

``` txt
who [オプション]

たくさんある。
```

---

## 小豆本問題

### 1 ○

TCP Wrapperを使ってアクセス制御している。  
/etc/hosts.allow「sshd : 192.168.2.」  
/etc/hosts.deny「ALL:ALL」  
このことの説明。  

→  
B : 192.168.2.5のホストからSSH接続ができる。  

ホワイトリスト→ブラックリスト  
ホワイトリストに当てはまったら即OK。  
ホワイトリストに無かったらブラックリストを見る。  
ブラックリストにあったら即OUT。  

---

### 2 ×

/etc/nologinファイルを作成するとどうなるか？  

→  
C : /etc/nologinファイルに記述されたユーザーはログインできなくなる。  

A : 全てのユーザーはログイン出来なくなる。  
まじか。覚え間違えだったかな。  
ファイルを作って、その中でユーザーを指定するものだと思っていたのだが、勘違いだったようだ。  

空のファイルで良いが、メッセージを記述すると、ログインしたときのそのメッセージが表示されるらしい。  
なるほどね。  

---

### 3 ○

パスワードの有効期限を表示、設定するコマンドは？

→  
change  

---

### 4 ○

SSHを使って、ホストa.example.netに、ユーザーstudentとしてログインしたい。  
実行するコマンドは？  

→  
`ssh student@a.example.net`  
Eかな。  

正解。  
`ssh ログインユーザー名@ホスト名`  
ユーザー名を省略した場合、ローカルホストでSSHを実行したユーザーのユーザー名が指定されたことになる。  

---

### 5 ×

SSHを使ってリモートホストへ公開鍵認証でログインできるよう設定中。  
①接続先リモートホストのホームディレクトリ内に「.ssh」ディレクトリを作成。  
②その中に___ファイルを作成。そこに公開鍵をコピーして登録した。  
ファイル名は？  

→  
`~/.ssh/authorized_keys`  
なのでファイル名は`authorized_keys`  
登録元は？  

---

### 6 ○

GPGを使って暗号化されたファイルsecret.ascが送られてきた。  
送付元の公開鍵はすでに登録済み。  
復号のコマンドは？  

→  
`gpg secret.asc`  
ということでA  

当たった。  
