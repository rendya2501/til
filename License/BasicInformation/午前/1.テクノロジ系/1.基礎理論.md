# 基礎理論

---

## 離散数学

### 基数関係

### 10進数→n進数

257mod2 = 1 余りをつなげていく。  
少数は逆に掛け算。  
整数になるまで続ける。  

![!](https://yttm-work.jp/img/computer_basics/computer_basics_0003.png?001)  

``` math
2 ) 60 0 ← 最下位
2 ) 30 0
2 ) 15 1
2 )  7 1
2 )  3 1
2 )  1 1 ← 最上位
     0
```

### n進数→10進数

10の位 * n^2 + 1の位 + n^1  

### 正の整数の10進表示の桁数Dと2進表示の桁数Bとの関係を表す式  

$D≒Blog_{10}2$  

### 2進数の分数表記

1,024 - (1／2,048) は、(01111111111.11111111111)_2

#### 基本 平成30年秋期　問1

16進数の小数0.248を10進数の分数で表したものはどれか。  

→  

小数点ではない場合、 $10の位*16^2 + 1の位*16^1$ ってやって10進に変換していたので、これも同じ要領でやればおｋ。  
小数点だから指数の部分は-1乗されていく。  

$2*16^{-1} + 4*16^{-2} + 8*16^{-3}$  
$= 1/8 + 1/64 + 1/512$  
$= 64/512 + 8/512 + 1/512$  
$= 73/512$  

#### 基本 平成26年秋期　問1

10進数の分数1／32を16進数の小数で表したものはどれか。  

→

16進を分数に変換してから当てはめるやり方でもいけるけど、少数の場合は掛ける事でも求められるはず。  
解説サイトにはその方法が乗っていなかった。どちらもまとめる。  
16進小数の各桁は、小数点の右に進むにつれて、  

$0.1(16)→1／16(10)，$  
$0.01(16)→1／256(10)，$  
$0.001(16)→1／4096(10)，$  
$0.00…00(16)→1／16n(10)$  

というように、16-nを表しています。  
1／32の分母を16進小数の小数点第2位の1／256と通分すると8／256になるので、小数点第2位を8にした0.08が正解となります。  

まず、分数から整数(小数点）に変換します。  
$１／３２＝０．０３１２５$  
これを１６進数に変換するのですが、小数点以下の数字を１６進数に変換する場合、整数部は１６で割っていきますが、少数点以下は逆に１６を整数になるまで、かけていきいきます。  

０．０３１２５×１６ ＝０．５ なので、０．０です。  
＝０．５×１６ ＝８ なので、８はそのまま数字を残し  
０．０８ と、なります。  
よって、１／３２の１６進数は０．０８ と、なります。  

#### 基本 平成31年春期　問1

10進数の演算式7÷32の結果を2進数で表したものはどれか。

→  

``` math
7/32 = 0.21875
0.21875 * 2 = 0.4375 : 0.0
0.4375 * 2 = 0.875 : 0.00
0.875 * 2 = 1.75 : 0.001
0.75 * 2 = 1.5 : 0.0011
0.5 * 2 = 1 : 0.00111
```

ってやったけど、分数に分解するとか2進数に変換してからビットシフト演算するとかやり方は色々あるみたいね。

【別解】
7÷32は7／32と表記できるので、これを
　4／32＋2／32＋1／32

と3つに分解します。さらに約分を施し、
　1／8＋1／16＋1／32

次のように分母を2の累乗で表すと、
　1／2^3＋1／2^4＋1／2^5

というように変換できるので、2進小数で表すと「0.00111」になります。

【別解】
10進数の7を2進数に変換すると111になります。さらに10進数の32を2の累乗で表現すると2^5になります。

つまり10進数の演算式「7÷32」は「7×(1／2^5)」というように、2進数の111を右に5ビットシフトする操作に置換えられる。
111を右に1ビットシフトすると11.1
111を右に2ビットシフトすると 1.11
111を右に3ビットシフトすると 0.111
111を右に4ビットシフトすると 0.0111
111を右に5ビットシフトすると 0.00111

平成26年秋期　問2
0000～4999のアドレスをもつハッシュ表があり，レコードのキー値からアドレスに変換するアルゴリズムとして基数変換法を用いる。キー値が55550のときのアドレスはどれか。
ここで，基数変換法とは，キー値を11進数とみなし，10進数に変換した後，下4桁に対して0.5を乗じた結果(小数点以下は切捨て)をレコードのアドレスとする。

→
n進数で表された数を10進数に変換できるかがポイントです。
キー値 55550 が11進数だとすると、桁ごとに11の累乗になっているので、10進数に変換するには、

　5×11^4＋5×11^3＋5×11^2＋5×11^1

という式の値を求めることになります。これを地道に計算してもよいのですが、ここでは速く解くために、まず式を変形(下線部分)してから解いています。

　5×11^4＋5×11^3＋5×11^2＋5×11^1
＝(11^3＋11^2＋11＋1)×55 ※
＝(1331＋121＋11＋1)×55
＝80520

最後に 80520 の下4けた「0520」に0.5を乗じると参照すべきアドレス0260が求められます。

※補足　式の変形
　5×11^4＋5×11^3＋5×11^2＋5×11^1
＝(11^4＋11^3＋11^2＋11^1)×5
＝(11^3＋11^2＋11＋1)×5×11
＝(11^3＋11^2＋11＋1)×55

#### 平成28年春期　問2

10進数123を，英字A～Zを用いた26進数で表したものはどれか。ここで，A＝0，B＝1，…，Z＝25とする。

→

10進数123を26で割ると、商と余りは以下のようになります。

　123÷26＝4余り19

つまり10進数123は、(261×4)＋19と表せます。英字と数字は以下のように対応しているため、各桁を4→E，19→Tと置き換えると26進数「ET」になります。したがって「ウ」が正解です。

![!](https://www.ap-siken.com/kakomon/28_haru/img/02.gif)  

※余りを下から上に持っていくのを忘れていた。  

#### 令和2年秋期　問1

正の整数の10進表示の桁数Dと2進表示の桁数Bとの関係を表す式のうち、最も適切なものはどれか。

``` math
正の整数をxとします。xは、10進数でD桁、2進数でB桁ですから、xの範囲は次のように表せます（例えばDが4であれば、xの範囲は1000～9999）。

　10^{D-1}≦x＜10^D
　2^{B-1}≦x＜2^B

最小値同士（10^{D-1}と2^{B-1}）及び最大値同士（10^Dと2^B）はほぼ等しいので、「10^{D-1}≒2^{B-1}」及び「10^D≒2^B」と言えます。

式「10^D≒2^B」をDについて解きます。

　10^D≒2^B
　(両辺の対数をとる)
　log_{10}10^D≒log_{10}2^B
　Dlog_{10}10≒Blog_{10}2
　(log_{10}10＝1なので)
　D≒Blog_{10}2

したがって、2進表示でB桁になる数値は、10進表示でおよそBlog_{10}2桁になります。
```

## 離散数学 BCD(Binary-coded decimal，2進化10進数)

BCD(Binary-coded decimal，2進化10進数)は、2進数4桁を10進数1桁に対応させて整数を表現する方法です。  

![!](https://www.ap-siken.com/kakomon/26_aki/img/02.gif)  

例えば、10進数の"725"は、BCDだと"0111 0010 0101"と表現されます。  

### 平成26年秋期　問2

4nビットを用いて整数を表現するとき，符号なし固定小数点表示法で表現できる最大値をaとし，BCD(2進化10進符号)で表現できる最大値をbとする。  
nが大きくなるとa／bはどれに近づくか。  

→

``` txt
4nビットのnを1から順に増やしていくと、BCDで表現できる最大値(b)は、
4×1ビット … 9
4×2ビット … 99≒10^2
4×3ビット … 999≒10^3
4×4ビット … 9999≒10^4
4×nビット … 10n
というように、10n で近似することができます（桁数がnになるからです）。

一方、符号なし固定小数点表示法で表現できる最大値(a)は、
4×1ビット … 15
4×2ビット … 255≒2^8
4×3ビット … 4095≒2^12
4×4ビット … 65535≒2^16
4×nビット … 2^4n
というように 2^4n で近似することができます。

"a／b"には以下の関係があると言えます。

　2^4n／10^n
＝16^n／10^n　//2^4n=(2×2×2×2)^n
＝(16／10)^n　//指数法則を適用
```

2進化10進法は最大値が9ということなので1001 1001の99で考える。  
この状態の2進数を求めると153になる。  
後は普通に割り算すると 17/11 になるので、一番それっぽい (15／9)×n を選んだら死んだ。  

あくまで、4nにおける2進化10進法における最大値と2進数における最大値の比較なので、  
BCDの最大表現は1001までだからって考えで行くと死ぬ。  

## 離散数学 無限少数

無限小数は、有限小数(終わりのある少数)に対して、終わりのない少数のこと。  

### 0.1を2進数で表す

<https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q148448134>

なんかしょっちゅう忘れる。  
0.25は簡単。
0.25 = 1 / 4 = 1 / 2^2 = 0.01

しかしこの考えで0.1を作ろうとすると死ぬ。
で、忘れたので調べた。
整数部分は割り算で求めるなら、少数は掛け算で求めるのだった。

小数部分が0になるまで繰り返す。  
0.1は無限小数なので、綺麗になることはないが、とりあえずそれで求められる。  

0.1
0.2
0.4
0.8
1.6
1.2
0.4
0.8
1.6
1.2
0.4
0.8
000011001100
最上位が整数部なので小数点を差し込んで0.00011001100。

0.25
0.5
1.0
0.01

因みに8進数だろうと16進数だろうとやることは変わらない。

試しに10進数の0.8359375を8進数に変換する。  
$0.8359375*8$  
$=6.6875*8$  
$=5.5*8$  
$=4.0$  

というわけで、0.654。  

### 基本 平成26年春期　問1

次の10進小数のうち，2進数で表すと無限小数になるものはどれか。  

→  

0.05
これに2を書けて行くと、小数部分が0にならない。そうなったら無限小数になる。

2進数の小数は以下のように1桁下がるごとに値が1／2ずつ小さくなっていきます。
0.1(2)＝1／21＝0.5(10)
0.01(2)＝1／22＝0.25(10)
0.001(2)＝1／23＝0.125(10)
0.0001(2)＝1／24＝0.0625(10)
0.00001(2)＝1／25＝0.03125(10)
2進小数で有限となるかどうかは、上記の値の組合せで表現できるか否かで判断します。
0.5
10進数0.5は2進数0.1で表現できます。
0.125
10進数0.125は2進数0.001で表現できます。
0.05
正しい。2進小数の各桁の組合せで表現できないので、0.05は無限小数となります。
0.375
0.375＝0.25＋0.125 なので、10進数0.375は2進数0.011で表現できます。

### 平成26年春期　問1

2進数で表現すると無限小数になる10進小数はどれか。

0.375
0.45
0.625
0.75

→

``` math
2進数の小数は以下のように1桁下がるごとに値が1／2ずつ小さくなっていきます。
0.1(2)＝1／21＝0.5(10)
0.01(2)＝1／22＝0.25(10)
0.001(2)＝1／23＝0.125(10)
0.0001(2)＝1／24＝0.0625(10)
0.00001(2)＝1／25＝0.03125(10)
2進小数で有限となるかどうかは、上記の値の組合せで表現できるか否かで判断します。

0.375
0.25＋0.125＝0.375なので、10進数0.375は2進数0.011で表現できます。

0.45
正しい。2進小数の各桁の組合せで表現できないので、0.45は無限小数となります。

0.625
0.5＋0.125＝0.625なので、10進数0.625は2進数0.101で表現できます。

0.75
0.5＋0.25＝0.75なので、10進数0.75は2進数0.11で表現できます。
```

## 離散数学 浮動小数点表示における正規化

仮数部と指数部を調整することで、仮数部の最上位桁が0以外になるように桁合わせする操作です。  
正規化の目的は、有効桁数を最大化し、丸め誤差をできるだけ少なくすることです。  

例）小数第1位を仮数部の最上桁とする正規化  
$10.75_{(10)} → 1010.11_{(2)} →(4ビット右にシフト)→ 0.101011_{(2)}×2^4$  
$0.1875_{(10)} → 0.0011_{(2)} →(2ビット左にシフト)→ 0.11_{(2)}×2^{-2}$  

※基本情報技術者平成29年春期 午前問2

## 離散数学 補数

<https://agency-star.co.jp/column/2-complement/>  
元の数字に足すと次の桁上がりを起こす「最小」の数字のこと。  
例えば、10進数の7の補数は3、77の補数は23といった具合です。  
基数の補数ともいう。  

補数作成手順
①ビット反転させる
②1を足す

例：
433-114 = 319
114の補数 = 886
433+886=1,319

最上位の桁を取り除けば加算でも減算と同様の結果が得られることが分かる。

8ビットの場合、2の補数表現を用いて表現できる範囲は「-128～127」です。
ビット数を「n」とした時に「-2^(n-1)〜2^(n-1)-1」の範囲が表現できる。
          符号なし 符号付き
0000 0000 0 0
0000 0001 1 1
0000 0010 2 2
0111 1111 127 127
1000 0000 128 -128
1000 0001 129 -127
1111 1110 254 -2
1111 1111 255 -1

127をマイナスにする。
0111 1111 : 127
→ビット反転して1を足す
1000 0001 : -127
→１を引く
1000 0000 : -128
というわけで、-128まで表現可能。

ちなみに128が本当に1000 0000についてだが、
1000 0000 : 128
→反転
0111 1111
→1を足す
1000 0000 : -128

128 + -128 = 0
 1000 0000
+1000 0000
 0000 0000
というわけで、辻褄はあっている。

先頭1ビットを符号と見立てる。0ならプラス。1ならマイナス。
0111 1111 がプラスの最大表現となるので、127がプラスの最大値となる。
先頭に1がついた場合の表現は上記表を参照。

補数表現の他に絶対値表現なるものがある。
先頭の0をプラス、1ならマイナスは補数と同じだが、その下の数をそのまま使う方式。

8ビット 27と-27の表記は以下のようになる。
0001 1011 : 27
1001 1011 : -27

ただ、こちらの方式は見た目のためにあるだけで、あまり使われない模様。
実際に計算させると意味が違うし、あくまでそういう表現もできるよねって物だけなのかもしれない。

### 減基数の補数

元の数に足して桁上がりを起こさない最大の数。  
7であれば2、77であれば22になるといった具合です。  

1の補数ともいう。  
ビットを反転させるだけで1の補数になる。  

---

## 離散数学 計算問題

### 基本 平成28年秋期　問1

8ビットのビット列の下位4ビットが変化しない操作はどれか。

→

一般に任意のビット列から特定のビット列を取り出したいときにはAND演算、
任意のビット列のうち特定のビット列を反転させたいときにはXOR演算を使うことができるので覚えておくといいでしょう。

### 基本 平成28年春期　問1

数値を2進数で格納するレジスタがある。このレジスタに正の整数xを設定した後，"レジスタの値を2ビット左にシフトして，xを加える"操作を行うと，レジスタの値はxの何倍になるか。ここで，あふれ(オーバフロー)は，発生しないものとする。

→  

下記の例のように、2進数のビット列をnビット左にシフトする操作は、元の数値を2n倍することと同じです（逆に右シフトの場合は1／2n倍です）。
2進数 11 を左に1ビットシフト → 2進数 110
数値（10進数、以下同じ）は、3 → 6 と 21倍＝2倍 になる
2進数 11 を左に2ビットシフト → 2進数 1100
数値は、3 → 12 と 22倍＝4倍 になる
2進数 11 を左に3ビットシフト → 2進数 11000
数値は、3 → 24 と 23倍＝8倍 になる
本問の操作を2つに分解して考えると、
**レジスタに格納された2進数(x)を2ビット左にシフト**
xを2^2倍、つまり4倍する
xを加える
**xを4倍した数値にxを足す**
という組合せなので、操作後のレジスタの値は元のxの値の5倍になります。

### 令和元年秋期　問1

あるホテルは客室を1,000部屋もち，部屋番号は，数字4と9を使用しないで0001から順に数字4桁の番号としている。部屋番号が0330の部屋は，何番目の部屋か。

→  

0,1,2,3,4,5,6,7,8,9  
0,1,2,3, ,5,6,7,8,  

``` txt
数字4と9を使用しないということは、0～3、5～8の8種類の数字のみを使うということです。1つの桁に8種類の数字を使えるということは、1つの桁に0～8を使う8進数と同じ考え方を適用できることになります。

つまり、部屋番号の数字を以下のように対応させて10進数に変換すれば、部屋番号の0001から数えて何番目の部屋なのかを素早く計算できます。

対象の部屋番号は0330なので数字の置き換えは発生せず、そのまま8進数を10進数に変換する計算を行えば大丈夫です。

　82×3＋8×3＝192＋24＝216
```

![!](https://www.ap-siken.com/kakomon/01_aki/img/01.gif)  

### 平成28年秋期　問1

8ビットのデータX及びYの値をそれぞれ16進表現で 0F，F0 とするとき，8ビットのデータAの下位4ビットを反転させ，上位4ビットを0にする論理式はどれか。ここで，X・Yは論理積を表し，Zは否定を表す。  

→  

データAを「10101010」と仮定します。「10101010」の下位4ビットを反転、上位4ビットを"0"にすると「00000101」になるため、これを各論理式の結果と比較することで正解を導きます。  

ウ
$\bar{A}・X$  
$\bar{10101010}・00001111$  
$＝01010101・00001111$  
$＝00000101$  
下位4ビットが反転し、上位4ビットは全て"0"になっているため正解です。  

あるビット列から特定のビット列を取り出す時には、取り出したい部分に"1"を設定したビット列とのAND演算を行います。  
データAを反転させ、下位4ビットを"1"にしたビット列(00001111)とのAND演算を行うことで、その部分だけを取り出せるという訳です。  

### 平成31年春期　問1

0以上255以下の整数nに対して，

![!](https://www.ap-siken.com/kakomon/31_haru/img/01.gif)  

と定義する。next(n)と等しい式はどれか。ここで，x AND y 及び x OR y は，それぞれxとyを2進数表現にして，桁ごとの論理積及び論理和をとったものとする。

→  

``` txt
next(n)は、引数nが0～254の場合には引数に1を加えた値を返し、255では0を返します。

この問題で考えなければならないポイントは、次の2点です。
(1)1ずつ加算がおこなわれるか。
(2)next(255)のときに結果が 0 となるか。

ア
(n＋1) AND 255
正しい。ビットマスクの255を2進数で表すと「11111111」で、このビット列との論理積(AND)は(n＋1)の下位8ビットだけを取り出すように作用します。引数が255の場合には、最上位ビットの演算結果が0になるので関数は0を返します。
```

![!](https://www.ap-siken.com/kakomon/31_haru/img/01a.gif)  

### 平成28年春期　問1

nビットの値 L1，L2がある。次の操作によって得られる値L3は，L1とL2に対するどの論理演算の結果と同じか。

〔操作〕
L1とL2のビットごとの論理和をとって，変数Xに記憶する。
L1とL2のビットごとの論理積をとって更に否定をとり，変数Yに記憶する。
XとYのビットごとの論理積をとって，結果をL3とする。

→  

ビット列L1＝10101010，ビット列L2＝11110000 を例として操作の様子を確認していきます。

[操作(1)]  
2つのビット列の論理和なので、2つのビットのどちらか、又は両方が1(真)になっている部分を1(真)としたビット列が変数Xに格納されます。  
![!](https://www.ap-siken.com/kakomon/28_haru/img/01_1.gif)  

[操作(2)]  
2つのビット列の論理積の否定なので、2つのビットが共に1(真)である部分以外を1(真)としたビット列が変数Yに格納されます。  
![!](https://www.ap-siken.com/kakomon/28_haru/img/01_2.gif)  

[操作(3)]  
変数X  
2つのビットのどちらか、又は両方が1(真)の部分が1(真)  
変数Y  
2つのビットが共に1(真)の部分以外が1(真)  
という2つのビット列の論理積をとった結果は、以下のように変数Xの1(真)のうち両方のビットが1(真)であった部分が取り除かれた形になり、L1とL2の排他的論理和(XOR)と等しくなります。  

![!](https://www.ap-siken.com/kakomon/28_haru/img/01_3.gif)  

---

## 離散数学 確立・比率計算

### 組合せ数の公式

n個の物からr個を選ぶ組み合わせ  
$nCr = n! / (n-r)!r!$  

例)8色のカラーボールから3色のボールを選ぶ方法  
$8C3＝(8×7×6)／(3×2×1)＝56(通り)$  

### 確率の乗法定理

各々が独立した事象Aと事象Bがあり、起こる確率がそれぞれP(A)，P(B)であるとき、事象A，Bが同時に起こる確率は次の式で求められます。

$P(A∩B)＝P(A)×P(B)$  

また、事象Aが起こらない確率$P(\bar{A})$は「$1－P(A)$」で表します。  

### 排反事象

「同時に起こらない」事象のこと。  
「互いに排反である」とは「同時に起こることがない」こと。  

互いが独立の時は掛け算  
互いが排反の時は足し算  

その二つの事象が同時に成り立たなければいけないなら掛け算です！  
その二つの事象のどちらかが成り立つ場合は足し算です！  
Aから白とBから黒は同時に成り立たないといけませんよね。だから掛け算なんです！  
逆に(2)は白→黒か黒→白のどちらかが成り立てばいいので足し算なんです！  

### 独立

独立とは、前に行った試行の結果が次の試行に全く 影響を与えないこと。  

### 基本 平成28年秋期　問2

ある工場では，同じ製品を独立した二つのラインA，Bで製造している。  
ラインAでは製品全体の60%を製造し，ラインBでは40%を製造している。ラインAで製造された製品の2%が不良品であり，ラインBで製造された製品の1%が不良品であることが分かっている。  
いま，この工場で製造された製品の一つを無作為に抽出して調べたところ，それは不良品であった。その製品がラインAで製造された確率は何%か。  

→  

60%で1%,40%で1%ならAの確立は60%と言えるだろう。  
2%なのだから、60より上なのは間違いないが、なぜ75%と言えるのか求めることができなかったが、単純に比率で考えたらそうなるしかないのだ。  

製品全体に対するラインAで製造された不良品の割合は、  
　0.6×0.02＝0.012  

同様にラインBで製造された不良品の割合は、  
　0.4×0.01＝0.004  

不良品の比率は、  
　0.012：0.004＝3：1  

であるため、調べた不良品がラインAで製造された確率は、  
　3／4＝75(%)  

### 平成27年春期　問3

製品100個を1ロットとして生産する。一つのロットからサンプルを3個抽出して検査し，3個とも良品であればロット全体を合格とする。100個中に10個の不良品を含むロットが合格と判定される確率は幾らか。

※組み合わせの公式を使わなかったのでそりゃ間違える。  
単純に $90/100 × 89/99 × 88/98$ をした。  

→

ロットが合格と判定されるのは3つのサンプルがすべて良品の場合です。
合格となる確率は、

　90個から3つを選ぶ組合せ数／100個から3つを選ぶ組合せ数

となるので、組合せ数を求める以下の公式を使って正解を導きます。

100個の製品の中から3個を取り出す組合せ数は、

　100C3＝(100×99×98)／(3×2×1)＝161700

90個の良品の中から3個を取り出す組合せ数は、

　90C3＝(90×89×88)／(3×2×1)＝117480

したがって、製品100個から3個を取り出し全てが良品である確率は、

　117480／161700＝（約分を繰り返して）178／245

【参考：素因数分解を利用した約分方法  
$  (90×89×88)／(3×2×1)$  
$＝15×89×88$  
$＝5・3×89×2^3・11$  
$＝2^3・3・5・11・89$  

$  (100×99×98)／(3×2×1)$  
$＝50×33×98$  
$＝2・5^2×3・11×2・7^2$  
$＝22・3・5^2・7^2・11$  

$　(2^3・3・5・11・89)／(2^2・3・5^2・7^2・11)$  
$＝(2・89)／(5・7^2)　//分子と分母で共通する2^2・3・5・11で約分$  
$＝178／245$  

### 令和2年秋期　問2

3台の機械A，B，Cが良品を製造する確率は，それぞれ60%，70%，80%である。機械A，B，Cが製品を一つずつ製造したとき，いずれか二つの製品が良品で残り一つが不良品になる確率は何%か。

→

``` math
設問にある二つの製品が良品で残り一つが不良品になるケースには以下の3通りがあります。

[Aが不良品、B・Cが良品の確率]
(1－0.6)×0.7×0.8＝0.224

[Bが不良品、A・Cが良品の確率]
0.6×(1－0.7)×0.8＝0.144

[Cが不良品、A・Bが良品の確率]
0.6×0.7×(1－0.8)＝0.084

それぞれの事象は排反事象であるため、二つの製品が良品で残り一つが不良品になる確率は、上記を合計して、

　0.224＋0.144＋0.084＝0.452→45.2%
```

---

## 離散数学 逆ポーランド記法

### 逆ポーランド表記法(後置表記法)

演算子を演算の対称である演算数の右側に記述する記法。  
構文木を深さ優先順で、帰りがけなぞりとして走査することで実現できる。  

通常の式を、逆ポーランド表記法で表現するための基本は、A＋B(項 演算子 項) を AB＋(項 項 演算子)で表すことです。  
これと一回使った演算子は2度使わないことに注意して、普通に計算式を解くのと同じ要領で行っていくことで逆ポーランド表記法の式になります。  

<https://kojimanotech.com/2021/07/03/324/>

#### 令和2年秋期　問3

式A＋B×Cの逆ポーランド表記法による表現として，適切なものはどれか。

→

``` txt
通常の式を、逆ポーランド表記法(後置表記法)で表現するための基本は、「A＋B」を「AB＋」で表すことです。
1回変換した部分は1つの項とみなすことに注意して、普通に計算式を解くのと同じ順番で変換で行っていくことで逆ポーランド表記法の式になります。
なお、変換を行う優先順位は通常の計算式と同様に、括弧付き"()"→積商算(×÷)→和差算(＋－) の順番です。

最初に「B×C」の部分を変換します。
　A＋B×C → A＋BC×

次に「BC×」を1つの項とみなしてAとの＋演算部分を変換します。
　A＋BC× → ABC×＋

これで式A＋B×Cの逆ポーランド表記法への変換が完了です。よって正解は「ウ」です。
```

### 中置→逆ポーランド

順序  
1.１番目に計算する「数字演算子数字」を「数字数字演算子」に並び替える  
2.１の後また並び替えができるか確かめる  
3.並び替えができたら１に戻る。並び替えができなくなったらカッコをはずす  
4.=があれば後ろに持っていく  
5.並び替え終わったら終了  

#### 平成24年度 春期 基本情報技術者試験 午前 問4

後置表記法(逆ポーランド表記法)では，例えば，式 Y＝(A－B)×C を YAB－C×＝ と表現する。  
　次の式を後置表記法で表現したものはどれか。  
　　Y＝(A＋B)×(C－(D÷E))  

１：(A+B)、(C-(D÷E))をそれぞれひとつの数字としてみなして並び替え  
Y=(A+B)(C-(D÷E))×  

２：D÷Eを並び替え  
Y=(A+B)(C-(DE÷))×  

３：(C-(DE÷))を並び替え  
(DE÷)は一つの数字としてみなします。  
Y=(A+B)(C(DE÷)-)×  

４：A+Bを並び替え  
Y=(AB+)(C(DE÷)-)×  

５：カッコをはずす  
Y=AB+CDE÷-×  

６：=を後ろに持っていく  
YAB+CDE÷-×=  

### 逆ポーランド→中置

ポイント  
カッコは一つの数字とみなす。  

1. =があれば１つ目の数字の後ろに持っていく  
2. 左から見ていき、「数字数字演算子」の並びをみつける  
3. ２で見つけた「数字数字演算子」を「数字演算子数字」に並び替える  
4. ３で並び変えたらカッコをつける  
5. ２～４を繰り返す  
6. 並び替え終わったら終了  

#### 平成21年度 秋期 基本情報技術者試験 午前 問3

逆ポーランド表記法（後置表記法）で，“EF－G÷CD－AB＋÷＋”と表現される式はどれか。  

１：EF-を並び替えてカッコつける  
(E-F)G÷CD－AB＋÷＋  

２：(E-F)G÷を並び替えてカッコつける  
((E-F)÷G)CD－AB＋÷＋  

３：CD－を並び替えてカッコつける  
((E-F)÷G)(C-D)AB＋÷＋  

４：AB＋を並び替えてカッコつける  
((E-F)÷G)(C-D)(A+B)÷＋  

５：(C-D)(A+B)÷を並び替えてカッコつける  
((E-F)÷G)((C-D)÷(A+B))＋  

６：((E-F)÷G)((C-D)÷(A+B))＋を並び替えてカッコつける  
((E-F)÷G)+((C-D)÷(A+B))  

#### 平成28年秋期　問3

逆ポーランド表記法で表された式を評価する場合，途中の結果を格納するためのスタックを用意し，式の項や演算子を左から右に順に入力し処理する。スタックが図の状態のとき，入力が演算子となった。このときに行われる演算はどれか。ここで，演算は中置表記法で記述するものとする。

![!](https://www.ap-siken.com/kakomon/28_aki/img/03.gif)  

→  

逆ポーランド表記法は、演算子を被演算子の右側に記述する表記法です。

例えば、
　A＝4×5－6＋3×2

という式を逆ポーランド表記法で記述すると、
　A45×6－32×＋＝

となり、これを構文木で表すと次のようになります。

![!](https://www.ap-siken.com/kakomon/28_aki/img/03a.gif)  

この構文木は式の並び順のとおりに「左の葉→右の葉→節」という後行順序で操作が行われます。  

問題に戻ると、演算子の前にCとDがスタックに積まれています。つまり先に積まれている「C」が左の葉の値、「D」が右の葉の値ということになります。  
これを逆ポーランド表記の式にすると「CD演算子」と変換することができます。  

答えは中置表記法で記述するので、正解は「C 演算子 D」となります。  

---

## 離散数学 丸め誤差、打ち切り誤差、情報落ち、桁落ち

<https://mathwords.net/marumegosa>  

### 丸め誤差

ある桁以降を無視することによって生じる誤差のことです。  
「0.1212121212 を 0.12 とみなして計算する」  
桁数が多い小数を、途中で四捨五入したり、切り捨て・切り上げする場合。  

### 打ち切り誤差

無限級数のある項以降を無視することによって生じる誤差のことです。  
「1+12+14+18+… という無限級数を計算したいが、18 までで打ち切る」  

### 情報落ち

絶対値が大きく異なる数を足したり引いたりすることで、小さい方の情報が無視されてしまう現象のことです。  
「1.0000+0.0001 を計算したいが、有効数字５桁で計算すると計算結果が 1.0000 になってしまい、足し算の意味がない」  

### 桁落ち

[1]  
近い数を引き算することで有効数字が少なくなる現象のことです。  

例)  
「1.2345−1.2344 を計算したいが、答えは 0.0001 になってしまい、有効数字が5桁から1桁に減少する」  
強引に有効数字5桁のように表すと、1.0000×10^−4 となりますが、小数点以下の4つの 0 は正しい保証が(意味が無い) 0 です。  

[2]  
計算誤差のひとつで、絶対値の差が非常に小さい2つの値の差を求めたときに、仮数部の大半が打ち消しあい、計算結果の有効桁数が少なくなることによって生じる誤差です。  
浮動小数点数の計算において、値がほぼ等しい値同士の減算や、絶対値がほぼ等しく正負が異なる値同士の加算による生じることがあります。  
桁落ちを防ぐ方法として"分子の有理化"があります。  

例）有効桁数が8桁から2桁に減少する計算  
$1.2345678－1.2345666＝0.0000012＝1.2×10^{-6}$  

### ごにょごにょ

丸め誤差と打ち切り誤差はわかる。  
言葉通りだからね。  
情報落ちと桁落ちが毎回怪しい。  

情報落ちは物凄く大きな値と物凄く小さな値を足したり引いたりすることで発生する誤差。  
桁落ちは物凄く近い値同士を足したり引いたりすることで発生する誤差。  

桁落ちのほうが大きい値と小さい値を足して小さい値が反映されない(桁が落ちてる)=切り捨てられる感じがして、  
言葉のイメージ的に、しっくりくるのだが、世間ではそうではないらしい。  
まぁ、情報落ちもあっているいえばあっているか。  
小さい情報が丸々抜け落ちていることになるからな。  

桁落ちの本質は、有効桁以降の値を捨てること=落ちることにある。  
そのトリガーが近似値の加減算。
演算の結果が0.000001とかになるから、有効数字に合わせようと頑張った結果、存在しない桁は0で埋める。
その0埋め部分の結果が保証されない。  

---

## 離散数学 集合論

### 分配法則

``` math
A∪(B∩C)＝(A∪B)∩(A∪C)\\
A∩(B∪C)＝(A∩B)∪(A∩C)
```

``` math : 理式の変形
\bar{x}
　\bar{A}・\bar{B}・C＋A・\bar{B}・C＋A・B・C＋A・B・C\\
＝C・(\bar{A}・\bar{B}＋\bar{A}・B＋A・B＋A・B)　//分配の法則\\
＝C・(\bar{B}・(\bar{A}＋A)＋B・(\bar{A}＋A))　//分配の法則\\
＝C・(\bar{B}＋B)　\bar{A}＋A＝1\\
＝C　\bar{B}＋B＝1\\
```

$\bar{A}+A = 1 : ∀$  
$\bar{A}・A = 0 : Φ$  

### 結合法則

論理演算の演算則の一つに「結合の法則」があります。  

$(A・B)・C＝A・(B・C)$  
$(A＋B)＋C＝A＋(B＋C)$  

排他的論理和(⊕)も論理和演算の一種ですので、論理和の場合と同様に結合の法則が成立するため、3つの演算記号のすべての場合で結合の法則が成立することになります。  
論理演算は集合演算と同様の性質を持っているので、上記の「結合の法則」をベン図を用いて表すと次のようになります。  

[論理和]  
![!](https://www.ap-siken.com/kakomon/29_haru/img/01_1.gif)  

[論理積]  
![!](https://www.ap-siken.com/kakomon/29_haru/img/01_2.gif)  

[排他的論理和]  
![!](https://www.ap-siken.com/kakomon/29_haru/img/01_3.gif)  

### ドモルガンの法則

$\bar{A}\bar{∪}\bar{B} = \bar{A}∩\bar{B}$  
$\bar{A}\bar{∩}\bar{B} = \bar{A}∪\bar{B}$  

### 空集合

空集合とは、要素（元）を一つも含まない集合。すべての集合は空集合を部分集合として持つ。  

数学の集合論で用いられる概念で、「何も含まない」状態を一つの集合として扱うようにしたもの。  
例えば、集合Xを偶数全体、集合Yを奇数全体とすると、両方に属する数は一つもないため、両者の共通部分は空集合となる（X∩Y=∅）。  

記号は「∅(ファイ)」  

### 部分集合

部分集合とは、ある集合Xの全ての要素が他の集合Yに含まれる(内包される)という2つの集合同士の関係を表し、数学記号"⊆"を用いて「X ⊆ Y」と表記します。  

#### 平成27年秋期　問2

集合A，B，Cに対して$\bar{A∪B∪C}$が空集合であるとき，包含関係として適切なものはどれか。  
ここで，∪は和集合を，∩は積集合を，$\bar{X}$は$X$の補集合を，また，X⊆YはXがYの部分集合であることを表す。  

→

まず設問の「$\bar{A∪B∪C}$が空集合」という記述から、すべての要素は集合A，B，Cのいずれかに含まれるという条件が付されていることが確認できます。  
さらに選択肢の右辺が全て「C」であるので、左辺の集合が集合Cに内包されているものをベン図に描いて導きます。  

![!](https://www.ap-siken.com/kakomon/27_aki/img/02.gif)  

ベン図で表すとCの部分集合となるのは「A∩B」とわかります。  

### 相補演算

相補演算とは、集合演算によって得られる結果が互いにもう一方の演算の補集合となっている関係、すなわち$A$と$\bar{A}$，X AND YとNOT (X AND Y)のような関係になっているものをいいます。  

#### 令和3年春期　問1  

排他的論理和(XOR)は、2つの入力値が異なれば真、同じであれば偽を返す論理演算で、演算結果は次のような真理値表となります。  

![!](https://www.ap-siken.com/kakomon/03_haru/img/01_1.gif)  

排他的論理和の相補演算になるのは、XORの補集合(XORのベン図の白い部分)が結果として得られる演算なので、答えとして適切なのは「等価演算」ということになります。  

![!](https://www.ap-siken.com/kakomon/03_haru/img/01_2.gif)  

### カルノー図

行・列それぞれの論理変数の組合せの結果が"真"となる場合に「1」を、"偽"となる場合に「0」を、その該当セルに書きこむことで論理式を図で表す方法です。  

カルノー図から論理式を導くには、表の中のすべての「1」が記入されているセルをグループ化して共通項を取り出すのですが、このグループ化は、  

1. グループ化するすべてのセルの値は1であること  
2. グループ化するセルの数は2Nであること  
3. カルノー図の上下の端、および左右の端は連続していると考える  

という3つのルールに則って行います。

#### 平成26年秋期　問1

A，B，C，Dを論理変数とするとき，次のカルノー図と等価な論理式はどれか。ここで，・は論理積，＋は論理和，$\bar{X}$はXの否定を表す。  

![!](https://www.ap-siken.com/kakomon/26_aki/img/01.gif)  

→

![!](https://www.ap-siken.com/kakomon/26_aki/img/01a.gif)  

次にグループごとに共通項を取り出して、その論理積を作ります。  
赤い枠で囲ったグループは、(ABCD)と(ABCD)なので、共通項はABD、論理積はA・B・Dになります。  
青い枠で囲ったグループは、(ABCD),(ABCD),(ABCD),(ABCD)なので、共通項はBD、論理積はB・Dになります。  

最後に"グループごとに生成された論理積"同士の論理和をとることで論理式が完成します。  
つまり、「A・B・D」と「B・D」の論理和である「A・B・D＋B・D」が適切な式です。  

### 集合論 問題

#### 令和元年秋期　問2

全体集合S内に異なる部分集合AとBがあるとき，$\bar{A}∩\bar{B}$に等しいものはどれか。  
ここで，A∪BはAとBの和集合，A∩BはAとBの積集合，AはSにおけるAの補集合，A－BはAからBを除いた差集合を表す。  

→  

[問題文 $\bar{A}\bar{∩}\bar{B}$]  
![!](https://www.ap-siken.com/kakomon/01_aki/img/02.gif)  

ア  
![!](https://www.ap-siken.com/kakomon/01_aki/img/02a.gif)  

イ  
![!](https://www.ap-siken.com/kakomon/01_aki/img/02i.gif)  

ウ  
![!](https://www.ap-siken.com/kakomon/01_aki/img/02u.gif)  
AとBの共通部分は $0or0$ なので0。  

エ  
![!](https://www.ap-siken.com/kakomon/01_aki/img/02e.gif)  

したがって$\bar{A}∩\bar{B}$と結果が等しくなる演算は「$\bar{A}$－B」となります。

---

## 応用数学

### 相関係数

2つの項目の関連度合いを示す値です。  

値として－1～＋1の間の実数値をとり、－1 に近ければ負の相関、＋1 に近ければ正の相関があるといいます。
逆に値が0に近いときには2項目間の相関は弱いと判断されます。  
正負の方向は相関の強さには関係しないので、負の相関といっても、正に比べて関連性が弱いわけではありません。  
相関係数の絶対値の大きさ(1にどれだけ近いか)がそのまま相関性の強さを示します。  

例)  
平成29年秋期　問1  
相関係数に関する記述のうち，適切なものはどれか。  
→  
すべての標本点が正の傾きを持つ直線上にあるときは，相関係数が＋1になる。  

### 正規分布

平均値を中心とする左右対称で釣鐘状の連続確率分布のこと  
平均値を中心に左右対称の山のようなカーブを描く確率分布で、平均と標準偏差だけで分布に関する全ての特性が規定できるという特徴があります。  

### 標準偏差

データの分布のばらつきを表す尺度で、正規分布では平均値と標準偏差(σ[シグマ])、および度数の間に次の関係が成り立っています。  
平均±σの範囲に全体の約68%が含まれる  
平均±2σの範囲に全体の約95%が含まれる  
平均±3σの範囲に全体の約99%が含まれる  

例：平均が60、標準偏差が10の場合、標準偏差±σの範囲(60±10=)は50～70となる。  

#### 平成30年秋期　問3

受験者1,000人の4教科のテスト結果は表のとおりであり，いずれの教科の得点分布も正規分布に従っていたとする。90点以上の得点者が最も多かったと推定できる教科はどれか。

![!](https://www.ap-siken.com/kakomon/30_aki/img/03.gif)  

各教科の90点以上の得点者の割合は、点数分布を図で表してみると一目瞭然です(90点以上の部分を赤色で示しています)。
![!](https://www.ap-siken.com/kakomon/30_aki/img/03a.gif)  
最も90点以上の得点者が多いのは「教科B」です。

※100点を超えていてもいいらしい。  

### ワイブル分布

故障確率に用いられ，バスタブのような形状をした連続確率分布のこと

### ポアソン分布

離散的に発生し，発生確率は一定である離散確率分布のこと

### 一様分布

全ての事象の起こる確率が等しい現象を表す確率分布のこと

### モンテカルロ法

モンテカルロ法は、数値解析の分野において、確率を近似的に求めるために使われる手法です。  
n回のシミュレーションを行い、ある事象がm回起これば、その事象の起こる確率は m／nで近似できます。  
試行回数nが大きくなるほど、よい近似値となります。  

### オイラー法

オイラー法は、常微分方程式の数値的解法の一つで、初期値である点(x0，f(x0))における接線を求め、その接線の傾きと十分に小さい刻み幅hを用いて x1=x0+h、x2=x1+h、…における y(x) の順次求めていくことで近似値を得る方法です。  

### ガウスの消去法

ガウスの消去法（掃き出し法）は、行列表現を用いて、前進消去と後退代入という2つのステップで連立一次方程式などを解くための方法です。  

### シンプソン法

数値積分法の一つで、非線型方程式の3点を通る二次関数で各区間を近似することで、2点を使う台形公式よりも高精度の近似値を求める方法です。  

### ニュートン法

ニュートン法は、微分方程式の解の一つを求める方法で、任意に定めた解の予測値から始めて、接線とx軸の交点を求める計算を繰り返しながら、その値を f(x) = 0 となるxに近づけていく方法です。  
計算前のxと計算後のxの差が設定した誤差の範囲になるまで計算を繰り返します。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/01.gif)  

#### 令和3年秋期　問1

非線形方程式 f(x)＝0 の近似解法であり，次の手順によって解を求めるものはどれか。  
ここで，y＝f(x) には接線が存在するものとし，(3)でx0と新たなx0の差の絶対値がある値以下になった時点で繰返しを終了する。  

〔手順〕  
(1) 解の近くの適当なx軸の値を定め，x0とする。  
(2) 曲線 y＝f(x) の，点(x0，f(x0))における接線を求める。  
(3) 求めた接線と，x軸の交点を新たなx0とし，手順(2)に戻る。  

### 待ち行列モデル

待ち行列モデル M/M/1では、条件としてトランザクションの到着間隔はランダムであり、待ち行列内のトランザクション数は一定であるとしています。（平衡状態）  

「客はランダムに到着し(M)、1人の客がサービスを受ける時間はバラバラ(M)、サービスを行う窓口は1つ」  

平均待ち時間は、処理待ち行列に並んでからサービス(処理)が開始されるまでの待ち時間の平均であり、M/M/1の待ち行列モデルでは、平均待ち時間を以下の公式で計算します。  
※言い換えれば、サービス(処理)要求が発生してから、実際にサービス(処理)を受けるまでの時間  

``` txt : 平均待ち時間の公式
   利用率
------------ × 平均サービス時間
 1 - 利用率
```

#### 平成28年春期　問3

多数のクライアントが，LANに接続された1台のプリンタを共同利用するときの印刷要求から印刷完了までの所要時間を，待ち行列理論を適用して見積もる場合について考える。  
プリンタの運用方法や利用状況に関する記述のうち，M/M/1の待ち行列モデルの条件に反しないものはどれか。  

この条件を考えると、プリンタの処理状況によって処理要求の到着間隔を操作する行為は条件に反すると言えると思います。  
→  
印刷の緊急性や印刷量の多少にかかわらず，先着順に印刷する。  

一つの印刷要求から印刷完了までの所要時間は，印刷の準備に要する一定時間と，印刷量に比例する時間の合計である。  
→  
印刷要求から印刷終了までの所要時間は、プリンタに印刷要求を出してからプリンタが他の印刷要求を処理するのを待つ時間と、自身の印刷要求が処理される時間の合計です。  

#### 令和3年秋期　問2

ATM(現金自動預払機)が1台ずつ設置してある二つの支店を統合し，統合後の支店にはATMを1台設置する。統合後のATMの平均待ち時間を求める式はどれか。ここで，待ち時間はM/M/1の待ち行列モデルに従い，平均待ち時間にはサービス時間を含まず，ATMを1台に統合しても十分に処理できるものとする。  

〔条件〕  
(1) 平均サービス時間：Ts  
(2) 統合前のシステムの利用率：両支店ともρ  
(3) 統合後の利用者数は，統合前の両支店の利用者数の合計  

→

``` txt
ATMにおける平均サービス時間は、1人の顧客がATMを使用する平均時間のことです。
また、利用率とは単位時間あたりにATMが使用されている割合です。
例えば、1人の顧客が平均して2分間ATMを使用し、1時間当たり15人にサービスを提供した場合を仮定すると、利用率は「(2分×15人)÷60分＝0.5」となります。

統合前の両支店に設置してあるATM2台の平均サービス時間は同じですから、利用者数が多いほど利用率は高くなると考えられるところ、両支店の利用率は同じ"ρ(ロー)"なので、利用者数は同じであったことがわかります。
統合後の支店では、平均サービス時間が従前と同じであるATM1台で2倍の利用者を処理することになるので、利用率は単純に2倍の"2ρ"になります。

したがって、この式の利用率の部分に"2ρ"を当てはめた「エ」が適切となります。
```

※統合して2倍の利用者を1台で捌く→利用率は2倍になる→ρは2ρになる。  

#### 平成30年秋期　問2

コンピュータによる伝票処理システムがある。このシステムは，伝票データをためる待ち行列をもち，M/M/1の待ち行列モデルが適用できるものとする。平均待ち時間がT秒以上となるのは，処理装置の利用率が少なくとも何%以上となったときか。ここで，伝票データをためる待ち行列の特徴は次のとおりである。

・伝票データは，ポアソン分布に従って到着する。  
・伝票データをためる数に制限はない。  
・1件の伝票データの処理時間は，平均T秒の指数分布に従う。  

→  

``` txt
M/M/1の詳細な説明については割愛しますが、待ち行列モデルでの平均待ち時間とは、サービス(処理)要求が発生してから、実際にサービス(処理)を受けるまでの時間を指します。

平均待ち時間を求める公式は次の通りです。

　{利用率／(1－利用率)}×平均サービス時間

問題文には「1件の伝票データの処理時間は，平均T秒の指数分布に従う。」とあり、平均サービス時間はT秒となります。

平均待ち時間がT秒以上となる利用率を求めたいので、

　{利用率／(1－利用率)}×T

の式で解がT秒以上となる利用率を求めればよいわけです。
式を見ると{利用率／(1－利用率)}の部分が1以上であれば、平均サービス時間はT秒以上になることがわかるので、利用率をρ(ロー)として方程式を解くと、
　
　ρ／(1－ρ)≧1
　ρ≧1－ρ
　2ρ≧1
　ρ≧0.5

上記から利用率が50%以上であるときに、平均待ち時間がT秒以上となることがわかります。したがって「イ」が正解です。
```

#### 応用参考書1

平均回線待ち時間、平均伝送時間、平均回線利用率の関係がMM1の待ち行列モデルに従う時、平均回線待ち時間を平均伝送時間の3倍以下にしたい。  
平均回線利用率を最大何%以下にすべきか。  

→  

・平均回線待ち時間 → 平均待ち時間  
・平均伝送時間 → 平均サービス時間
・平均回線利用率 → 利用率

``` txt : 平均回線待ち時間の求め方
                     平均回線利用率
平均回線待ち時間 = ------------------- × 平均伝送時間
                   1 - 平均回線利用率
```

平均回線待ち時間をW、平均伝送時間をT、平均回線利用率をρとし、「平均回線待ち時間Wが平均伝送時間Tの3倍以下」となる式

$W ≦ 3*T → ρ/1-ρ + T ≦ 3T$  
$ρ/1-ρ ≦ 3$  
$ρ ≦ 3*(1-ρ)$  
$ρ ≦ 0.75)$  

#### 令和元年秋期　問3

通信回線を使用したデータ伝送システムにM/M/1の待ち行列モデルを適用すると，平均回線待ち時間，平均伝送時間，回線利用率の関係は，次に式で表すことができる。  
![!](https://www.ap-siken.com/kakomon/01_aki/img/03.gif)  
回線利用率が0%から徐々に増加していく場合，平均回線待ち時間が平均伝送時間よりも最初に長くなるのは，回線利用率が幾つを超えたときか。  

→  

平均回線待ち時間が平均伝送時間より長くなるには、![!](https://www.ap-siken.com/kakomon/01_aki/img/03_1.gif)が1より大きくなることが条件です。  
![!](https://www.ap-siken.com/kakomon/01_aki/img/03_1.gif)に回線利用率を当てはめていくと、回線利用率が0.5のときにちょうど1となり、回線利用率が0.5を超えると1を超えて「平均回線待ち時間＞平均伝送時間」となることが、設問の関係式からわかります。  

したがって正解は0.5です。

---

## 応用数学 計算問題

### 基本 令和元年秋期　問6

Random(n)は，0以上n未満の整数を一様な確率で返す関数である。整数型の変数A，B及びCに対して次の一連の手続を実行したとき，Cの値が0になる確率はどれか。
　　A＝Random(10)
　　B＝Random(10)
　　C＝A－B

→
Random(10)の返す値は整数0～9なので、Aがとり得る値は10種類、Bも同様に10種類となります。これより、確率の分母となるAとBの組合せ総数は次のように計算できます。
　10通り×10通り＝100通り

Cの値が0、すなわち「A－B＝0」となるのは、AとBが同じ値のときのみです。これは、A=B=0，A=B=1，…，A=B=9 というように全部で10通りあります。
したがって、Cの値が0になる確率は、
　10通り／100通り＝1／10

### 基本 平成30年春期　問2

図の線上を，点Pから点Rを通って，点Qに至る最短経路は何通りあるか。

→
どの経路も「上方向に2回，右方向に2回」の移動を行うことは同じです。
4回行われる移動のうち上2回の位置が決まると自動的に右2回の位置も決定することから、経路の組合せ数は、4つの中から2つを選ぶ組合せ数と同様の計算で求めることができることになります。

つまり点Pから点Rに至る経路数は、組合せの公式※を用いて次のように求められます。
4C2＝(4×3)／2＝6(通り)

同様に点Rから点Qに至る最短経路数は、
5C3＝(5×4×3)／(3×2)＝10(通り)

最終的に求める点Pから点Rを通って，点Qに至る最短経路ですが、点Pから点Rに至る6通りのそれぞれに対して、点Rから点Qに至る10通りが存在するので、
6×10＝60(通り)

正解は60通りになります。

### 基本 平成27年春期　問2

2けたの2進数x1x2が表す整数をxとする。2進数x2x1が表す整数を，xの式で表したものはどれか。ここで，int(r)は非負の実数r の小数点以下を切り捨てた整数を表す。

``` txt
x1 x2     x2 x1
1 1 = 3    1  1 = 3
1 0 = 2    0  1 = 1
0 1 = 1    1  0 = 2
0 0 = 0    0  0 = 0
```

``` math
(xと×が紛らわしいので掛けるを*で記述しています)

xは10進数で x1*2＋x2 なので、選択肢中の2xは10進数で以下のように示すことができます。

　2x＝x1*4＋x2*2　…①

また、x／2は、xを右に1ビットシフト(1／2)させたものなので、

　x1x2→(右へ1ビットシフト)→x1.x2("."は小数点)

さらに int()は整数部を取り出す操作なので、

　int(x1.x2)＝x1

したがって

　int(x／2)＝x1　…②

となります。

2進数x2x1を、10進数で表すと x2*2＋x1 で、先程の 2x との差分は x1 が3つ分です。

　x1*4＋x2*2 -x1*3＝x2*2＋x1

①、②より 2x＝x1*4＋x2*2、x1＝int(x／2) なので、上記の式中の左辺の該当部分を置き換えると、

　2x－3int(x／2)＝x2*2＋x1


ここまでがこの設問の正しい理解ですが実際の試験本番では、x1＝1，x2＝1 として、

　x1x2＝11(2)＝3(10)
　x2x1＝11(2)＝3(10)
　int(x／2)＝1

　3＝2*3－a
　a＝3

で「ウ」が正解としたり、x1＝1，x2＝0 として、

　x1x2＝10(2)＝2(10)
　x2x1＝01(2)＝1(10)
　int(x／2)＝1

　1＝2*2－a
　a＝3

とするなど簡単に計算できる値を代入して消去法で解く方法が現実的かもしれません。
```

### 平成29年春期　問5

次の数式は，ある細菌の第n世代の個数f(n)が1世代後にどのように変化するかを表現したものである。この漸化式の解釈として，1世代後の細菌の個数が，第n世代と比較してどのようになるかを説明しているものはどれか。

$f(n＋1)＋0.2×f(n)＝2×f(n)$

→

``` math
問題文で与えられた数式を整理することで正解を導きます。

　f(n＋1)＋0.2×f(n)＝2×f(n)
　f(n＋1)＝2×f(n)－0.2×f(n)
　f(n＋1)＝1.8×f(n)

計算式の表現する変化は「1世代後の個数"f(n＋1)"は、第n世代の個数"f(n)"の1.8倍に増える」が正しいとわかります。
したがって「ア」が正解です。
```

### 平成26年春期　問2

三つのグラフA～Cの同形関係に関する記述のうち，適切なものはどれか。ここで，二つのグラフが同形であるとは，一方のグラフの頂点を他方のグラフの頂点と1対1に漏れなく対応付けることができ，一方のグラフにおいて辺でつながれている頂点同士は他方のグラフにおいても辺でつながれていて，一方のグラフにおいて辺でつながれていない頂点同士は他方のグラフにおいても辺でつながれていないことをいう。

![!](https://www.ap-siken.com/kakomon/26_haru/img/02.gif)  

→  

グラフAとグラフBは、a1とb1，a2とb2というようにそれぞれの頂点が対応していますが、グラフAではa1－a4，a2－a5の頂点同士が辺でつながれているのに対して、グラフBは繋がれていないため同形ではありません。

グラフAとグラフCですが、下図のように グラフAのa0がグラフCのc3に、a3がc0にそれぞれ移動したと考えると、頂点と辺の両方が完全に一致していることになります。つまり頂点の位置が異なるだけでグラフAとグラフCは同形であると言えます。

![!](https://www.ap-siken.com/kakomon/26_haru/img/02a.gif)  

グラフBとグラフCは、グラフCがグラフAと同形であることから同形ではないことになります。  

### 平成29年春期　問2

(1＋α)^nの計算を，1＋n×αで近似計算ができる条件として、適切なものはどれか。

→  

``` math
仮に α＝0.01, n＝10 としてみると
　(1＋0.01)^10≒1.11
　1＋(10×0.01)＝1.10
となり近似計算が成り立ちます。

その他の選択肢の条件をすべて満たす α=100, n=2 を計算式に代入みても、

　(1＋100)2＝10201
　1＋(2×100)＝201

となり近似計算となりません。
```

aを0.0000000.....でnを2にした時、  
(1 + 00000000....)^2 = 2  
1+(2*0.0000000000...) = 1  
って思ったんで辞めたんですが、やり方がまずかったんですかね。  
あくまで近似なので、他よりましだったらなんでもいいんですかね。  
まぁ、もうどうでもいいですけど。  

---

## 計測・制御に関する理論

### フィードバック制御

出力結果と目標値とを比較して，一致するように制御を行う制御方式。  
制御対象の現在の状態を定期的に測定し、その測定値を目標値に近づけるように動作する自動制御方式です。  
室内の温度を一定に保つなどの自動制御システムで多く用いられています。  
フィードバック制御では、外乱を検知せず、その修正動作は目標値と測定値の差異によってのみ決定されます。  
したがって外乱が生じてもそれに対する修正動作は測定値に影響が現れてからになります。  

### フィードフォワード制御

外乱の影響が出力に現れる前に制御を行う制御方式。  
外乱自体を検知し、前もって出力への影響を打ち消すように動作します。  
一般的に、フィードフォワード制御はフィードバック制御と組み合わせて使用されます。  

### TOF(Time of Flight)方式

TOF方式は、光源から発せられた光が対象物に当たり、その反射光が光源と同じ位置にあるセンサに返ってくるまでの時間によって対象物との距離を測定する方式です。  
カメラを用いる方式と比較すると、カメラが不要な単純な構成、昼夜及び天候の影響を受けないなどの利点があります。  

光の速度は約30万キロメートル／秒なので、1ナノ秒に約30cm進むことになります。  
反射光を受け取るまでの時間が1ナノ秒増加すると、対象物との距離が「30cm÷2＝15cm」だけ離れたことになるというわけです。  

なお、TOF方式のセンサが採用されている家庭用ゲーム機とはMicroSoftのXboxです。  

### ジャイロセンサ

角速度(単位時間あたりの回転角)を検出するセンサで、主に以下の3つの用途で使用されます。  

・角速度の検出  
・傾き(角度)の検出  
・振動の検出  

例)  
携帯端末に搭載されているジャイロセンサが検出できるもの→端末の角速度  

### サーミスタ

温度の変化により抵抗値が大きく変化する半導体で、流れる電流量によって温度を測定することができます。  
－50℃から150℃程度の範囲に使えるので、一般的な温度センサとして用いられています。  
電子体温計の感温部がサーミスタです。  

※体温を測定するのに適切なセンサ  

### 超音波センサ

超音波センサは、発出した超音波が対象物に当たり、その反射が返ってくるまでの時間を計測することで対象物までの距離を測定するセンサです。

### フォトトランジスタ

フォトトランジスタは、フォトダイオードとトランジスタが一体になった電気部品で、フォトダイオードが光を電気エネルギーに変換し、トランジスタがそれを増幅して出力します。  
光の検出ができるのでリモコン、カメラ、自動ドアのセンサなどに用いられています。  

### ポテンショメータ

ポテンショメータは、抵抗値を任意に変化させることのできる電気部品で、オーディオのボリューム調整や角度検出などに用いられます。  

### リアルタイムシステム(Real-time System)

使える資源(リソース)に限りがある状態で、ジョブの実行が命令された時、その処理を決められた時刻(デッドライン)までに終了することに着目した制御工学における概念の一つであり、「即時処理」とも呼ばれています。  

車に装備されているエアバッグの制御もリアルタイムシステムの実例の一つで、設定されている制限時間内に処理が終了することが制御システムに求められる第一条件となります。  

※リアルタイムシステムでは、時間資源の保護および実行時間の予測可能性を提供することに特化したRTOS(Real-time operating system)により管理されています。  
※リアルタイムシステムでのタスクスケジューリングは、到着順方式ではなく優先度方式が用いられます。  
※入力時刻を記録することよりも、出力を制限時間内に完了することがリアルタイムシステムに求められることです。  

---

## 計測・制御に関する理論 計算問題

---

## 通信に関する理論

### CRC方式(Cyclic Redundancy Check，巡回冗長検査)

送信側では，ビット列をある生成多項式で割った余りをそのビット列に付加して送信し，受信側では，受信したビット列が同じ生成多項式で割り切れるか否かで誤りの発生を判断する誤り検査方式。  
送信データから生成多項式によって誤り検出用のデータを付加して送信します。  
受信側では送信側と同じ生成多項式を用いて受信データを除算し、送信されてきた誤り検出用のデータと比較することで誤りの有無を判断することができます。  
単純なパリティチェックでは検出できない偶数個の誤りやバースト誤りを検出できるという特長があります。  

「生成多項式」というキーワードが出たらCRC方式と覚えましょう。  
この方式は他の誤り検出方式では使用されません。  

### ハミング符号方式

ハミング符号は、情報ビットに対して検査ビットを付加することで、2ビットの誤り検出と1ビットの自動訂正機能をもった方式です。  

#### 平成30年春期　問3

ハミング符号とは，データに冗長ビットを付加して， 1ビットの誤りを訂正できるようにしたものである。ここでは，X1，X2，X3，X4の4ビットから成るデータに，3ビットの冗長ビットP3，P2，P1を付加したハミング符号 X1X2X3P3X4P2P1 を考える。付加ビットP1，P2，P3は，それぞれ
　　X1⊕X3⊕X4⊕P1＝0
　　X1⊕X2⊕X4⊕P2＝0
　　X1⊕X2⊕X3⊕P3＝0
となるように決める。ここで⊕は排他的論理和を表す。
　ハミング符号 1110011 には1ビットの誤りが存在する。誤りビットを訂正したハミング符号はどれか。

→  

``` txt
ハミング符号 1110011 をデータビットと冗長ビットに分けると次のようになります。
X1=1，X2=1，X3=1，X4=0，
P1=1，P2=1，P3=0
各ビットを問題中の3つの式に当てはめて、誤りを検証します。
1⊕1⊕0⊕1＝1
1⊕1⊕0⊕1＝1
1⊕1⊕1⊕0＝1
存在する誤りが1ビットであり、すべての式の結果が0ではないということは、唯一すべての式に含まれているX1が誤りビットであると判断できます。

したがって、訂正前のハミング符号「1110011」のX1(1ビット目)を0に反転させた「0110011」が正解となります。
```

### 垂直パリティチェック方式

垂直パリティチェック方式は、データに検査用のパリティビットを付加することによって誤りを検出する方式です。  

### 水平パリティチェック方式

水平パリティチェック方式は、パリティビットを付加する方向が違うだけで垂直パリティチェックと同じです。  

### パリティチェック

データ通信やメモリチェックなどにおいてデータのビット誤りを検出する最もシンプルな方法の一つです。  
一定長のビット列（通常は7～8ビット）ごとに1ビットの検査ビット（パリティビット）を付加し、検査側が受信データとパリティビットを照合することで誤りを検出します。  

データのビット列とパリティビットを合わせて"1"のビット数が奇数になるようにパリティビットを付加する方式を奇数パリティ、偶数になるように付加する方式を偶数パリティといいます（設問の図は偶数パリティ）。  

チェック方式にも2種類あり、送信データそれぞれに対してパリティを付加する方式を垂直パリティ、1番目のデータブロックの1ビット目、2番目のデータの1ビット目、…、n番目のデータの1ビット目というようにデータブロックの並びに対して付加する方式を水平パリティといいます。  
また、両者を併用して2方向にパリティを付加する方式を「垂直水平パリティ」と言います。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/04_1.gif)  

### 垂直水平パリティ

2方向にパリティを付加するのが「垂直水平パリティ」です。  
パリティチェックは基本的には誤りの検出を目的としていて、誤りを検出したときには送信元に再送を依頼するのですが、垂直水平パリティ方式ではビット誤りの検出にとどまらず、垂直・水平の併用で誤り位置を特定することにより、**1ビットであれば正しいデータに訂正することが可能**となっています。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/04_2.gif)  

例)令和3年秋期　問4  
パリティで訂正できるビットの数で1以上なんて聞いたことがない。  

---

## 情報に関する理論

### 機械学習(Machine Learning)

コンピュータに大量の学習データを与え、数学的アプローチによって自律的にデータの特徴点を見出して、コンピュータに人間のようなパターン認識や分類能力をもたせるAIの分野です。教師あり学習、教師なく学習、強化学習などの学習方法があります。  
学習方法をプログラムしたコンピュータに大量の訓練データを与えることで、コンピュータ自らに事象の認識や分類方法を学習させ、未知のデータに対しても学習結果に基づく推論を行うシステムを作る手法の総称です。  

キーワード「大量のデータ。特定パターン。」  

機械学習:  
入力層→中間層→出力層  

機械学習は、訓練データの性質によって「教師あり学習」「教師なし学習」「強化学習」の3つに大別できます（※強化学習を教師なし学習に含めることもあります）。  

![!](https://www.ap-siken.com/kakomon/01_aki/img/04.gif)  

教師あり学習と教師なし学習の違いは、入力データに対する正しい答え(出力)が与えられているかどうかです。  

教師あり学習による分類では、正解となる分類先があらかじめ定義されていますが、教師なし学習の分類では、与えられた入力データ同士の類似度分析などを通してシステム自らがグループを定義し、グルーピングします。  
クラスタリングは教師なし学習の代表的な活用事例です。  

### 教師あり学習

訓練データとして、ラベル(正解)付きデータを使用する学習方法。  
入力に対する正しい出力の例を与えることで、入力と出力の関係を学習させる。  

例)  
正解のデータを提示したり，データが誤りであることを指摘したりすることによって，未知のデータに対して正誤を得ることを助ける。  

### 教師なし学習

訓練データとして、ラベルなしデータを使用する学習方法。  
クラスタリングなどのためにデータ構造を学習させる。  

※クラスタリングやフィルタリング等

例)  
・正解のデータを提示せずに，統計的性質や，ある種の条件によって入力パターンを判定したり，クラスタリングしたりする。  
・データ同士の類似度を定義し，その定義した類似度に従って似たもの同士は同じグループに入るようにデータをグループ化するクラスタリング  
・コンピュータ利用者の挙動データを蓄積し，挙動データの出現頻度に従って次の挙動を推論する。  
→協調フィルタリングの説明です。  

### 強化学習

正解データの代わりに、与えられた環境における個々の行動に対して得点や報酬を与える学習方法。  
一連の行動に対して評価値を与えることで、高い得点を取る、すなわち最良の行動を自律的に学習させる。  

例)  
個々の行動に対しての善しあしを得点として与えることによって，得点が最も多く得られるような方策を学習する。  

### ディープラーニング(Deep Learning)

人間や動物の**脳神経**をモデル化したアルゴリズム(ニューラルネットワーク)を多層化したものを用意し、それに「十分な量のデータを与えることで、人間の力なしに自動的に特徴点やパターンを学習させる」ことをいいます。  
人工知能分野における要素技術の1つで、深層学習とも呼ばれます。  
従来の機械学習と異なり、中間層の多層化によって複雑なパターンの表現と計算を可能にしていることが特徴です。  

![!](https://www.ap-siken.com/kakomon/31_haru/img/03.gif)  

ディープラーニングでは、脳の神経細胞であるニューロンの信号伝達をパーセプトロンというアルゴリズムで模倣し、それを大量かつ幾層にもに繋ぎ合わせた疑似的な脳神経網ネットワークを使用して学習を行います。  

![!](https://www.ap-siken.com/kakomon/03_aki/img/03.gif)  

このネットワークに大量の学習用データ(入力値と正しい解の組み)を与え、損失関数や勾配法、誤差逆伝播法などの数学的なアプローチを用いて、出力と正しい解の差異が最小になるように中間層のパラメタ(重みとしきい値)を自動調整していきます。  
この仕組みにより、入力に対して最適解を出力するシステム(学習モデル)を得るのがディープラーニングです。  
学習させるデータが多いほど判定の精度も高まっていきます。  

※キーワード「人間の脳を模倣。ニューラルネットワーク。」  
※中間層を増やして更なる推論をした奴。
入力層→中間層→中間層→中間層→...→出力層  

### データマイニング

・大量のデータからまだ知られていない新たな規則や仮説を発見するために，想定値から大きく外れている例外事項を取り除きながら分析を繰り返す手法である。  
・多様なデータや大量のデータに対して，三段論法，統計的手法やパターン認識手法を組み合わせることによって，高度なデータ分析を行う手法である。  

### UTF-8

UTF-8は、ASCIIと同じ文字は1バイト、その他の文字については2～6バイトを用いて世界中の文字を表現する文字符号化形式です。  
ASCIIの上位互換であるため、従来のシステムとの親和性が高く、またASCII主体のテキストであればデータ量をそれほど増加させずに多言語対応の恩恵を受けられる利点があります。  
UTF-8は世界中で使用されていますが、特にWebページを記述する際の文字コードとしてはスタンダードと呼ばれるほど普及しています。  
UTF-8は可変長なので先頭のビット"1"が連続する個数で、その文字のバイト数がわかるようになっています。  
なお漢字を含む日本語の文字は3バイトで表現されます。  

※1文字を1バイトから4バイト(又は6バイト)までの可変長で表現しており，ASCIIと上位互換性がある。  

**UTF-16(UCS-2)**  
2バイトで表現する領域に収まらない文字は，上位サロゲートと下位サロゲートを組み合わせて4バイトで表現する。  
1文字を2バイトで符号化するUTF-16(UCS-2)の説明です。  

**UTF-7**  
ASCII文字だけを使用することが前提の電子メールで利用するために，7ビットで表現する。  

**UTF-32(UCS-4)**  
各符号位置が4バイトの固定長で表現される符号化形式である。  
1文字を4バイトで符号化するUTF-32(UCS-4)の説明です。  

### アナログ,ディジタル変換

平成28年秋期　問5
アナログ信号からディジタル信号への変換では標本化、量子化、符号化の3段階で処理をします。  

#### 平成27年秋期　問4

アナログ電圧をディジタル化した後に演算処理することの利点として，適切なものはどれか。

→

演算結果が部品精度，温度変化及び外来雑音の影響を受けにくい。

→
アナログ電圧は、値が時間的に連続的に変化する波として表されます。
ディジタル値への変換は、ある一定周期ごとにサンプリングした電圧値を8ビット(256段階)、10ビット(1,024段階)などで表現することで行います。

例として0V～8Vの範囲で変化するアナログ電圧を2ビットのディジタル値に変換する場合を考えてみます。
2ビットでは「00」「01」「10」「11」の4種類のビットパターンを表現できるので、次のように4段階に分けて数値化します。
2V以下 → 00
2V超～4V以下 → 01
4V超～6V以下 → 10
6V超～8V以下 → 11
アナログ値では外来ノイズが測定される値にダイレクトに影響しますが、ディジタル化ではある一定範囲内の値はすべて同じディジタル値に変換されることになります。
少々のノイズが有っても範囲内に収まっていれば変換後の値に変化はないので、ディジタル化された値はノイズの影響を受けにくい特徴があります。

電圧が変化してから演算結果を得るまでの遅延時間が発生しない。  
先にデジタル化してから演算するので、遅延がないと思っていたけど、デジタル化に時間がかかればそもそも遅延となってしまうか。
ディジタル化に要する時間によって遅延が発生することがあります。

演算結果が部品精度，温度変化及び外来雑音の影響を受けにくい。
はて、回答だけ見てもさっぱりである。

---

## 情報に関する理論 オートマトン

現在の状態と入力信号の組合せだけによって次に遷移する状態が決まるモデルです。  
初期状態のS1を例に挙げると、入力信号が0であれば再度S1に遷移し、入力信号が1であればS2に遷移するといった具合です。  

### 平成28年秋期　問4

次の表は，入力記号の集合が{0，1}，状態集合が{a，b，c，d}である有限オートマトンの状態遷移表である。長さ3以上の任意のビット列を左(上位ビット)から順に読み込んで最後が110で終わっているものを受理するには，どの状態を受理状態とすればよいか。  
![!](https://www.ap-siken.com/kakomon/28_aki/img/04.gif)  

→  

表の有限オートマトンを図にすると次のようになります。  
![!](https://www.ap-siken.com/kakomon/28_aki/img/04a.gif)  

ビット列「110」が入力されるときに、a～dのどの状態であるかはわかりませんが、最後の0が入力されて遷移する先はaかcのどちらかしかないので、bとdは正解候補から除外できます。

aとcを比較してみると、cが受理状態となるケースは、
b→(1)→d→(1)→d→(0)→c
c→(1)→b→(1)→d→(0)→c
a→(1)→b→(1)→d→(0)→c
d→(1)→d→(1)→d→(0)→c
という4通りが考えられます。

一方aが受理状態となるケースを考えてみると、aの直前状態のうち、aに遷移するには状態aまたはcに0が入力されなければならず、cに遷移するには状態bまたはdに0が入力されなければならないので、aが受理状態になるには入力ビット列の後ろ2つが「0」であることが必要条件になります。したがって「110」を受理するルートはありません。

以上より「c」が正解とわかります。

【別解】
ビット列「110」が入力されるときに、a～dのどの状態であるかはわかりませんが、最初の1が入力されて遷移する先はbかdのどちらかしかなく、次の1が入力されて遷移する先はdしかないので、最後の0が入力されて遷移する先はcです。

---

## 情報に関する理論 サンプリング

### 標本化

時間的に連続したアナログ信号(振幅、周波数、電圧など)を一定の時間間隔で測定する  

### 量子化

標本化で得られた数値を整数などの離散値で近似する  

### 符号化

量子化で得られた整数値を2進数のビットに対応付ける  

### サンプリング周波数

標本化において、1秒間にアナログ音声からデータを取得する回数を示します。  
また量子化ビット数は、量子化において、1回ごとの取得データを何ビットで表現するかを示します。  

### 平成28年春期　問4

PCM伝送方式によって音声をサンプリング(標本化)して8ビットのディジタルデータに変換し、圧縮せずにリアルタイムで転送したところ、転送速度は64,000ビット／秒であった。このときのサンプリング間隔は何マイクロ秒か。

→
**"転送速度は64,000ビット／秒であった"ということは、1秒ごとに64,000ビットのデータが生成されているということです。**
1回のサンプリング(標本化)で生成されるデータは8ビットですから、64,000を8で割れば、1秒間に何回サンプリングが行われているかがわかります。
　64,000÷8＝8,000回

1秒間に8,000回のサンプリングを行うためには、以下の周期(サンプリング周波数)でデータを取得する必要があります。
　1秒÷8,000回＝125マイクロ秒

因みに標本化→量子化→符号化ね。
量子化はアナログの数値をデジタル化できるように近似する作業。
符号化は0，1に変換する作業。

### 平成31年春期　問22

音声を標本化周波数10kHz，量子化ビット数16ビットで4秒間サンプリングして音声データを取得した。この音声データを，圧縮率1／4のADPCMを用いて圧縮した場合のデータ量は何kバイトか。ここで，1kバイトは1,000バイトとする。

→

``` math
標本化周波数が10kHzなので、1秒間のサンプリング回数は次のように計算できます。

　10k→10,000(回)

つまり4秒間で40,000回のサンプリングが行われることになります。さらに各サンプリングデータを16ビット＝2バイトで量子化するため、量子化後のデータ量はサンプリング回数に2を乗じた値になります。

　40,000×2＝80,000(バイト)

このデータがADPCMで1／4に圧縮されるため、圧縮後のデータ量は以下のようになります。

　80,000×1／4＝20,000(バイト)＝20(kバイト)
```

### 令和3年春期　問3

サンプリング周波数40kHz，量子化ビット数16ビットでA/D変換したモノラル音声の1秒間のデータ量は，何kバイトとなるか。ここで， 1kバイトは1,000バイトとする。

``` txt
つまり、この問題のA/D変換は以下の条件で行うことになります。
サンプリング周波数40kHz → 1秒間に40,000回データを取得する
量子化ビット数16ビット → 各々のサンプリングデータを16ビットで表現する
1秒間のデータ量は「サンプリング回数×量子化ビット数」で求められるので、

　40,000回×16ビット＝640,000ビット＝640kビット

単位をバイトに変換して、

　640kビット÷8＝80kバイト
```

---

## 情報に関する理論 ハフマン符号化

可変長の符号化方式で、出現確率が高いデータには短い符号を、低いデータには長い符号を与えることで圧縮を効率よく行う方法です。  
特に、出現確率に差がある場合には固定長の符号化よりも高い圧縮率になります。  

ハフマン符号では、符号化のビット列に全く同じ符号の並びが存在しないように、ある文字に対応する符号が、他の文字に対応する符号の接頭辞にならないように設定されます。  
これにより単純に先頭から読んでいくだけでデコードができます。  

``` txt
010000111101011000101110111001
↓
01 00 00 111 10 10 110 00 10 111 01 110 01
↓
BAAECCDACEBDB
```

設問の表を見ると"00"、"01"、"10"、"111"は既に割当て済なので、Dにはこれ以外のビット列から開始する符号を与える必要があります。

### 平成30年春期　問2

表は，文字A～Eを符号化したときのビット表記と，それぞれの文字の出現確率を表したものである。1文字当たりの平均ビット数は幾らになるか。  
![!](https://www.ap-siken.com/kakomon/30_haru/img/02.gif)  

→

``` txt
各文字を表すビット数とその出現確率をかけたものを足し合わせて平均ビット数を求めます。
A → 1ビット×0.5＝0.5ビット
B → 2ビット×0.3＝0.6ビット
C → 3ビット×0.1＝0.3ビット
D → 4ビット×0.05＝0.2ビット
E → 4ビット×0.05＝0.2ビット
すべてを足し合わせると、

　0.5＋0.6＋0.3＋0.2＋0.2＝1.8ビット

したがって、平均ビット数は1.8ビットになります。

このように情報の出現確率が高いデータには短い符号を、低いデータには長い符号を与えることで圧縮を効率よく行う方法をハフマン符号といいます。
```

### 令和2年秋期　問4

a，b，c，d の4文字からなるメッセージを符号化してビット列にする方法として表のア～エの4通りを考えた。この表は a，b，c，d の各1文字を符号化するときのビット列を表している。メッセージ中の a，b，c，d の出現頻度は，それぞれ，50%，30%，10%，10% であることが分かっている。符号化されたビット列から元のメッセージが一意に復号可能であって，ビット列の長さが最も短くなるものはどれか。

![!](https://www.ap-siken.com/kakomon/02_aki/img/04.gif)  

→  

``` txt
最小ビットで圧縮できる方式を考える前に、各方式が符号化されたビット列から元のメッセージを一意に復号可能かどうかを検証し、条件を満たす方式についてだけビット数を計算します。

ア 文字列bb(11)と、d(11)の区別がつかず一意の復号は不可能です。

イ abc(00110)と、aada(00110)の区別がつかず一意の復号は不可能です。

ウ 並べてみるとわかりますが、一意の復号が可能です。
各文字の出現頻度を考慮すると、1文字を表現するのに必要な平均ビットは、
　(1×0.5)＋(2×0.3)＋(3×0.1)＋(3×0.1)
＝0.5＋0.6＋0.3＋0.3＝1.7
となり、4つの中では復号可能かつビット列の長さが最も短くなる方法となります。

エ 各文字が2ビットずつなので一意の復号が可能です。
1文字を表現するのに必要な平均ビットは2ビットなので、「ウ」の方式よりはビット列が長くなります。

この設問の例のように、出現度の高い文字を短いビット列で、出現率が低い文字を長いビット列で表現することで、1文字を表現するのに使用する平均ビット長を最小とする圧縮技術をハフマン符号化と言います。
```

先に文字を作る。  
数字に変換したときに他の文字に置き換えることができるか確かめる。  

### 平成29年秋期　問3

四つのアルファベットa～d から成るテキストがあり，各アルファベットは2ビットの固定長2進符号で符号化されている。  
このテキストにおける各アルファベットの出現確率を調べたところ，表のとおりであった。  
各アルファベットの符号を表のような可変長2進符号に変換する場合，符号化されたテキストの，変換前に対する変換後のビット列の長さの比は，およそ幾つか。  

![!](https://www.ap-siken.com/kakomon/29_aki/img/03.gif)  

※単純な長さではなく、元の長さとの比であることに注意。  

→

``` txt
各文字を可変長2進符号で表したときのビット列の長さは次の通りです。
a → 0 → 1ビット
b → 10 → 2ビット
c → 110 → 3ビット
d → 111 → 3ビット
文字ごとに出現確率が異なっているので、各ビットを文字の出現率で重み付けすることで1文字に要する平均ビット長を算出します。

　1×0.4＋2×0.3＋3×0.2＋3×0.1
＝0.4＋0.6＋0.6＋0.3
＝1.9(ビット)

変換前(固定長2進符号)には1文字が2ビットだったので、変換前に対する変換後のビット列の長さの比は、

　1.9÷2＝0.95
```

---

## 情報に関する理論 BNF(Backus-Naur Form)

バッカス・ナウア記法とも呼ばれ、XMLをはじめ多くのプログラム言語の構文定義に用いられている記法です。
BNFで使われている各記号は、「::＝」が左辺と右辺の区切り、「｜」がor(または)、「＜＞」は非終端記号を表しています。
それぞれのBNFは次のように解釈することができます。

＜数字＞
1～9までの1文字
＜英字＞
A～Fまでの1文字
＜英数字＞
＜数字＞または＜英字＞または"_"
＜変数名＞
＜英字＞1文字、または＜変数名＞の後ろに＜英数字＞が付いたもの

ある文字列が特定の非終端記号に合致するかどうかを判断する場合、文字を非終端記号に置き換えることを繰り返して、
最終的に目的の非終端記号(本問では＜変数名＞)の形になるかを考えていきます。

### 令和元年秋期　問7

次のBNFで定義される＜変数名＞に合致するものはどれか。

　＜数字＞::＝ 0｜1｜2｜3｜4｜5｜6｜7｜8｜9  
　＜英字＞::＝ A｜B｜C｜D｜E｜F  
　＜英数字＞::＝＜英字＞｜＜数字＞｜_  
　＜変数名＞::＝＜英字＞｜＜変数名＞＜英数字＞  

_B39
↓
＜英数字＞＜英字＞＜数字＞＜数字＞
↓
＜英数字＞＜英字＞＜英数字＞＜英数字＞
↓
＜英数字＞＜変数名＞＜英数字＞
↓
＜英数字＞＜変数名＞
先頭文字が"_"なので＜変数名＞には合致しません。

3E5
↓
＜数字＞＜英字＞＜数字＞
↓
＜数字＞＜英字＞＜英数字＞
↓
＜英数字＞＜変数名＞
先頭文字が＜数字＞なので＜変数名＞には合致しません。

F5_1
↓
＜英字＞＜数字＞＜英数字＞＜数字＞
↓
＜英字＞＜英数字＞＜英数字＞＜英数字＞
↓
＜変数名＞＜英数字＞＜英数字＞
↓
＜変数名＞＜英数字＞
↓
＜変数名＞
最終的に＜変数名＞に置き換え可能なので、BNFに合致する文字列となります。よって正解です。

【別解】
＜変数名＞は＜英字＞1文字、または＜変数名＞の後ろに＜英数字＞が付いたもの
解答群は、前者ではないため、後者でしかない。
＜変数名＞の後ろに＜英数字＞が付いたもの
↓
(＜変数名＞の後ろに＜英数字＞が付いたもの)の後ろに＜英数字＞が付いたもの
↓
((＜変数名＞の後ろに＜英数字＞が付いたもの)の後ろに＜英数字＞が付いたもの)の後ろに＜英数字＞が付いたもの
↓
・・・
つまり
＜変数名＞の後ろに＜英数字＞が一つ以上付いたもの
つまり
＜英字＞1文字の後ろに＜英数字＞が一つ以上付いたもの

### 平成30年秋期　問4

次に示す記述は，BNFで表現されたあるプログラム言語の構文の一部である。<パラメタ指定>として，適切なものはどれか。  

<パラメタ指定>::＝<パラメタ>｜(<パラメタ指定>，<パラメタ>)  
<パラメタ>::＝<英字>｜<パラメタ><英字>  
<英字>::＝a｜b｜c｜d｜e｜f｜g｜h｜i  

→  

``` txt
各肢を展開していき<パラメタ指定>に帰結するか否かを調べていきます。※英字の並びは<パラメタ>で表されます。

ア
((abc，def)，ghi)
正しい。
((<パラメタ>，<パラメタ>)，<パラメタ>)
→　((<パラメタ指定>，<パラメタ>)，<パラメタ>)
→　(<パラメタ指定>，<パラメタ>)
→　<パラメタ指定>
最終的に<パラメタ指定>になるのでこれが正解です。

イ
((abc，def))
((<パラメタ>，<パラメタ>))
→　((<パラメタ指定>，<パラメタ>))
→　(<パラメタ指定>)
外側の括弧を外すことができないので不適切です。

ウ
(abc，(def))
(<パラメタ>，(<パラメタ>))
これ以上変形できないので不適切です。

エ
(abc)
(<パラメタ>)
→　(<パラメタ指定>)
括弧を外すことができないので不適切です。

また、上記とは逆に<パラメタ指定>を再帰的に展開していき、答えを導くこともできます

<パラメタ指定>
→　(<パラメタ指定>，<パラメタ>)
→　((<パラメタ指定>，<パラメタ>)，<パラメタ>)
→　((<パラメタ>，<パラメタ>)，<パラメタ>)

括弧の位置と英字列の数から考えて適切な構文となっているのは「ア」とわかります。
```

### 平成29年秋期　問2

次のBNFにおいて非終端記号`<A>`から生成される文字列はどれか。

``` math
<R0> ::= 0｜3｜6｜9
<R1> ::= 1｜4｜7
<R2> ::= 2｜5｜8
<A> ::= <R0>｜<A> <R0>｜<B> <R2>｜<C>< R1>
<B> ::= <R1>｜<A> <R1>｜<B> <R0>｜<C>< R2>
<C> ::= <R2>｜<A> <R2>｜<B> <R1>｜<C> <R0>
```

→  

``` txt
各選択肢の文字列を問題中のBNFで表記すると次のようになります。

ア123
123→<R1><R2><R0>
イ124
124→<R1><R2><R1>
ウ127
127→<R1><R2><R1>
エ128
128→<R1><R2><R2>

次に<A>の定義にある「<A><R0>」「<B><R2>」「<C><R1>」の3つの型から導出されるBNFのパターンを考えます。

[<A> <R0>]
非終端記号<A>に、それぞれ3つの型を当てはめます。
<A><R0><R0>→<R0><R0><R0>
<B><R2><R0>→<R1><R2><R0>
<C><R1><R0>→<R2><R1><R0>

[<B><R2>]
非終端記号<B>に、それぞれ3つの型を当てはめます。
<A><R1><R2>→<R0><R1><R2>
<B><R0><R2>→<R1><R0><R2>
<C><R2><R2>→<R2><R2><R2>

[<C><R1>]
非終端記号<C>に、それぞれ3つの型を当てはめます。
<A><R2><R1>→<R0><R2><R1>
<B><R1><R1>→<R1><R1><R1>
<C><R0><R1>→<R2><R0><R1>

上記の9つのBNFが非終端記号<A>で生成可能な文字列のパターンです。このうち選択肢の文字列と合致するのは「ア」123のBNF表記である「<R1><R2><R0>」だけです。よって、<A>から生成可能な文字列は123とわかります。
```

### 平成29年春期　問4

あるプログラム言語において，識別子(identifier)は，先頭が英字で始まり，それ以降に任意個の英数字が続く文字列である。  
これをBNFで定義したとき，a に入るものはどれか。  

``` txt
　　<digit>::＝0｜1｜2｜3｜4｜5｜6｜7｜8｜9  
　　<letter>::＝A｜B｜C｜…｜X｜Y｜Z｜a｜b｜c｜…｜x｜y｜z  
　　<identifier>::＝ a  
```

→

``` txt
ア
<letter>｜<digit>｜<identifier><letter>｜<identifier><digit>
2つ目の項に<digit>があり、先頭が数字で始まる場合があるので誤りです。
例えば、
<identifier>
↓
<identifier><letter>
↓
<digit><letter>
のように、先頭が数字で始まる文字列が使用可能になってしまいます。

イ
<letter>｜<digit>｜<letter><identifier>｜<identifier><digit>
「ア」と同じ理由で誤りです。

ウ
<letter>｜<identifier><digit>
英字が先頭にしか使えないので誤りです。
例えば、
<identifier>→<identifier><digit>
↓
<identifier><digit><digit>
↓
<identifier><digit><digit><digit>
↓
<letter><digit><digit><digit>
というように展開されますが、先頭以外の文字は必ず数字<digit>になってしまうことになります。

エ
<letter>｜<identifier><digit>｜<identifier><letter>
正しい。
```

---

## 1回目に間違えた問題

### 平成30年秋期　問4

出現頻度の異なるA，B，C，D，Eの5文字で構成される通信データを，ハフマン符号化を使って圧縮するために，符号表を作成した。aに入る符号として，適切なものはどれか。

→
出現頻度が高ければ短くなって、低ければ長くなる程度でしか覚えていなかった。
後は、他の文字列と組み合わせた時に、被るか被らないかの違い。
被らない奴を選んだつもりだったのだが、よく見るとほとんど被るので、それっぽいやつを選んだらダメだった。

→

110
正しい。既存のどの符号からも始まっていないため適切です。
010
Bの符号"01"が接頭辞になっています。デコードの際に先頭部分がBに変換されてしまうため不適切です。
101
Cの符号"10"が接頭辞になっています。デコードの際に先頭部分がCに変換されてしまうため不適切です。
001
Aの符号"00"が接頭辞になっています。デコードの際に先頭部分がAに変換されてしまうため不適切です。

そういうことね。先頭から解読した時に、既にあるパターンはだめという事か。
そのパターンに合致した瞬間、その文字だと認識されてしまうから。

### 平成29年秋期　問4

図のような黒色で描かれた円に沿って車が走るように，左右の後輪に独立に取り付けられたモータL及びRの回転速度を制御する。センサL及びRは反射型光センサであり，センサが黒色に掛かる比率が大きいと出力値が小さくなり，黒色に掛かる比率が小さいと出力値が大きくなる。この車を円に沿って走行させるためのモータ回転速度の制御方法として，適切なものはどれか。ここで，二つのセンサの出力値が一致するときには，二つのモータの回転速度を初期値に戻すものとする。

→
日本語を読み解く問題です。
やりたいことはわかりますが、notだの何だの、多重に変換が設けられているので、頭の中だけでは限界があります。
ちゃんとメモ帳に書き出しながらやればワンちゃんあったのではないでしょうか。

### 令和元年秋期　問4

a及びbを定数とする関数 $f(x)=a/{t+1}$ 及び $g(t)=b/{t^2-t}$ に対して，  はどれか。
ここで，a≠0，b≠0，t＞1とする。

→
無限に発散した場合、例えばt=10の地点で見れば、
f(t) = a/11
g(t) = b/100-10
となって、g(t)の増加率が大きいので、無限に発散すると思ったが、よく考えてみると、分母がって話なんだよな。
g(t)だけを無限に発散させたら0に収束するわけで、それが分子にいるんだから、自然と0に収束していくはずなんだ。
なのに、無限と応えたのは最初のインスピレーションだけで、よく検証しないで答えたからだろう。
こういうところで自分が嫌になる。

→
まず、式中の lim について簡単な例を交えて少し説明しておきます。

式中のある変数が限りなく0に近づいたときや、無限大(またはマイナスの無限大)に限りなく近づいたときの式の値を考えることを数列の極限といいます。
極限値は lim の記号を用いて次の例のように表します。
$\lim_{h\to 0}(2+h) = 2$  … hが限りなく0に近づいたとき 2＋h の極限値は2である。  
$\lim_{h\to \infty}(2+h) = \infin$… hが限りなく無限大(∞)に近づいたとき 2＋h の極限値は∞である。
同様に関数中のある変数が0又は無限大に限りなく近づいたときの関数の値を関数の極限といいます。

これを踏まえて $\lim_{t\to \infin}{g(t)/f(t)}$ の値を求めます。
$g(t)/f(t)$  を変換すると次のような形になります。
$g(t)/f(t) = {b/{t^2-t}} ÷ {a/{t+1}} = b(t+1) / a(t^2-t)$
tが増えると、  

 というように分子の増加量よりも分母の増加量が多く0に近づいていくので、t→∞のとき $g(t)/f(t)$ の値は限りなく0に近づきます。

### 平成30年春期　問1

ある整数値を，負数を2の補数で表現する2進表記法で表すと最下位2ビットは"11"であった。10進表記法の下で，その整数値を4で割ったときの余りに関する記述として，適切なものはどれか。ここで，除算の商は，絶対値の小数点以下を切り捨てるものとする。

→
負数を2の補数での表現。
いつぞや、ネットで記事を漁って納得したが、忘れた。
マイナスになるって事は11が単純に4になるわけではないとは思ったんので、それっぽい奴を選んだが、
まさか整数値が正の時に3になるとは思わなんだ。
回答をそのまま使う。
あと、余りがマイナスになることがあるのか不思議でならなかったので、解説を読み込むことにする。

→
設問では「ある整数値を…2進数記法で表すと最下位ビットが"11"であった。」としていますが、最下位2ビットが"11"となる整数値の特徴は正負によって異なります。

[正の数の場合]
正の数に対しては2の補数を適用しないので、2進数表現 xx…x11 をそのまま10進数に直すことを考えます（xは任意のビット）。最下位2ビットが"11"となる正の数は、
・111(2) → 7(10)
・1011(2) → 11(10)
・10111(2) → 23(10)
・110011(2) → 51(10)
というように、常に「4で割った余りが3である数」になります。これは4で割るという行為が2進数のビット列を右に2つシフトさせることと同義だからです。ビット列全体を右に2つシフトさせると、"11"（＝10進数で3）の部分が端数（＝除算の余り）となります。

[負の数の場合]
2の補数に変換したときと逆の手順で、その負数の絶対値を示すビット列を求めます。
1.xx…x11 から1を引く。
　xx…x10
2.全てのビットを反転させる。
　xx…x01 //絶対値の2進数表現
これにより、2の補数表現で最下位2ビットが"11"となる負数があるとき、その負数の絶対値の最下位2ビットは必ず"01"になることがわかります。最下位2ビットが"01"となる数は、
・101(2) → (絶対値)5(10) → (負数)－5(10)
・1001(2) → (絶対値)9(10) → (負数)－9(10)
・10101(2) → (絶対値)21(10) → (負数)－21(10)
・110001(2) → (絶対値)49(10) → (負数)－49(10)
というような数の集合になります。これらの負数を4で割ると余りは 3 または －1 になります。ここで、設問の「除算の商は，絶対値の小数点以下を切り捨てるものとする。」という条件を適用すると、
・－5÷4＝－1.25 → 絶対値の小数点以下を切り捨てると商は－1
商が－1ならば余りは－1
・－9÷4＝－2.25 → 絶対値の小数点以下を切り捨てると商は－2
商が－2ならば余りは－1
というように、常に「4で割った余りは－1」になります。

以上より、最下位2ビットが"11"である整数値を4で割った余りは、その整数値が正ならば3、負ならば－1になります。よって〔ウ〕の記述のみが適切です。

**2の補数**
マイナスの数をプラスの数で表す表現方法を「補数（ほすう）」という。
2進数で負数を表現する方法の一つです。ある負の数を2の補数で表すには、①その負の数の絶対値を2進数に直し、②すべてのビットを反転して、③その結果に1を加えます。

例えば、10進数表記の -10 は以下の手順で2の補数に変換します。
1.-10の絶対値である10を2進数に直す。
10(10) →　1010(2)
2.1010(2)の全ビットを反転させる。
1010(2) → 0101(2)
3.②の結果に1を加える。
0101(2) → 0110(2)

-10の補数は6。
例えば正の12と計算をしてみる。

12+(-10) = 2
1100 + 0110 = 10010

先頭の1を無視すると答えは2になるので辻褄はあっているというわけ。

### 平成29年春期　問2

0以外の数値を浮動小数点表示で表現する場合，仮数部の最上位桁が0以外になるように，桁合わせする操作はどれか。ここで，仮数部の表現方法は，絶対値表現とする。

→
正規化なの！？しらねー。まじか。
こういうのがあるから油断できないんだよな。
