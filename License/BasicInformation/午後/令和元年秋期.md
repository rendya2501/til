# 令和元年秋期

## セキュリティー

サブネットマスク

192.168.64.0/24 11000000 101010000 01000000/ 00000000
192.168.65.0/24 11000000 101010000 01000001/ 00000000

192.168.64.0/23 11000000 101010000 0100000/0 00000000
※ 192.168.64.0/24と192.168.65.0/24をどちらも含むネットワーク

こういうのは`スーパーネット化`というんだったか。  
上記例では、左から23ビットまでが同じなので、サブネットを23とすることで、  
192.168.64.0/23という1つのネットワークに集約することができる、と参考書には書いているな。  
サブネット化の逆、と考えれば話は早いか？

<https://wa3.i-3-i.info/word11985.html>  
ネットワークの説明においてはわかりそうでわからないが一番わかりやすい気がする。
そうだよね。サブネット化が右に1の領域が増えていくのに対し、逆に行くのだから、ネットワークがまとまるわけだよな。

---

## アルゴリズム

おーけー。わかった。
俺が苦手なのはアルゴリズムだ。
もちろん時間をかければ理解できるが、制限時間内ですべてを理解しろといわれたら結構きつい。
応用の時はこれを把握できていなかったので落ちた感じだな。
プログラミングまではいい。ただ、配列とか絡み出すとダメかも。
なので、アルゴリズムを解くなら、最初に簡単な問題を解いて余った残り時間でやるのがベストかもなぁ。
ちょっと厳しい。これがわかっただけでも儲けものだ。

gはポカミス。逆から考えないといけない事を忘れていた。
逆にどうやったら気が付くことが出来た？

hは言語仕様の認識ミス。
それさえわかれば普通にインクリメントされる事はわかる。


iはIndexが何を返すのかわからなかったのでトレースの使用もなかった。
誤って Pat[] に"AC[B[AB]AC]A"を格納して関数 GenerateBitMaskRegex を呼び出した場合，Mask[1]はiとなる。
→
Aの観測結果がどうなってしまうのかトレースせよって言ってる。

Index(Pat[i])が何を返すのかわからなかった。  
→
関数 Index は，引数にアルファベット順でn番目の英大文字を設定して呼び出すと，整数n(1≦n≦26)を返す。
アルファベットを数値に変換した物。
A→1
B→2
・・・
Z→26

こういう関数の説明は頭の片隅に記憶しておかないとトレースの仕様がないよなー。
→
背景色を変更できるのを発見したので次から重要な文章には容赦なくチェックを入れる。


Maskは各文字の出現位置をビットで表現するための配列。


以上をわかったうえでトレースしてみると？

OriginalPatLen = 12
PatLen = 0
Mode = 0

// 1文字目 A
PatLen = 1
Mask[Index(Pat[1])] = Mask[Index("A")] = Mask[1]
Mask[1] = 0B;
1Bを(1-1)ビットだけ左シフトした値→1B つまりシフトしてないって事だからね。
Mask[1] = 1B

// 2文字目 C
PatLen = 2

// 3文字目 [
PatLen = 3
Mode = 1

// 4文字目 B
Modeが0でないとPatLenはカウントされないのでスルー

// 5文字目 [
PatLen = 4
Mode = 1

// 6文字目 A
Masi[1]の値 : 1B
1Bを(4-1)ビットだけ左シフト→1000B
シフト演算は新しく出現するものに関しては0から始まる。
Mask[1] = 1000Bと1Bの論理和→1001B

// 7文字目 B

// 8文字目 ]
Mode = 0

// 9文字目 A
PatLen = 5
Mask[1]の値 : 1001B
1Bを(5-1)ビットだけ左シフト→10000B
Mask[1] = 10000Bと1001Bとの論理和→11001B

// 10文字目C
PatLen = 6

// 11文字目 ]
Mode = 0

// 12文字目 A
PatLen = 7
Mask[1]の値 : 11001B
1Bを(7-1)ビットだけ左シフト→1000000B
Mask[1] = 1000000Bと11001Bとの論理和→1011001B

全部をトレースするのではなく、必要な奴だけ考える。

なぜトレースできそうにないと思ったのか。
そもそもどういう出力がされるのかイメージできなかった。
Mask[Index(Pat[i])]が何を指すのかイメージできなかった。
疑似言語を理解していなかった。

午後問題はわざわざプログラムとして書き起こすまではしなくていいかも。
机上で十分トレースできる。


[令和元年（R01）秋期 基本情報技術者試験 アルゴリズム問題 解き方解説](https://daeudaeu.com/fe_algorithm_r01f/)  
・（特に穴埋め問題以外は）プログラムの全体像・全容を理解する必要はない  

---

## Java

final,throws,put  
javaの言語仕様をある程度学ぶ必要がある。  
ここにメモ書きしつつ、Javaのフォルダにもちゃんと書くことで対応したほうがいいだろうか。

### final

・クラスに付ける場合→継承の禁止
・メソッドにつける場合→オーバーライドの禁止
・変数に付ける場合→再代入の禁止(定数)

付けるものによって意味が違うけど、おおよそ想定通りの動きではある。

### throws

メソッドの宣言に追加するキーワード。  
指定した例外を発生させることを宣言する。  
throwsがついたメソッドを呼び出す場合は例外の対策をしないといけない。  
それだけの宣言みたいだ。  
実際あまり使われないみたいだし、インターフェースと組み合わせた場合、  
抽象が実装に引っ張られるから失敗作だとどこかで効いたことがある。  

### HashMap

C#でいうListっぽいことしてるのがこれ。  
Listではaddメソッドで要素を追加するが、JavaのHashMapはput(置く)がそれに当たるらしい。  
直観的にそうだろうとは思ったが、確証がなかったので後学のためにまとめておく。  

---

## データベース

データベースは簡単だった。  
と、言いつつ1問間違えたが、制限時間内に余裕を持って答えられるあたり、普通に得点源になりえる。  

一番最後の問題。どの順番でテーブルを削除していけばいいか？という問題を間違えてしまった。  
キーワードは「外部キーと参照制約。」  
1.外部キーを持つレコードを追加する場合、その外部キーの値は参照先のレコードの主キーとして存在するものでなければならない。  
2.別表から主キーの値を参照されているレコードは削除することができない。  

つまり、主キーのテーブルを先に消してはいけない！！ということだ。  
主キーのテーブルを先に消したら、一瞬だけど、外部キーで辿った先が何もないっていう状態になってしまうから。  
というわけで、参照しているテーブルから消して、最後に主キーのレコードを削除しましょうって流れになるわけです。  

解説を見ると、確かに順々に参照しているのがわかる。  
業務においてはあまり意識しない事だったので全然思いつかなかった。  

---

## ネットワーク

ネットワークは好きなんですけどね。意外と当たらないんだよね。  
応用の時もそうだったけど、送信元と宛先のIPアドレスを応える系の問題が苦手かも？  
後は純粋な知識の問題かなー。  

ポートを固定したければ静的NAT。  
動的NATはポート番号が毎回異なる。適当なポート番号にアクセスしても、変換テーブルにないポート番号はパケットを破棄する。  
というわけで、固定ポートでインターネットを介したLAN同士のやり取りは静的NATでないと実現不可能。  
IPアドレスandポート番号が固定で無ければならない、というわけではなく、ポート番号を固定しなければならないという場面でも静的NATで無ければならない。  
IPアドレス固定の場合もそうだろうか？  
いや、静的NAPTの場合、80番ポートへのアクセスは192.168.0.1へ。  
53番ポートへのアクセスは192.168.100.0に回すといった具合に、ポート番号からIPを設定の流れが自然なのかも。  
もちろんグローバルIPアドレスとプライベートIPアドレスを直接紐づける事もできるだろうけど、  
それはNATの話であって、NAPTの話ではないし、今の時代NATだけではやっていけないでしょう。  

というわけで、ポート固定の地点で静的NATです。  

### NAT64/DNS64

IPv6機器からIPv4機器にアクセスするための機能に関する問題で、普通のNetworkAddressTranslationとDomainNameSystemを拡張したNAT64とDNS64なるものが登場した。  
単純に気になったので調べて見た次第。  
64はIPv6とIPv4を相互に変換する技術のため、「64 (ろく・よん) 変換」を意味している見たい。
基本的に、この2つの機器はIPv6側のネットワークに設置されるものらしい。

<https://support.biglobe.ne.jp/ipv6/nat64.html>  
ここが普通にわかりやすいかな。  

DNS64は名前解決としてIPv6も返すようにしたもの。  
NAT64はIPv6とIPv4をつなげるための中間機器。  
端末→IPv6→IPv4→サーバー  
サーバー→IPv4→IPv6→端末  

単純にそれだけではある。  
午後問題では、端末からサーバーへのアクセス時にどのようなIP変換が行われるのかを問いていた。

---

## ソフトウェア設計

うん。令和元年に関しては特になし。  
全問正解したし、10分で解き終わった。  

応用情報で信号機の設計とか、テストの合格範囲の設定とかやったでしょ。  
あれの簡単バージョンだ。  
今回の問題はテストの合格範囲の問題だったので、もろ応用でやったときのあれと被ってる。  
あれで点数がある程度撮れていれば、条件分岐や境界値の判定くらいどおってことはない。  

---

## Java 2回目

15分 【成績】全6問中 6問 回答/6問 正解　正解率:100.0%  

不安になって2週目をやった結果である。  
明らかに解けるようになっているのでうれしい限りである。  

元年は一番最初にやったので何分で解けて、何問正解だったのかの情報がないけれど、確実に30分はかかったし、何問か間違えたのは確実だ。  
それから比べて見ればかなりの進歩と言えるのでは無かろうか。  
というか、元年から非同期だとかシングルトンだとか、拡張for文とか、色々な要素が普通に出題されていたのね。  
こんなに難しいものが出ているとは思わなんだ。  
しかし、全部わかったので問題はなさそう。  
少し安心した。  

一回目はとにかくプログラムの全容を把握しようと思って、上から下まで頑張って読んでたけど、ばかだなーって思うね。  
問題文を読んでいれば、どうすれば解けるかの塩梅くらいはわかってくる。  
そういう意味で過去問は絶対に解かねばならんのだ。  
2回目をやって思ったが、やっぱり普通に忘れてる。  
なんとなくこんな問題だった気がするけどって感じになってた。  
2週目も普通に意味はありそうだ。  

## アルゴリズム2回目

30分きっかり 【成績】全9問中 9問 回答/9問 正解　正解率:100.0%  

うーん。だいぶわかるようになったぞ。  
ちょっと自信がついてきた。  
何回も問題を解いていると、読み方がわかってくる。  
最初は手も足も出なかったけど、この調子ならいけそうだ。  
ちょっと前回の知識もある状態で解いたのでアドバンテージはあるけど、それでも「あぁ、そういうことね」ってのは理解出来た。  
最初の時と比べながら理解の違いを確認出来たのは大きい。  
これなら令和3年の問題に手を付けてもいいだろう。  
