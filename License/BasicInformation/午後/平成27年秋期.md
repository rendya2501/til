# 平成27年秋期

■ a 不正解  
■ b 不正解  
■ c 不正解  
■ d 不正解  
■ e 不正解  
■ f 不正解  
■ g 不正解  
■ h 不正解  

まぁ、Javaの点は悪かったけど、どれも8割取れてるから27年の秋は合格出来たんじゃないか。  

---

## セキュリティー

23分 【成績】全8問中 8問 回答/7問 正解　正解率:87.5%  

今回は中々骨がある問題だった。  
今までが温過ぎたってのもあるがね。  
全体として話は理解出来たけど、1問はまじでわからなかった。  

■ 1-a 不正解  
「ログを基にいつ、だれが、どのように利用したかを追跡可能なこと」を達成するための仕組みが入ります。  
いつに対する仕組みがないので、時刻の同期が答えってわけ。  
個人的には、ログインしたときのログの事で頭がいっぱいだったので、この答えにはたどり着かなかった。  

電子署名は改ざん防止

■ 2  
「ログ集積ファイルを基に，いつ，誰が，どの端末からどの業務システムをどのように操作したのかが追跡できる」  
→
「誰が」→社員ID
「どの端末から」→端末のIPアドレス
「どの業務システム」→業務ID

---

## データベース

16分 【成績】全5問中 5問 回答/5問 正解　正解率:100.0%  

簡単だったな。以上。  
あー、でもANYっていう、見慣れない命令があったのでそれだけまとめる。  

ANYは、値リストのそれぞれと比較して、いずれかが真ならば真を返す演算子です。  

パッケージ表からリコール対象の部品番号のリストを得るには、WHERE句に「同梱部品 = '007551'」を指定することで、同梱部品が'007551'であるレコードを選択し、
「SELECT 部品番号」で、そのレコードの部品番号列を抜き出すことになります。

IN句と何が違うんだ？やりたいことってINとほぼ同じだろう？
あー、副問い合わせの結果を条件として使うことができるのか。
INと似たような感じではあるが、もう少し範囲が広いというか、結果を条件に使うにはANYが一番いいのか。  

[ANY(SOME)句を用いた副問合せ](https://www.sql-reference.com/select/subquery_any.html)  
例としてANY句を使用して受注テーブルからレコードを抽出します．

``` txt : 受注テーブル
注文番号,商品コード,受注個数
01-101,A001,100
01-102,A002,200
01-103,B001,300
01-104,B002,400
02-101,A001,150
02-102,A002,350
```

``` SQL
SELECT * FROM 受注
WHERE 受注個数 > ANY (
    SELECT 受注個数
    FROM 受注
    WHERE 商品コード = 'A002' (
)
```

``` txt 結果
注文番号,商品コード,受注個数
01-103,B001,300
01-104,B002,400
02-102,A002,350
```

---

## ソフトウェア設計

25分 【成績】全6問中 6問 回答/5問 正解　正解率:83.3%  

最後、全部Noはあり得ると思ったがダメだった模様。  
あー、1円も買い物してなかったら10万円未満になるので、全部Noは基本的にあり得ないか・・・。
もったいないことをした。  

今回の問題はどちらかといえばパズルでしかなかった。  
条件網羅の問題を出したのだろうけど、感覚的には完全にパズルなんだわ。  

---

## アルゴリズム

29分 【成績】全6問中 6問 回答/5問 正解　正解率:83.3%  

30分中でほとんど理解できた。  
間違えた1問はどうやらミスリードしてしまったみたいだが、トレース自体は苦労せずに出来たのであまり気にしていない。  
というか、この文字列比較の問題は元年と同じだ。  
文字列の比較って、やっぱりアルゴリズムにし易いんだなー。  

うわ・・・。  
間違えが部分確認してみると最後までしっかりトレースしていれば正解する内容だった。  
やってしまった。  
まぁでもほとんど解説読む必要がないので、サクッといけるだけマシだ。  
それにアルゴリズムで8割いけたから全然いいでしょう。  

---

## Java

27分 【成績】全7問中 7問 回答/4問 正解　正解率:57.1%  

あれー・・・結構間違ってた。  
話はわかったのだが、arrayのsizeの問題とか文法の部分でまだ不安があったかな。  

あちゃー。最後の問題くらいは普通に正解で来てたな。  
removeはインデックスの指定ではなく、オブジェクトの指定だった。  
早く終わらせたくてろくに見直しもしなかった影響だろうな。  

LRU（Least Recently Used）は、置換対象の中で最も長い時間参照されていないものを置換対象とするアルゴリズム  

"<>"(ダイアモンド演算子)と"?"を用いた宣言はジェネリクス（総称型）を指定する際に渡せるクラスに制限を付けるときに使いますが、クラス Cache はジェネリクスではないので、

Array[][]
Array.lengthは要素数が返却されるらしいが、つまりどういうことだ？
今回見たいにbyte[][] blocks = new byte[100][512]とした場合に返却されるのは何だ？

×a:ア　blocks→ウ
○b:ア　Cache
○c:エ　==
○d:オ　entries.size()==CACHE_SIZE
×e:エ　index→イ
○f:カ　ListBasedCache
×g:エ　entry.getIndex()→ウ

LRUは参照されたらそれを先頭に持ってくる。
で一番最後にある要素は参照されない要素なので、キャッシュからは消えて当然って話か。

てか、LRUの復習しないと。
確か親戚が2つ位あった。
頻繁に参照しているか、最後に読みだしてから一番時間が立っている奴だったか。
正直そいつとの違いを納得できていないので、そこを確認する。

後は入れ子クラスとか、入れ子のクラスが親クラスを継承できることを知っておく位かな。

C#の多次元配列とJavaの多次元配列の宣言の仕方って違うんだな。
lengthで吐き出される値も違うし。
というか、基本的な部分がここまで欠落していることに恐怖している。

``` C#
    // a.length → 51200と表示される。
    // a[0].lengthの指定はできない。
    var a = new byte[100,512];

    // こっちはジャグ配列って奴みたい。
    // こっちならb[0].lengthの指定はできる。エラーになるけど。
    int[][] b = new int[2][];
```

 ``` Java
    byte[][] blocks = new byte[100][512];
    // blocks.length → 100と表示される。
    System.out.println(blocks.length);
    // blocks[0].length → 512と表示される。
    System.out.println(blocks[0].length);
    // blocks[0][0]は何も入っていないので 0と表示される。
    System.out.println(blocks[0][0]);
    // このようなアクセスは出来ない。
    // System.out.println(blocks[0][0].length);
 ```

Javaに破棄はない。  
Java10からvarによる変数の宣言ができるようになった。  
Javaに置ける多次元配列はC#に置けるジャグ配列みたいなものかもしれない。  
微妙にアクセスの仕方が異なる。  
