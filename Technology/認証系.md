# 認証に関するメモ

[Basic認証、Digest認証、Bearer認証、OAuth認証方式について](https://architecting.hateblo.jp/entry/2020/03/27/130535)  

---

## Basic認証

---

## Digest認証

---

## Bearer認証

[トークンを利用した認証・認可 API を実装するとき Authorization: Bearer ヘッダを使っていいのか調べた](https://qiita.com/uasi/items/cfb60588daa18c2ec6f5)  
[【入門】最短距離で身に付くAPIの叩き方【GAS】](https://zenn.dev/shikumiya_hata/books/33f44d4f561ec4/viewer/fd3203)  

Bearer認証(アクセストークン認証)は、ログインID・パスワードなどでユーザー認証を行なった後に、サービスから発行されるアクセストークンを受け取って、APIのリクエスト時に送信する方式です。  

具体的には、HTTPリクエストヘッダーにアクセストークンを記述して送ります。  
設定するヘッダー項目は「Authorizationヘッダー」です。  
以下のような書式となります。(Bearerはトークンを利用した認証を行いますよという意味で付けるものです）  

`Authorization: Bearer {アクセストークン}`

bearerは「担い手」や「使い」といった意味を持つ。  

### そもそもBearerとは?

通信やネットワークの分野で、伝送する内容の圧縮や変換などを行わず、信号やビット列をそのまま忠実に相手先に伝える回線やサービスをこのように呼ぶ。  

### Bearerトークン

[What is Bearer token and How it works?](https://www.devopsschool.com/blog/what-is-bearer-token-and-how-it-works/)  
→  
ベアラー認証（トークン認証とも呼ばれます）は、ベアラートークンと呼ばれるセキュリティトークンを含むHTTP認証スキームです。  
ベアラートークンは不可解な文字列であり、通常、ログイン要求に応じてサーバーによって生成されます。  
クライアントは、保護されたリソースにリクエストを行うときに、Authorizationヘッダーでこのトークンを送信する必要があります。  

ベアラートークンは、OAuth2.0で使用される主要なタイプのアクセストークンです。  
Bearer Tokenは不透明な文字列であり、それを使用するクライアントにとって意味を持つことを意図したものではありません。  

→  
というわけで、単純に `Authorization: Bearer {アクセストークン}` のアクセストークンの部分をベアラートークンと呼ぶみたいな感じではなかろうか？  

wiki  
セキュリティトークンとはある対象へのアクセス制御（利用可否など）を担うトークン・許可証であり、Bearerトークンはその一形態である。  
Bearerとは「持参人」すなわち「トークンを持ってきた存在」を意味する。  
BearerトークンはBearer（それを持ってきた存在）にアクセス権限を与える特性を持つ。  

Bearerトークンはしばしば切符に例えられる。  
切符は乗り物への乗車=アクセスを制御するトークンである。  
切符の利用権利は単純に「切符を持ってきた人=Bearer」に付与される。誰が切符を購入し管理していたかは関係がない。  
極端な例では拾った切符であっても（切符の権利者でなくても）持ってきた人=Bearerに乗車権利が付与される。  
このように切符はBearerトークンと同じ性質を持っている。  

### Bearer スキーム

HTTP 認証スキームの一つで、WebAPI へアクセスするためのセキュリティトークン（アクセストークン等）を `Authorization: Bearer {トークン}` という形で HTTP ヘッダーにセットし、トークンの受け渡しを行う仕組みです。  

---

## OAuth認証

[一番分かりやすい OAuth の説明](https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be)  

---

## JWT(JSON Web Token)

属性情報（Claim）をJSONデータ構造で表現したトークンの仕様です。
IETFによってRFC 7519として標準化されている。  
特徴として、署名、暗号化ができ、URL-safeであることなどが挙げられます。  
読み方は「ジョット」  

JWTと関連する仕様として、JSON Web Signature（JWS）、JSON Web Encryption（JWE）というものがあり、それぞれJSONデータ構造を用いて署名、暗号化するための仕様です。  
JWTでは、署名付きデータの場合はJWS、暗号化する場合はJWEの仕様に基づき、JWTが利用されますが、現状使われている多くのJWTが署名付きのものであるため、今回扱うJWTはJWSを用いた署名付きのJWTとします。  

[JSON Web Token（JWT）の紹介とYahoo! JAPANにおけるJWTの活用](https://techblog.yahoo.co.jp/advent-calendar-2017/jwt/)  
[【JWT】 入門](https://qiita.com/knaot0/items/8427918564400968bd2b)  

[JWT の仕組み](https://zenn.dev/mikakane/articles/tutorial_for_jwt)  
→  
JSON ベースのデータを暗号化してつくられる文字列で、認証や認可のための仕組みとして Web アプリケーションなどで用いられる技術  

### JWTの構造

下記の文字列がJWTの例です。

``` txt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

JWTの構成をわかりやすくするため、改行をしてみます。

``` txt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
.
TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

すると、JWTは2つのピリオド（"."）で区切られた3つのパートによって成り立っているということがわかります。  
この3つのパートにはそれぞれ役割があり、前から順番にヘッダー（Header）、ペイロード（Payload）、署名（Sinature）となっています。  

`<ヘッダー>.<ペイロード>.<署名>`

[JWT （JSON Web Token）認証方式](https://techdocs.broadcom.com/jp/ja/ca-enterprise-software/layer7-identity-and-access-management/single-sign-on/12-8/464987779/464987780/464987952/464987986.html)  
→  
JWT の形式は、以下のように base64url でエンコードされ、ピリオドで区切られた 3 つの部分で構成されます。
`base64urlencode(header) + "." + base64urlencode(payload) + "." + base64urlencode(digitalsignature(header + payload))`  

### ヘッダー

ヘッダーはJWTの署名検証を行うために必要な情報を格納するためのパートとなっています。  
文字列の形式としては、キー名と値のペアで表現されたJSONをBase64urlエンコードした文字列となっています。  
Base64エンコードの場合は"+", "/", "="が含まれますが、JWTはURIのクエリパラメーターなどに使用されることを想定しているので、URL-safeに表現するためにBase64urlエンコードがされています。  
Base64urlエンコードでは"+"を"-"に、"/"を"_"、"="を""に変換しています。  
デコードをするとJSONに変換できるので、デコードをしてみます。  

``` json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

"typ"は"JWT"の文字列からJWTであることを示し、"alg"は署名アルゴリズムを示しています。  
上記の例の"HS256"はHMAC SHA-256を表しています。  
署名アルゴリズムはHMAC SHA-256が実装を義務付けられていますが、他にもデジタル署名のRSA-SHA256などをサポートすることが推奨されています。  
このヘッダーから署名アルゴリズムでJWTの検証を行います。  

### ペイロード

ペイロードはやりとりに必要な属性情報（Claim）です。  
ペイロードの内容はアプリケーションによっては異なるため、必須とされるものは存在しませんが、相互運用性のある属性情報については予約済みパラメーターとして提供されています。  
ヘッダーと同様に、JSONをBase64urlエンコードした文字列なので、デコードが容易にできます。  

``` json
{
  "admin": true,
  "name": "John Doe",
  "sub": "1234567890"
}
```

### 署名

署名パートは、エンコード済みヘッダー、ピリオド（"."）、エンコード済みペイロードを連結したものを入力値として"alg"の署名アルゴリズムで署名し、Base64urlエンコードすることにより作成されます。  

`TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ`  

こちらの文字列をヘッダーで指定されたアルゴリズムで署名検証することにより、ID Tokenの正当性を評価できます。  

### JWTを利用した仕様の紹介

では、実際にはどういった用途でJWTが使用されているのでしょうか。  
JWTを利用している仕様を紹介いたします。  

#### Single Sign-On での JWT の使用方法

[JWT （JSON Web Token）認証方式](https://techdocs.broadcom.com/jp/ja/ca-enterprise-software/layer7-identity-and-access-management/single-sign-on/12-8/464987779/464987780/464987952/464987986.html)  
→  
Single Sign-On は、リクエストの認証および許可に JWT を使用します。保護されたリソースにアクセスするために、CA Access Gateway は以下の形式でベアラー スキーマを使用して許可ヘッダ内の JWT を送信します。  

ユーザーがサーバーにログインを行う場合、従来のセッションによる認証ではCookieにてセッションIDが返されるが、JWTにおいてはトークンが返され、それをローカルに保存して利用する（主にlocal storageやsession storage（英語版）が用いられる。セッションIDのようにCookieを用いる場合もある）。

[wiki_JSON Web Token](https://ja.wikipedia.org/wiki/JSON_Web_Token)  
→  
ユーザーが認証が必要な機能やリソースにアクセスする際、クライアントはトークンを何らかの手段、主としてAuthorizationヘッダーでBearerスキーマを用いてサーバーに送信する。  
この場合、Authorizationヘッダーは以下のような形式となる。  

`Authorization: Bearer eyJhbGci...(中略)...yu5CSpyHI`  

JWTは、サーバー上に認証状態を保持しないステートレスな認証方式である。  
サーバーはAuthorizationヘッダーで渡されたトークンが正しいかだけを検証し、アクセスを許可する。  
JWTにおいては、認証に必要な情報は全てトークン内に格納されており、データベースへの問い合わせを削減することができる。  

`Authorization: Bearer <token>`  

#### OAuth 2.0のAccess Token取得のためのJWTの利用

OAuth 2.0はRFC6749（外部サイト）で策定されている、認可の標準仕様です。  
OAuth 2.0はサードパーティーアプリケーションによるHTTPサービスへ、限定的なアクセスを可能にします。  
OAuth 2.0のAccess Tokenを取得する際のクライアント認証はBasic認証や、クライアントIDとシークレットを用いた認証でも可能ですが、RFC7523では、それらの代わりにJWTを用いる方法が提案されています。  
また、RFC7523の中でもう1つの仕様として、Authorization grantとしてJWTを用いる方法も提案されています。  
これは、バッチ処理でのAPIアクセスなどの際に、ユーザーのインタラクションなしでAccessTokenを取得することを想定したものです。  

#### OAuth 2.0のstate

また、最近ではOAuth 2.0の拡張で、使用されるCSRF対策のパラメーターである"state"に対して、JWTのフォーマットを適用する仕様がIETFのdraftとして提案されています。  

Encoding claims in the OAuth 2 state parameter using a JWT draft-bradley-oauth-jwt-encoded-state-07（外部サイト）
OAuth 2.0では、発行されたトークンを受け渡すためにリダイレクト先のURIを指定する"redirect_uri"というパラメーターが存在します。
このパラメーターは、"client_id"にひもづいており、予期せぬアプリにトークンをわたしてしまわないように、登録している"redirect_uri"以外にはリダイレクトしないような仕組みになっています。
OAuth 2.0を提供する認可サーバーの検証内容としては、リクエスト時にわたした"redirect_uri"パラメーターの値と、認可サーバーに保存された"client_id"にひもづく"redirect_uri"が完全に一致しているかを確認しています。
したがって、例えば"redirect_uri"にurlをクエリパラメーターとしてつけ、認可サーバーからサードパーティーアプリケーションにリダイレクトで戻ってきた後、そのurlにリダイレクトしたいなどといった要件があっても、"redirect_uri"には付加できないため、別途パラメーターをわたす必要がありました。
このdraftでは"state"をJWTのフォーマットにしてリダイレクト先のURIなどの属性情報を含めることが提案されています。
JWTのフォーマットを用いることで、本来の"state"としてCSRF対策の役割も果たしつつ、安全に複数の属性情報を持たせることが可能です。

#### OpenID ConnectのID Token

OpenID ConnectとはID連携の標準仕様であり、OAuth 2.0の仕様を拡張し、認証機能を加え、ID連携に必要な機能を定義したものとなっています。  
OpenID ConnectはOpenID Foundationが使用を定義しています。  

OpenID Connect Core 1.0 incorporating errata set 1（外部サイト）  
OAuth 2.0にはない拡張機能として、ID Tokenというものがあります。  
ID Tokenはユーザーの認証情報をもったトークンで、改ざんを検知するためにJWTのフォーマットで表現されることが仕様で定められています。  

### SPAでの認証で、JWT(JSON Web Token)を採用するのは良い方法なのでしょうか？

[SPAでの認証で、JWT(JSON Web Token)を採用するのは良い方法なのでしょうか？](https://teratail.com/questions/182141)  

---

## BearerとJWTに関する個人的見解

Bearerトークンとして乗っけてるのがJWT  
JWTはbase64エンコードされてあの文字列になってるだけで、あれを複合すればちゃんと認証情報っぽい何かを持ったjsonにデコードできる。  
bearerは単純なヘッダーなのか？  

jwtはただの仕様。  

jsonをこれこれこういう形式に沿ってエンコードしてね。  
そうして生成された文字列は認証情報として使えるよって言ってるのがjwtだ。  

で、jwtの仕様に則って生成された文字列を載せる先として bearerトークン なるものがあり、bearerを使った認証がbearer認証ってわけだ。  
bearerトークンとして載せる文字列は別にjwtでなくてもいいけどjwtも使えるよってことかな。  

---

## OpenAPI (Swagger) を利用して効率よく WebAPI の仕様を管理する
