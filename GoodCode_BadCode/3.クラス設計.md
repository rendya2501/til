# 3. クラス設計 すべてにつながる設計の基盤

保守や変更がしやすいコードを書くには、関心の分離(10.1.1)が重要。  
オブジェクト指向は、ロジック整理の方針が分かりやすく、関心の分離が容易である点から、Javaが流行し始めた1990年代後半から今日に至るまで広く支持されている。  

オブジェクト指向は、ソフトウェアの品質向上を目的とする考え方の一種となる。  
定義は諸説ある。  
バートランド・メイヤーの「オブジェクト指向入門 第2版 原則・コンセプト」では「クラス、表明、総称性、継承、多層性、動的束縛から構成されるもの」とある。  

---
---

## 3.1 クラス単体で正常に動作するように設計する

まず大事にするのは「クラスが単体で正常動作するように設計する」という考え方。  

家電製品はコンセントを指しただけで使えるようになる。  
他の部品と組み合わせないとまともに使えないということは基本的にはない。  
クラスの考え方もこれと同じ。  

まどろっこしい初期設定をせずとも初めから使えるように設計すべし。  
クラスが不正状態に陥り、バグを生み出さないように正しく操作できるメソッドのみを外部に提供すべし。  

---

### 3.1.1 頑強なクラスの構成要素

クラスの構成要素は次の2つ  

- インスタンス変数  
- メソッド  

この構成を、より強固にするためには、メソッドの役割を明確化する必要がある。  
これを踏まえた、**良いクラスの構成要素**は次のようになる。  

- インスタンス変数  
- インスタンス変数を不正状態から防御し、正常に操作するメソッド  

どれか1つ欠けてもダメ。  

``` mermaid
---
title: よいクラスの構成
---
classDiagram
    class GoodClass{
        +type field 
        +method() type
    }
```

メソッドは必ずインスタンス変数を使用する。  

``` mermaid
---
title: 悪いクラスの構成
---
classDiagram
    class BadClass_A{
        +type field 
    }
    class BadClass_B{
        +method() type
    }
```

メソッド、インスタンス変数のどちらかが欠けても良くない。  
ただし、目的によっては例外的にこのような構造でも良い場合がある。  

Q.なぜこれらを守らなければならないのか？  
A.データクラスの例(1.3)があるから。  

データクラスのインスタンス変数を操作するロジックが、まったく別のクラスに実装されていたため、関連し合うものどうしの認知が困難になり、重複コードの発生、修正漏れ、可読性低下の弊害を招いていた。  

インスタンスを生成した段階では、インスタンス変数は不正状態であり、初期化処理をしなければバグになる作りだった。  
そして、初期化処理は別のクラスに実装されていた。  

どんな値でも、インスタンス変数に出し入れ可能であったため、不正値が容易に混入する作りでもあった。  
不正値から防御するためのバリデーションは別のクラスに実装されており、データクラス自身に自分を守るロジックは用意されていなかった。  

家電製品は、それ自身が単体で正常動作するように設計されている。  
この観点からすると、データクラスは他のクラスがあれこれ準備してやらないと正常動作できない、1人では何もできない未熟なクラスであることがわかる。  

---

### 3.1.2 全てのクラスに備わる自己防衛責務

ソフトウェアはメソッド、クラス、モジュール、どの粒度でも、それ自体が単体でバグがなく、いつでも安全に利用できる品質が求められる。  
わざわざ他のクラスに初期化してもらったり、データの入力をチェックしてもらったりしているようなクラスは、単体では安全に利用できない未熟なクラスと言える。  

自分の身は自分で守らせる、**自己防衛責務**を全てのクラスが備える、という考え方がソフトウェア品質を考える上で重要となる。  
構成部品であるクラスの1つ1つが品質的に完結していることにより、ソフトウェア全体の品質が向上する。  

データクラスの例であれば、何でも他のクラスに任せきりだったため、様々な弊害が発生していた。  
その弊害を解消するためには、自己防衛責務の考えに基づき、他のクラスに任せきりだったことを、データを持つクラスにやらせるように設計すれば良い。  

---
---

## 3.2 成熟したクラスへ成長させる設計術

金額を表すMoneyクラスを例に設計方法を見ていく。  
リスト3.1のMoneyクラスはインスタンス変数しかもっていない、典型的なデータクラスとなる。  

``` java
// リスト3.1
// 金額を表すクラス

class Money {
    int amount;        // 金額値
    Currency currency; // 通貨単位
}
```

---

### 3.2.1 コンストラクタで確実に正常値を設定する

データクラスではデフォルトコンストラクタ(引数なしのコンストラクタ)を使ってインスタンスを生成した後に、インスタンス変数に個別に値を代入して初期化するモノだった。  
これは「生焼けオブジェクト(1.3.5)」であり、未初期化状態を誘発するクラス構造となる。  

生焼けオブジェクトを防ぐには、「クラスのインスタンスを生成する時点で、インスタンス変数に正常値が確実に設定されている状態」にする。  
適切な初期化ロジックをコンストラクタに実装する。  

まず、デフォルトコンストラクタを使わず、インスタンス変数を全て初期化できるだけの引数を持ったコンストラクタを用意する。  

``` java
// リスト3.2
// 必ずコンストラクタで初期化する

class Money {
    int amount;
    Currency currency;

    Money(int amount,Currency currency) {
        this.amount = amount;
        this.currency = currency;
    }
}
```

これでインスタンス変数を初期化できる。  
しかしこれでは不十分。  
引数に不正値を渡せてしまう。  

``` java
Money money = new Money(-100,null);
```

不正値の混入を防止するため、バリデーション(入力チェック)をコンストラクタ内に定義する。  
不正値の場合は、例外をスローするように実装する。  

バリデーションの定義は以下とする。  

- 金額 amount : 0以上の整数  
- 通貨 currency : null以外

``` java
// リスト3.4
// コンストラクタで正常値のみが確実に設定されるしくみ

class Money {
    int amount;
    Currency currency;

    Money(int amount,Currency currency) {
        if (amount < 0) {
            throw new IllegalArgumentExecption("金額が0以上ではありません");
        }
        if (currency == null) {
            throw new NullPointerException("通貨を指定してください");
        }

        this.amount = amount;
        this.currency = currency;
    }
}
```

これで、正常値のみインスタンス変数に格納できるようになった。  

リスト3.4のコンストラクタのように、処理の対象外となる条件をメソッドの先頭に定義する方法を**ガード節**という。  
ガード節を用いると、不要な要素を先頭で除外できるため、継続のロジックがシンプルになる。  

コンストラクタにカード節を用意する方法のメリットは、コンストラクタで例外がスローされるため、不正なインスタンスが生成出来なくなり、常に安全で正常なインスタンスのみ生成できる環境と整えられる点である。  

---

### 3.2.2 計算ロジックをデータ保持側に寄せる

データクラス前提の実装では、金額の加算など計算ロジックは別のクラスに実装されてしまう。  
このようなデータとデータを操作するロジックが分散している構造(低凝縮)には、様々な弊害がある。  
この弊害の1つである、「別のクラスにまかせっきりだったこと」を自身にやらせるようにする。  

計算ロジックも同様に、Moneyクラス自身に持たせるようにする。  
金額加算メソッドをMoneyクラスに追加する。  

``` java
// リスト3.5
// Moneyクラスに金額加算メソッドをようする

class Money {
    // 省略
    void add(int other) {
        amount += other;
    }
}
```

---

### 3.2.3 不変で思わぬ動作を防ぐ

インスタンス変数の上書きは理解を難しくする。  

``` java
// リスト3.6
// インスタンス変数をどんどん上書きしていく

money.amount = originalPrice;
// 中略
if (specialServiceAdded) {
    money.add(additionalServiceFee);
}
// 中略
if (seasonOffApplied) {
    money.amount = seasonPrice();
}
```

変数の値が変わる前提では、いつ変更されたのか、今の値がどうなっているのかを気にする必要がある。  
仕様変更で処理が分かった時、意図しない値に書き変わる「**思わぬ副作用**」が容易に発生する。  

これを防止するため、インスタンス変数を不変(イミュータブル)にする。  
各言語に置けるconst的な修飾子を使用する。  

``` java
// リスト3.7
// finalで不変にする

class Money {
    final int amount;
    final Currency currency;

    Money(int amount,Currency currency) {
        // 省略
        this.amount = amount;
        this.currency = currency
    }
}
```

定数修飾子を付与されたインスタンス変数は変数宣言時かコンストラクタでのみ代入可能となり、再代入は不可能となる。  
インスタンス変数に不正値を直接代入することも出来なくなる。  

``` java
// リスト3.8
// 再代入出来なくなる

Currency yen = Currency.GetInstance(Locale.JAPAN);
Money money = new Money(100,yen);
money.amount = -200; // コンパイルエラー
```

ガード節付きコンストラクタとも合わせて、さらに不正に強い構造となる。  

---

### 3.2.4 変更したい場合は新しいインスタンスを作成する

変更できないのは些か不便なので、方法を考える。  
インスタンス変数の中身を変更するのではなく、変更値を持ったMoneyクラスのインスタンスを新たに生成する。  

``` java
// リスト3.9
// 変更値を持ったMoneyクラスのインスタンスを生成する

class Money {
    // 省略
    Money add(int other) {
        int added = amount + other;
        return new Money(added,currency);
    }
}
```

加算値を持ったMoneyインスタンスを生成、返却するロジックに変更した。  
これで、不変にしつつ、値を変更できるようになった。  

---

### 3.2.5 メソッド引数やローカル変数にも定数修飾子を付けて不変にする

メソッド引数は、メソッド内であれば変更可能。  
しかし、引数等、途中で値が変化すると、どう変化したのか追うのが難しくなり、バグの原因にもなる。  
従って、基本的に引数は変更するものではない。  

よって、引数にも定数修飾子を付ける。  

コンストラクタ引数、ローカル変数も同様。  
途中で値が変化すると意味が変わってしまう。  
ローカル変数で値を変更したい場合は新しく変数を定義すべし。  

``` java
// リスト3.13
// ローカル変数も不変にする

class Money {
    // 省略
    Money add(final int other) {
        final int added = amount + other;
        return new Money(added,currency);
    }
}
```

---

### 3.2.6 「値の渡し間違い」を型で防止する

**思わぬ副作用**の他に、「**値の渡し間違い**」という弊害もある。  

``` java
// リスト3.14
// 金額ではない値を渡せてしまう

final int ticketCount = 3; //チケット枚数
money.add(ticketCount);
```

リスト3.14のように、金額ではないチケット枚数の値を加算出来てしまう。  
これは、型が同じint型であるために引数として渡せてしまうのが原因。  

膨大なデータを取り扱うアプリケーションでは、実装者の不注意から混入してしまう可能性がある。  
渡し間違いを防ぐには、Money型どうしのみで加算するメソッド構造にする。  

``` java
// リスト3.15
// Moeny型だけ渡せるようにする

class Money {
    // 省略
    Money add(final Money other) {
        final int added = amount + other.amount;
        return new Money(added,currency);
    }
}
```

引数の型を、int型からMoney型に変更した。  
Money型以外の型を渡す事が出来なくなった事により、値の渡し間違いを抑止可能となった。  

同じint型では、意図が異なる値を間違って渡してもコンパイルエラーにならない。  
そのため、間違いの発見が困難となる。  

int型やstring型等、プログラミング言語が標準で容易している基本データ型を**プリミティブ型**と呼ぶ。  
プリミティブ型に固執すると、意図が異なる値が複数あっても、整数は全てint型、文字列は全てstring型で定義しがちになってしまう。  
そのため、この手の意図が異なる値を渡してしまうミスを防げない。  

一方、Money型のように独自の型を用いると、異なる型の値が渡された場合にコンパイルエラーで弾く事ができる。  
リスト3.16にもうひと手間を加えて、異なる通貨単位での加算を防止するロジックも組み込む。  
これで、バグに強い、頑強な加算メソッドに仕上がった。  

``` java
// リスト3.16
// addメソッドにもバリデーション追加

class Money {
    // 省略
    Money add(final Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("通貨単位が違います。");
        }
        final int added = amount + other.amount;
        return new Money(added,currency);
    }
}
```

---

### 3.2.7 現実の営みにはないメソッドを追加しないこと

例えば、乗算メソッドを実装したとしよう。  
すること自体は簡単だが、意味はあるだろうか？  

金額の合計値を算出するには加算、割引計算するには減算、割合を求めたい場合には除算を使うだろうが、金額どうしの乗算はあり得るのか？  
少なくとも、会計サービスではあり得ないはず。  
「int型だから加減乗除できるようにしておこう...」と考え、システムに必要ないメソッドを「善意」で追加すると、うっかり使われた時にバグる。  
システムの使用に必要なメソッドのみを定義すべし。  

[地獄への道は、善意で舗装されている | あたご研究日誌](https://ameblo.jp/atago-kenkyujo/entry-12338602400.html)  

---
---

## 3.3 効果の検証

ここまでの実装をまとめる

``` java
// リスト3.18
// 関連ロジックを凝縮した変更に強いMoneyクラス

class Money {
    final int amount;
    final Currency currency;

    Money(final int amount,final Currency currency) {
        if (amount < 0) {
            throw new IllegalArgumentExecption("金額が0以上ではありません");
        }
        if (currency == null) {
            throw new NullPointerException("通貨を指定してください");
        }

        this.amount = amount;
        this.currency = currency;
    }

    Money add(final Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("通貨単位が違います。");
        }

        final int added = amount + other.amount;
        return new Money(added,currency);
    }
}
```

``` mermaid
classDiagram
    class Money{
        +int amount 
        +Currency currency 
        +Money(amount:int ,currency:Currency) void
        +add(other:Money) Money
    }
```

オブジェクト指向による設計効果の検証  
|脆弱性|どうなったか|
|:-|:-|
|重複コード|必要なロジックがMoneyクラスに集まっているため、別のクラスに重複コードが書き散らされにくくなった。|
|修正漏れ|重複コード解消に伴い修正漏れも発生しにくくなった|
|可読性低下|必要なロジックはMoneyクラスに集まっているため、デバッグ時や仕様変更時にあちこち関連ロジックを探し回らずに済み、可読性が向上した。|
|生焼けオブジェクト|コンストラクタでインスタンス変数の値を確定し、未初期化状態がなくなった。|
|不正値の混入|不正値を弾くガード節を用意し、インスタンス変数をfinal修飾子で不変にすることで、不正値が混入されないようになった。|
|思わぬ副作用|final修飾子で不変にすることで副作用から解放された。|
|値の渡し間違い|引数をMoney型にすることで、異なる型の値をコンパイラで防止できるようになった。|

冒頭で述べた、**良いクラスの構成要素**

- インスタンス変数  
- インスタンス変数を不正状態から防御し、正常に操作するメソッド  

見事に実現できたと思われる。  

クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくりと言っても過言ではない。  
同じデータであっても、メソッド引数やローカル変数、static変数を中心にした設計では防御しきれない。  
インスタンス変数だからこそ防御できる。  

関連ロジックがあちこちに散らばった構造を**低凝縮**といった。  
それに対し、ここで示したMoneyクラスのように、密接に関係しあうロジックが一か所にギュッと集まっている構造を**高凝縮**と呼ぶ。  
また、データとそのデータを操作するロジックを1つのクラスにまとめ、必要な手続き(メソッド)のみを外部へ公開する事を**カプセル化**と呼ぶ。  

---
---

## 3.4 プログラム構造の問題解決に役立つ設計パターン

高凝縮化したり、不正状態から防護したり等、プログラム構造を改善する設計手法を**設計パターン**(**デザインパターン**)と呼ぶ。  
デザインパターンは、設計ノウハウとしてカタログ化されている。  

デザインパターンの例  
|デザインパターン|効果|
|:-|:-|
|完全コンストラクタ|不正状態から防護する|
|値オブジェクト|特定の値に関するロジックを高凝縮にする|
|ストラテジ|条件分岐を削減し、ロジックを単純化する|
|ポリシー|条件分岐を単純化したり、カスタマイズできるようにする|
|ファーストクラスコレクション|値オブジェクトの亜種。コレクションに関するロジックを高凝縮にする|
|スプラウトクラス|既存のロジックを変更せずに安全に新機能を追加する|

---

### 3.4.1 完全コンストラクタ

完全コンストラクタとは、不正状態から防護するためのデザインパターン。  

引数なしのデフォルトコンストラクタで生成し、後からインスタンス変数に値を設定する方法では、未初期化のスキが生じ、生焼けオブジェクトになってしまう。  

生焼けオブジェクトを防止するため、インスタンス変数を全て初期化できるだけの引数を持ったコンストラクタを容易する。  
そして、コンストラクタ内では、ガード節で不正値を弾く。  
このように設計することで、生成された段階で正常値だけを持つ完全なインスタンスが生成される。  

さらに、インスタンス変数にはreadonly修飾子を付与して不変とすることで、生成後に不正状態に陥らなくなるため、不正に強い頑強な構造に仕上がる。  

---

### 3.4.2 値オブジェクト(Value Object)

値オブジェクトとは、値をクラス(型)として表現するデザインパターン。  

アプリケーションでは金額、日付、注文数、電話番号など、様々な値を扱う。  
こうした値をクラスとして表現する事で、各値それぞれのロジックを高凝縮にする効果がある。  

例えば、金額を単なるint型のローカル変数や引数で制御していると、金額計算ロジックがあちこちに書かれて低凝縮に陥る。  
また、同じint型の「注文数」や「割引ポイント」が、金額用のint型変数に不注意で代入されてしまう可能性もある。  

こうした事態を防ぐために、値の概念そのものをクラスとして定義する。  
Moneyクラスでは、金額の制約条件(0円以上)をコンストラクタにカプセル化している。  
また、金額計算ロジックが別のクラスにバラバラに書かれないように、Money.addメソッドとして備えている。  
これにより高凝縮をはたしている。  
さらに、Money.addには同じMoney型のみ渡せるので、意図の異なる値を間違って渡してしまうミスを防げる。  

値オブジェクトとして設計する対象は、アプリケーションで取り扱う値、概念となる。  

値オブジェクトとして設計可能な値、概念の例  
|アプリケーション|値オブジェクトとなる値、概念|
|:-|:-|
|ECサイト|税別金額、税込み金額、商品名、注文数、電話番号、配送元、配送先、割引ポイント、割引料金、配送日時|
|タスク管理ツール|タスクタイトル、タスク説明、コメント、開始日、期日、優先度、進捗状態、担当者ID、担当者名|
|健康管理アプリ|年齢、性別、身長、体重、BMI、血圧、腹囲、体脂肪量、体脂肪率、基礎代謝量|
|ゲーム|最大ヒットポイント、残りヒットポイント、ヒットポイント回復量、攻撃力、魔法力、消費魔法力、所持金、敵がドロップする金額、アイテムの売値、アイテム名|

値オブジェクトと完全コンストラクタは得たい効果が近いため、ほぼセットで用いられる。  
**「値オブジェクト + 完全コンストラクタ」は、オブジェクト指向設計の最も基本形を体現している構造の一つ**といっても過言ではない。  
「値オブジェクト + 完全コンストラクタ」で設計すると、制約や意図を型として表現可能になり、堅牢なコードを書けるようになる。  
アプリケーションで扱う値を丁寧に値オブジェクトとして設計していく事が基本となる。  
