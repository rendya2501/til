# 1. 悪しき構造の弊害を知覚する

良き構造へ改善を勧めるためには、まず悪しき構造の弊害を知覚することが必須となる。  
そのうえで、変更に強い良き構造を知ると、ギャップとして悪しき構造の具体的課題を認識できるようになり、設計改善が可能になる。  

設計の重要さを知覚するには、設計をないがしろにするとどんな弊害が怒るのかを知ることが第一歩となる。  
弊害の例としては以下のような事柄が当てはまる。  

- コードを読み解くのに時間がかかる  
- バグを埋め込みやすくなる  
- 悪しき構造がさらに悪しき構造を誘発する  

---
---

## 1.1 意味不明な命名規則

``` java
// リスト1.1
// 技術駆動命名

class MemoryStateManager {
    void changeIntValue01(int changeValue) {
        intValue01 -= changeValue;
        if (intValue01 < 0 ) {
            intValue01 = 0;
            updateState02Flag();
        }
    }
    // …
}
```

リスト1.1のプログラムが何をするプログラムなのか全くわからないだろう。  
型名やメモリ制御を表す用語が散見される。  
このように、プログラミング用語やコンピューター用語に基づいた、技術ベースでの命名を**技術駆動命名**と呼ぶ。  

``` java
// リスト1.2
// 連番命名

class Class001 {
    void method001();
    void method002();
    // …
}
```

リスト1.2のように、クラスやメソッドに対し番号付けで命名するのを**連番命名**と呼ぶ。  

技術駆動命名や連番命名は、意図が全く読み取れない悪しき手法。  
こうしたコードは理解が難しく、読み解くのに膨大な時間がかかり、理解が不十分のまま変更するとバグとなる。  
さらにロジックが不必要に複雑化しやすい。  

意図や目的を表現した命名をすることで構造が簡明になる。  

このようなリスクを下げるため、スプレッドシートなどを用いた対応表が作られる場合があるが、この手のドキュメントは忙しさ等からメンテナンスされなくなっていくため、コードの仕様変更にドキュメントのメンテナンスが追いつかず、ドキュメントが噓を付き始めてしまう。  
実際の動作と乖離が発生し、担当者は混乱にバグを埋め込む可能性が増大するので、即刻辞めるべし。  

---
---

## 1.2 理解を困難にする条件分岐のネスト

言わずもがな。  

条件分岐は、条件に応じて処理を切り替えるための、プログラミングの基本制御となる。  
条件分岐をずさんに扱い、なんの考えもなしに条件を追加していくと簡単にネストしてしまう。  

ネストしているとコードの見通しが悪くなってくる。  
どこからどこまでがif文のブロックなのか読み解くのが難しくなる。  
条件が複雑になると見通しが悪くなり、理解が困難になる。  
理解が困難になるとデバッグに時間がかかったり、仕様変更に時間がかかったりする。  
条件ロジックを正確に理解出来ずに仕様変更した場合、バグとなってしまう。  

---
---

## 1.3 様々なバグを招きやすいデータクラス

データクラスは、設計が不十分なソフトウェアで頻繁に登場するクラス構造。  
データクラスは単純な構造でありながら、様々なバグを招きやすく、開発者を苦しめる。  

金額を扱うサービスを例に、データクラスの何が問題なのかを見ていく。  

業務契約を扱うサービスがあるとする。  
そのサービスでは、契約金額を扱う仕様だとする。  
何も考えずに実装すると、リスト1.5のようなクラス構造になりがちになる。  

``` java
// リスト1.5
// データしか持たないありがちなクラス構造

// 契約金額
public class ConstractAmount {
    public int amountIncludingTax;  // 税込金額
    public BigDecimal salestaxRate; // 消費税率
}
```

税込み金額と消費税率をpublicなインスタンス変数として持ち、自由にデータの出し入れが可能な構造。  
データを保持するだけのクラスを**データクラス**と呼ぶ。  

データの入れ物だけでなく、税込み金額を計算するロジックが当然必要となる。  
設計を考えないで実装した場合、この手の計算ロジックはデータクラスとは別のクラスに実装されることが多い。  

例えば、リスト1.6のように、別のクラスに計算ロジックが実装されたとする。  

``` java
// リスト1.6
// ConstractManagerに書かれる金額計算ロジック

// 契約を管理するクラス
public class ConstractManager {
    public ConstractAmount constractAmount;

    // 税込み金額を計算する
    public int calculateAmountIncludingTax(int amountExcludingTax BigDecimal salesTaxRate) {
        BigDecimal multiplier = salesTaxRate.add(new BigDecimal("1.0"));
        BigDecimal amountIncludingTax = multiplier.multiply(new BigDecimal(amountExcludingTax));
        return amountIncludingTax.intValue();
    }

    // 契約締結する
    public void conclude() {
        // 省略
        int amountIncludingTax = calculateAmountIncludingTax(amountExcludingTax, salesTaxRate);
        contractAmount = new ContractAmount();
        contractAmount.amountIncludingTax = amountIncludingTax;
        contractAmount.salesTaxRate = salesTaxRate;
        // 省略
    }
}
```

小規模なアプリであれば、この構造は特に問題にはならない。  
しかし、大規模になるに連れて、この構造は様々な弊害引き起こすことになる。  

---

### 1.3.1 仕様変更時

この業務契約サービスにおいて、消費税関係で仕様変更が発生したとする。  
あなたは消費税の税率ロジックを変更しました。  

何日か経過して「消費税が新しい税率になっていない」との障害報告が上がってきます。  
原因を調べると、別の箇所にも税込み計算ロジックが存在しました。  
修正対応したが、また障害報告が上がりました。  
やはり別の箇所にも計算ロジックが存在していました。  
他にも税込み計算ロジックがあるのでは？と推測して調べると、数十か所で税込み計算ロジックが実装されていました。  

``` mermaid
---
title: 図1.1 データクラスが原因の重複
---
classDiagram
    direction RL

    class ContractAmount{
        +int amountIncludingTax
        +BigDecimal salesTaxRate
    }

    class ContractManager {
        +calculateAmountIncludingTax(int amountExcludingTax,BigDecimal salesTaxRate) int
        +conclude() void
    }

    class ScreeningManager {
        +calculateAmountIncludingTax(int amountExcludingTax,BigDecimal salesTaxRate) int
    }

    class MessageManager {
        +calculateAmountIncludingTax(int amountExcludingTax,BigDecimal salesTaxRate) int
    }

    class その他クラス {
        +calculateAmountIncludingTax(int amountExcludingTax,BigDecimal salesTaxRate) int
    }

ContractManager --> ContractAmount
ScreeningManager --> ContractAmount
MessageManager --> ContractAmount
その他クラス --> ContractAmount
```

なぜこのようになったのか？  

1. 税込み計算は、金額を取り扱うあらゆるユースケースで必要になるため、多くの箇所で実装されやすい。  
2. 計算ロジックを共通化しても、実装されていることに他のメンバーが気づかず、再実装してしまう。  

このような事態はデータを保持するクラスとデータを使って計算するロジックが離れている時に頻発する。  
データと計算ロジックがそれぞれの箇所に実装されているため、計算ロジックが複数実装されていても認知が難しい。  

このように関連するデータやロジックどうしが分散し、バラバラになっているのを**低凝集**と呼ぶ。  

---

### 1.3.2 重複コード

関連するコードどうしが離れていると、関連するものどうしの把握が困難になる。  
業務契約サービスの例で紹介したように、既に実装済みの機能があるのに、同じようなロジックを至る所に複数実装してしまう可能性が高まる。  

結果、意図せず**重複コード**が量産されることになる。  

---

### 1.3.3 修正漏れ

重複コードが多く実装されている場合、仕様変更時に全ての重複コードを変更しなければならない。  
しかし、重複コードを全て把握していないと、修正漏れが発生し、バグとなってしまう。  

---

### 1.3.4 可読性低下

**可読性**とは、コードの意図や関係する処理の流れを、どれだけ素早く正確に読み解けるかを表す指標のこと。  

関連するコードどうしが分散していると、重複コードを含め、関連するすべてのを探し出すのに膨大な時間が必要になる。  
→可読性が低い。  

大規模なシステムでこれがあると、読み解くだけで体力や精神力が削られていく。  
そして、これらの問題は大抵理解されない。  

---

### 1.3.5 未初期化状態(生焼けオブジェクト)

``` java
// リスト1.7
// 生焼けオブジェクト

ContractAmount amount = new ContractAmount();
_ = amount.salesTaxRate.toString();
```

消費税率salesTaxRateはBigDecimal型として定義されているため、初期化しない限りnullとなる。  
ContractAmountが初期化の必要なクラスであることを利用側が知らないとバグが生じてしまう、不完全なクラスとなる。  

このように、初期化しないと使いモノにならないクラス、または未初期化状態が発生しうるクラスを**生焼けオブジェクト**と呼ぶ。  

---

### 1.3.6 不正値の混入

不正とは、仕様として正しくない状態を指す。  

- 注文数がマイナスになる  
- ゲームにおいて、ヒットポイントの値が最大を超えてしまっている  

リスト1.8が示すように、負の消費税率を代入するなど、データクラスは不正値を与える事が用意に出来てしまう。  

``` java
// リスト1.8
// 不正値を混入可能

ContractAmount amount = new ContractAmount();
_ = amount.salesTaxRate.toString();
```

不正値が混入しないように、データクラスの利用側でバリデーションロジックを実装したとする。  
しかし、税込み計算ロジックと同様に、バリデーションロジックの重複コードがあちこちに記述される可能性がある。  

バリデーションに仕様変更が生じた場合、今度はバリデーションロジックに関して、低凝集で引き起こされる弊害…、すなわち修正漏れや可読性低下が発生する事だろう。  

データクラスが引き起こす弊害まとめてみる。  

- 重複コード  
- 修正漏れ  
- 可読性低下  
- 未初期化状態(生焼けオブジェクト)  
- 不正値の混入  

データクラス1つだけでここまでの弊害が発生しうる。  
可読性が低下し、総じて正確に変更できるまでの時間がかかり、**開発生産性が低下してしまう**。  

---
---

## 1.4 悪魔退治の基本

悪しき構造の弊害を知ること。  
弊害を知ることで「何か対処しなければ」という意識が生まれる。  

オブジェクト指向の基本であるクラスを適切に設計する事。  
オブジェクト指向設計が悪魔退治の武器となる。  
