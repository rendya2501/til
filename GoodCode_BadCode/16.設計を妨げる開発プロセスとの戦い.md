# 16. 設計を妨げる開発プロセスとの戦い

レガシーコードが書かれてしまうのは、問題を抱えた開発プロセスが背景にあることが多い。  
この章では、設計品質を貶めてしまう開発プロセスの問題をとりあげる。  
問題はスキル不足以外に心理的要因やコミュニケーション要因、組織的要因など様々。  

---
---

## 16.1 コミュニケーション

### 16.1.1 コミュニケーションが希薄だと設計品質に問題が生じる

すぐ隣同士のメンバーが全く同じコードを書いている。  
お互いのロジックがうまく嚙み合わずバグ化するといった事象が、チーム開発では度々見受けられる。  

こうした事象はなぜ引き起こされるのか？  
それは、お互いに何をやっているのかわからないから。  
なぜわからないのか？  
メンバー同士のコミュニケーションが希薄だから。  

忙しかったり、メンバー同氏の関係がうまくいっていなかったり、情報も目線があっていなかったり、コミュニケーションを阻害する様々な原因が考えられる。  
メンバーどうしのコミュニケーションに問題があると、バグが増大する傾向にある。  

### 16.1.2 コンウェイの法則

コミュニケーションの問題解決にあたり、コンウェイの法則を紹介する。  

**コンウェイの法則**は「システムの構造が、それを設計する組織構造に似てくる」という法則。  

もっと平たく言うと、例えば開発部門が3チームに分かれているとしたら、チームと同じ数のモジュール、3個から構成されるシステムが出来上がる、ということ。  

なぜこうなるのか。  
複数のチームを編成すると、各チーム内のコミュニケーションは密になる。  
一方、チームがいとのコミュニケーションは疎になる。  
機能リリースの都合を考えた場合、チーム外と歩調を合わせるより、チーム内で完結したほうがリリースしやすくなる。  
そのため、リリース機能の粒度はチームの粒度に近づいていく。  
こうしてシステム構造がリリース単位、すなわちチーム単位の構造になっていく。  

コンウェイの法則はコミュニケーションコスト構造の法則ともとらえられる。  
チーム内はコミュニケーションコストが低い、チーム外とはコミュニケーションコストが高い、といったコスト構造がシステム構造に影響してしまうため。  

つまり、あるべきシステム構造と組織構造に違いがあると、あるべきシステム構造を作り上げるのが困難になってしまう。  

そこで近年では、コンウェイの法則を逆手に取った**逆コンウェイ作戦**が考案されている。  
それは、ソフトウェアとしてあるべき構造を先に設計し、それからソフトウェア構造に最適な組織編成をする作戦。  

しかし、逆コンウェイ作戦を表面的になぞるだけでは、うまくいかないと考える。  
メンバーどうしのコミュニケーションに課題があると、隣同士なのに同じコードを書いたり、お互いに嚙み合わないロジックを書いたりしてしまいがち。  
コンウェイの法則はコミュニケーションコスト構造の法則。  
つまり、メンバー間のコミュニケーションの問題は、メンバー間でのコミュニケーションコストが高いと言える。  
逆コンウェイ作戦でチーム編成しても、チーム内の関係性に問題がある場合、本質的な構造課題の解決にならない。  

---

### 16.1.3 心理的安全性

チームメンバーとの関係改善には、心理的安全性の向上が不可欠。  

**心理的安全性**とは、「自分が発言することを恥じたり、拒絶されるなど、不利益を被ることがないことをチームで教諭されている心理状態」や「安心して自由に発言したり、行動できる状態」という定義がなされている。  
1999年にハーバード大学で提唱され、2012年にGoogle社の労働改革プロジェクトにて採用されたことから脚光を浴びた概念。  
心理的安全性は、成功に導くチームを構築する上で重要と言われている。  

意見や提案をする上で、冷笑されたり、煙たがられたり、聞く耳を持たれない状態では、情報共有がうまくいかない。  
ましてチーム単位での設計品質向上はとても難しくなることだろう。  

コミュニケーションに課題がある時、まずは心理的安全性の向上に努めるべし。  

---
---

## 16.2 設計

設計は極めて重要な開発プロセスであるが、設計が行われない、設計がうまく働かない等、様々な問題があると思われる。  
ここではその対処の仕方を説明する。  

---

### 16.2.1 「早く終わらせたい」心理が品質低下の罠

品質がよくないシステムを作るチームでは、そもそもクラス設計の習慣がない。  
仕事が忙しいと、実装を早く終わらせたい気持ちが先走り、動くコードをとにかく早く実装しがちになる。  
納期の厳しい受託開発では顕著だろう。  
そのため、クラス図すらろくに書かないなど、設計品質が無視されがちとなる。  
著者の観測の範囲に過ぎないが、こういった事例は本当に多く、懸念を覚える。  

設計品質度外視で、動くコードをとにかく早く書けるプログラマーが一部にはいる。  
コードが劣悪でも、動いている画面を見ると、非エンジニアを含む現場は喜んでしまう。  
口々に「もう実装できたんですか、流石ですね！」ともてはやす。  
褒められたプログラマーはうれしいし、早く書けることがある種正義のような雰囲気が醸成されていく。  
しかし、それが罠なのだ。  

ほとんどのソフトウェアは1回作って終わりではない。  
その後、仕様変更が繰り返され、機能はどんどん拡張されていく。  

品質を無視した実装の繰り返しにより、粗悪なコードはどんどん蓄積されていく。  
粗悪なコードは後から牙をむくようになる。  
複雑で読み解くのに時間がかかり、些細なコード修正でバグが発生するなど、開発生産性は低下の一途をたどっていく。  

設計品質度外視で動くコードを早く書けるプログラマーは、序盤では早く実装できる。  
しかし、後になるほど実装速度が遅くなっていく。  
粗悪な実装により、修正の影響が様々な箇所に伝播してしまうためである。  
彼らは「完成しました」と報告はしても、その後の度重なるバグの修正に忙殺される。  
バグだらけのコードを書いて完成したといえるのだろうか。  

---

## 16.2.2 粗悪なコードはきれいなコードを書くより常に遅い

書籍「Clean Architecture」には、コードに関する驚くべき実験結果が記載されている。  
テスト駆動開発(TDD)を用いての実装と、用いない実装のどちらが早く完成するかの比較実験である。  

TDDでは、プロダクションコード以外にテストコードを実装しなければならないため、一見テストコードを書かないほうが早く完成しそうな感じがする。  

ところがこの実験では、TDDのほうが全体的に早いという結果になったのだ。  
この実験結果からも、「動くコードをとにかく早く書けるのが正義」といった考えに、著者は疑問を覚える。  

※テスト駆動開発(TDD,Test Driven Development)とは、開発手法の1つ。  
プログラムの機能要件をテストコードとして最初に書き、次にテストをパスするようにプロダクションコードを実装し、さらにコードの洗練を繰り返していく手法。  

---

### 16.2.3 クラス設計と実装のフィードバックサイクルを回す

仕様変更の際、最低でもメモ書き程度のクラス図を書こう。  

責務や凝集性などの観点から課題がないかどうかを、チームでざっくりレビューするのだ。  
問題がなさそうであれば実装に取り掛かる。  

実装してみて改めてわかることや見落としが発見されるケースが多分にあるので、クラス図にフィードバックする。  

設計と実装のフィードバックサイクルを回すことで、設計品質が高まっていく。  

---

### 16.2.4 厳密に設計しすぎず、サイクルを回し続けるのがコツ

大がかりな仕様変更では、それなりにしっかりしたクラス設計が必要となる。  
一方で厳密に設計しすぎるのはお勧めしない。  
どんなに設計しても、動作に必要な要素の見落としを、実装してみて初めて気が付くケースが多いためである。  

初手で厳格に設計しすぎると、実装と乖離が生じたときの精神ダメージが大きくなる。  
「いくら厳密に設計しても、実際の実装とは違う。こんな大変な思いをして設計しても、役にたたない」と、設計に価値を感じなくなり、設計をしなくなる場合すらある。  

**たった一度の設計では、良き構造は見いだせない。**
設計と実装のフィードバックサイクルを回し続けることで理解が深まっていき、徐々に設計品質が向上していくものだ。  

「設計と実装が違う」「この設計でいくときめたじゃないですか、話が違う」ともめる原因にもなりかねないので、このサイクルの考え方はチームでしっかり合意することをお勧めする。  

---

### 16.2.5 「パフォーマンスが落ちるからクラスを追加しない」は正しい？

「クラスのインスタンス生成はコストがかかる。パフォーマンスが落ちるから、クラスを増やしたくない」と考える方が一定数いる。  
生成コストがかかるのは確かであるが、そのコストは多くのケースで無視できるものである。  

近年はハード、ソフトともに性能の向上が続き、相対的にクラス生成コストはますます低下していく。  
それでもパフォーマンスが気になるなら、まずは実際にパフォーマンスに影響が出ているか計測すべし。  
計測すると、多くの場合、クラス生成が与える影響はまったく、またはほとんどないことが分かるはずである。  

この問題はクラス生成に限らない。  
パフォーマンスに対して支配的な部分、いわゆるボトルネックは、計測するまでわからないのだ。  
ボトルネックが分からないうちから高速に動作するコードをやみくもに書くことは、**早すぎる最適化**と呼ばれるアンチパターンとなる。  

パフォーマンスに影響のない箇所で高速化を目指したコードを書き、変更容易性を犠牲にするのは問題である。  

---

### 16.2.6 設計ルールを多数決で決めるとコード品質は最低になる

コードの品質を向上させるため、コーディングルールや設計ルールをつくるケースがあるだろう。  
ここで、もしかするとチーム全体の合意形成を目的に、ルールを多数決で決定する方法を採ろうとするかもしれない。  

しかし、設計ルールの策定において、多数決は不幸な結果になりがちになる。  
多数決や全会一致でコードや設計について決めようとすると、どうしてもレベルの低いほうに合わせて基準をまとめようとするためだ。  

提案されたルールの良し悪しを、設計スキルが未熟なメンバーは判断できない。  
そのような未熟なメンバーが多数を占めているチームでルールを多数決で決めようとすると何が起こるだろうか。  

ルールの意図がっ十分に理解されないまま、無用な反発が生まれる。  
「自分のコーディングの仕方と会わない」「いちいちこんなことしていられない」「面倒だ」「よくわからない」などの様々な反対意見が生じ、ルールの採用が難しくなっていく。  

改善提案は通りにくくなり、粗悪なルールが採用されたり、ルールそのものが策定されなくなったりする。  

---

### 16.2.7 設計ルールづくりのポイント

メンバー間の能力差が大きい場合は、多数決でなく、シニアエンジニアなど設計スキルの高いメンバーが中心となってルールを作るべし。  
そしてチームリーダーの権限で、ルールの遵守を推進していくべし。  

設計ルールそれぞれには、理由や意図を必ず併記すべし。  
形骸化を防ぎ、より洗練されるようにするためである。  

表16.1 設計ルールの例  
|ルール|理由、意図|
|:-|:-|
|ネストは3以下とすること。</br>ネストが深くなりそうな場合、早期リターンへの書き換えを検討する事。|可読性を向上させるため。|
|同じ条件分岐が複数実装されそうな場合、インターフェース設計を検討する事|修正漏れの可能性が高くなるため。|
|クラスやメソッドの名前は特定の目的を表現していること。|目的がよくわからないとロジックが混乱し、保守や変更が大変になるため。|

これらを踏まえて、次のことを伝えるべし。  

- 設計ルールは、パフォーマンスやフレームワークの制約など、様々な要件とトレードオフになる可能性がある。  
- 何が何でもルール絶対遵守ではなく、落とし所、妥協点の模索が必要な状況がある。  

チームの設計スキルが成熟していないうちは、自助努力に任せず、設計に詳しいメンバーが設計品質をコントロールできるようにする。  
詳しいメンバーを設計レビューやコードレビューにアサインしよう。  

レビューだけではスキルアップが不十分な場合もある。  
フォローアップ勉強会も適宜開催し、チームの設計スキルアップを目指そう。  

設計ルールの意図が一度で伝わるのは稀である。  
レビューや勉強会を繰り返して、何度も伝え続けることで少しずつ理解が進んでいく。  

チームの設計スキルが成熟して来たら、そこで改めて設計ルールについて議論するのがいいだろう。  

---
---

## 16.3 実装

コードへの向き合い方、考え方が変わると、実装の取り組み方が違ってくる。  

---

### 16.3.1 割れ窓理論とボーイスカウトの規則

犯罪学に**割れ窓理論**という理論がある。  
以下の経過をたどって治安が悪化していくとする説である。  

1. 建物に割れた窓が1枚ある。  
2. 割れた窓が長く放置されていると、誰も気にかけていない象徴になる。  
3. ほかの窓が割られる、ごみを捨てられるなど軽犯罪が起こり、次第に治安が悪化する。  
4. さらにエスカレートし、凶悪犯罪が起こるようになる。  

ソフトウェア開発でも同じことが言える。  
粗悪で、複雑で秩序のないコードが放置されていると、ソフトウェア全体が無秩序になってしまう。  
「ほかのコードも雑な作りなんだから、自分のも多少は雑でいいだろう」という心のスキが生じる。  
自分が1回に追加・変更するコードは大した量ではないかもしれない。  
しかし、積み重なっていくと、取り返しが困難なレベルにまでソフトウェア全体のコードを腐敗させてしまう。  

アメリカの**ボーイスカウトの規則**には「キャンプ場を、自分が来た時よりもきれいにすること」がある。  
これをプログラミングにも当てはめて考えることができる。  
コードを変更する時、自分が変更する前よりもきれいな状態にしてコミットするのである。  
小さな積み重ねではあるが、小さな改善が繰り返されることによって少しずつ秩序が回復していくはずである。  

あるべき構造を本書で学んだ後は、どんな構造が悪魔を呼び寄せるのか、すでに「目を持っている」状態なはずである。  
悪しき構造が光って見えるはずである。  
少しずつでよいので、気が付いた箇所を改善するクセを付けていこう。  

---

### 16.3.2 既存コードを信用せず、冷静に正体を見破る

粗悪なコードを疑いもなく真似てしまうことが多々ある。  
新入社員や後任者は、先輩社員や前任者が書いたコードがレガシーコードだと気づかず、むしろ「これが先輩のお手本だ」「前任者の流儀だ」と思い違いをしてしまい、レガシーコードと同じ書き方でさらにレガシーコードを量産してしまうことになる。  
技術力が未熟な新入社員はこの傾向が顕著である。  

レガシーコードを撲滅するには、既存コードを一切信用しないぐらいの心構えが重要である。  
構造的に怪しいもの、クラス名やメソッド名が怪しいものなど、さまざまである。  
名前一つとっても、仕様と異なる、意味が異なる名前が付与されているものもある。  

「これは何を解決したいコードなのか」「達成したい目的はなんなのか」を分析し、あるべき設計をゼロベースでくみ上げる必要がある。  
筆者はこれを**正体を見破る**と呼んでいる。  
しかし、正体を見破るにあたり、いくつか乗り越えるべきハードルがある。  s

ハードルの1つは、**アンカリング効果**と呼ばれる心理作用である。  
これは、最初に提示された数値や情報が基準になってしまい、その後の判断をゆがめてしまう認知バイアスのことである。  
例えば、最初に提示された価格が高額だと、後から提示された価格が割安に感じられる。  
最初の価格が損得の判断基準になってしまう。  
これがアンカリング効果である。  
アンカリング効果に振り回されないためには、そもそも最初に提示された価格が本当に妥当だったのかどうかを検証する必要がある。  

アンカリング効果はソフトウェア開発でも発生する。  
既存のクラス名やメソッド名が基準となってしまい、開発者の判断を歪ませ、混乱させてしまうケースがとても多い。  

もう一つのハードルは、**ジョシュアツリーの法則**と呼ばれる法則である。  
これは、名前を知って初めて存在を知覚できるようになる、逆に名前を知らないと存在を知覚できないとする認知法則である。  

「生焼けオブジェクト」を知ったことで、どういったコードが生焼けオブジェクトなのか、読者の皆さんは知覚できるようになったはずである。  
一方、「売買契約」という名前も概念も知らなければ、売買契約について回る支払い条件の存在を知ることは困難である。  

知らなければ対処できないというハードルを乗り越えるには、詳しい人にインタビューしたり、文献を読んだりするなど、ソフトウェアで解決したい内容、達成したい目的について、詳しい知見やそこで使われている言葉を把握し、理解することが重要になる。  

これら2つのハードルを乗り越えて冷静に正体を見破り、正体を正しく表現した名前をクラスに付与しよう。  

---

### 16.3.3 コーディング規約を利用しよう

プログラミング言語は多様な書き方ができる。  
例えばある変数名が`personName`でも`PERSONNAME`でも`person_name`でも、Javaではコンパイルが成功する。  
また、インデントの深さや`{`の前で改行するかどうかも自由である。  

しかし、これらに統一性がないと、コードが非常に読みづらくなる。  
コードの読みやすさを高めるには、コーディング規約が欠かせない。  
**コーディング規約**とは、コードの可読性、保守性向上や、問題のあるコードの未然防止を目的に、コーディングスタイルや命名規則などのルールを定めたものである。  

コーディング規約を遵守することで、コードの構造や命名に秩序が生まれ、読みやすさがグッと上がる。  
ほとんどのプログラミング言語には、企業や有志の団体により編纂されたコーディング規約があり、ネット上に公開されている。  

コーディングスタイルをチェックする機能やツールは多数ある。  
多くのIDEには、チェック機能が備わっている。  
RoboCop(Ruby)やESLint(JavaScriptほか)など、ツールが個別に提供されていることもある。  
これらを使わない手はない。  

---

### 16.3.4 命名規則

コーディング規約はフォーマットやコメントの書き方など多岐にわたる。  
そのうちの命名規則を開設する。  

**命名規則**とは変数名やクラス名、メソッド名を決める際のルールである。  
例えば、Javaのコーディング規約を定めた「Future Enterprise Coding Standard for Java」には次のようなルールがある。  

表16.3 Java命名規約の例  
|要素|ルール|例|
|:-|:-|:-|
|クラス|アッパーキャメルケース|Customer|
|メソッド|ローワーキャメルケース|payMoney|
|定数|すべて大文字、区切りは`_`|MAX_NAME_LENGTH

アッパーキャメルケースとは単語の先頭を大文字にするルールで、ローワーキャメルケースとは区切りのみ大文字にするルールである。  
他には、すべて小文字で単語の区切りを`_`で示すスネークケース(例:`pay_money`)などがある。  

プログラミング言語ごとに命名規約は異なる。  
例えば、インスタンス変数の命名に関してJava(Future Enterprice Coding Standards for Java)とRuby(RuboCop Style Guide)では以下の違いがある。  

表16.4 言語ごとの命名規則の違い
|言語|ルール|例|
|:-|:-|:-|
|Java|ローワーキャメルケース|totalPrice|
|Ruby|スネークケース|total_price|

同じ言語でも、採用するコーディング規約によって命名規則が異なるケースがある。  
コーディング規約は既存のものをそのまま利用することもあれば、既存をベースに改良することもある。  
いずれにしても、統一的なルールを定めて、チーム全体で可読性を高めていくことが大切となる。  

---
---

## 16.4 レビュー

レビュー時に注意すべき点や工夫の仕方をまとめる。  

---

### 16.4.1 コードレビューを仕組化しよう

レガシーコードが書かれる現場では、コードレビューの習慣がない場合が多い。  
とりあえず動作するだけの雑なコードが誰のチェックも通らず、次々にマージされていく。  

品質が良くないため、バグが頻発することになる。  
バグに対して付け焼き刃的な修正がなされるが、得てして根本原因の解決にはなっておらず、何度も同じバグが発生したり、バグ修正が原因で別の箇所がバグ化したりする。  

GitHubでは、他のメンバーからApprove(承認)されたPullRequestのみマージ可能な仕組みを利用できる。  
他にもコード品質の解析やユニットテストとの連携、自動実行などCI機能が充実しているので利用すべし。  

PullRequestしたコードには、コードの歴史や経緯を知っている人や、設計に詳しい人をレビュアーとしてアサインすべし。  
PullRequest作成時のテンプレートテキストには、レビュー観点を盛り込むべし。  
ボーイスカウト規則のチェック項目を設けたり、設計ルールへのリンクを張ったりするのも良いだろう。  

---

### 16.4.2 コードを設計視点でレビューしよう

コードレビューは「ロジックが機能要件を満足しているかどうか」や「欠陥の有無」、「コーディングスタイルをレビューするもの」として広く認知されている模様。  
しかし、むしろ**設計的な妥当性に重点をおいてレビューすべき**である、と筆者は言っている。  

解説してきたように、設計品質はコード1つ1つに現れる。  
上げてきた設計観点と照らし合わせながらレビューすべし。  

---

### 16.4.3 敬意と礼儀

コードレビューにおいて、技術的な正しさをかさに来て、攻撃的なコメントを寄せる人がいる。  
攻撃的なコメントは、どんなに正しい内容であれ許されない。  
こうしたレビューは人格を傷つけ、生産性を低下させ、コードを良くするという本来の目標を阻害する。  

コードレビューで最重要なのは、敬意と礼儀となる。  
レビューを受ける側への敬意を第一に意識しよう。  
技術的な正しさや有用性よりも、まずは共に働く、コードを書く仲間を尊重すること。  
敬意と礼儀を意識しながら指摘することが、コード品質を高める最短経路。  

GoogleのChromiumプロジェクトのレビュー方針、「敬意に満ちたコードレビュー」は以下の通り。  
この方針は、すべきことといけないことを決めている。  

|すべきこと|解説|
|:-|:-|
|能力と善意を想定する|開発者の十分な能力と善意を想定する。ミスは情報不足に起因するものだと考える|
|会って話し合う|レビューツール上でのやり取りで意見がまとまらなければ、実際に話して意見を交換する|
|理由を説明する|なぜ間違っているか、どういう変更が正しいかを説明する。「間違っています」だけでは相手に伝わらない。|
|理由を効く|相手の意図が不明瞭な時は、遠慮せず変更理由を聞く。</br>やり取りを記録することで、将来的に変更の意図などがわかる。</dr>また、よりよい実装を考える機会にもなる。|
|終わりを見つける|完璧に拘泥して徹底的なレビューを使用とすると、レビューされる側は疲弊する。「絶対に間違いないと保証する」ではなく、「よさそうです」でレビューを適切に終える|
|適度な時間内に返信する|レビューをいつまでも放置しない。24時間以内に返信出来なければ、いつまでに返信できるかをコメントで残すなど、適切に対応する。|
|ポジティブに述べる|「すべての欠点をみつけてやるぞ」という気持ちで臨まず、ポジティブな点を認める姿勢でレビューする。無理に褒める必要はないが、難しい仕事を引き受けてくれた人や、良い変更をしてくれた人に感謝する姿勢は大事。|

|いけないこと|解説|
|:-|:-|
|人を貶めない|相手は最善を尽くしている事を前提にする。「なぜ気が付かなかった？」といった無意味なコメントをしない事|
|極端な言葉やネガティブな表現を使わない|「まともな人間ならこうはしない」「ひどいアルゴリズムだ」といったネガティブな表現をレビュー時に使ってはいけない。</br>人を脅して思い通りに動かそう等と考えてはいけない。</br>人ではなく、コードについて議論すべし。|
|ツールの使用を思いとどまらせない|コードフォーマッターなど自動化ツールを導入してくれたら、まずそのことに感謝する。ツールの是非やや好みを押し付けてはいけない。|
|自転車置き場の議論をしない|どちらでもいいようなことについて、レビューで決着を付けようとしないこと。レビューの目的は「勝ち負け」ではない。|

このレビュー指針は、多くをそのまま導入可能であるはず。  

簡単な例を示す。  
次の指定は技術的には正確かもしれないが、敬意と礼儀に欠ける。  

>ここで○○メソッドは使わないでください。パフォーマンスが悪いです。こういう実装は何もいいことがありません。  

この指摘は以下の指針に反している。  

- 能力と善意を想定する  
- 理由を説明する  
- 人を貶めない  
- 極端な言葉やネガティブな表現を使わない  

これらを踏まえ、望ましい形に直す。  

>動作しますし、十分いい変更です。ただ、パフォーマンスをもう少し改善したいです。○○メソッドでも実装出来ますが、□□メソッドのほうが実行速度で有利です。  

相手を傷つけるかもしれない表現をしないように注意を払いましょう。  
正しければ何を言ってもいいというのは、幼稚な考え方です。  

---

### 16.4.4 定期的に改善タスクを棚卸しすること

実装やレビューの途中で良くないコードに気づく場合がある。  
スケジュール的な問題により対処が難しいこともある。  
こうした状況では「後で直しておこう」と後回しにされがち。  

しかし、この手の欠陥は、なんら対策せずにいると放置され、修正されることはほぼない。  
なぜなら次々に新しい業務をアサインされ、次のスケジュールで埋まってしまうから。  
新しい仕事に忙殺され、結局は忘れ去られてしまう。  

良くないコードへの対処は、タスク管理ツールに改善タスクとして積み上げておく事。  
そして、定期的にタスクを棚卸して、確実に対処できるようにしておく。  

例えば、週1回のチームミーティングで、今週取り組む改善タスクの話し合いを設けるのがいいだろう。  
タスク管理には、GitHubのIssueを用いると良い。  
ソースコードやPullRequestとの関連付けが便利。  

---
---

## 16.5 チームの設計力を高める

この章で取り上げた開発プロセスは、設計に理解を示すメンバーがチームにある程度いる前提の話だった。  
チームによっては、設計に詳しいメンバーが誰もいない事もある。  
そのような状況では、設計改善に取り組もうにも、殆どうまくいくことはない。  
筆者もそうだった模様。  
実際にあったやり取りが以下の通りなんだとか。  

``` txt
筆者  「この○○Managerの責務は何でしょうか」
同僚A 「○○を管理するクラスです」
筆者  「管理とは何でしょうか」
同僚A 「管理は管理です」
筆者  「管理が意味するところの具体的な内訳をお願いします」
同僚A 「○○を登録したり、△△を転送したり、□□を切り替えたり」
筆者  「それらはいずれも関心事が別ですよね。仕様変更時の課題になりそうなので、関心事それぞれのクラスに分解したほうが良いです」
同僚A 「気にしすぎですよ、管理は管理でいいじゃないですか」
```

このようにレビューがまともに機能しないケースが往々にしてある。  
レビューに限らず、設計や実装の改善提案も困難になる。  
チーム全体の設計力が不足している場合、設計力を高めていくための活動が必要となる。  
開発リソースを決める経営層を説得するのが一番のように思えるが、それはそれで非常に骨が折れる。  
どうすれば良いか。  

---

### 16.5.1 影響力を持つレベルにまで仲間を集める

あなたが品質のマズさに気づき、設計のテコ入れを考えたとする。  
しかし、自分1人で品質向上活動をしてもなかなか効果は上がらない。  
下手をすれば、「あいつは指示以外の何か余計なことをやっているようだぞ」と逆に目をつけられてしまうリスクが生じる。  

設計に限った話ではないが、仕事のやり方をボトムアップで変えていくには周囲の協力が不可欠となる。  
自分のチームや他の全てを巻き込めるに越したことはないが、中には考えが会わないメンバーがいるなど、多くを巻き込むのは至難の業となる。  

なぜ協力が必要なのか？  
それは仕事のやり方を変えるだけの影響力を持つためである。  
まずは影響力を持てるだけの仲間を集めることが重要になる。  
影響力を発揮できるのはどれくらいの規模なのか？  

ランチェスターの法則と呼ばれる軍事理論がある。  
これは戦闘力、および的に与える損害量定義した理論である。  
このランチェスターの法則を応用したマーケットシェア理論は、市場占有率に基づいた競争理論である。  

この理論で注目したいのが、市場占有率別の目標を定義したクープマン目標値である。  
目標値の一つに、影響目標値がある。  
これは「影響力を無視できない存在レベルであり、シェア争いに本格参入する目標値」とされている。  
この目標値は10.9%と定義されている。  
筆者は、この数値が現場の改善のために必要な人数の算出にも活かせると考えている。  

この数値をエンジニアチームに当てはめて考えてみる。  
仮にチームが20人であれば、2.18で約2人。50人であれば、5.45で約5人となる。  
それほど多くはない。  
チームが20人なら自分以外のもう1人を仲間に出来れば良いのだからなんだかいけそうな気がしないだろうか。  

まずは気の合うメンバーに声をかけてみよう。  
「最近の実装はどう？変更するのが結構大変だと思わない？」「変更後のデバッグが辛いよね」「ちゃんと設計したいよね」など、なんでもいいです。  
悩みを打ち明けながら、協力してくれそうな仲間を増やしてみよう。  

---

### 16.5.2 基本はスモールステップ

仲間が見つかると、もしかしたら本書に書かれている内容を一度に伝えてしまいたい衝動にかられるかもしれない。  
しかし、焦りは禁物である。  
人は一度に大量の情報を受け止めきれないし、大きな変化に対して不安や抵抗を覚える物である。  

毎日少しずつ、スモールステップで設計の知識を共有していこう。  
もちろん聞き手が食いつく、興味がありそうなら、より多くを共有して議論するのはありだろう。  

---

### 16.5.3 実感が大事、手を動かしてみよう

仲間と設計の知識や認識をある程度共有できたら、一緒にクラスを設計、実装してコードレビューをしてみよう。  
百聞は一見に如かずというように、物事のありさまは言葉を重ねるよりも実際に見たり実家したりする方が確かだ。  

設計も同様で、例えばコードが読みやすいかどうかは感覚的な問題となる。  
つまり、読みやすさについて改善前と改善後を見比べて、初めて良さを実感できる物である。  
実際に手を動かして、コードの見通しが良くなった、重複コードが減った、といった実感を仲間と共有して見よう。  

その際、プロダクションコードを用いての改善実験をお勧めする。  
架空の仕様やコードを用いるのも良いかもしれないが、複雑さや無秩序さ、泥臭さはプロダクションコードに及ばない。  
複雑で無秩序なコードを、シンプルで秩序あるコードに改善することで、設計のありがたみをより実感できる。  

---

### 16.5.4 フォローアップ勉強会を開いてみよう

仲間の輪をより大きくするために、設計の勉強会を開催してみよう。  
始めは読書会形式で本書のような設計本を読み合わせるのが良いが、先述のように、やはり実際に手を動かしてコードを改善してみるのが効果的である。  
インプットよりもアウトプットのほうが学習効果が高いと言われているので猶更。  

- おすすめの勉強会の流れ  
  1. 本に書かれているノウハウを1,2個程度読み合わせる。  
  2. ノウハウを適用できそうな箇所を、プロダクションコードの中から探す。  
     参加者それぞれが普段触っているコードであればとっつきやすくて良い。  
  3. ノウハウを使ってコードを改善してみる。  
  4. どう改善したかについて、before,afterがわかるように発表する。  
  5. 発表内容について質疑応答や議論をする。  

この勉強会を、1回1時間程度、スモールステップで繰り返していく。  
こうすることで、インプット、アウトプット、フィードバックを素早く回す事ができ、効果的に記憶に定着する。  
また、設計に対する意識付けと認知度が向上する。  

---

### 16.5.5 勉強会のバッドノウハウ

勉強会のやり方によっては、あまり効果を得られなかったり、イメージダウンしてしまったりするので注意が必要。  
まず、本の読み合わせ「だけ」をするのはお勧めしない。  
アウトプットが伴わず、学習効果が低いため。  
また、一度に大量にインプットだけしても、忙しい仕事の中では、人はすぐに忘れてしまう。  

先述のように、コードを改善して実際に良くなった感覚を得るのが重要となる。  
インプットだけだと実感が伴わず、「ほんとにこれ役に立つの？実際の開発に使えるのか怪しいんだけど」と、参加者は不安や疑念を抱いてしまう。  
もっとひどくなると「あれは理想論、使い物にならない」と失望されてしまう。  
「これが正しい設計手法だ!すぐに受け入れろ!」と言わんばかりに、これ間の実装を頭ごなしに否定するのも良くない。  

設計に限らず、新しい技術を取り入れる際は、ついつい既存のスタイルを否定しがちになってしまうが、それは悪手である。  
人にはプライドがある。  
成果物を否定された良い気分はしないものだ。  

不信感が大きくなれば、そもそも話すら聞いてもらえなくなる。  
設計の輪を広げるどころではなくなってしまう。  
そうならないためには、相手の意見に共感したり、尊重したりする姿勢が重要となる。  
そのうえで少しずつ課題と解決方法について冷静に議論し、話の歩みを寄せていくべし。  
よく話してみたら、例えばパフォーマンス上の課題があり、新しい設計手法を適用するにも出来なかった、というケースも時にはあったりする。  

ここまで意見共有できて、初めて同じ目線で設計課題をどうしようか、と一緒に考えていける。  
考えが異なる人と目線を合わせるのは中々骨が折れるものだ。  
しかし、目線にギャップがある状態で無理に話を通そうとするとお互いが不幸になる。  

中々設計の考えが広まらないことに対して、時には焦りやいらだちを覚えることもあるだろう。  
しかし、ここは忍耐だ。  

ソフトウェアの変更容易性に課題があるのは、これまで悪魔に例えてきたように変更容易性に関する設計が認知されていない事が大きな原因の一つである。  
あるべき構造と効果を知らないと悪魔には見えないものなのだ。  

勉強会においても、設計技術をいきなり無理に教え広めるのではなく、徐々に伝えていくべきである。  
変更容易性という品質特性がある、そして変更容易性を向上させる設計技術があることを認知させる程度の方が、入っていきやすいだろう。  

---

### 16.5.6 リーダーやマネージャーに設計と費用対効果の話をする

変更容易性ｎテコ入れできず、低下の一途を辿ってしまう組織的な問題は、そもそも開発リソース(予算、計画)に変更容易性に関する設計コストが盛り込まれていない事が主たる要因である。  
盛り込まれない理由として、予算や計画を決めるメンバー、すなわちチームリーダーやマネージャーや特に経営層の頭脳に、変更容易性に関する知識がインプットされていないケースが考えられる。  

組織として設計品質を向上させるには、やはり開発プロセスの流れに設計を組み込む必要がある。  
そのためには、リーダーやマネージャーと設計意識の共有が必須となる。  
プロセスに正式に認められていないと、他の仕事を優先するよう支持されるなど、何かと動きにくいものだ。  

マネージャーには、費用対効果を中心に話を持っていくべし。  
マネージャーは、チームに割り当てられた予算を用いて、どのように投資し、利益を最大化するかに責任を追っているためである。  
費用対効果は彼らの最大の関心事である。  

開発効率低下の問題と、問題解決のための設計業務があることを伝えるべし。  
そして設計が必要な投資コストであることを説明すべし。  
一方マネージャーからすれば、設計コストがどれぐらい高くつくのか気になるところとなる。  
毎日の開発業務の中で、スモールステップで遂行するものであることを説明しよう。  
仕様変更の頻度が高い領域に絞って、集中的かつ効果的ンい変更容易性個以上を狙う設計であることを伝えよう。  

マネージャーへ説明する際は、1人ではなく仲間と一緒であることが望ましい。  
これまで仲間内でやってきた設計活動とその実績も交えて説明すると、より説得力が上がるだろう。  

---

### 16.5.7 設計責任者を立てる

開発メンバーの多くが設計品質を良くしていく積極性があれば、品質向上のための様々な取り組みが自然となされていくものだ。  
しかし、そうではない場合、設計責任者を立てることをお勧めする。  
設計責任者は変更容易性の品質向上のため、以下を推進していくものとする。  

- 設計品質に関わるルールや開発プロセスの策定  
- ルールの周知、教育  
- リーダー・マネージャー層への共有  
- 品質の可視化  
- 設計品質の維持  

設計方針やコーディングルール、レビュー方法など、設計品質に関わるルールや開発プロセスを策定仕様。  
ルールはほおっておくと形骸化する。  
なぜルールが必要なのか、理由を必ず併記しよう。  

ルールを策定しても、守られなければ意味がない。  
開発メンバーに周知徹底しよう。  
必要であれば勉強会を開催するなど、教育的な業務も執り行うべし。  
ルールは一度ではなかなか伝わらない。  
繰り返し伝えていくことが大切となる。  

また、開発メンバーだけでなく、リーダーやマネージャーに対しても、日ごろから設計と開発コストについて意思共有を怠らないようにしよう。  
変更容易性は、とかく認知が困難である。  
困難だからこそ、忘れ去られないよう定期的に伝え、意思共有していくことが大事となる。  

設計品質向上に寄与するツールを導入しよう。  
品質を可視化し、品質向上を効率化する。  
導入には当然コストがかかるため、必要な開発環境であることをマネージャーに説明しよう。  

設計品質の劣化は仕様変更時に発生する。  
仕様変更に伴う品質劣化が生じないように取り計らうのも設計責任者の仕事となる。  
例えば、設計的に無理のある仕様変更が、ビジネスサイドからインプットされることが度々あるだろう。  
ビジネスサイドからは設計品質が見えないことがほとんどであるため、ある意味当然といえば当然である。  
だからこそ、設計責任者は設計品質を守る責任がある。  
懸念のある仕様変更は、設計上どのような課題が生じるかについてビジネスサイドに伝えよう。  
課題解決のための落とし所をお互いに模索しよう。  
時には仕様変更を断る勇気も必要となる。  

ところで、誰が設計責任者になれば良いのだろうか。  
チーム内に相応しい人物がいないなら、責任者となるのは他でもない、あなただと考える。  
あなたは、少なくとも設計に関して課題を感じ、危機意識を持っているものと思われる。  
是非、設計責任者として立候補し、開発力の向上に貢献してほしいと願う。  
