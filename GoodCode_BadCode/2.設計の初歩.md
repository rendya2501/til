# 2. 設計の初歩

## 2.1 省略せずに意図が伝わる名前を設計する

下記コードが何をするコードなのか理解できるか？

``` java
// リスト2.1
// いったい何のロジックだろう

int d = 0;
d = p1 + p2;
d = d - ((d1 + d2) / 2);
if (d < 0>) {
    d = 0;
}
```

上記コードがゲームのダメージ計算ロジックだとした場合、各変数は以下の表に示す意味を持つ。  

|変数|意味|
|:-|:-|
|d|ダメージ量|
|p1|プレーヤー本体の攻撃力|
|p2|プレーヤーの武器の攻撃力|
|d1|敵本体の防御力|
|d2|敵の防具の防御力|

意図が伝わるように変数名を書き換える。  

``` java
// リスト2.2
// 意図が伝わる名前をつけよう

int damageAmount = 0;
damageAmount = playerArmPower + playerWeaponPower; // ①
damageAmount = damageAmount - ((enemyBodyDefence + enemyArmorDefence) / 2); // ②
if (damageAmount < 0){
    damageAmount = 0;
}
```

名前を省略するとタイピング文字数が減って、少しは素早く実装できるかもしれないが、読み解くのが難しくなってしまう。  
何倍も、何十倍も読むのに時間がかかってしまうので、トータルに要する時間が増大してしまう。  
意図が分かる変数名に改善すべし。  
変更しやすいコードを実装するうえで、コードが読みやすくなる名前を考えることは立派な設計行為。  

---
---

## 2.2 変数を使いまわさない、目的ごとの変数を用意する

リスト2.2で読みやすくはなったが、まだ課題がある。  
ダメージ`damageAmount`に何度か値が代入されている。  
変数に再度値を代入することを**再代入**と呼ぶ。  

再代入はコードの途中で変数の用途が変わってしまう。  
読み手が混乱し、バグを埋め込んでしまう可能性がある。  

実際、リスト2.2の①で`damageAmount`に代入されているのは、プレーヤーの攻撃力の総量であって、ダメージ量ではない。  
再代入で変数を使いまわさず、目的ごとの変数を用意すべし。  

①ではプレーヤーの攻撃力の総量を、②では敵の防御力の総量を計算している。  
これらを計算して格納する変数をそれぞれ`totalPlayerAttackPower`、`totalEnemyDefence`として用意する。  

``` java
// リスト2.3
// 丁寧に目的ごとの変数を用意すべき

int totalPlayerAttackPower = playerArmPower + playerWeaponPower;
int totalEnemyDefence = enemyBodyDefence + enemyArmorDefence;
int damageAmount = totalPlayerAttackPower - (totalEnemyDefence / 2);
if (damageAmount > 2) {
    damageAmount = 0;
}
```

全体としてどんな値を扱っているのか、ある値を算出するのにどんな値を使っているのか、関係性が分かりやすくなったと思われる。  

---
---

## 2.3 べた書きせず、意味のあるまとまりでメソッド化

リスト2.3では、攻撃力や防御力の総量の計算や、計算結果を格納する変数を分けた。  

しかし、一連の処理の流れの中にすべてべた書きとなっている。  
こうした計算ロジックがダラダラと書かれると、どこからどこまでが何の処理なのか分からなくなってくる。  

計算ロジックがさらに複雑になってくると、例えば攻撃力の計算に防御力が混ざりこむなど、違うものが紛れ込むといったことも実際の開発ではたびたび発生する。  

こうした事態を防ぐには、意味のあるまとまりでロジックをまとめメソッド(関数)として実装すべき。  

``` java
// リスト2.4
// 意味のあるまとまりでメソッド化すべき


// プレイヤーの攻撃力を合算する
int sumUpPLayerAttackPower(int playerArmPower,int playerWeaponPower) {
    return playerArmPower + playerWeaponPower;
}

// 敵の防御力を合算する
int sumUpEnemyDefence(int enemyBodyDefence, int enemyArmorDefence){
    return enemyBodyDefence + enemyArmorDefence;
}

// ダメージ量を評価する
int estimateDamage(int totalPlayerAttackPower,int totalEnemyDefence) {
    int damageAmount = totalPlayerAttackPower - (totalEnemyDefence / 2);
    if (damageAmount < 0) {
        return 0;
    }
    return damageAmount;
}
```

``` java
// リスト2.5
// メソッドを呼び出す形に整理

int totalPlayerAttackPower = sumUpPlayerAttackPower(playerBodyPower,playerWeaponPower);
int totalEnemyDefence = sumUpEnemyDefence(enemyBodyDefence,enemyArmorDefence);
int damageAmount = estimateDamage(totalPlayerAttackPower,totalEnemyDefence);
```

細かい計算ロジックをメソッドに閉じ込めたおかげで、一連の流れが読みやすくなった。  
種類の異なる処理をそれぞれメソッドとして分離したことで、違う処理が紛れ込みにくくなっている。  

リスト2.1と比べれば、記述量は大幅に増えているが、理解のしやすさでは圧倒的になっている。  
このように、保守しやすい、変更しやすいよう、変数の名前やロジックに工夫を凝らすことが設計となる。  

---
---

## 2.4 関係しあうデータとロジックをクラスにまとめる

クラスの効能についての説明。  

ゲームを例とする。  
戦闘を伴うゲームには、主人公の生命力を表すヒットポイント(HP)がある。  
ヒットポイントが、リスト2.6のように、ローカル変数など、何らかの変数で定義されているとする。  

``` java
// リスト2.6
// 単なる変数として用意されたヒットポイント

int hitPoint;
```

ダメージを受けてヒットポイントが減少するロジックが必要。  
リスト2.7のようにどこかに実装されるだろう。  

``` java
// リスト2.7
// どこかに書かれるヒットポイント減少ロジック

hitPoint = hitPoint - damageAmount;
if (hitPoint < 0 ){
    hitPoint = 0;
}
```

「回復アイテムなどで回復する仕様を追加したい」となった場合、リスト2.8のようなロジックが、またどこかに実装されるはず。  

``` java
// リスト2.8
// どこかに書かれるヒットポイント回復ロジック

hitPoint = hitPoint + recoveryAmount;
if (999 < hitPoint){
    hitPoint = 999;
}
```

こういった変数や変数を操作するロジックは、ゲームに限らず、バラバラに書かれがちになる。  
小さなプログラムであれば問題にはならないが、何万行もあるソースコードだと、関係するロジックを探し回るだけでも時間がかかってしまう。  
変数`hitPoint`に負の値が入ってしまう等、どこかで不正な値が混入する可能性もある。  

こうした問題を解決するのがクラスとなる。  
クラスはデータをインスタンス変数として持ち、インスタンス変数を操作するメソッドをまとめることができる。  

以下が、ヒットポイント表現するデータと関連する操作を一つにまとめたクラスとなる。  

``` java
// リスト2.9
// クラスにすると強く関係するデータとロジックをまとめられる

// ヒットポイント(HP)を表現するクラス
class HitPoint{
    private static final int MIN = 0;
    private static final int MAX = 999;
    final int value;

    HitPoint(final int value) {
        if (value < MIN) throw new IllegalArgumentException(MIN + "以上を指定してください");
        if (MAX < value) theow new IllegalArgumentException(MAX + "以下を指定してください");
        this.value = value;
    }

    // ダメージを受ける
    HitPoint damage(final int damageAmount) {
        final int damaged = value - damageAmount;
        final int corrected = damaged < MIN ? MIN : damaged;
        return new HitPoint(corrected);
    }

    // 回復する
    HitPoint recover(final int recoveryAmount) {
        final int recovered = value + recoveryAmount;
        final int corrected = MAX < recovered ? MAX : recovered;
        return new HitPoint(corrected);
    }
}
```

強く関係するデータとロジックを一か所に集めることができた。  
コンストラクタにおけるバリデーションもバグを許さない頑強なクラス構造となる。  

意図をもって適切に設計することで、保守や変更がしやすい構造となる。  
これはあくまでも、設計の初歩であって基本である。  
