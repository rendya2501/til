# 5. 低凝集 バラバラになったモノたち

**凝縮度**とは、「モジュール内における、データとロジックの関係性の強さを表す指標」となる。  
モジュールは、クラス、パッケージ、レイヤーなど、様々な粒度の解釈がある。  
ここでは、「クラス内における、データとロジックの関係性の強さを表す指標」を凝縮度として話を勧める。  

高凝集な構造は、変更に強い、望ましい構造。  
低凝集な構造は、壊れやすく変更が困難な構造。  

---

## 5.1 staticメソッドの誤用

staticメソッドの誤用により、低凝集に陥る例を示す。  

``` java
// リスト5.1
// staticメソッドが定義されたOrderManager

// 注文を管理するクラス
class OrderManager {
    static int add(int moneyAmount1, int moneyAmount2) {
        return moneyAmount1 + moneyAmount2;
    }
}
```

staticメソッドはクラスのインスタンスを生成することなく、メソッドを呼び出し可能。  
このようなstaticメソッドは、moneyData1,moneyData2のようなデータクラスとセットで用いられる傾向が多い。  

``` java
// リスト5.2 
// staticメソッドとデータクラスはセットで登場しがち

// moneyData1,moneyData2はデータクラス
moneyData1.amount = OrderManager.add(moneyData1.amount,moneyData2.amount);
```

データ保持はMoneyData、データを操作するロジックはOrderManagerというように、データとロジックが別のクラスに定義されている、低凝集な構造であるため、不都合の温床となる。  

---

### 5.1.1 staticメソッドはインスタンス変数を使えない

staticメソッドはインスタンス変数を使えない。  
staticメソッドを持ち出した時点で、データとデータを操作するロジックが乖離する。  
どうしても低凝集にならざるを得ない。  

ロジックとデータを一つのクラスに集めて高凝集に設計するのがオブジェクト指向設計の基本となる。  

---

### 5.1.2 インスタンス変数を使う構造に作り変える

staticメソッドの引数に着目する。  
OrderManager.addメソッドでは金額を引数、moneyAmount1,moneyAmount2で受け取り計算している。  

このような場合は、インスタンス変数を使って計算する構造に変更すればよろしい。  
Moneyクラスと同じ構造のように、金額をインスタンス変数amountとして持ち、amountを使って加算するようaddメソッドを設計しなおす。  

---

### 5.1.4 どうしてstaticメソッドが使われてしまうのか

staticメソッドが使われる背景には、C言語などの手続き型言語の考え方が影響していると考えられる。  
手続きがた言語では、データとロジックが別々になるよう設計される。  
この考え方のままオブジェクト指向言語で設計すると、データとロジックは別々のクラスになる。  
そして、メソッドはクラスのインスタンスを生成せずに使えるstaticメソッドとして定義してしまう。  

staticメソッドはクラスのインスタンス生成が不要なため、お手軽に使うことができるが、低凝集問題を引き起こしやすいため、濫用すべきではない。

---

### 5.1.5 どういう時にstaticメソッドを使えばいいのか

凝縮度に影響がない場合にstaticメソッドを使えばよい。  
ログ出力用メソッドやフォーマット変換用メソッドなど、凝縮度に無関係なものはstaticメソッドとして設計して問題ない。  
ファクトリメソッドとして使うのもあり。  

---
---

## 5.2 初期化ロジックの分散

十分にクラス設計しても、初期化ロジックがあちこちに分散して低凝集になってしまう場合がある。  

---

### 5.2.1 privateコンストラクタ+ファクトリメソッドで目的別初期化

初期化ロジックの分散を防ぐには、コンストラクタをprivateにして、代わりに目的別のファクトリメソッドを用意する。  

``` java
// リスト5.7
// ファクトリメソッドを備えたGiftPointクラス

class GiftPoint {
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;
    final int value;

    // 外部から
    private GiftPoint(final int point){
        if (point < MIN_POINT){
            throw new IllegalArgumentException("ポイントが0以上ではありません。");
        }
        value = print;
    }

    /**
     * @return 標準会員向け入会ギフトポイント
    **/
    static GiftPoint forStandardMembership() {
        return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
    }

    /**
     * @return プレミアム会員向け入会ギフトポイント
    **/
    static GiftPoint forPremiumMembership() {
        return new GiftPoint(PREMIUM_MEMBERSHIP_POINT);
    }
}
```

``` mermaid
classDiagram
    class GiftPoint{
        - int value

        - GiftPoint(point: int)
        + add(ohter: GiftPoint) GiftPoint
        + isEnough(point : ConsumptionPoint) boolean
        + consume(point : ConsumptionPoint) GiftPoint
        + forStandardMembership()$ GiftPoint
        + forPremiumMembership()$ GiftPoint
    }
    class ConsumptionPoint{
        int value
    }

GiftPoint --> ConsumptionPoint
```

コンストラクタをprivateにすると、クラス内部でのみインスタンス生成できる。  
インスタンス生成用のsitaticなファクトリメソッド内でコンストラクタを呼び出す。  
ファクトリメソッドは目的別に用意する。  

こうすること、新規入会ポイントに関連するロジックがGiftPointクラスに凝集する。  
新規入会ポイントやギフトポイント自体の仕様が変更される場合、GiftPointクラスを中心に変更すれば良くなる。  
他のクラスから関連ロジックを探し回る手間を提言できる。  

標準会員の新規入会、プレミアム会員の新規入会ロジックは、各ファクトリメソッドにより改善される。  

---

### 5.2.2 生成ロジックが増えすぎたらファクトリクラスを検討する事

場合により、生成ロジックが増えすぎたケースを考える。  
クラス内部で全てやると、クラス内で生成以外のロジックが希薄になってしまい、何をやるクラスなのか分かりにくくなってしまう。  
生成ロジックが余りにも長大になるようであれば、生成専門のファクトリクラスとして分離することを検討すべし。  

---
---

## 5.3 共通処理クラス(Common・Util)

staticメソッドのもうひとつの形して頻繁に見られるのが、共通処理の置き場所として用意されたクラス(共通処理クラス)。  
Common、Utilなどとつけられることが多い。  
問題の性質はstaticメソッドと同じ低凝集構造。  
こちらのほうが質が悪い。  

同じような処理がたくさん書かれそうな時、再利用できるように共通処理を実装した共通クラスが作られることがある。  
このとき、共通処理用のメソッドはstaticメソッドとして実装されがちになる。  

例えば、消費税計算等。  
金額の取引を伴うサービスでは非常に多くのユースケースで金額を取り扱うことになり、どこでも消費税計算が伴う。  
ユースケース毎に消費税計算ロジックを書いていては無駄であり、故に共通処理クラスにstaticメソッドとして消費税計算ロジックが実装されることが多いはず。  

``` java
// リスト5.10
// Commonクラス

// 共通処理クラス
class Common {
    // 省略

    // 税込み金額を計算する
    static BigDecimal calcAmountIncludingTax(BigDecimal amountExcludingTax,BigDecimal taxRate) {
        return amountExcludingTax.multiply(taxRate);
    }
}
```

処理の共通化により重複コードの発生を抑える効果は期待できるように思える。  
しかし、staticメソッドであることに変わりはなく、低凝集構造の問題を抱えている。  
また、グローバル変数が出現しやすくなるなど、悪影響は多岐に渡る。  

---

### 5.3.1 様々なロジックが雑多に置かれがち

税込み金額以外にも、退会済みか調べるメソッド、注文メソッドなど、お互い関連のないロジックがCommonクラスに雑多に実装されることになる。  
もちろん全てstaticメソッド。  

なぜこのようなことが起こってしまうのか。  

1. CommonやUtilといって「共通」を臭わせる名前。  
   - 「共通利用したいロジックはCommonクラスに置けばよい」と読み手に感じさせてしまうため。  
2. 共通化や再利用性に関して理解が不足している事。  
   - さらに根本的な原因となる。再利用性は、高凝集な設計にすることで高まる。  

---

### 5.3.2 オブジェクト指向の基本に立ち返る

共通処理クラスを安易に作らないようにする。  
データと処理を一つのクラスにまとめるオブジェクト指向設計の基本に基づいて設計すること。  

---

### 5.3.3 横断的関心事

ログ出力処理やエラー検出処理は、アプリケーションのどんな処理でも必要となる。  
ECサイトなら注文、予約、配送、どんなユースケースでも必要となる基盤的な処理。  

このように、様々なユースケースに広く横断する事柄を、**横断的関心事**と呼ぶ。  
代表的なモノとして、以下が挙げられる。  

- ログ出力  
- エラー検出  
- デバッグ  
- 例外処理  
- キャッシュ  
- 同期処理  
- 分散処理  

横断的関心事に関する処理であれば、共通処理としてまとめ上げて問題ない。  
Loggerクラスのlogingメソッドもインスタンス化する用途がないため、staticメソッドとして設計して問題ない。  

``` java
// リスト5.13
// 横断的関心事はstaticメソッドでもよい

try {
    shoppingCart.add(product);
}
catch (IllegalArgumentException e) {
    // reportはログ出力用のstaticメソッド
    Logger.report("問題が発生しました。買い物かごに商品を追加できません。");
}
```

---
---

## 5.4 結果を返すために引数を使わないこと

引数の扱いを誤ると低凝集に陥りやすい。  
出力引数もその一つとなる。  

``` java
// リスト5.14
// 引数の変更をしている

class ActorManager {
    // ゲームキャラの位置を移動する。
    void shift(Location location, int shiftX, int shiftY) {
        location.x += shiftX;
        location.y += shiftY;
    }
}
```

`shift`はゲームの位置を移動するメソッド。  
ただし、移動対象のインスタンスを引数locationで渡し、変更している。  
このように出力として用いる引数を出力引数と呼ぶ。  

データ操作対象はLocation、操作ロジックはActorManager、といった形で別々のクラスに定義されているため、この構造も低凝集となる。  
低凝集構造は重複を生みやすいため、まったく同じメソッドが別のクラスに意図せず実装されることが多い。  

``` java
// リスト5.15
// まったく同じメソッドが別のクラスにも

class SpecialAttackManager {
    void shift(Location location, int shiftX, int shiftY) {
```

引数は入力値として渡すのが普通。  
出力値として扱ってしまうと、引数が入力なのか出力なのか、メソッド内部のロジックを読んで確認しなければならなくなる。  
メソッドの中身をいちいち気にしなければならない構造はロジックを読み解く時間をいたずらに増大させ、可読性の低下を招く。  

``` java
// リスト5.16
// 何がおこるのか？
discountManager.set(money);

// リスト5.17
// 引数変更されることが外部からわからない
class DiscountManager {
    // 割引を適用する
    void set(MoneyData money) {
        // 引数のデータを変更している!!
        money.amount -= 2000;
        if (money.amount < 0) {
            money.amount = 0;
        }
    }
}
```

出力引数として設計せず、オブジェクト指向の基本に基づいてデータとデータを操作するロジックを同じクラスに凝集する。  

``` java
// リスト5.18
// 引数を変更しない構造へ改善

class Location {
    final int x;
    final int y;

    Location(final int x, final int y) {
        this.x = x;
        this.y = y;
    }

    Location shift(final int shiftX, final int shiftY) {
        final int nextX = x + shiftX;
        final int nextY = y + shiftY;
        return new Location(nextX,nextY);
    }
}
```

---
---

## コラム C#のoutキーワード

C#には出力引数の仕様としてoutキーワードやrefキーワードがある。  
outを付与すると、引数valueは参照渡しとなり、宣言元の変数を変更できる。  

``` cs
static void Set(out int value) {
    value = 10;
}

int value;
set(out value);
Console.WriteLine(value); // 10が出力される。
```

複数の値を変更して返したい場合にoutキーワードは使えるが、わざわざ取り上げるって事は何がいいたいのかわかるよな？  
出力引数は容易に低凝集な構造へと陥ってしまうため、安易に使うなって事だ。  
outキーワードはTruParseメソッドのように、極めて汎用的な変換用途などに限定して使用すべき。  
凝集性に問題がある場合は使用をお勧めしない。  

``` cs
// リスト5.22
// 出力引数は凝集性に問題がないケースに限定すべし

int valueString = "123";
int value;
// TryParseはintへの型変換を試みるメソッド
bool success = int.TryParse(valueString,out value);
if (success) {
    total += value;
}
```

もしoutキーワードを使って複数の値を返却できるように記述したのなら、それは丁寧にクラス化して返却できるようにすべし。  

``` cs
// リスト5.20
// 出力引数による変更

static void RecoverCompletely(out int hitPoint, out int magicPoint) {
    hitPoint = MAX_HIT_POINT;
    magicPoint = MAX_MAGIC_POINT;
}

int hitPoint;
int magicPoint;
RecoverCompletely(out hitPoint,out magicPoint);
member.HitPoint = hitPoint;
member.MagicPoint = magicPoint;
```

``` cs
// リスト5.21
// ヒットポイントを値オブジェクトとして設計

// ヒットポイント
class HitPoint {
    private const int MIN = 0;
    // readonlyはjavaのfinalに相当
    readonly int _value;
    private readonly MaxHitPoint _maxHitPoint;

    // value 現在のヒットポイント
    // maxHitPoint 最大ヒットポイント
    HitPoint(int value, MaxHitPoint maxHitPoint) {
        if (value < MIN) {
            throw new ArgumentOutOfRangeException("0以上を指定してください。");
        }
        _value = value;
        _maxHitPoint = maxHitPoint;
    }

    // 最大まで回復する
    // return ヒットポイント
    HitPoint RecoverCompletely() {
        return new HitPoint(_maxHitPoint._value, maxHitPoint);
    }
}
```

---
---

## 5.5 多すぎる引数

引数が多すぎるメソッドは低凝集に陥る良くない構造。  

ゲーム内における魔法力を例に説明する。  
RPGなどのゲームには、魔法力(マジックポイント)がある。  
魔法力に関して、以下の仕様であるとする。  

- 回復を使うと、魔法力は一定量減少する。  
- 回復アイテムなどにより、魔法力は一定量回復する。  
- 魔法力には最大値がある。  
- 魔法力は最大値まで回復可能。  
- 一部の装備品は、魔法力の最大値を増加させる効果を持つ。  

設計をあまり考えない場合のロジックは以下のようになりがち。  

``` java
// リスト5.23
// 引数の多いメソッド

// 魔法力を回復する
// @param currentMagicPoint 現在の魔法力残量
// @param originalMaxMagicPoint オリジナルの魔法力最大値
// @param maxMagicPointIncrements 魔法力最大値の増分
// @return 回復後の魔法力残量
int recoverMagicPoint(int currentMagicPoint, int originalMaxMagicPoint, List<Integer> maxMagicPointIncrements, int recoveryAmount) {
    int currentMaxMagicPoint = originalMaxMagicPoint;
    // アイテムの増分を最大値に反映させる
    for (int each : maxMagicPointIncrements) {
        currentMaxMagicPoint += each;
    }

    return Math.min(currentMagicPoint + recoveryAmount,currentMaxMagicPoint);
}
```

recoverMagicPointでは、装備品の魔法力最大値増加効果を追加した、魔法力最大値currentMaxMagicPointを算出している。  
currentMaxMagicPointを超えないように魔法力を回復させている。  

機能はするが、メソッドの構造が良くない。  
魔法力残量や魔法力最大値、魔法力最大値の増分、回復量がバラバラに渡されている。  
バラバラに渡す方法は、不注意で正しくない値を代入してしまう可能性が高まる。  
この例では4個のデータで済んでいるが、実際のアプリケーションでは、さらに膨大なデータを取り扱うため、その確率は飛躍的に高まるだろう。  

回復以外の処理を行っている。  
魔法力最大値の増加計算は、回復以外の様々なケースでの利用が容易に考えられる。  
このようなべた書きロジックでは、重複コードが様々な箇所に書かれる事態を招く。  

こういった問題がなぜ生じるのか。  
メソッドに引数を渡すのは、その引数を使って何か処理をさせたいからに他ならない。  
引数の量が多いということは、それだけ処理させたい内容が膨らむことになる。  
処理内容が増えると、ロジックが複雑化したり重複コードが増えたり、悪影響しかない。  

---

### 5.5.1 プリミティブ型執着

boolean,int,float,double,stringといった、プログラミング言語が標準で容易している基本データ型を**プリミティブ型**と呼ぶ。  
リスト5.23(魔法力)の例のように、引数、戻り値ともにプリミティブ型だけで構成されている。  
このようにプリミティブ型を濫用したコードを**プリミティブ型執着**と呼ぶ。  

プログラミング初心者やプリミティブ型を中心に長年コードを書いてきたプログラマーには、クラス設計の習慣がない。  
そのため、プリミティブ型執着に陥りがちになってしまう。  

「これが一般的なスタイル」「クラスをたくさん作る事が普通ではない」これらは誤りである。  

``` java
// リスト5.25
// プリミティブ型に執着するとコード重複が生じやすい

class Util {
    // @param regularPrice 定価
    // @return 適性価格である場合true
    boolean isFairPrice (int regularPrice) {
        if (regualarPrice < 0) {
            throw new IllegalArgumentException();
        }
    }
}
```

isFairPriceは適性価格化どうかを調べるメソッド。  
この程度のロジックなら、別のCommonクラスにも実装されかねない。  
プリミティブ型だけで実装すると、重複コードや演算ロジックがあちこちに無秩序に実装されやすくなる。  

プリミティブ型だけで「動くコード」を書くことはできるだろう。  
しかし、それでは強く関係し合うデータとロジックをうまく凝縮できない。  
このため、バグを埋め込みやすくなったり、可読性が低下したりする。  

データがただ存在しているだけ、というのはほとんどありえない。  
データを使って計算したり、データを判断して制御を切り替えたりするのが普通。  
プリミティブ型だけで実装しようとすると、データのありかとデータを使って制御するロジックのあり方がバラバラになり、低凝集となる。  

まずは1つ1つ丁寧にクラス化していくよう、プログラミングへの向き合い方、考え方を改める必要がある。  

リスト5.26に示すように、割引料金、定価、割引率を1つ1つクラスへ成長させる。  
定価クラスRegularPriceｎ中に、バリデーションをカプセル化する。  
割引率も同様にクラス化する。  
そして、割引料金DiscountPriceには、定価クラスRegularPriceと割引率クラスDiscountRateを渡すようにする。  
リスト5.24のCommon.discountedPriceとは異なり、引数はプリミティブ型ではなくクラスになっている。  
こうすることで各クラスそれぞれに関連の高いロジックが凝集する。  

``` java
// リスト5.26
// 「定価」という具体的な型として設計する

// 定価
class RegularPrice {
    final int amount;

    // @param amount 金額
    RegularPrice(final int amount) {
        if (amount < 0) {
            throw new IllegalArgumentException();
        }
        this.amount = amount;
    }
}

// リスト5.27
// プリミティブではなくクラスの型を渡す

// 割引料金
class DiscountedPrice {
    final int amount;

    DiscountedPrice(final RegularPrice regularPrice, final DiscountRate discountRate) {
        // regularPriceとdiscountRateを使った計算
    }
}


// リスト5.24
// プリミティブ型執着の例

class Common {
    // @param regularPrice 定価
    // @param discountRate 割引率
    // @return 割引価格
    int discountPrice(int regularPrice, float discountRate) {
        if (regularPrice < 0) {
            throw new IllegalArgumentException();
        }
        if (discountRate < 0.0f) {
            throw new IllegalArgumentException();
        }
```

---

### 5.5.2 意味のある単位ごとにクラス化する

引数が多すぎる事態に陥らないためには、概念的に意味のあるクラスを作ることが肝要となる。  

魔法の話に戻る。  
ここでは魔法力が中心的な概念となる。  
魔法力を表現するクラス`MagicPoint`を用意する。  
そして、魔法力に関係する値をインスタンス変数として所有するクラス構造にする。  

``` java
// リスト5.28
// 引数ではなくインスタンス変数として表現する

// 魔法力
class MagicPoint {
    // 現在の魔法力残量
    int currentAmount;
    // オリジナルの魔法力最大値
    int originalMaxAmount;
    // 魔法力最大値の増分
    List<Integer> maxIncrements;
}
```

魔法力の最大値計算や回復メソッドを定義する。  
この時、他のクラスに余計な操作をさせないようにインスタンス変数はprivateとする。  
そのほか、魔法力消費メソッドなども定義する。  

``` java
// 魔法力
class MagicPoint {
    private int currentAmount;
    private int originalMaxAmount;
    private final List<Integer> maxIncrements;

    // 省略

    // @return 現在の魔法力残量
    int current() {
        return currentAmount;
    }

    // @return 魔法力の最大値
    int max() {
        int amount = originalMaxAmount;
        for (int each : maxIncrements) {
            amount += each;
        }
        return amount;
    }

    // 魔法力を回復する
    // @param recoveryAmount 回復量
    void recover(final int recoveryAmount) {
        currentAmount = Math.min(currentAmount + recoveryAmount, max());
    }

    // 魔法力を消費する
    // @param consumeAmount 消費量
    void consume(final int consumeAmount) {
        // …
    }
}
```

``` mermaid
classDiagram
    class MagicPoint{
        - int currentAmount
        - int originalMaxAmount
        - List~int~ maxIncrements

        current() int
        max() int
        recover(recoverAmount : int) void
        consume(consumeAmount : int) void
    }
```

魔法力に関係するロジックが凝集された。  
引数が多い場合は、データを引数として扱うのではなく、そのデータをインスタンス変数として持つクラスへ設計変更してみるべし。  

---
---

## 5.6 メソッドチェイン

リスト5.30は、ゲームでメンバーの装備を変更するメソッド。  

``` java
// リスト5.30
// 数珠つなぎにコールする「メソッドチェイン」

// 鎧を装備する
// @param memberId 装備変更したいメンバーのID
// @param newArmor 装備する鎧

void equipArmor(int memberId, Armor newArmor) {
    if (party.members[memberId].equipments.canChange) {
        party.members[memberId].equipments.armor = newArmor;
    }
}
```

PartyクラスのList型インスタンス変数membersから装備変更したいメンバーを取得し、さらにequipmentsで装備一覧を取得している。  
その中からさらにcanChangeを取得して装備変更可能かどうかを判断し、armorへアクセスして装備変更している。  

このように「`.`」(ドット)で数珠つなぎにして、戻り値の要素に次々にアクセスする書き方を**メソッドチェイン**と呼ぶ。  

この例では、メソッドチェインを使い、階層構造になっているクラスの、かなり奥深い要素にアクセスしている。  
この方法も低凝集に陥る良くない書き方となる。  

このコードではarmorへ代入しているが、代入するコードをとこでも書けてしまう。  
似たようなコードが複数個所に実装される恐れがある。  
それだけではなく、membersやequipments等も同様。  
どこでも様々な要素へアクセス可能となる。  

例えば、members,equipments,canChange,armorにアクセスするコードが様々な箇所にいくつも実装されていたとする。
これらの要素に仕様変更が生じた場合、呼び出している箇所全ての影響を調べて回らなければならなくなる。  
また、バグが発生した場合も同様に、どこでバグが混入したのか呼び出し個所を全て調べて回らなければならなくなる。  

このように、影響範囲がいたずらに拡大可能な構造なので、グルーバル変数と同様の性質を帯びてくる。  
より多くの要素に、あらゆる箇所からアクセス可能な構造である点で、単一のグローバル変数よりも悪質と言える。  

---

### デメテルの法則

**デメテルの法則**と呼ばれる法則がある。  
利用するオブジェクトの内部を知るべきではない、とするもので、「知らない人に話しかけるな」と要約されたりもする。  
メソッドチェインで内部詳細を渡り歩く作りは、デメテルの法則に違反していることになる。  

---

### 5.6.1 尋ねるな、命じろ (Tell,Don't Ask.)

ソフトウェア設計には、**尋ねるな、命じろ**という有名な格言がある。  
他のオブジェクトの内部状態(つまり変数)を尋ねたり、その状態に応じて呼び出し側が判断したりするのではなく、呼び出し側はただメソッドで命ずるだけで、命令された側で適切な判断や制御をするように設計すべし、というものである。  

まず、インスタンス変数をprivateにして、外部からアクセス出来なくする。  
インスタンス変数に対する制御は、メソッドとして外部から命じる形にする。  
そして、命令された側が詳細な判断や制御を担う作りにする。  

具体的に見ていく。  
リス5.31に示すように、インスタンス変数はprivateにする。  

装備中の防具一覧を表現するEquipmentsクラスには、防具の脱着に関して「仕様的に意味のある」メソッドを定義する。  
例えば、装備変更用にequipArmorメソッド、全装備解除用にdeactivateAllメソッドを用意する。  

こうすることで、防具の脱着に関するロジックがEquipmentsに凝集する。  
これにより、防具の装備仕様が変わった場合、Equipmentsに着もすれば良いことになり、ソースコードのあちこちを探し回る必要がなくなる。  

``` java
// リスト5.31
// 詳細なロジックは呼ぶ側ではなく、呼ばれる側に実装すべし

// 装備中の防具一覧
class Equipments {
    private boolean canChange;
    private Equipment head;
    private Equipment armor;
    private Equipment arm;

    // 鎧を装備する
    // @param newArmor 装備する鎧
    void equipArmor(final Equipment newArmor) {
        if (canChange) {
            armor = newArmor;
        }
    }

    // 全装備を解除する
    void deactivateAll() {
        head = Equipment.EMPTY;
        armor = Equipment.EMPTY;
        arm = Equipment.EMPTY;
    }
}
```

``` mermaid
classDiagram
    class Equipments{
        - boolean canChange

        equipArmor(newArmor : Equipment) void
        deactiveAll() void
    }

    class Equipment {
        EMPRY Equipment$
        string name
        int price
        int defence 
        int magicDefence
    }

    Equipments --> Equipment
```
