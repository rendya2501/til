# 15. 設計の意義と設計への向き合い方

クラスを中心に、設計の方法や重要性を取り上げてきた。  
ノウハウを用いると、コードを楽に素早く正確に変更できるようになる。  
素早く変更できると、ソフトウェアの価値が素早く高まる。  
ソフトウェアの成長性を軸に、設計の意義や設計への向かい方を解説する。  

---
---

## 15.1 なんの設計について書いたものなのか

表15.1 ソフトウェア製品に関する品質特性(JIS X 25010:2013を参考に作成)  
|品質特性|説明|品質副特性|
|:-|:-|:-|
|機能適合性|機能がニーズを満たす度合い|機能完全性、機能正確性、機能適切性|
|性能効率性|リソース効率や性能の度合い|時間効率性、資源効率性、容量満足性|
|互換性|ほかのシステムと情報の共有、交換できる度合い|共存性、相互運用性|
|使用性|利用者がシステムを満足に利用できる度合い|適切度認識性、習得性、運用操作性、ユーザーエラー防止性、ユーザーインターフェース快美性、アクセスビリティ|
|信頼性|必要な時に機能実行できる度合い|成熟性、可用性、障害許容性、回復性|
|セキュリティ|不正利用から保護する度合い|気密性、完全性、否認防止性、責任追跡性、真正性|
|保守性|システムを修正する有効性や効率の度合い|モジュール性、再利用性、解析性、修正性、試験性|
|移植性|ほかの実行環境に移植できる度合い|適応性、設置性、置換性|

表15.1はソフトウェア製品に関する品質特性の一覧となる。  
例えば、システムの機能が顧客のニーズを満たす品質特性は機能適合性となる。  
各品質特性にはさらに副特性があり、機能適合性の副特性には機能完全性、機能正確性、機能適切性がある。  

設計とは、課題を効率的に解決する仕組み作りのことを言う。  
そして、ソフトウェアにおける設計とは、何らかのソフトウェア品質特性の向上を促進するための仕組みを作ることを言う。  
例えば性能効率性はパフォーマンス性能を表す品質特性であり、性能効率性を上げるには、パフォーマンス設計をする。  

本書での設計は主にどの品質特性の向上を狙ったものだろうか。  
本書はソフトウェア開発上の悪魔を退治する設計方法を記述したものである。  
悪魔は様々な悪事を働く。  
デバッグ時や仕様変更時、どのロジックが影響しているのか影響範囲の把握を困難にさせる。  
また、仕様変更時に修正漏れが起こりやすく、バグが発生するなど、正確に動作できるようになるまで時間を浪費させる。  

こうした悪魔の性質と最も関係がありそうな品質特性はどれだろうか。  
保守性を見てみよう。  
「システムを修正する有効性や効率の度合い」とある。  
本書で取り扱っているのは、保守性に関係する設計となる。  
そして保守性の副特性には修正性がある。  
修正性は変更容易性とも呼び、どれだけ素早く(バグを発生させず)正確にコード変更可能かを示す指標となる。  
保守性の中でも、特に**変更容易性の向上を目的にした設計手法**なのである。  

---
---

## 15.2 設計しないと開発生産性が低下する

変更が困難で壊れやすいコードを**レガシーコード**と呼ぶ。  
レガシーコードが蓄積している状態を**技術的負債**と呼ぶ。  
レガシーコードは変更容易性が低いコードとなる。  
変更容易性の設計をしないと、開発生産性が低下する。  
低下要因は、大きく分けて2つある。  

---

### 15.2.1 要因1 : バグを埋め込みやすくなる

コード変更時にバグを埋め込みやすくなる。  
バグがないように正確に変更できるまで時間がかかってしまう。  

- 低凝集な構造によって仕様変更時に修正漏れが起きやすくなり、バグになる。  
- コードの理解が難しいために、実装ミスが起こりやすく、バグになる。  
- 不正値が容易に混入する構造になりがちで、バグが起こりやすくなる。  

---

### 15.2.2 要因2 : 可読性が低下する

可読性が低下し、意図を正確に理解するまでに時間がかかるようになる。  

- ロジックの見通しが悪く、読み解くのに時間がかかる。  
- 関係し合うロジックがあちこちに散在しているために、仕様変更に関連するロジックをすべて探し回る手間が増える。  
- 不正値の混入でバグが発生した場合に、どこから不正値が混入したのか追跡が困難になる。  

---

### 15.2.3 木こりのジレンマ

「木こりのジレンマ」という説話がある。  

>ある木こりが、斧で一生懸命気を切っていた。  
>
>通りかかった旅人が木を切る様子をしばらく眺めていたが、なかなか木が切れない。  
>
>よく見てみると、斧が刃こぼれしていたので、旅人は言いました。  
>
>「刃を研げば楽に切れますよ」  
>
>木こりは答えた。  
>
>「刃を研ぐ時間なんかない!」  

ソフトウェア開発でも、この「木こりのジレンマ」と同じことが起こっていないだろうか。  
この説話の「木を切る時間」を「ロジックの実装時間」、「刃を研ぐ時間」を「設計する時間」に置き換えて考えてみよう。  
設計していないと、ロジックの変更やデバッグに多大な時間を浪費してしまう。  
そして設計する余裕すらなくなってしまうジレンマに陥ってしまう。  

---

### 15.2.4 一生懸命仕事した感覚だけが残って生産性は悪いまま

開発生産性が悪いと、新機能をなかなかリリースできなくなる。  
当然、収益を出せなくなってくる。  
成果を出せない体質になっていくのだ。  

開発現場では、リリース期日までに何とか間に合わせようと、長時間労働が慢性化していく。  
開発メンバーは一生懸命がむしゃらに、とにかく動作するよう実装と修正を繰り返すことになる。  
「とにかく一生懸命働いた!」という感覚だけは強烈に残る。  
しかし、生産性は悪いままなので、成果はなかなかでない。  
「これほど一生懸命働いているのに、なぜ成果が出ないんだ!」と憤り、失望の声が上がってくることも想像に難くない。  

しかし、それは本当の意味で一生懸命働いたといえるのだろうか。  
本来一生懸命やるべきなのは、成果を出しやすい構造を設計する事なのだ。  

---

### 15.2.5 国家規模の経済損失

レガシーコードによる生産性低下がどれほどの損失になるか考えてみる。  

開発チームにはメンバーが20人いて、レガシーコードによる実装遅延が1人1日3時間発生していると仮定する。  
単純計算で、開発チーム全体で1日あたり、3*20=60時間損失が発生していることになる。  
これが１か月ともなると実働日数20日として120時間、1年間となると1440時間も損失が生じる。  
低生産性による損失は、少しずつ確実に蓄積していく。  

この損失は、実際にはレガシーコードの量に単純に比例するものでは無い。  
なぜなら**複雑で混乱したロジックがあると、もっと混乱したロジックが作りこまれやすくなるためである。**  
ソースコードの巨大化に伴い、加速度的に混乱に拍車がかかる。  
そしていつしか、機能開発がほとんど立ち行かず、リリース困難になってしまうほど悪化していくのだ。  

経済産業省の発表資料によると、2025年以降、技術的負債による経済的損失額は、12兆円になるとの試算が出ている。[^1]  
日本の2021年度国家予算が142.5兆円(補正含む)であることを踏まえると、すさまじい損失額と言える。  
まさに「塵も積もれば山となる」。  
設計をないがしろにし、日々の生産性の低さを放置していった結果、国家規模の損失を抱えるまでに至っている。  

この点から、変更容易性は極めて重要な品質特性だといえる。  

[^1]『DXレポート～ITシステム[2025年の壁」克服とDXの本格的な展開～』著:デジタルトランスフォーメーションに向けた研究会  
<https://www.meti.go.jp/shingikai/mono_info_service/digital_transformation/pdf/20180907_03.pdf>
[^2]『老朽化ソフトウェアの技術的な負債、毎年12兆円の衝撃』著:広木大地  
<https://note.com/hirokidaichi/n/n1ce83fa154e5>  

---
---

## 15.3 ソフトウェアとエンジニアの成長性

何のためにコードを変更するのだろうか。  
ソフトウェアの価値や魅力をより高めるために仕様が追加・変更され、そしてコードが変更されていく。  
コードの変更容易性が高いほど、ソフトウェアの価値を素早く高められる。  
ソフトウェアが素早く成長するのである。  

つまり、変更容易性を高めることは、ソフトウェアの成長性を高めることなのだ。  
**ソフトウェアの成長性を高めることが、本稿の意義となる。**  

変更容易性が悪化すると、ソフトウェアの成長性が悪化する。  
それだけではなく、あなたのスキルの成長性まで悪化する。  

---

### 15.3.1 エンジニアにとっての資産とは何か

「エンジニアにとっての」資産とは何だろうか。  
貯蓄が沢山あることだろうか。それとも高年収であることだろうか。  

人によってお金の使い方は異なるため、貯蓄額の多寡は「エンジニアにとっての」資産とは違うように思える。  
年収に関しても、景気の浮き沈みでいくらでも変わるものだから、「エンジニアにとっての」本質的な資産とは異なっていそうだ。  

エンジニアにとっての本質的な資産とは何だろうか。  
それは**技術力**に他ならないと筆者は考える。  
貯蓄がゼロでも、技術力があればどこでも稼いでいけるのがエンジニアであり、まさに富を生み出す源泉といえる。  
何にも代えがたい、エンジニア自身の貴重な資産となる。  

しかし、レガシーコードは資産の蓄積、すなわち技術力の成長を妨げてしまう恐ろしい存在なのだ。  
その理由は以下に続く。  

---

### 15.3.2 レガシーコードに人は引きずられやすい

新入社員や後任担当者が、レガシーコードだらけのプロダクトの開発を担当するケースを考えてみる。  
先輩社員や前任者が書いたコードがレガシーコードだと気づくのは困難である。  
むしろ「これが先輩のお手本だ」とか「前任者の流儀だ」と勘違いし、レガシーコードと同じ書き方でさらにレガシーコードが量産されることが非常に多い。  
技術力が未熟な新入社員には顕著な傾向となる。  

レガシーコードは、レガシーコードの書き手を育ててしまう。  
エンジニアを低スキルに陥れてしまう。  

---

### 15.3.3 レガシーコードは高品質設計を妨げる

中にはレガシーコードのマズさに気付く人もいる。  
なんとか設計的なテコ入れを試みたくなるだろう。  
しかし、レガシーコードは極めてアンバランスでトリッキーな実装であることが多い。  
設計改善が非常に困難となる。  
プロジェクトの納期などの都合により、設計改善を諦めてしまうことが本当に多い。  

結局、高品質な設計実装の経験を積めなくなり、設計スキル向上を果たせなくなる。  

---

### 15.3.4 レガシーコードは開発工数を減少させる

レガシーコードは理解に多大な時間を要する。  
一方時間は有限である。  
従って、本来もっと価値の高い仕事に充てられるべき時間が、目減りしてしまう。  
十分な経験を積めず、設計スキルに限らず様々なスキルの向上を果たせなくなる。  

委譲、レガシーコードはスキル向上の妨げになり、エンジニアにとって本当に大切な資産を貯蓄できなくなってしまう。  
そして、エンジニアにとって技術力は収入に直結する。  
レガシーコードはエンジニアのスキル成長を妨げ、稼げなくしてしまう。  

---
---

## 15.4 課題を解決する

こうした課題をどう解決すべきか整理する。  

---

### 15.4.1 課題が見えないとそもそも設計する意識が生まれない

よちよち歩きの幼児がいたとする。  
車がビュンビュン走る道路の近くを一人で歩かせて大丈夫だろうか？  
そんなわけないよな？  
交通事故の恐ろしさを幼児は知らないので、大人が手を引いて歩いたり、交通ルールを一生懸命教育したりする。  

プログラミングも同様である。  
課題を知覚できないと、そもそも設計しようとする意識すら生まれない。  

---

### 15.4.2 知覚用意な課題と知覚困難な課題がある

図15.1は、フィリップ・クルーシュティンがソフトウェアシステムに関して定義したマトリクスになる。[^1]  
「見える/見えない」「プラスの価値/マイナスの価値」の2軸、4象限で表現している。  

図15.1  
||見える|見えない|
|:-:|:-:|:-:|
|**プラスの価値**|新機能|アーキテクチャー|
|**マイナスの価値**|バグ|技術的負債|

ここでの「見える/見えない」は、システムの内部構造が見えるかどうかを表している。  

「見える」側にあるのは、内部構造の理解がなくとも知覚可能なものとなる。  
見える側のプラスの価値は新機能、マイナスの価値はバグである。  
これらは画面上からすぐにわかる。  

一方「見えない」側には、プラスの価値としてアーキテクチャー、マイナスの価値として技術的負債がある。  
プログラミングの知識がない方にとってはシステムの内部構造を知覚できない。  

では、エンジニアであれば、この図の「見えない」側にあるアーキテクチャーと技術的負債は見えるのだろうか？  
本書で説明しているように、どんな悪魔がいて、どんな悪さをするか知らなければ、技術的負債の存在を知覚することすら困難となる。  
**ソースコードの読解スキルと技術的負債の知覚スキルは別である。**  

---

### 15.4.3 理想形を知って初めて課題を知覚できる

技術的負債の知覚を説明するため、著者がたしなんでいる空手を例に挙げる。  
空手はただ腕や脚を振り回すのではなく、技の効果wお最大化するため、合理的に動作する。  

①上から下へ斜めに突き下げる  
②直角に突く  
③下から上へ斜めに突き上げる  

直立している相手に自分の突き(パンチ)や蹴りの威力を100%伝えるには、どの入射角が適切だろうか。  
②の90度が正解だろう。  
斜めの入射角では威力のベクトルが垂直方向に逃げてしまう。  
空手の技や動きはすべてこのような物理的合理性の塊になる。  

著者の通う道場の市販は次のように問いかける。  

「あなたがいまやっているその動き、どうなったら理想なのか明瞭に定義できていますか。説明できますか。」  

「脚の向き、股関節の開き、筋肉のねじり具合、膝の位置、重心の位置、腕の角度、技の始動...。  
それぞれどうなっていれば理想なのか、そしてなぜそれが理想なのか理由を説明できますか」  

「理想が明瞭に詳細に定義できているのであれば、私がいなくても一人で練習できる。  
理想に向かって練習すればいいんですから。  
たとえスランプに陥ったとしても、理想と比べてどう違うのか自分自身でチェックできる利点があります。」  

「逆に定義できていない内に練習するのは非常に良くない。なぜか。  
理想に近づいているのか遠ざかっているのか判断できなくなるから。  
運よく近づければそれで良いかもしれないが、悪化した場合に悪化したことを自分自身で気づけない。  
さらに悪化して悪循環に陥る可能性がとても高い。  
ゆえに理想形を描けていない状態での練習は、上達どころか逆に動作が悪くなる原因になる。  
練習しない方がマシ」  

これは空手に限った話ではなく、スポーツ全般、そのほかあらゆる事柄に当てはまる。  
課題とは、理想と現状のギャップなのだ。  
つまり、理想を知っていれば現状と比較でき、課題が分かる。  
理想的な設計と現状を比較することで、技術的負債が知覚可能になる。  

---

### 15.4.4 変更容易性を比較できないジレンマ

技術的負債を低減する変更容易性設計の効果を、どう計測すればいいのだろうか。  

例えば、パフォーマンスに関しては、速度が出るよう設計したコードと設計しなかったコードを用意し、それぞれ計測すればすぐに比較が可能となる。  
変更容易性はどうだろうか。  
変更容易性は開発生産性から推し量るが、パフォーマンスとは異なり、すぐに比較はできない。  
なぜなら、変更容易性は未来の変更コストがどれほど低いかを示すものであり、経時変化により表出するためである。  
長い目で見たときにはじめて効果を観測できる品質なのである。  

設計の効果がどの定価はどうやって算出すればよいだろうか。  
対照実験の実施が思いつく。[^2]  
しかし、この方法には問題がある。  
まず、変更容易性の効果を確認するために、ある程度長い期間を要する。  
また、変更容易性設計するチームとしないチームの、2つの開発リソースを用意しなければならない。  
日々の開発が忙しく、リソースがひっ迫しているような現場で、変更容易性の検証のために予算や人員を割くことは難しいだろう。  
変更容易性を検証する研究チームを編成できるほど予算が潤沢にある企業なら可能かもしれないが、そんな企業はごく一握りだ。  

他に比較手段はないだろうか。  
同じプロダクトに対し、変更容易性の設計をした未来と、設計しなかった未来の両方を同時に観測できれば可能である。  
しかし、異なる未来(平行世界)を行き来したり観測したりするタイムマシンのような技術はない。  

[^1]  
『エンジニアリング組織論への招待～不確実性に向き合う思考と組織のリファクタリング』  
著:広木大地、2016年観光、技術評論社、P256より引用。  
PP.Kruchaten,R,Nord, I.Ozakaya(2012). Technial debt: From metaphor to theory and practice.  
IEEE Software,29(6):18-21, Novemver/December で紹介された図。  

[^2]  
まったく同じ状況を2つ用意し、その中で１つの部分だけを変更して比較する方法。  
ここれは、一方は変更容易性をして開発、もう一方は設計しないで開発し、その後の開発生産性がどう違うかを比較する。  

---
---

## 15.5 コードの良し悪しを判断する指標

未来の開発生産性を計測する手段は残念ながら今のところはない。  
しかし、現状のソースコードの良し悪しを表す指標はある。  
コードの複雑さや、可読性などの一連の品質指標を**コードメトリクス**、または**ソフトウェアメトリクス**と呼ぶ。  

コードメトリクスやその分析ツールの一部を紹介する。  

---

### 15.5.1 実行可能コードの行数

実行可能コードの行数とは、コメント行を除いた、実行可能なロジックを含む行数のことを言う。  
行数が多いと、多くのことをやりすぎている可能性がある。  
メソッド内の行数が増えるほど扱う変数や条件分岐が増大する。  
条件分岐により内部ロジックが複雑化し、多すぎる変数は読み手を混乱させて理解を難しくする。  

適切なコード行数の一例として、Rubyのコード解析ライブラリ`RubyCop`を挙げる。  
デフォルトではコード行数の上限を表15.2と定めており、違反すると警告される。  

表15.2 コード行数の上限  
|スコープ|行数上限|
|---|---|
|メソッド|10行以内|
|クラス|100行以内|

同じ実行内容でも、ロジックの必要記述量はプログラミング言語によっていくらか違いがある。  
ただ、どの言語を使っても大体この行数が適切だろう。  
行数が多すぎる場合は、メソッドやクラスの分割を検討すべし。  

---

### コラム クラスを分割すると読みにくくなる？

クラスを小さく分割することに抵抗感を覚える方がいる。  
「細切れになってロジックを追いにくくなる」「分割した先の内部構造をたどっていくのが大変になる」「クラスが大きくても一度にまとめてロジックを読み流せるほうが良い」といった理由が多いように見受けられる。  

話は変わるが、各言語には標準ライブラリが用意されている。  
ライブラリの内部実装がどうなっているかについて、いちいち気になるものだろうか。  
おそらく、気にせずライブラリを使う方がほとんどだろう。  
標準ライブラリのクラスは、使用方法や仕様が明確な上、信頼性が高いため、内部構造が気にならなくて済んでいる。  

第3章でも、クラス1つ1つが常に正常動作するように設計するのが重要だと説明した。  
この観点から考えると、分割した先のロジックが気になるのは、分割したクラスの挙動に不安を覚えるからだと推測する。  
正常動作に不安を覚える、信頼性の低い構造であるほど、ロジックがどうなっているか気になるものだ。  

クラスを分割する際は、第3章のオブジェクト指向設計の基本を守ろう。  
分割したクラス1つ1つが一貫して正常動作する構造にしよう。  
内部のロジックをいちいち気にしなくても良い構造にしよう。  

---

### 15.5.2 循環的複雑度

**循環的複雑度(サイクロマティック複雑度)**は、コードの構造的な複雑なを示す指標である。  
条件分岐やループ処理が増える、ネストすると複雑さは増大していく。  
この複雑さの度合いにより、それぞれの状態を示すといわれている。  

表15.3 循環的複雑度の目安  
|循環的複雑度|複雑さの状態|バグ混入確率|
|---|---|---|
|10以下|非常に良い構造|25%|
|30以上|構造的なリスクあり|40%|
|50以上|テスト不可能|70%|
|75以上|いかなる変更も誤修正を生む|98%|

条件分岐やループ処理、およびネストが複雑さ増大の原因となる。  
複雑度は、早期リターンやストラテジーパターン、ファーストクラスコレクションパターンなど、本書で取り上げたテクニックを駆使することで低減可能である。  

データクラスは処理を持たないので、複雑度は0であるが、他のクラスが複雑化している可能性があるため、注意が必要。  

循環的複雑度は後述する分析ツールによって計測可能。  

---

### 15.5.3 凝集度

**凝集度**はモジュール内における、データとロジックの関係性の強さを表す指標を言う。  

モジュールは、クラス、パッケージ、レイヤーなど、様々な粒度の解釈がある。  
クラス粒度で解釈すると、クラス内における、データとロジックの関係性の強さを表す指標となる。  
具体的には、インスタンス変数とい、そのインスタンス変数を用いるロジックが同じクラス内に実装されていると凝集度が高いといえる。  

凝集度が高いほど変更容易性が高く、良い構造といえる。  
凝集度は測定可能である。  
凝集度を表すメトリクスに、LCOM(Lack of Cohesion in Method)[^1]があり、計測ツールもある。  

[^1]  
[『凝集度と結合度:このコードのどこが悪いのか？』](https://www.itmedia.co.jp/articles/0510/07/news106.html)にて、LCOMの計算式が解説されている。  

---

### 15.5.4 結合度

**結合度**は、モジュール間の、依存の度合いを表す指標を言う。  

モジュール粒度の解釈は凝集度と同様。  
例えば、クラス粒度の結合度は、あるクラスが呼び出している、他のクラスの数量のことを言う。  
あるクラスを変更した時、そのクラスを呼び出しているクラスも影響を受ける可能性がある。  
影響によりバグが生じないか検証が必要な場合もある。  
依存しているクラスが多いほど、すなわち結合度が増大するほど多くの変更影響を考慮しなければならず、保守や仕様変更が困難になっていく。  

結合度は分析ツールにより計測可能である。  
ツールがなくても、呼び出しクラスの数量を数えたり、クラス図を描画したりするだけでも、ある程度推量可能である。  
結合度が高い場合、多くのことをやりすぎている、つまり単一責任ではない可能性があるということになる。  
依存をもっと減らせないか、クラスをもっと小さく分割できないかを検討すべし。  

---

### 15.5.5 チャンク

コードメトリクスではないが、著者が良く意識する指標なので説明する。  

人間の記憶は、短期記憶と長期記憶に分類される。  
近年の認知心理学の研究では、人間の短期記憶は1度に4±1個の概念しか把握できない、という説がある。  
この個数を**マジカルナンバー4**と呼ぶ。  
また、記憶個数の単位を**チャンク**と呼ぶ。  

例えば、英語で「こんにちは」を意味する「Hello」。  
これは「H」「E」「L」「L」「O」の5文字から構成されており、「Hello」を初めて学ぶ人にとっては5チャンクになる。  
(なお、繰り返し学習し記憶に定着すると「Hello」がひとまとまりとして記憶され、1チャンクになる。)  

プログラミングは、非常に多くの種類のデータやロジックとにらめっこする仕事である。  
データや仕様の変更がどこに影響するか、バグが生じないか様々な要素を俯瞰し検証することが求められる。  

そうした中で、数千行、数万行もあり、膨大な変数が使われているような巨大クラスに対し、人は一度にすべての変数やロジックを把握可能だろうか？  
記憶がパンクして混乱してしまうことだろう。  
巨大クラスで扱っている概念の個数が、マジカルナンバー4を優に超えているからだ。  
実装担当者として長年携わってきた人にとっては長期記憶として定着し、理解可能かもしれない。  
しかし、後任として初めて触れる人にとっては、短期記憶に非常に強い負荷がかかり、理解が難しくなる。  

クラス設計をする際は、マジカルナンバー4を援用して、脳にやさしい構造を心がけよう。  
クラス内部で取る扱う概念が4±1個に収まるように設計し、大きなクラスは小さなクラスに分割しよう。  

「クラスの大小に関係なく、取り扱う概念の個数はシステム全体では変わらないから意味がないのでは？」という意見があるかもしれない。  
大事なのは、強く関係する概念同士が凝集し、関係が薄い概念どうしが疎になっていることである。  
巨大クラスでは、どの概念とどの概念が強く関係し合っているのか見分けるのが本当に大変である。  
強く関係し合う概念同士を凝集し、それぞれ小さいクラスで区分けしておけば、概念の関係性を容易に把握できる。  

3章で説明したクラス設計の基本や、8.1.3の単一責任原則を遵守すれば、容易にマジカルナンバーの個数に収められるだろう。  

---
---

## 15.6 コード分析をサポートする各種ツール

### 15.6.1 Code Climate Quality

`Code Climate Quality`はCode Climate社のコード品質分析ツールである。  
GitHubと連携し、リポジトリ内のコードの品質を自動でスコアリングする。  
様々な分析機能を備えている。  

- 独自の計算式により技術的負債を算出し、負債の増減を時系列でグラフ化。  
- 負債の度合いをファイル単位で可視化。ソートも可能。  
- 複雑度やコード行数など、メトリクス的に問題のある個所を可視化。  
- ファイル事の更新頻度を横軸、技術的負債を縦軸に取りグラフ化。  
  - 更新頻度と負債の双方が大きいものほど負債解消の価値があり、開発生産性向上に貢献すると考えられている。  

---

### 15.6.2 Understand

`Understand`はテクマトリックス社のコード品質分析ツールである。  
コード行数や複雑度、凝集度(LCOM)、結合度のほか、様々な観点のメトリクスを計測可能。  
クラスやメソッド間の依存関係を図で可視化するグラフィカルビューと呼ばれる機能もあり、仕様変更時の影響範囲を把握する、広すぎる影響範囲の低減を検討するのに役立つ。  

---

### Visual Studio

`Visual Studio`はMicrosoft社のIDE(統合開発環境)である。  
無償利用可能なCommunityを含む、すべてのライセンス形態でコードメトリクス計測機能が利用可能である。  
実行可能コード行数や複雑度、結合度をファイルごとに分析する。  
また、トータルの負債の度合いを示す保守容易性インデックスを算出可能である。  
これらの指標をメソッド、クラス、パッケージ単位で計測可能である。  

---

### コラム シンタックスハイライトを品質可視化に利用する

一般的なエディタには、シンタックスハイライトの機能が備わっている。  
シンタックスハイライトとは、コードの特定の記号やキーワード、構文をそれぞれ異なる色で表示する機能のことを言う。  
多くの方はおしゃれの感覚で、好みのカラースキームにカスタマイズしていることだろう。  

著者はコードの品質を可視化するために、シンタックスハイライトを意識的に改良して使っている。  
コードに問題を発生させやすいところには警戒するような色、コードの品質を保つのに有用なところには安全を示す色を割り当てる。  
例えば、数値はマジックナンバー、多すぎる引数は低凝集の可能性があるため、赤やオレンジなど警告色にする。  

表15.4 警告色で表示するハイライト要素の例  
|要素|色|意図|
|---|---|---|
|数値|赤|マジックナンバーの危険性あり|
|引数|オレンジ|多すぎる引数は低凝集の可能性あり|
|ローカル変数|黄|ローカル変数が多いと、関心事の違う多くの処理をやりすぎている可能性あり|

finalインスタンス変数やクラス、interfaceは緑や青など安全色にする。  

表15.5 安全色で表示するハイライト要素の例  
|要素|色|意図|
|---|---|---|
|メソッド|黄緑|ここままでもいいが、改善の可能性があるかも？|
|finalインスタンス変数|緑|不変で頑強な構造|
|クラス|水色|凝集度に貢献|
|interface|青|条件分岐の低減に貢献|

このように設定すると、品質の悪いであろう箇所は赤色系に染まり、品質の良い箇所は青色系に染まる。  
信号機のようになって、どこを改善すればよいのか、色で一目瞭然になる。  

静的解析ツールでコードの良し悪しを具体的に解析できるが、シンタックスハイライトは視覚的な効果が高く、おすすめ。  

---
---

## 15.7 設計対象と費用対効果

設計する上で、費用対効果の話は避けて通れない。  

読者は、今携わっているプロダクトの、あらゆるソースコードが粗悪な構造に見えてくるかもしれない。  
そして、すべてリファクタリングする、いっそのこと書き直してしましたい衝動に駆られるなんてことも考えられる。  

ところで無限にリファクタリングできるのだろうか？  
会社の予算は有限である。  
(事務所の賃料や光熱水費のほか、従業員が使うPC、備品、そして従業員の給与…様々な経費がかかる。)  
その中で開発費用が捻出されるのだ。  
こうした投資に対して、時間的な制約がある中、なんとか利益を上げなければならない。  

つまり、設計やリファクタリングは無限にはできないのだ。  
プロダクトの構造が全体的に粗悪であっても、設計的なテコ入れは一部分しかできない現実がある。  
(プロダクションコードのすべてに大真面目にテストコードを書くと、テストコードの量はプロダクションコードの3倍近くになるといわれている。テストコードの実装にもコスト意識が必要だ。)  

こうしたコスト制約がある中で、一体どの箇所の品質設計を高めればよいのだろうか。  
例えば構造的に粗悪であっても、バグがなく機能的に安定しており、仕様変更がほぼ全く生じないような箇所を一生懸命リファクタリングして、意味があるだろうか。  
変更容易性は、将来の仕様変更時の変更コストを低減する品質である。  
仕様変更もないのに、変更容易性を高めても、かけた労力、経費が無駄になってしまう。  
費用対効果が非常に低いものと考えられる。  
費用対効果の高い箇所を狙う必要がある。  

---

### 15.7.1 パレートの法則(80:20の法則)

パレートの法則と呼ばれる法則がある。  
ほんの一部分が全体要素を生み出しているとする法則で、「売上の8割は、全商品の内2割の商品が生み出している」「ソフトウェアの処理時間の内80%は、ソースコード全体の2割の部分が占めている」などの事象としてたとえられている。  
80:20の法則とも呼ばれている。  

一説には、ソフトウェアの機能全体の内、重点的に使われる機能は1/3程度しかないといわれている。  
頻繁に使用変更が生じる箇所も同様に、一部分に局所化しているといわれている。  
機能の重要性、そして仕様変更頻度が、パレートの法則に当てはまりそうではなかろうか。  

重要な機能は顧客が着目するし、改善ニーズも当然多く上がってくる。  
そしてニーズを受けて頻繁に使用が変更される。  
こうした重要かつ仕様変更が頻繁に発生する箇所を狙って設計改善するれば、変更コストが抑えられ、費用対効果が高くなると考えられる。  

---

### 15.7.2 サービスの中心的領域、コアドメイン

どの商品にも、どのサービスにも、「これがウリだ!」といえるような、中心的価値がある。  
特徴的なバトルシステムがウリのゲームや、話題性がウリのSNS、苦手科目の分析や手厚いサポートがウリのオンライン学習サービスなどだ。  

このように、サービスのウリになるビジネス領域を、書籍『ドメイン駆動設計』では**コアドメイン**と呼ぶ。  
コアドメインは以下のように説明される。  

- システム内で最大の価値を付加すべき場所  
- 価値があり重要で、費用対効果が最大の個所  
- 競争優位性があり、差別化が図られれ、ビジネス上優位に立つポイント  

まさに設計コストをかけるべき箇所、費用対効果が高い箇所といえる。  

---

### 15.7.3 重点設計対象の選定にはビジネス知識が必要

ではコアドメインと呼べるにふさわしいビジネス領域とは何だろうか。  
そのビジネス領域に対応する機能はどれだろうか。  

サービスはローンチ後、繰り返し多くの様々な機能が追加されていく。  
そうして巨大化していくと、何がサービスの中心的価値なのかわからなくなっていく。  

重要な機能は高い頻度で仕様変更される傾向にある。  
CodeClimateQualityなどの分析ツールを使えば、変更頻度の高い箇所の分析もできる。  
しかし、流行り廃りで一時的に変更頻度が上がっているだけの場合がある。  

ドメイン駆動設計は、コアドメインの価値を継続的に高め、サービスを長期的に成長させる設計手法である。  
サービスの事業領域に関して深い知識を持っている人を**ドメインエキスパート**と呼ぶ。  
ドメインエキスパートと協力し、何がコアドメインなのかを見定める必要がある、という教えがドメイン駆動設計にはある。  

設計の費用対効果を高めるためには、重点的な設計対象の選定が必要になる。  
そしてその選定には、サービスが解決したい顧客課題は何か、サービスの本質は何かを見通す力が必要になる。  
つまり、サービスのビジネス知識が必須になるのだ。  
構造の良し悪しだけに着目していると、ビジネス戦略上、設計がうまく働かなくなるのだ。  

ソフトウェアエンジニアには、アーキテクトと呼ばれる職種がある。  
アーキテクトは、ビジネス戦略を実現するアーキテクチャーを設計する役割を担っている。  
アーキテクトの職務遂行には、対象ビジネスの理解が必要なのだ。  
成長性を高める最適な設計とビジネス知識は、切っても切り離せない関係にあるといえる。  

---
---

## 15.8 時間を操る超能力者になろう

変更容易性設計は開発生産性を向上させる。未来の時間を操れる。  
レガシーコードでいたずらに疲弊するか、ソフトウェアを素早く成長させられるようになるかは、設計者の腕次第となる。  

今の設計品質が未来の時間に直結しているのを意識できるようになろう。  
時間に対して注意力が高まると、デバッグの時間が長かったり、コードの解読に時間がかかったり、普段の開発で発生している「無駄な時間」が見えるようになってくる。  
現状がちっとも当たり前ではなく、異常とすら思えるようになってくるだろう。  

非エンジニアはシステムの表面的な機能しか見えない。  
システムを開発するエンジニアは、内部構造を可視化する目を持っている。  
そのうえ、設計のあるべき姿が分かるエンジニアは、悪魔の正体を見破る目、すなわちレガシーコードを可視化する目を持っている。  
無駄な時間の発生要因を見つける目を持っている。  
「目」を持っていない人からすると、もはや超能力である。  

高度なスキルだが、訓練次第で誰でも習得できる。  
この可視化能力と設計力で未来の時間を操れるようになろう。  
