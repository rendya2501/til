# 15. 設計の意義と設計への向き合い方

クラスを中心に、設計の方法や重要性を取り上げてきた。  
ノウハウを用いると、コードを楽に素早く正確に変更できるようになる。  
素早く変更できると、ソフトウェアの価値が素早く高まる。  
ソフトウェアの成長性を軸に、設計の意義や設計への向かい方を解説する。  

---
---

## 15.1 なんの設計について書いたものなのか

表15.1 ソフトウェア製品に関する品質特性(JIS X 25010:2013を参考に作成)  
|品質特性|説明|品質副特性|
|:-|:-|:-|
|機能適合性|機能がニーズを満たす度合い|機能完全性、機能正確性、機能適切性|
|性能効率性|リソース効率や性能の度合い|時間効率性、資源効率性、容量満足性|
|互換性|ほかのシステムと情報の共有、交換できる度合い|共存性、相互運用性|
|使用性|利用者がシステムを満足に利用できる度合い|適切度認識性、習得性、運用操作性、ユーザーエラー防止性、ユーザーインターフェース快美性、アクセスビリティ|
|信頼性|必要な時に機能実行できる度合い|成熟性、可用性、障害許容性、回復性|
|セキュリティ|不正利用から保護する度合い|気密性、完全性、否認防止性、責任追跡性、真正性|
|保守性|システムを修正する有効性や効率の度合い|モジュール性、再利用性、解析性、修正性、試験性|
|移植性|ほかの実行環境に移植できる度合い|適応性、設置性、置換性|

表15.1はソフトウェア製品に関する品質特性の一覧となる。  
例えば、システムの機能が顧客のニーズを満たす品質特性は機能適合性となる。  
各品質特性にはさらに副特性があり、機能適合性の副特性には機能完全性、機能正確性、機能適切性がある。  

設計とは、課題を効率的に解決する仕組み作りのことを言う。  
そして、ソフトウェアにおける設計とは、何らかのソフトウェア品質特性の向上を促進するための仕組みを作ることを言う。  
例えば性能効率性はパフォーマンス性能を表す品質特性であり、性能効率性を上げるには、パフォーマンス設計をする。  

本書での設計は主にどの品質特性の向上を狙ったものだろうか。  
本書はソフトウェア開発上の悪魔を退治する設計方法を記述したものである。  
悪魔は様々な悪事を働く。  
デバッグ時や仕様変更時、どのロジックが影響しているのか影響範囲の把握を困難にさせる。  
また、仕様変更時に修正漏れが起こりやすく、バグが発生するなど、正確に動作できるようになるまで時間を浪費させる。  

こうした悪魔の性質と最も関係がありそうな品質特性はどれだろうか。  
保守性を見てみよう。  
「システムを修正する有効性や効率の度合い」とある。  
本書で取り扱っているのは、保守性に関係する設計となる。  
そして保守性の副特性には修正性がある。  
修正性は変更容易性とも呼び、どれだけ素早く(バグを発生させず)正確にコード変更可能かを示す指標となる。  
保守性の中でも、特に**変更容易性の向上を目的にした設計手法**なのである。  

---
---

## 15.2 設計しないと開発生産性が低下する

変更が困難で壊れやすいコードを**レガシーコード**と呼ぶ。  
レガシーコードが蓄積している状態を**技術的負債**と呼ぶ。  
レガシーコードは変更容易性が低いコードとなる。  
変更容易性の設計をしないと、開発生産性が低下する。  
低下要因は、大きく分けて2つある。  

---

### 15.2.1 要因1 : バグを埋め込みやすくなる

コード変更時にバグを埋め込みやすくなる。  
バグがないように正確に変更できるまで時間がかかってしまう。  

- 低凝集な構造によって仕様変更時に修正漏れが起きやすくなり、バグになる。  
- コードの理解が難しいために、実装ミスが起こりやすく、バグになる。  
- 不正値が容易に混入する構造になりがちで、バグが起こりやすくなる。  

---

### 15.2.2 要因2 : 可読性が低下する

可読性が低下し、意図を正確に理解するまでに時間がかかるようになる。  

- ロジックの見通しが悪く、読み解くのに時間がかかる。  
- 関係し合うロジックがあちこちに散在しているために、仕様変更に関連するロジックをすべて探し回る手間が増える。  
- 不正値の混入でバグが発生した場合に、どこから不正値が混入したのか追跡が困難になる。  

---

### 15.2.3 木こりのジレンマ

「木こりのジレンマ」という説話がある。  

>ある木こりが、斧で一生懸命気を切っていた。  
>
>通りかかった旅人が木を切る様子をしばらく眺めていたが、なかなか木が切れない。  
>
>よく見てみると、斧が刃こぼれしていたので、旅人は言いました。  
>
>「刃を研げば楽に切れますよ」  
>
>木こりは答えた。  
>
>「刃を研ぐ時間なんかない!」  

ソフトウェア開発でも、この「木こりのジレンマ」と同じことが起こっていないだろうか。  
この説話の「木を切る時間」を「ロジックの実装時間」、「刃を研ぐ時間」を「設計する時間」に置き換えて考えてみよう。  
設計していないと、ロジックの変更やデバッグに多大な時間を浪費してしまう。  
そして設計する余裕すらなくなってしまうジレンマに陥ってしまう。  

---

### 15.2.4 一生懸命仕事した感覚だけが残って生産性は悪いまま

開発生産性が悪いと、新機能をなかなかリリースできなくなる。  
当然、収益を出せなくなってくる。  
成果を出せない体質になっていくのだ。  

開発現場では、リリース期日までに何とか間に合わせようと、長時間労働が慢性化していく。  
開発メンバーは一生懸命がむしゃらに、とにかく動作するよう実装と修正を繰り返すことになる。  
「とにかく一生懸命働いた!」という感覚だけは強烈に残る。  
しかし、生産性は悪いままなので、成果はなかなかでない。  
「これほど一生懸命働いているのに、なぜ成果が出ないんだ!」と憤り、失望の声が上がってくることも想像に難くない。  

しかし、それは本当の意味で一生懸命働いたといえるのだろうか。  
本来一生懸命やるべきなのは、成果を出しやすい構造を設計する事なのだ。  

---

### 15.2.5 国家規模の経済損失

レガシーコードによる生産性低下がどれほどの損失になるか考えてみる。  

開発チームにはメンバーが20人いて、レガシーコードによる実装遅延が1人1日3時間発生していると仮定する。  
単純計算で、開発チーム全体で1日あたり、3*20=60時間損失が発生していることになる。  
これが１か月ともなると実働日数20日として120時間、1年間となると1440時間も損失が生じる。  
低生産性による損失は、少しずつ確実に蓄積していく。  

この損失は、実際にはレガシーコードの量に単純に比例するものでは無い。  
なぜなら**複雑で混乱したロジックがあると、もっと混乱したロジックが作りこまれやすくなるためである。**  
ソースコードの巨大化に伴い、加速度的に混乱に拍車がかかる。  
そしていつしか、機能開発がほとんど立ち行かず、リリース困難になってしまうほど悪化していくのだ。  

経済産業省の発表資料によると、2025年以降、技術的負債による経済的損失額は、12兆円になるとの試算が出ている。[^1]  
日本の2021年度国家予算が142.5兆円(補正含む)であることを踏まえると、すさまじい損失額と言える。  
まさに「塵も積もれば山となる」。  
設計をないがしろにし、日々の生産性の低さを放置していった結果、国家規模の損失を抱えるまでに至っている。  

この点から、変更容易性は極めて重要な品質特性だといえる。  

[^1]『DXレポート～ITシステム[2025年の壁」克服とDXの本格的な展開～』著:デジタルトランスフォーメーションに向けた研究会  
<https://www.meti.go.jp/shingikai/mono_info_service/digital_transformation/pdf/20180907_03.pdf>
[^2]『老朽化ソフトウェアの技術的な負債、毎年12兆円の衝撃』著:広木大地  
<https://note.com/hirokidaichi/n/n1ce83fa154e5>  

---
---

## 15.3 ソフトウェアとエンジニアの成長性

何のためにコードを変更するのだろうか。  
ソフトウェアの価値や魅力をより高めるために仕様が追加・変更され、そしてコードが変更されていく。  
コードの変更容易性が高いほど、ソフトウェアの価値を素早く高められる。  
ソフトウェアが素早く成長するのである。  

つまり、変更容易性を高めることは、ソフトウェアの成長性を高めることなのだ。  
**ソフトウェアの成長性を高めることが、本稿の意義となる。**  

変更容易性が悪化すると、ソフトウェアの成長性が悪化する。  
それだけではなく、あなたのスキルの成長性まで悪化する。  

---

### 15.3.1 エンジニアにとっての資産とは何か

「エンジニアにとっての」資産とは何だろうか。  
貯蓄が沢山あることだろうか。それとも高年収であることだろうか。  

人によってお金の使い方は異なるため、貯蓄額の多寡は「エンジニアにとっての」資産とは違うように思える。  
年収に関しても、景気の浮き沈みでいくらでも変わるものだから、「エンジニアにとっての」本質的な資産とは異なっていそうだ。  

エンジニアにとっての本質的な資産とは何だろうか。  
それは**技術力**に他ならないと筆者は考える。  
貯蓄がゼロでも、技術力があればどこでも稼いでいけるのがエンジニアであり、まさに富を生み出す源泉といえる。  
何にも代えがたい、エンジニア自身の貴重な資産となる。  

しかし、レガシーコードは資産の蓄積、すなわち技術力の成長を妨げてしまう恐ろしい存在なのだ。  
その理由は以下に続く。  

---

### 15.3.2 レガシーコードに人は引きずられやすい

新入社員や後任担当者が、レガシーコードだらけのプロダクトの開発を担当するケースを考えてみる。  
先輩社員や前任者が書いたコードがレガシーコードだと気づくのは困難である。  
むしろ「これが先輩のお手本だ」とか「前任者の流儀だ」と勘違いし、レガシーコードと同じ書き方でさらにレガシーコードが量産されることが非常に多い。  
技術力が未熟な新入社員には顕著な傾向となる。  

レガシーコードは、レガシーコードの書き手を育ててしまう。  
エンジニアを低スキルに陥れてしまう。  

---

### 15.3.3 レガシーコードは高品質設計を妨げる

中にはレガシーコードのマズさに気付く人もいる。  
なんとか設計的なテコ入れを試みたくなるだろう。  
しかし、レガシーコードは極めてアンバランスでトリッキーな実装であることが多い。  
設計改善が非常に困難となる。  
プロジェクトの納期などの都合により、設計改善を諦めてしまうことが本当に多い。  

結局、高品質な設計実装の経験を積めなくなり、設計スキル向上を果たせなくなる。  

---

### 15.3.4 レガシーコードは開発工数を減少させる

レガシーコードは理解に多大な時間を要する。  
一方時間は有限である。  
従って、本来もっと価値の高い仕事に充てられるべき時間が、目減りしてしまう。  
十分な経験を積めず、設計スキルに限らず様々なスキルの向上を果たせなくなる。  

委譲、レガシーコードはスキル向上の妨げになり、エンジニアにとって本当に大切な資産を貯蓄できなくなってしまう。  
そして、エンジニアにとって技術力は収入に直結する。  
レガシーコードはエンジニアのスキル成長を妨げ、稼げなくしてしまう。  

---
---

## 15.4 課題を解決する
